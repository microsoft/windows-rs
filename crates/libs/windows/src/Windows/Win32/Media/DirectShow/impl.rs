pub trait IAMAnalogVideoDecoderImpl: Sized {
    fn AvailableTVFormats();
    fn SetTVFormat();
    fn TVFormat();
    fn HorizontalLocked();
    fn SetVCRHorizontalLocking();
    fn VCRHorizontalLocking();
    fn NumberOfLines();
    fn SetOutputEnable();
    fn OutputEnable();
}
impl ::windows::core::RuntimeName for IAMAnalogVideoDecoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMAnalogVideoDecoder";
}
impl IAMAnalogVideoDecoderVtbl {
    pub const fn new<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMAnalogVideoDecoderVtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats(::core::mem::transmute_copy(&lanalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVFormat<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTVFormat(lanalogvideostandard) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVFormat<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TVFormat(::core::mem::transmute_copy(&planalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalLocked<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pllocked: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalLocked(::core::mem::transmute_copy(&pllocked)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVCRHorizontalLocking<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvcrhorizontallocking: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVCRHorizontalLocking(lvcrhorizontallocking) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VCRHorizontalLocking<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plvcrhorizontallocking: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VCRHorizontalLocking(::core::mem::transmute_copy(&plvcrhorizontallocking)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfLines<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plnumberoflines: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumberOfLines(::core::mem::transmute_copy(&plnumberoflines)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputEnable<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, loutputenable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputEnable(loutputenable) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutputEnable<Impl: IAMAnalogVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ploutputenable: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutputEnable(::core::mem::transmute_copy(&ploutputenable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMAnalogVideoDecoder>, base.5, AvailableTVFormats::<Impl, OFFSET>, SetTVFormat::<Impl, OFFSET>, TVFormat::<Impl, OFFSET>, HorizontalLocked::<Impl, OFFSET>, SetVCRHorizontalLocking::<Impl, OFFSET>, VCRHorizontalLocking::<Impl, OFFSET>, NumberOfLines::<Impl, OFFSET>, SetOutputEnable::<Impl, OFFSET>, OutputEnable::<Impl, OFFSET>)
    }
}
pub trait IAMAnalogVideoEncoderImpl: Sized {
    fn AvailableTVFormats();
    fn SetTVFormat();
    fn TVFormat();
    fn SetCopyProtection();
    fn CopyProtection();
    fn SetCCEnable();
    fn CCEnable();
}
impl ::windows::core::RuntimeName for IAMAnalogVideoEncoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMAnalogVideoEncoder";
}
impl IAMAnalogVideoEncoderVtbl {
    pub const fn new<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMAnalogVideoEncoderVtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats(::core::mem::transmute_copy(&lanalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVFormat<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTVFormat(lanalogvideostandard) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVFormat<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TVFormat(::core::mem::transmute_copy(&planalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCopyProtection<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvideocopyprotection: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCopyProtection(lvideocopyprotection) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyProtection<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvideocopyprotection: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyProtection(::core::mem::transmute_copy(&lvideocopyprotection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCCEnable<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lccenable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCCEnable(lccenable) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCEnable<Impl: IAMAnalogVideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lccenable: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CCEnable(::core::mem::transmute_copy(&lccenable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMAnalogVideoEncoder>, base.5, AvailableTVFormats::<Impl, OFFSET>, SetTVFormat::<Impl, OFFSET>, TVFormat::<Impl, OFFSET>, SetCopyProtection::<Impl, OFFSET>, CopyProtection::<Impl, OFFSET>, SetCCEnable::<Impl, OFFSET>, CCEnable::<Impl, OFFSET>)
    }
}
pub trait IAMAsyncReaderTimestampScalingImpl: Sized {
    fn GetTimestampMode();
    fn SetTimestampMode();
}
impl ::windows::core::RuntimeName for IAMAsyncReaderTimestampScaling {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMAsyncReaderTimestampScaling";
}
impl IAMAsyncReaderTimestampScalingVtbl {
    pub const fn new<Impl: IAMAsyncReaderTimestampScalingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMAsyncReaderTimestampScalingVtbl {
        unsafe extern "system" fn GetTimestampMode<Impl: IAMAsyncReaderTimestampScalingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfraw: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimestampMode(::core::mem::transmute_copy(&pfraw)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimestampMode<Impl: IAMAsyncReaderTimestampScalingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fraw: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimestampMode(&*(&fraw as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMAsyncReaderTimestampScaling>, base.5, GetTimestampMode::<Impl, OFFSET>, SetTimestampMode::<Impl, OFFSET>)
    }
}
pub trait IAMAudioInputMixerImpl: Sized {
    fn SetEnable();
    fn Enable();
    fn SetMono();
    fn Mono();
    fn SetMixLevel();
    fn MixLevel();
    fn SetPan();
    fn Pan();
    fn SetLoudness();
    fn Loudness();
    fn SetTreble();
    fn Treble();
    fn TrebleRange();
    fn SetBass();
    fn Bass();
    fn BassRange();
}
impl ::windows::core::RuntimeName for IAMAudioInputMixer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMAudioInputMixer";
}
impl IAMAudioInputMixerVtbl {
    pub const fn new<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMAudioInputMixerVtbl {
        unsafe extern "system" fn SetEnable<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnable(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Enable<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfenable: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Enable(::core::mem::transmute_copy(&pfenable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMono<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmono: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMono(&*(&fmono as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Mono<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfmono: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mono(::core::mem::transmute_copy(&pfmono)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixLevel<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, level: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixLevel(level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MixLevel<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plevel: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MixLevel(::core::mem::transmute_copy(&plevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPan<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pan: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPan(pan) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pan<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppan: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pan(::core::mem::transmute_copy(&ppan)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLoudness<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, floudness: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLoudness(&*(&floudness as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Loudness<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfloudness: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Loudness(::core::mem::transmute_copy(&pfloudness)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTreble<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, treble: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTreble(treble) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Treble<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptreble: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Treble(::core::mem::transmute_copy(&ptreble)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TrebleRange<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prange: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TrebleRange(::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBass<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bass: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBass(bass) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Bass<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbass: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bass(::core::mem::transmute_copy(&pbass)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BassRange<Impl: IAMAudioInputMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prange: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BassRange(::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMAudioInputMixer>,
            base.5,
            SetEnable::<Impl, OFFSET>,
            Enable::<Impl, OFFSET>,
            SetMono::<Impl, OFFSET>,
            Mono::<Impl, OFFSET>,
            SetMixLevel::<Impl, OFFSET>,
            MixLevel::<Impl, OFFSET>,
            SetPan::<Impl, OFFSET>,
            Pan::<Impl, OFFSET>,
            SetLoudness::<Impl, OFFSET>,
            Loudness::<Impl, OFFSET>,
            SetTreble::<Impl, OFFSET>,
            Treble::<Impl, OFFSET>,
            TrebleRange::<Impl, OFFSET>,
            SetBass::<Impl, OFFSET>,
            Bass::<Impl, OFFSET>,
            BassRange::<Impl, OFFSET>,
        )
    }
}
pub trait IAMAudioRendererStatsImpl: Sized {
    fn GetStatParam();
}
impl ::windows::core::RuntimeName for IAMAudioRendererStats {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMAudioRendererStats";
}
impl IAMAudioRendererStatsVtbl {
    pub const fn new<Impl: IAMAudioRendererStatsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMAudioRendererStatsVtbl {
        unsafe extern "system" fn GetStatParam<Impl: IAMAudioRendererStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatParam(dwparam, ::core::mem::transmute_copy(&pdwparam1), ::core::mem::transmute_copy(&pdwparam2)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMAudioRendererStats>, base.5, GetStatParam::<Impl, OFFSET>)
    }
}
pub trait IAMBufferNegotiationImpl: Sized {
    fn SuggestAllocatorProperties();
    fn GetAllocatorProperties();
}
impl ::windows::core::RuntimeName for IAMBufferNegotiation {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMBufferNegotiation";
}
impl IAMBufferNegotiationVtbl {
    pub const fn new<Impl: IAMBufferNegotiationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMBufferNegotiationVtbl {
        unsafe extern "system" fn SuggestAllocatorProperties<Impl: IAMBufferNegotiationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprop: *const ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuggestAllocatorProperties(&*(&pprop as *const <ALLOCATOR_PROPERTIES as ::windows::core::Abi>::Abi as *const <ALLOCATOR_PROPERTIES as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllocatorProperties<Impl: IAMBufferNegotiationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprop: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocatorProperties(::core::mem::transmute_copy(&pprop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMBufferNegotiation>, base.5, SuggestAllocatorProperties::<Impl, OFFSET>, GetAllocatorProperties::<Impl, OFFSET>)
    }
}
pub trait IAMCameraControlImpl: Sized {
    fn GetRange();
    fn Set();
    fn Get();
}
impl ::windows::core::RuntimeName for IAMCameraControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMCameraControl";
}
impl IAMCameraControlVtbl {
    pub const fn new<Impl: IAMCameraControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMCameraControlVtbl {
        unsafe extern "system" fn GetRange<Impl: IAMCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRange(property, ::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set<Impl: IAMCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set(property, lvalue, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Get<Impl: IAMCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Get(property, ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMCameraControl>, base.5, GetRange::<Impl, OFFSET>, Set::<Impl, OFFSET>, Get::<Impl, OFFSET>)
    }
}
pub trait IAMCertifiedOutputProtectionImpl: Sized {
    fn KeyExchange();
    fn SessionSequenceStart();
    fn ProtectionCommand();
    fn ProtectionStatus();
}
impl ::windows::core::RuntimeName for IAMCertifiedOutputProtection {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMCertifiedOutputProtection";
}
impl IAMCertifiedOutputProtectionVtbl {
    pub const fn new<Impl: IAMCertifiedOutputProtectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMCertifiedOutputProtectionVtbl {
        unsafe extern "system" fn KeyExchange<Impl: IAMCertifiedOutputProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prandom: *mut ::windows::core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyExchange(::core::mem::transmute_copy(&prandom), ::core::mem::transmute_copy(&varlencertgh), ::core::mem::transmute_copy(&pdwlengthcertgh)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SessionSequenceStart<Impl: IAMCertifiedOutputProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psig: *mut AMCOPPSignature) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SessionSequenceStart(&*(&psig as *const <AMCOPPSignature as ::windows::core::Abi>::Abi as *const <AMCOPPSignature as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtectionCommand<Impl: IAMCertifiedOutputProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cmd: *const AMCOPPCommand) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProtectionCommand(&*(&cmd as *const <AMCOPPCommand as ::windows::core::Abi>::Abi as *const <AMCOPPCommand as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtectionStatus<Impl: IAMCertifiedOutputProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatusinput: *const AMCOPPStatusInput, pstatusoutput: *mut AMCOPPStatusOutput) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProtectionStatus(&*(&pstatusinput as *const <AMCOPPStatusInput as ::windows::core::Abi>::Abi as *const <AMCOPPStatusInput as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pstatusoutput)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMCertifiedOutputProtection>, base.5, KeyExchange::<Impl, OFFSET>, SessionSequenceStart::<Impl, OFFSET>, ProtectionCommand::<Impl, OFFSET>, ProtectionStatus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMChannelInfoImpl: Sized + IDispatchImpl {
    fn ChannelName();
    fn ChannelDescription();
    fn ChannelURL();
    fn ContactAddress();
    fn ContactPhone();
    fn ContactEmail();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMChannelInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMChannelInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMChannelInfoVtbl {
    pub const fn new<Impl: IAMChannelInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMChannelInfoVtbl {
        unsafe extern "system" fn ChannelName<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrchannelname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelName(&*(&pbstrchannelname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChannelDescription<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrchanneldescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelDescription(&*(&pbstrchanneldescription as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChannelURL<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrchannelurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelURL(&*(&pbstrchannelurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactAddress<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrcontactaddress: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContactAddress(&*(&pbstrcontactaddress as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactPhone<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrcontactphone: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContactPhone(&*(&pbstrcontactphone as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactEmail<Impl: IAMChannelInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrcontactemail: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContactEmail(&*(&pbstrcontactemail as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMChannelInfo>, base.5, ChannelName::<Impl, OFFSET>, ChannelDescription::<Impl, OFFSET>, ChannelURL::<Impl, OFFSET>, ContactAddress::<Impl, OFFSET>, ContactPhone::<Impl, OFFSET>, ContactEmail::<Impl, OFFSET>)
    }
}
pub trait IAMClockAdjustImpl: Sized {
    fn SetClockDelta();
}
impl ::windows::core::RuntimeName for IAMClockAdjust {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMClockAdjust";
}
impl IAMClockAdjustVtbl {
    pub const fn new<Impl: IAMClockAdjustImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMClockAdjustVtbl {
        unsafe extern "system" fn SetClockDelta<Impl: IAMClockAdjustImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtdelta: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetClockDelta(rtdelta) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMClockAdjust>, base.5, SetClockDelta::<Impl, OFFSET>)
    }
}
pub trait IAMClockSlaveImpl: Sized {
    fn SetErrorTolerance();
    fn GetErrorTolerance();
}
impl ::windows::core::RuntimeName for IAMClockSlave {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMClockSlave";
}
impl IAMClockSlaveVtbl {
    pub const fn new<Impl: IAMClockSlaveImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMClockSlaveVtbl {
        unsafe extern "system" fn SetErrorTolerance<Impl: IAMClockSlaveImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtolerance: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetErrorTolerance(dwtolerance) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetErrorTolerance<Impl: IAMClockSlaveImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwtolerance: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetErrorTolerance(::core::mem::transmute_copy(&pdwtolerance)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMClockSlave>, base.5, SetErrorTolerance::<Impl, OFFSET>, GetErrorTolerance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMCollectionImpl: Sized + IDispatchImpl {
    fn Count();
    fn Item();
    fn _NewEnum();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMCollection {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMCollection";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMCollectionVtbl {
    pub const fn new<Impl: IAMCollectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMCollectionVtbl {
        unsafe extern "system" fn Count<Impl: IAMCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&plcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IAMCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, litem: i32, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(litem, ::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IAMCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMCollection>, base.5, Count::<Impl, OFFSET>, Item::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>)
    }
}
pub trait IAMCopyCaptureFileProgressImpl: Sized {
    fn Progress();
}
impl ::windows::core::RuntimeName for IAMCopyCaptureFileProgress {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMCopyCaptureFileProgress";
}
impl IAMCopyCaptureFileProgressVtbl {
    pub const fn new<Impl: IAMCopyCaptureFileProgressImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMCopyCaptureFileProgressVtbl {
        unsafe extern "system" fn Progress<Impl: IAMCopyCaptureFileProgressImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, iprogress: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Progress(iprogress) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMCopyCaptureFileProgress>, base.5, Progress::<Impl, OFFSET>)
    }
}
pub trait IAMCrossbarImpl: Sized {
    fn PinCounts();
    fn CanRoute();
    fn Route();
    fn IsRoutedTo();
    fn CrossbarPinInfo();
}
impl ::windows::core::RuntimeName for IAMCrossbar {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMCrossbar";
}
impl IAMCrossbarVtbl {
    pub const fn new<Impl: IAMCrossbarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMCrossbarVtbl {
        unsafe extern "system" fn PinCounts<Impl: IAMCrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputpincount: *mut i32, inputpincount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PinCounts(::core::mem::transmute_copy(&outputpincount), ::core::mem::transmute_copy(&inputpincount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRoute<Impl: IAMCrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanRoute(outputpinindex, inputpinindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Route<Impl: IAMCrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Route(outputpinindex, inputpinindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRoutedTo<Impl: IAMCrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRoutedTo(outputpinindex, ::core::mem::transmute_copy(&inputpinindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CrossbarPinInfo<Impl: IAMCrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, isinputpin: super::super::Foundation::BOOL, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CrossbarPinInfo(&*(&isinputpin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), pinindex, ::core::mem::transmute_copy(&pinindexrelated), ::core::mem::transmute_copy(&physicaltype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMCrossbar>, base.5, PinCounts::<Impl, OFFSET>, CanRoute::<Impl, OFFSET>, Route::<Impl, OFFSET>, IsRoutedTo::<Impl, OFFSET>, CrossbarPinInfo::<Impl, OFFSET>)
    }
}
pub trait IAMDecoderCapsImpl: Sized {
    fn GetDecoderCaps();
}
impl ::windows::core::RuntimeName for IAMDecoderCaps {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDecoderCaps";
}
impl IAMDecoderCapsVtbl {
    pub const fn new<Impl: IAMDecoderCapsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDecoderCapsVtbl {
        unsafe extern "system" fn GetDecoderCaps<Impl: IAMDecoderCapsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcapindex: u32, lpdwcap: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderCaps(dwcapindex, ::core::mem::transmute_copy(&lpdwcap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDecoderCaps>, base.5, GetDecoderCaps::<Impl, OFFSET>)
    }
}
pub trait IAMDevMemoryAllocatorImpl: Sized {
    fn GetInfo();
    fn CheckMemory();
    fn Alloc();
    fn Free();
    fn GetDevMemoryObject();
}
impl ::windows::core::RuntimeName for IAMDevMemoryAllocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDevMemoryAllocator";
}
impl IAMDevMemoryAllocatorVtbl {
    pub const fn new<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDevMemoryAllocatorVtbl {
        unsafe extern "system" fn GetInfo<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInfo(::core::mem::transmute_copy(&pdwcbtotalfree), ::core::mem::transmute_copy(&pdwcblargestfree), ::core::mem::transmute_copy(&pdwcbtotalmemory), ::core::mem::transmute_copy(&pdwcbminimumchunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CheckMemory<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckMemory(pbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Alloc<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Alloc(::core::mem::transmute_copy(&ppbuffer), pdwcbbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Free<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Free(pbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDevMemoryObject<Impl: IAMDevMemoryAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunkinnner: *mut *mut ::core::ffi::c_void, punkouter: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDevMemoryObject(::core::mem::transmute_copy(&ppunkinnner), &*(&punkouter as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDevMemoryAllocator>, base.5, GetInfo::<Impl, OFFSET>, CheckMemory::<Impl, OFFSET>, Alloc::<Impl, OFFSET>, Free::<Impl, OFFSET>, GetDevMemoryObject::<Impl, OFFSET>)
    }
}
pub trait IAMDevMemoryControlImpl: Sized {
    fn QueryWriteSync();
    fn WriteSync();
    fn GetDevId();
}
impl ::windows::core::RuntimeName for IAMDevMemoryControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDevMemoryControl";
}
impl IAMDevMemoryControlVtbl {
    pub const fn new<Impl: IAMDevMemoryControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDevMemoryControlVtbl {
        unsafe extern "system" fn QueryWriteSync<Impl: IAMDevMemoryControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryWriteSync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WriteSync<Impl: IAMDevMemoryControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WriteSync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDevId<Impl: IAMDevMemoryControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwdevid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDevId(::core::mem::transmute_copy(&pdwdevid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDevMemoryControl>, base.5, QueryWriteSync::<Impl, OFFSET>, WriteSync::<Impl, OFFSET>, GetDevId::<Impl, OFFSET>)
    }
}
pub trait IAMDeviceRemovalImpl: Sized {
    fn DeviceInfo();
    fn Reassociate();
    fn Disassociate();
}
impl ::windows::core::RuntimeName for IAMDeviceRemoval {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDeviceRemoval";
}
impl IAMDeviceRemovalVtbl {
    pub const fn new<Impl: IAMDeviceRemovalImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDeviceRemovalVtbl {
        unsafe extern "system" fn DeviceInfo<Impl: IAMDeviceRemovalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclsidinterfaceclass: *mut ::windows::core::GUID, pwszsymboliclink: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeviceInfo(::core::mem::transmute_copy(&pclsidinterfaceclass), ::core::mem::transmute_copy(&pwszsymboliclink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reassociate<Impl: IAMDeviceRemovalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reassociate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Disassociate<Impl: IAMDeviceRemovalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Disassociate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDeviceRemoval>, base.5, DeviceInfo::<Impl, OFFSET>, Reassociate::<Impl, OFFSET>, Disassociate::<Impl, OFFSET>)
    }
}
pub trait IAMDirectSoundImpl: Sized {
    fn GetDirectSoundInterface();
    fn GetPrimaryBufferInterface();
    fn GetSecondaryBufferInterface();
    fn ReleaseDirectSoundInterface();
    fn ReleasePrimaryBufferInterface();
    fn ReleaseSecondaryBufferInterface();
    fn SetFocusWindow();
    fn GetFocusWindow();
}
impl ::windows::core::RuntimeName for IAMDirectSound {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDirectSound";
}
impl IAMDirectSoundVtbl {
    pub const fn new<Impl: IAMDirectSoundImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDirectSoundVtbl {
        unsafe extern "system" fn GetDirectSoundInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplpds: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectSoundInterface(::core::mem::transmute_copy(&lplpds)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrimaryBufferInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplpdsb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrimaryBufferInterface(::core::mem::transmute_copy(&lplpdsb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSecondaryBufferInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplpdsb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSecondaryBufferInterface(::core::mem::transmute_copy(&lplpdsb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseDirectSoundInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpds: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseDirectSoundInterface(&*(&lpds as *const <super::Audio::DirectSound::IDirectSound as ::windows::core::Abi>::Abi as *const <super::Audio::DirectSound::IDirectSound as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleasePrimaryBufferInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdsb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleasePrimaryBufferInterface(&*(&lpdsb as *const <super::Audio::DirectSound::IDirectSoundBuffer as ::windows::core::Abi>::Abi as *const <super::Audio::DirectSound::IDirectSoundBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseSecondaryBufferInterface<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdsb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseSecondaryBufferInterface(&*(&lpdsb as *const <super::Audio::DirectSound::IDirectSoundBuffer as ::windows::core::Abi>::Abi as *const <super::Audio::DirectSound::IDirectSoundBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusWindow<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param0: super::super::Foundation::HWND, param1: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFocusWindow(&*(&param0 as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType), &*(&param1 as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFocusWindow<Impl: IAMDirectSoundImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param0: *mut super::super::Foundation::HWND, param1: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFocusWindow(&*(&param0 as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType), &*(&param1 as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDirectSound>, base.5, GetDirectSoundInterface::<Impl, OFFSET>, GetPrimaryBufferInterface::<Impl, OFFSET>, GetSecondaryBufferInterface::<Impl, OFFSET>, ReleaseDirectSoundInterface::<Impl, OFFSET>, ReleasePrimaryBufferInterface::<Impl, OFFSET>, ReleaseSecondaryBufferInterface::<Impl, OFFSET>, SetFocusWindow::<Impl, OFFSET>, GetFocusWindow::<Impl, OFFSET>)
    }
}
pub trait IAMDroppedFramesImpl: Sized {
    fn GetNumDropped();
    fn GetNumNotDropped();
    fn GetDroppedInfo();
    fn GetAverageFrameSize();
}
impl ::windows::core::RuntimeName for IAMDroppedFrames {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMDroppedFrames";
}
impl IAMDroppedFramesVtbl {
    pub const fn new<Impl: IAMDroppedFramesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMDroppedFramesVtbl {
        unsafe extern "system" fn GetNumDropped<Impl: IAMDroppedFramesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pldropped: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumDropped(::core::mem::transmute_copy(&pldropped)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumNotDropped<Impl: IAMDroppedFramesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plnotdropped: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumNotDropped(::core::mem::transmute_copy(&plnotdropped)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDroppedInfo<Impl: IAMDroppedFramesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDroppedInfo(lsize, ::core::mem::transmute_copy(&plarray), ::core::mem::transmute_copy(&plnumcopied)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAverageFrameSize<Impl: IAMDroppedFramesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plaveragesize: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAverageFrameSize(::core::mem::transmute_copy(&plaveragesize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMDroppedFrames>, base.5, GetNumDropped::<Impl, OFFSET>, GetNumNotDropped::<Impl, OFFSET>, GetDroppedInfo::<Impl, OFFSET>, GetAverageFrameSize::<Impl, OFFSET>)
    }
}
pub trait IAMExtDeviceImpl: Sized {
    fn GetCapability();
    fn ExternalDeviceID();
    fn ExternalDeviceVersion();
    fn SetDevicePower();
    fn DevicePower();
    fn Calibrate();
    fn SetDevicePort();
    fn DevicePort();
}
impl ::windows::core::RuntimeName for IAMExtDevice {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMExtDevice";
}
impl IAMExtDeviceVtbl {
    pub const fn new<Impl: IAMExtDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMExtDeviceVtbl {
        unsafe extern "system" fn GetCapability<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapability(capability, ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdblvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExternalDeviceID<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExternalDeviceID(::core::mem::transmute_copy(&ppszdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExternalDeviceVersion<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExternalDeviceVersion(::core::mem::transmute_copy(&ppszdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDevicePower<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, powermode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDevicePower(powermode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DevicePower<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppowermode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DevicePower(::core::mem::transmute_copy(&ppowermode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Calibrate<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hevent: usize, mode: i32, pstatus: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Calibrate(hevent, mode, ::core::mem::transmute_copy(&pstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDevicePort<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, deviceport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDevicePort(deviceport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DevicePort<Impl: IAMExtDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeviceport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DevicePort(::core::mem::transmute_copy(&pdeviceport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMExtDevice>, base.5, GetCapability::<Impl, OFFSET>, ExternalDeviceID::<Impl, OFFSET>, ExternalDeviceVersion::<Impl, OFFSET>, SetDevicePower::<Impl, OFFSET>, DevicePower::<Impl, OFFSET>, Calibrate::<Impl, OFFSET>, SetDevicePort::<Impl, OFFSET>, DevicePort::<Impl, OFFSET>)
    }
}
pub trait IAMExtTransportImpl: Sized {
    fn GetCapability();
    fn SetMediaState();
    fn MediaState();
    fn SetLocalControl();
    fn LocalControl();
    fn GetStatus();
    fn GetTransportBasicParameters();
    fn SetTransportBasicParameters();
    fn GetTransportVideoParameters();
    fn SetTransportVideoParameters();
    fn GetTransportAudioParameters();
    fn SetTransportAudioParameters();
    fn SetMode();
    fn Mode();
    fn SetRate();
    fn Rate();
    fn GetChase();
    fn SetChase();
    fn GetBump();
    fn SetBump();
    fn AntiClogControl();
    fn SetAntiClogControl();
    fn GetEditPropertySet();
    fn SetEditPropertySet();
    fn GetEditProperty();
    fn SetEditProperty();
    fn EditStart();
    fn SetEditStart();
}
impl ::windows::core::RuntimeName for IAMExtTransport {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMExtTransport";
}
impl IAMExtTransportVtbl {
    pub const fn new<Impl: IAMExtTransportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMExtTransportVtbl {
        unsafe extern "system" fn GetCapability<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapability(capability, ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdblvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaState<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaState(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaState<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaState(::core::mem::transmute_copy(&pstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalControl<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalControl(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalControl<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalControl(::core::mem::transmute_copy(&pstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, statusitem: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(statusitem, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportBasicParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportBasicParameters(param, pvalue, &*(&ppszdata as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportBasicParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32, pszdata: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTransportBasicParameters(param, value, &*(&pszdata as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportVideoParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportVideoParameters(param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportVideoParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTransportVideoParameters(param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportAudioParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportAudioParameters(param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportAudioParameters<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTransportAudioParameters(param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Mode<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode(::core::mem::transmute_copy(&pmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dblrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(dblrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Rate<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdblrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Rate(::core::mem::transmute_copy(&pdblrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetChase<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetChase(::core::mem::transmute_copy(&penabled), ::core::mem::transmute_copy(&poffset), ::core::mem::transmute_copy(&phevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChase<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enable: i32, offset: i32, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChase(enable, offset, hevent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBump<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pspeed: *mut i32, pduration: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBump(::core::mem::transmute_copy(&pspeed), ::core::mem::transmute_copy(&pduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBump<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, speed: i32, duration: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBump(speed, duration) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AntiClogControl<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penabled: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AntiClogControl(::core::mem::transmute_copy(&penabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAntiClogControl<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAntiClogControl(enable) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEditPropertySet<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, editid: i32, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEditPropertySet(editid, ::core::mem::transmute_copy(&pstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditPropertySet<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peditid: *mut i32, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEditPropertySet(peditid, state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEditProperty<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, editid: i32, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEditProperty(editid, param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditProperty<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, editid: i32, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEditProperty(editid, param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EditStart<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EditStart(::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditStart<Impl: IAMExtTransportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEditStart(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMExtTransport>,
            base.5,
            GetCapability::<Impl, OFFSET>,
            SetMediaState::<Impl, OFFSET>,
            MediaState::<Impl, OFFSET>,
            SetLocalControl::<Impl, OFFSET>,
            LocalControl::<Impl, OFFSET>,
            GetStatus::<Impl, OFFSET>,
            GetTransportBasicParameters::<Impl, OFFSET>,
            SetTransportBasicParameters::<Impl, OFFSET>,
            GetTransportVideoParameters::<Impl, OFFSET>,
            SetTransportVideoParameters::<Impl, OFFSET>,
            GetTransportAudioParameters::<Impl, OFFSET>,
            SetTransportAudioParameters::<Impl, OFFSET>,
            SetMode::<Impl, OFFSET>,
            Mode::<Impl, OFFSET>,
            SetRate::<Impl, OFFSET>,
            Rate::<Impl, OFFSET>,
            GetChase::<Impl, OFFSET>,
            SetChase::<Impl, OFFSET>,
            GetBump::<Impl, OFFSET>,
            SetBump::<Impl, OFFSET>,
            AntiClogControl::<Impl, OFFSET>,
            SetAntiClogControl::<Impl, OFFSET>,
            GetEditPropertySet::<Impl, OFFSET>,
            SetEditPropertySet::<Impl, OFFSET>,
            GetEditProperty::<Impl, OFFSET>,
            SetEditProperty::<Impl, OFFSET>,
            EditStart::<Impl, OFFSET>,
            SetEditStart::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMExtendedErrorInfoImpl: Sized + IDispatchImpl {
    fn HasError();
    fn ErrorDescription();
    fn ErrorCode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMExtendedErrorInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMExtendedErrorInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMExtendedErrorInfoVtbl {
    pub const fn new<Impl: IAMExtendedErrorInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMExtendedErrorInfoVtbl {
        unsafe extern "system" fn HasError<Impl: IAMExtendedErrorInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phaserror: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasError(phaserror) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ErrorDescription<Impl: IAMExtendedErrorInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrerrordescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ErrorDescription(&*(&pbstrerrordescription as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ErrorCode<Impl: IAMExtendedErrorInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, perrorcode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ErrorCode(perrorcode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMExtendedErrorInfo>, base.5, HasError::<Impl, OFFSET>, ErrorDescription::<Impl, OFFSET>, ErrorCode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMExtendedSeekingImpl: Sized + IDispatchImpl {
    fn ExSeekCapabilities();
    fn MarkerCount();
    fn CurrentMarker();
    fn GetMarkerTime();
    fn GetMarkerName();
    fn SetPlaybackSpeed();
    fn PlaybackSpeed();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMExtendedSeeking {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMExtendedSeeking";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMExtendedSeekingVtbl {
    pub const fn new<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMExtendedSeekingVtbl {
        unsafe extern "system" fn ExSeekCapabilities<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pexcapabilities: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExSeekCapabilities(pexcapabilities) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MarkerCount<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmarkercount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MarkerCount(pmarkercount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentMarker<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrentmarker: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentMarker(pcurrentmarker) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMarkerTime<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, markernum: i32, pmarkertime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMarkerTime(markernum, pmarkertime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMarkerName<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, markernum: i32, pbstrmarkername: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMarkerName(markernum, &*(&pbstrmarkername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaybackSpeed<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, speed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPlaybackSpeed(speed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaybackSpeed<Impl: IAMExtendedSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pspeed: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaybackSpeed(pspeed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMExtendedSeeking>, base.5, ExSeekCapabilities::<Impl, OFFSET>, MarkerCount::<Impl, OFFSET>, CurrentMarker::<Impl, OFFSET>, GetMarkerTime::<Impl, OFFSET>, GetMarkerName::<Impl, OFFSET>, SetPlaybackSpeed::<Impl, OFFSET>, PlaybackSpeed::<Impl, OFFSET>)
    }
}
pub trait IAMFilterGraphCallbackImpl: Sized {
    fn UnableToRender();
}
impl ::windows::core::RuntimeName for IAMFilterGraphCallback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMFilterGraphCallback";
}
impl IAMFilterGraphCallbackVtbl {
    pub const fn new<Impl: IAMFilterGraphCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMFilterGraphCallbackVtbl {
        unsafe extern "system" fn UnableToRender<Impl: IAMFilterGraphCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnableToRender(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMFilterGraphCallback>, base.5, UnableToRender::<Impl, OFFSET>)
    }
}
pub trait IAMFilterMiscFlagsImpl: Sized {
    fn GetMiscFlags();
}
impl ::windows::core::RuntimeName for IAMFilterMiscFlags {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMFilterMiscFlags";
}
impl IAMFilterMiscFlagsVtbl {
    pub const fn new<Impl: IAMFilterMiscFlagsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMFilterMiscFlagsVtbl {
        unsafe extern "system" fn GetMiscFlags<Impl: IAMFilterMiscFlagsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMiscFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMFilterMiscFlags>, base.5, GetMiscFlags::<Impl, OFFSET>)
    }
}
pub trait IAMGraphBuilderCallbackImpl: Sized {
    fn SelectedFilter();
    fn CreatedFilter();
}
impl ::windows::core::RuntimeName for IAMGraphBuilderCallback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMGraphBuilderCallback";
}
impl IAMGraphBuilderCallbackVtbl {
    pub const fn new<Impl: IAMGraphBuilderCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMGraphBuilderCallbackVtbl {
        unsafe extern "system" fn SelectedFilter<Impl: IAMGraphBuilderCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmon: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedFilter(&*(&pmon as *const <super::super::System::Com::IMoniker as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IMoniker as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreatedFilter<Impl: IAMGraphBuilderCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfil: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreatedFilter(&*(&pfil as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMGraphBuilderCallback>, base.5, SelectedFilter::<Impl, OFFSET>, CreatedFilter::<Impl, OFFSET>)
    }
}
pub trait IAMGraphStreamsImpl: Sized {
    fn FindUpstreamInterface();
    fn SyncUsingStreamOffset();
    fn SetMaxGraphLatency();
}
impl ::windows::core::RuntimeName for IAMGraphStreams {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMGraphStreams";
}
impl IAMGraphStreamsVtbl {
    pub const fn new<Impl: IAMGraphStreamsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMGraphStreamsVtbl {
        unsafe extern "system" fn FindUpstreamInterface<Impl: IAMGraphStreamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvinterface: *mut *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindUpstreamInterface(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvinterface), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SyncUsingStreamOffset<Impl: IAMGraphStreamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, busestreamoffset: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SyncUsingStreamOffset(&*(&busestreamoffset as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxGraphLatency<Impl: IAMGraphStreamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtmaxgraphlatency: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxGraphLatency(rtmaxgraphlatency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMGraphStreams>, base.5, FindUpstreamInterface::<Impl, OFFSET>, SyncUsingStreamOffset::<Impl, OFFSET>, SetMaxGraphLatency::<Impl, OFFSET>)
    }
}
pub trait IAMLatencyImpl: Sized {
    fn GetLatency();
}
impl ::windows::core::RuntimeName for IAMLatency {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMLatency";
}
impl IAMLatencyVtbl {
    pub const fn new<Impl: IAMLatencyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMLatencyVtbl {
        unsafe extern "system" fn GetLatency<Impl: IAMLatencyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtlatency: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLatency(::core::mem::transmute_copy(&prtlatency)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMLatency>, base.5, GetLatency::<Impl, OFFSET>)
    }
}
pub trait IAMLine21DecoderImpl: Sized {
    fn GetDecoderLevel();
    fn GetCurrentService();
    fn SetCurrentService();
    fn GetServiceState();
    fn SetServiceState();
    fn GetOutputFormat();
    fn SetOutputFormat();
    fn GetBackgroundColor();
    fn SetBackgroundColor();
    fn GetRedrawAlways();
    fn SetRedrawAlways();
    fn GetDrawBackgroundMode();
    fn SetDrawBackgroundMode();
}
impl ::windows::core::RuntimeName for IAMLine21Decoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMLine21Decoder";
}
impl IAMLine21DecoderVtbl {
    pub const fn new<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMLine21DecoderVtbl {
        unsafe extern "system" fn GetDecoderLevel<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplevel: *mut AM_LINE21_CCLEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderLevel(lplevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentService<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpservice: *mut AM_LINE21_CCSERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentService(lpservice) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentService<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, service: AM_LINE21_CCSERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentService(service) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceState<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpstate: *mut AM_LINE21_CCSTATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceState(lpstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServiceState<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: AM_LINE21_CCSTATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetServiceState(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputFormat<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputFormat(&*(&lpbmih as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFormat<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFormat(&*(&lpbmi as *const <super::super::Graphics::Gdi::BITMAPINFO as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::BITMAPINFO as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwphyscolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor(pdwphyscolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwphyscolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundColor(dwphyscolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRedrawAlways<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpboption: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRedrawAlways(lpboption) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRedrawAlways<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, boption: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRedrawAlways(&*(&boption as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpmode: *mut AM_LINE21_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDrawBackgroundMode(lpmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Impl: IAMLine21DecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: AM_LINE21_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDrawBackgroundMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMLine21Decoder>,
            base.5,
            GetDecoderLevel::<Impl, OFFSET>,
            GetCurrentService::<Impl, OFFSET>,
            SetCurrentService::<Impl, OFFSET>,
            GetServiceState::<Impl, OFFSET>,
            SetServiceState::<Impl, OFFSET>,
            GetOutputFormat::<Impl, OFFSET>,
            SetOutputFormat::<Impl, OFFSET>,
            GetBackgroundColor::<Impl, OFFSET>,
            SetBackgroundColor::<Impl, OFFSET>,
            GetRedrawAlways::<Impl, OFFSET>,
            SetRedrawAlways::<Impl, OFFSET>,
            GetDrawBackgroundMode::<Impl, OFFSET>,
            SetDrawBackgroundMode::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMMediaContentImpl: Sized + IDispatchImpl {
    fn AuthorName();
    fn Title();
    fn Rating();
    fn Description();
    fn Copyright();
    fn BaseURL();
    fn LogoURL();
    fn LogoIconURL();
    fn WatermarkURL();
    fn MoreInfoURL();
    fn MoreInfoBannerImage();
    fn MoreInfoBannerURL();
    fn MoreInfoText();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMMediaContent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMediaContent";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaContentVtbl {
    pub const fn new<Impl: IAMMediaContentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMediaContentVtbl {
        unsafe extern "system" fn AuthorName<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrauthorname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AuthorName(&*(&pbstrauthorname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Title<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrtitle: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Title(&*(&pbstrtitle as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Rating<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrrating: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Rating(&*(&pbstrrating as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description(&*(&pbstrdescription as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Copyright<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrcopyright: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Copyright(&*(&pbstrcopyright as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaseURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrbaseurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BaseURL(&*(&pbstrbaseurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LogoURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LogoURL(&*(&pbstrlogourl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LogoIconURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LogoIconURL(&*(&pbstrlogourl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WatermarkURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrwatermarkurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WatermarkURL(&*(&pbstrwatermarkurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MoreInfoURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrmoreinfourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MoreInfoURL(&*(&pbstrmoreinfourl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MoreInfoBannerImage<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrmoreinfobannerimage: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MoreInfoBannerImage(&*(&pbstrmoreinfobannerimage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MoreInfoBannerURL<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrmoreinfobannerurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MoreInfoBannerURL(&*(&pbstrmoreinfobannerurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MoreInfoText<Impl: IAMMediaContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrmoreinfotext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MoreInfoText(&*(&pbstrmoreinfotext as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMMediaContent>, base.5, AuthorName::<Impl, OFFSET>, Title::<Impl, OFFSET>, Rating::<Impl, OFFSET>, Description::<Impl, OFFSET>, Copyright::<Impl, OFFSET>, BaseURL::<Impl, OFFSET>, LogoURL::<Impl, OFFSET>, LogoIconURL::<Impl, OFFSET>, WatermarkURL::<Impl, OFFSET>, MoreInfoURL::<Impl, OFFSET>, MoreInfoBannerImage::<Impl, OFFSET>, MoreInfoBannerURL::<Impl, OFFSET>, MoreInfoText::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMMediaContent2Impl: Sized + IDispatchImpl {
    fn MediaParameter();
    fn MediaParameterName();
    fn PlaylistCount();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMMediaContent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMediaContent2";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaContent2Vtbl {
    pub const fn new<Impl: IAMMediaContent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMediaContent2Vtbl {
        unsafe extern "system" fn MediaParameter<Impl: IAMMediaContent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, entrynum: i32, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrvalue: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaParameter(entrynum, &*(&bstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&pbstrvalue as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaParameterName<Impl: IAMMediaContent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, entrynum: i32, index: i32, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaParameterName(entrynum, index, &*(&pbstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaylistCount<Impl: IAMMediaContent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnumberentries: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaylistCount(pnumberentries) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMMediaContent2>, base.5, MediaParameter::<Impl, OFFSET>, MediaParameterName::<Impl, OFFSET>, PlaylistCount::<Impl, OFFSET>)
    }
}
pub trait IAMMediaStreamImpl: Sized + IMediaStreamImpl {
    fn Initialize();
    fn SetState();
    fn JoinAMMultiMediaStream();
    fn JoinFilter();
    fn JoinFilterGraph();
}
impl ::windows::core::RuntimeName for IAMMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMediaStream";
}
impl IAMMediaStreamVtbl {
    pub const fn new<Impl: IAMMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMediaStreamVtbl {
        unsafe extern "system" fn Initialize<Impl: IAMMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourceobject: *mut ::core::ffi::c_void, dwflags: u32, purposeid: *const ::windows::core::GUID, streamtype: STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psourceobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), dwflags, &*(&purposeid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), streamtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetState<Impl: IAMMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: FILTER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetState(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn JoinAMMultiMediaStream<Impl: IAMMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pammultimediastream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).JoinAMMultiMediaStream(&*(&pammultimediastream as *const <IAMMultiMediaStream as ::windows::core::Abi>::Abi as *const <IAMMultiMediaStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn JoinFilter<Impl: IAMMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediastreamfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).JoinFilter(&*(&pmediastreamfilter as *const <IMediaStreamFilter as ::windows::core::Abi>::Abi as *const <IMediaStreamFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn JoinFilterGraph<Impl: IAMMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfiltergraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).JoinFilterGraph(&*(&pfiltergraph as *const <IFilterGraph as ::windows::core::Abi>::Abi as *const <IFilterGraph as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMMediaStream>, base.5, Initialize::<Impl, OFFSET>, SetState::<Impl, OFFSET>, JoinAMMultiMediaStream::<Impl, OFFSET>, JoinFilter::<Impl, OFFSET>, JoinFilterGraph::<Impl, OFFSET>)
    }
}
pub trait IAMMediaTypeSampleImpl: Sized + IStreamSampleImpl {
    fn SetPointer();
    fn GetPointer();
    fn GetSize();
    fn GetTime();
    fn SetTime();
    fn IsSyncPoint();
    fn SetSyncPoint();
    fn IsPreroll();
    fn SetPreroll();
    fn GetActualDataLength();
    fn SetActualDataLength();
    fn GetMediaType();
    fn SetMediaType();
    fn IsDiscontinuity();
    fn SetDiscontinuity();
    fn GetMediaTime();
    fn SetMediaTime();
}
impl ::windows::core::RuntimeName for IAMMediaTypeSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMediaTypeSample";
}
impl IAMMediaTypeSampleVtbl {
    pub const fn new<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMediaTypeSampleVtbl {
        unsafe extern "system" fn SetPointer<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: *const u8, lsize: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPointer(pbuffer, lsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPointer<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPointer(::core::mem::transmute_copy(&ppbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSize<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTime(ptimestart, ptimeend) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSyncPoint<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSyncPoint() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncPoint<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncPoint(&*(&bissyncpoint as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPreroll<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPreroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreroll<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreroll(&*(&bispreroll as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActualDataLength<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActualDataLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActualDataLength<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__iammediatypesample0000: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetActualDataLength(__midl__iammediatypesample0000) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaType(::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(&*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDiscontinuity<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDiscontinuity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiscontinuity<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiscontinuity(&*(&bdiscontinuity as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTime<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaTime<Impl: IAMMediaTypeSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaTime(ptimestart, ptimeend) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMMediaTypeSample>,
            base.5,
            SetPointer::<Impl, OFFSET>,
            GetPointer::<Impl, OFFSET>,
            GetSize::<Impl, OFFSET>,
            GetTime::<Impl, OFFSET>,
            SetTime::<Impl, OFFSET>,
            IsSyncPoint::<Impl, OFFSET>,
            SetSyncPoint::<Impl, OFFSET>,
            IsPreroll::<Impl, OFFSET>,
            SetPreroll::<Impl, OFFSET>,
            GetActualDataLength::<Impl, OFFSET>,
            SetActualDataLength::<Impl, OFFSET>,
            GetMediaType::<Impl, OFFSET>,
            SetMediaType::<Impl, OFFSET>,
            IsDiscontinuity::<Impl, OFFSET>,
            SetDiscontinuity::<Impl, OFFSET>,
            GetMediaTime::<Impl, OFFSET>,
            SetMediaTime::<Impl, OFFSET>,
        )
    }
}
pub trait IAMMediaTypeStreamImpl: Sized + IMediaStreamImpl {
    fn GetFormat();
    fn SetFormat();
    fn CreateSample();
    fn GetStreamAllocatorRequirements();
    fn SetStreamAllocatorRequirements();
}
impl ::windows::core::RuntimeName for IAMMediaTypeStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMediaTypeStream";
}
impl IAMMediaTypeStreamVtbl {
    pub const fn new<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMediaTypeStreamVtbl {
        unsafe extern "system" fn GetFormat<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *mut AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormat(::core::mem::transmute_copy(&pmediatype), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFormat(&*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSample<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: *mut ::core::ffi::c_void, ppammediatypesample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSample(lsamplesize, pbbuffer, dwflags, &*(&punkouter as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppammediatypesample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAllocatorRequirements<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAllocatorRequirements(::core::mem::transmute_copy(&pprops)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamAllocatorRequirements<Impl: IAMMediaTypeStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprops: *const ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamAllocatorRequirements(&*(&pprops as *const <ALLOCATOR_PROPERTIES as ::windows::core::Abi>::Abi as *const <ALLOCATOR_PROPERTIES as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMMediaTypeStream>, base.5, GetFormat::<Impl, OFFSET>, SetFormat::<Impl, OFFSET>, CreateSample::<Impl, OFFSET>, GetStreamAllocatorRequirements::<Impl, OFFSET>, SetStreamAllocatorRequirements::<Impl, OFFSET>)
    }
}
pub trait IAMMultiMediaStreamImpl: Sized + IMultiMediaStreamImpl {
    fn Initialize();
    fn GetFilterGraph();
    fn GetFilter();
    fn AddMediaStream();
    fn OpenFile();
    fn OpenMoniker();
    fn Render();
}
impl ::windows::core::RuntimeName for IAMMultiMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMMultiMediaStream";
}
impl IAMMultiMediaStreamVtbl {
    pub const fn new<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMMultiMediaStreamVtbl {
        unsafe extern "system" fn Initialize<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamtype: STREAM_TYPE, dwflags: AMMSF_MMS_INIT_FLAGS, pfiltergraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(streamtype, dwflags, &*(&pfiltergraph as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterGraph<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppgraphbuilder: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilterGraph(::core::mem::transmute_copy(&ppgraphbuilder)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilter<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilter(::core::mem::transmute_copy(&ppfilter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddMediaStream<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstreamobject: *mut ::core::ffi::c_void, purposeid: *const ::windows::core::GUID, dwflags: AMMSF_MS_FLAGS, ppnewstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddMediaStream(&*(&pstreamobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&purposeid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppnewstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenFile<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenFile(&*(&pszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenMoniker<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pctx: ::windows::core::RawPtr, pmoniker: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenMoniker(&*(&pctx as *const <super::super::System::Com::IBindCtx as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IBindCtx as ::windows::core::DefaultType>::DefaultType), &*(&pmoniker as *const <super::super::System::Com::IMoniker as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IMoniker as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Render<Impl: IAMMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Render(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMMultiMediaStream>, base.5, Initialize::<Impl, OFFSET>, GetFilterGraph::<Impl, OFFSET>, GetFilter::<Impl, OFFSET>, AddMediaStream::<Impl, OFFSET>, OpenFile::<Impl, OFFSET>, OpenMoniker::<Impl, OFFSET>, Render::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMNetShowConfigImpl: Sized + IDispatchImpl {
    fn BufferingTime();
    fn SetBufferingTime();
    fn UseFixedUDPPort();
    fn SetUseFixedUDPPort();
    fn FixedUDPPort();
    fn SetFixedUDPPort();
    fn UseHTTPProxy();
    fn SetUseHTTPProxy();
    fn EnableAutoProxy();
    fn SetEnableAutoProxy();
    fn HTTPProxyHost();
    fn SetHTTPProxyHost();
    fn HTTPProxyPort();
    fn SetHTTPProxyPort();
    fn EnableMulticast();
    fn SetEnableMulticast();
    fn EnableUDP();
    fn SetEnableUDP();
    fn EnableTCP();
    fn SetEnableTCP();
    fn EnableHTTP();
    fn SetEnableHTTP();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMNetShowConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMNetShowConfig";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowConfigVtbl {
    pub const fn new<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMNetShowConfigVtbl {
        unsafe extern "system" fn BufferingTime<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbufferingtime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingTime(pbufferingtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBufferingTime<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bufferingtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBufferingTime(bufferingtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseFixedUDPPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pusefixedudpport: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseFixedUDPPort(pusefixedudpport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseFixedUDPPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usefixedudpport: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUseFixedUDPPort(usefixedudpport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FixedUDPPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfixedudpport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FixedUDPPort(pfixedudpport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFixedUDPPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fixedudpport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFixedUDPPort(fixedudpport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseHTTPProxy<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pusehttpproxy: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseHTTPProxy(pusehttpproxy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseHTTPProxy<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usehttpproxy: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUseHTTPProxy(usehttpproxy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableAutoProxy<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penableautoproxy: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableAutoProxy(penableautoproxy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableAutoProxy<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enableautoproxy: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableAutoProxy(enableautoproxy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HTTPProxyHost<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrhttpproxyhost: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HTTPProxyHost(&*(&pbstrhttpproxyhost as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHTTPProxyHost<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrhttpproxyhost: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHTTPProxyHost(&*(&bstrhttpproxyhost as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HTTPProxyPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phttpproxyport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HTTPProxyPort(phttpproxyport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHTTPProxyPort<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, httpproxyport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHTTPProxyPort(httpproxyport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableMulticast<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penablemulticast: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableMulticast(penablemulticast) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableMulticast<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enablemulticast: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableMulticast(enablemulticast) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableUDP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penableudp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableUDP(penableudp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableUDP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enableudp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableUDP(enableudp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableTCP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penabletcp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableTCP(penabletcp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableTCP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enabletcp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableTCP(enabletcp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableHTTP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penablehttp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableHTTP(penablehttp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableHTTP<Impl: IAMNetShowConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enablehttp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableHTTP(enablehttp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMNetShowConfig>,
            base.5,
            BufferingTime::<Impl, OFFSET>,
            SetBufferingTime::<Impl, OFFSET>,
            UseFixedUDPPort::<Impl, OFFSET>,
            SetUseFixedUDPPort::<Impl, OFFSET>,
            FixedUDPPort::<Impl, OFFSET>,
            SetFixedUDPPort::<Impl, OFFSET>,
            UseHTTPProxy::<Impl, OFFSET>,
            SetUseHTTPProxy::<Impl, OFFSET>,
            EnableAutoProxy::<Impl, OFFSET>,
            SetEnableAutoProxy::<Impl, OFFSET>,
            HTTPProxyHost::<Impl, OFFSET>,
            SetHTTPProxyHost::<Impl, OFFSET>,
            HTTPProxyPort::<Impl, OFFSET>,
            SetHTTPProxyPort::<Impl, OFFSET>,
            EnableMulticast::<Impl, OFFSET>,
            SetEnableMulticast::<Impl, OFFSET>,
            EnableUDP::<Impl, OFFSET>,
            SetEnableUDP::<Impl, OFFSET>,
            EnableTCP::<Impl, OFFSET>,
            SetEnableTCP::<Impl, OFFSET>,
            EnableHTTP::<Impl, OFFSET>,
            SetEnableHTTP::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMNetShowExPropsImpl: Sized + IDispatchImpl {
    fn SourceProtocol();
    fn Bandwidth();
    fn ErrorCorrection();
    fn CodecCount();
    fn GetCodecInstalled();
    fn GetCodecDescription();
    fn GetCodecURL();
    fn CreationDate();
    fn SourceLink();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMNetShowExProps {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMNetShowExProps";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowExPropsVtbl {
    pub const fn new<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMNetShowExPropsVtbl {
        unsafe extern "system" fn SourceProtocol<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourceprotocol: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProtocol(psourceprotocol) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Bandwidth<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbandwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bandwidth(pbandwidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ErrorCorrection<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrerrorcorrection: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ErrorCorrection(&*(&pbstrerrorcorrection as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CodecCount<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcodeccount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CodecCount(pcodeccount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecInstalled<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, codecnum: i32, pcodecinstalled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecInstalled(codecnum, pcodecinstalled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecDescription<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, codecnum: i32, pbstrcodecdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecDescription(codecnum, &*(&pbstrcodecdescription as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecURL<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, codecnum: i32, pbstrcodecurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecURL(codecnum, &*(&pbstrcodecurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreationDate<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcreationdate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreationDate(pcreationdate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceLink<Impl: IAMNetShowExPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrsourcelink: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceLink(&*(&pbstrsourcelink as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMNetShowExProps>, base.5, SourceProtocol::<Impl, OFFSET>, Bandwidth::<Impl, OFFSET>, ErrorCorrection::<Impl, OFFSET>, CodecCount::<Impl, OFFSET>, GetCodecInstalled::<Impl, OFFSET>, GetCodecDescription::<Impl, OFFSET>, GetCodecURL::<Impl, OFFSET>, CreationDate::<Impl, OFFSET>, SourceLink::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMNetShowPrerollImpl: Sized + IDispatchImpl {
    fn SetPreroll();
    fn Preroll();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMNetShowPreroll {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMNetShowPreroll";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowPrerollVtbl {
    pub const fn new<Impl: IAMNetShowPrerollImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMNetShowPrerollVtbl {
        unsafe extern "system" fn SetPreroll<Impl: IAMNetShowPrerollImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fpreroll: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreroll(fpreroll) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Preroll<Impl: IAMNetShowPrerollImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfpreroll: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Preroll(pfpreroll) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMNetShowPreroll>, base.5, SetPreroll::<Impl, OFFSET>, Preroll::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMNetworkStatusImpl: Sized + IDispatchImpl {
    fn ReceivedPackets();
    fn RecoveredPackets();
    fn LostPackets();
    fn ReceptionQuality();
    fn BufferingCount();
    fn IsBroadcast();
    fn BufferingProgress();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMNetworkStatus {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMNetworkStatus";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMNetworkStatusVtbl {
    pub const fn new<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMNetworkStatusVtbl {
        unsafe extern "system" fn ReceivedPackets<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, preceivedpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReceivedPackets(preceivedpackets) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecoveredPackets<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, precoveredpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecoveredPackets(precoveredpackets) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LostPackets<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plostpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LostPackets(plostpackets) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReceptionQuality<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, preceptionquality: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReceptionQuality(preceptionquality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingCount<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbufferingcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingCount(pbufferingcount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsBroadcast<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pisbroadcast: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBroadcast(pisbroadcast) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgress<Impl: IAMNetworkStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbufferingprogress: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingProgress(pbufferingprogress) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMNetworkStatus>, base.5, ReceivedPackets::<Impl, OFFSET>, RecoveredPackets::<Impl, OFFSET>, LostPackets::<Impl, OFFSET>, ReceptionQuality::<Impl, OFFSET>, BufferingCount::<Impl, OFFSET>, IsBroadcast::<Impl, OFFSET>, BufferingProgress::<Impl, OFFSET>)
    }
}
pub trait IAMOpenProgressImpl: Sized {
    fn QueryProgress();
    fn AbortOperation();
}
impl ::windows::core::RuntimeName for IAMOpenProgress {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMOpenProgress";
}
impl IAMOpenProgressVtbl {
    pub const fn new<Impl: IAMOpenProgressImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMOpenProgressVtbl {
        unsafe extern "system" fn QueryProgress<Impl: IAMOpenProgressImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plltotal: *mut i64, pllcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryProgress(::core::mem::transmute_copy(&plltotal), ::core::mem::transmute_copy(&pllcurrent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AbortOperation<Impl: IAMOpenProgressImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AbortOperation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMOpenProgress>, base.5, QueryProgress::<Impl, OFFSET>, AbortOperation::<Impl, OFFSET>)
    }
}
pub trait IAMOverlayFXImpl: Sized {
    fn QueryOverlayFXCaps();
    fn SetOverlayFX();
    fn GetOverlayFX();
}
impl ::windows::core::RuntimeName for IAMOverlayFX {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMOverlayFX";
}
impl IAMOverlayFXVtbl {
    pub const fn new<Impl: IAMOverlayFXImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMOverlayFXVtbl {
        unsafe extern "system" fn QueryOverlayFXCaps<Impl: IAMOverlayFXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwoverlayfxcaps: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryOverlayFXCaps(::core::mem::transmute_copy(&lpdwoverlayfxcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverlayFX<Impl: IAMOverlayFXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoverlayfx: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOverlayFX(dwoverlayfx) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOverlayFX<Impl: IAMOverlayFXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwoverlayfx: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOverlayFX(::core::mem::transmute_copy(&lpdwoverlayfx)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMOverlayFX>, base.5, QueryOverlayFXCaps::<Impl, OFFSET>, SetOverlayFX::<Impl, OFFSET>, GetOverlayFX::<Impl, OFFSET>)
    }
}
pub trait IAMParseImpl: Sized {
    fn GetParseTime();
    fn SetParseTime();
    fn Flush();
}
impl ::windows::core::RuntimeName for IAMParse {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMParse";
}
impl IAMParseVtbl {
    pub const fn new<Impl: IAMParseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMParseVtbl {
        unsafe extern "system" fn GetParseTime<Impl: IAMParseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParseTime(::core::mem::transmute_copy(&prtcurrent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParseTime<Impl: IAMParseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtcurrent: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetParseTime(rtcurrent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IAMParseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMParse>, base.5, GetParseTime::<Impl, OFFSET>, SetParseTime::<Impl, OFFSET>, Flush::<Impl, OFFSET>)
    }
}
pub trait IAMPhysicalPinInfoImpl: Sized {
    fn GetPhysicalType();
}
impl ::windows::core::RuntimeName for IAMPhysicalPinInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMPhysicalPinInfo";
}
impl IAMPhysicalPinInfoVtbl {
    pub const fn new<Impl: IAMPhysicalPinInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMPhysicalPinInfoVtbl {
        unsafe extern "system" fn GetPhysicalType<Impl: IAMPhysicalPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut i32, ppsztype: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPhysicalType(::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&ppsztype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMPhysicalPinInfo>, base.5, GetPhysicalType::<Impl, OFFSET>)
    }
}
pub trait IAMPlayListImpl: Sized {
    fn GetFlags();
    fn GetItemCount();
    fn GetItem();
    fn GetNamedEvent();
    fn GetRepeatInfo();
}
impl ::windows::core::RuntimeName for IAMPlayList {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMPlayList";
}
impl IAMPlayListVtbl {
    pub const fn new<Impl: IAMPlayListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMPlayListVtbl {
        unsafe extern "system" fn GetFlags<Impl: IAMPlayListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemCount<Impl: IAMPlayListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwitems: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItemCount(::core::mem::transmute_copy(&pdwitems)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItem<Impl: IAMPlayListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwitemindex: u32, ppitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItem(dwitemindex, ::core::mem::transmute_copy(&ppitem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNamedEvent<Impl: IAMPlayListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszeventname: super::super::Foundation::PWSTR, dwitemindex: u32, ppitem: *mut ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNamedEvent(&*(&pwszeventname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwitemindex, ::core::mem::transmute_copy(&ppitem), ::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepeatInfo<Impl: IAMPlayListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRepeatInfo(::core::mem::transmute_copy(&pdwrepeatcount), ::core::mem::transmute_copy(&pdwrepeatstart), ::core::mem::transmute_copy(&pdwrepeatend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMPlayList>, base.5, GetFlags::<Impl, OFFSET>, GetItemCount::<Impl, OFFSET>, GetItem::<Impl, OFFSET>, GetNamedEvent::<Impl, OFFSET>, GetRepeatInfo::<Impl, OFFSET>)
    }
}
pub trait IAMPlayListItemImpl: Sized {
    fn GetFlags();
    fn GetSourceCount();
    fn GetSourceURL();
    fn GetSourceStart();
    fn GetSourceDuration();
    fn GetSourceStartMarker();
    fn GetSourceEndMarker();
    fn GetSourceStartMarkerName();
    fn GetSourceEndMarkerName();
    fn GetLinkURL();
    fn GetScanDuration();
}
impl ::windows::core::RuntimeName for IAMPlayListItem {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMPlayListItem";
}
impl IAMPlayListItemVtbl {
    pub const fn new<Impl: IAMPlayListItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMPlayListItemVtbl {
        unsafe extern "system" fn GetFlags<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceCount<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwsources: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceCount(::core::mem::transmute_copy(&pdwsources)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceURL<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceURL(dwsourceindex, ::core::mem::transmute_copy(&pbstrurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStart<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceStart(dwsourceindex, ::core::mem::transmute_copy(&prtstart)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceDuration<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceDuration(dwsourceindex, ::core::mem::transmute_copy(&prtduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStartMarker<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceStartMarker(dwsourceindex, ::core::mem::transmute_copy(&pdwmarker)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceEndMarker<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceEndMarker(dwsourceindex, ::core::mem::transmute_copy(&pdwmarker)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStartMarkerName<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrstartmarker: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceStartMarkerName(dwsourceindex, ::core::mem::transmute_copy(&pbstrstartmarker)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceEndMarkerName<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrendmarker: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceEndMarkerName(dwsourceindex, ::core::mem::transmute_copy(&pbstrendmarker)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLinkURL<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLinkURL(::core::mem::transmute_copy(&pbstrurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScanDuration<Impl: IAMPlayListItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtscanduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetScanDuration(dwsourceindex, ::core::mem::transmute_copy(&prtscanduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMPlayListItem>, base.5, GetFlags::<Impl, OFFSET>, GetSourceCount::<Impl, OFFSET>, GetSourceURL::<Impl, OFFSET>, GetSourceStart::<Impl, OFFSET>, GetSourceDuration::<Impl, OFFSET>, GetSourceStartMarker::<Impl, OFFSET>, GetSourceEndMarker::<Impl, OFFSET>, GetSourceStartMarkerName::<Impl, OFFSET>, GetSourceEndMarkerName::<Impl, OFFSET>, GetLinkURL::<Impl, OFFSET>, GetScanDuration::<Impl, OFFSET>)
    }
}
pub trait IAMPluginControlImpl: Sized {
    fn GetPreferredClsid();
    fn GetPreferredClsidByIndex();
    fn SetPreferredClsid();
    fn IsDisabled();
    fn GetDisabledByIndex();
    fn SetDisabled();
    fn IsLegacyDisabled();
}
impl ::windows::core::RuntimeName for IAMPluginControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMPluginControl";
}
impl IAMPluginControlVtbl {
    pub const fn new<Impl: IAMPluginControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMPluginControlVtbl {
        unsafe extern "system" fn GetPreferredClsid<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, subtype: *const ::windows::core::GUID, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsid(&*(&subtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, subtype: *mut ::windows::core::GUID, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsidByIndex(index, ::core::mem::transmute_copy(&subtype), ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferredClsid<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, subtype: *const ::windows::core::GUID, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreferredClsid(&*(&subtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDisabled<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDisabled(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisabledByIndex<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDisabledByIndex(index, ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabled<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDisabled(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&disabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLegacyDisabled<Impl: IAMPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dllname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsLegacyDisabled(&*(&dllname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMPluginControl>, base.5, GetPreferredClsid::<Impl, OFFSET>, GetPreferredClsidByIndex::<Impl, OFFSET>, SetPreferredClsid::<Impl, OFFSET>, IsDisabled::<Impl, OFFSET>, GetDisabledByIndex::<Impl, OFFSET>, SetDisabled::<Impl, OFFSET>, IsLegacyDisabled::<Impl, OFFSET>)
    }
}
pub trait IAMPushSourceImpl: Sized + IAMLatencyImpl {
    fn GetPushSourceFlags();
    fn SetPushSourceFlags();
    fn SetStreamOffset();
    fn GetStreamOffset();
    fn GetMaxStreamOffset();
    fn SetMaxStreamOffset();
}
impl ::windows::core::RuntimeName for IAMPushSource {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMPushSource";
}
impl IAMPushSourceVtbl {
    pub const fn new<Impl: IAMPushSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMPushSourceVtbl {
        unsafe extern "system" fn GetPushSourceFlags<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPushSourceFlags(::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPushSourceFlags<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPushSourceFlags(flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamOffset<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamOffset(rtoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamOffset<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtoffset: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamOffset(::core::mem::transmute_copy(&prtoffset)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxStreamOffset<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtmaxoffset: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxStreamOffset(::core::mem::transmute_copy(&prtmaxoffset)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxStreamOffset<Impl: IAMPushSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtmaxoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxStreamOffset(rtmaxoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMPushSource>, base.5, GetPushSourceFlags::<Impl, OFFSET>, SetPushSourceFlags::<Impl, OFFSET>, SetStreamOffset::<Impl, OFFSET>, GetStreamOffset::<Impl, OFFSET>, GetMaxStreamOffset::<Impl, OFFSET>, SetMaxStreamOffset::<Impl, OFFSET>)
    }
}
pub trait IAMRebuildImpl: Sized {
    fn RebuildNow();
}
impl ::windows::core::RuntimeName for IAMRebuild {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMRebuild";
}
impl IAMRebuildVtbl {
    pub const fn new<Impl: IAMRebuildImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMRebuildVtbl {
        unsafe extern "system" fn RebuildNow<Impl: IAMRebuildImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RebuildNow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMRebuild>, base.5, RebuildNow::<Impl, OFFSET>)
    }
}
pub trait IAMResourceControlImpl: Sized {
    fn Reserve();
}
impl ::windows::core::RuntimeName for IAMResourceControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMResourceControl";
}
impl IAMResourceControlVtbl {
    pub const fn new<Impl: IAMResourceControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMResourceControlVtbl {
        unsafe extern "system" fn Reserve<Impl: IAMResourceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pvreserved: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reserve(dwflags, &*(&pvreserved as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMResourceControl>, base.5, Reserve::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMStatsImpl: Sized + IDispatchImpl {
    fn Reset();
    fn Count();
    fn GetValueByIndex();
    fn GetValueByName();
    fn GetIndex();
    fn AddValue();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAMStats {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMStats";
}
#[cfg(feature = "Win32_System_Com")]
impl IAMStatsVtbl {
    pub const fn new<Impl: IAMStatsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMStatsVtbl {
        unsafe extern "system" fn Reset<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&plcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValueByIndex<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, szname: *mut super::super::Foundation::BSTR, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValueByIndex(lindex, ::core::mem::transmute_copy(&szname), ::core::mem::transmute_copy(&lcount), ::core::mem::transmute_copy(&dlast), ::core::mem::transmute_copy(&daverage), ::core::mem::transmute_copy(&dstddev), ::core::mem::transmute_copy(&dmin), ::core::mem::transmute_copy(&dmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValueByName<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValueByName(&*(&szname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&lcount), ::core::mem::transmute_copy(&dlast), ::core::mem::transmute_copy(&daverage), ::core::mem::transmute_copy(&dstddev), ::core::mem::transmute_copy(&dmin), ::core::mem::transmute_copy(&dmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndex<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, lcreate: i32, plindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndex(&*(&szname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), lcreate, ::core::mem::transmute_copy(&plindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddValue<Impl: IAMStatsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, dvalue: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddValue(lindex, dvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMStats>, base.5, Reset::<Impl, OFFSET>, Count::<Impl, OFFSET>, GetValueByIndex::<Impl, OFFSET>, GetValueByName::<Impl, OFFSET>, GetIndex::<Impl, OFFSET>, AddValue::<Impl, OFFSET>)
    }
}
pub trait IAMStreamConfigImpl: Sized {
    fn SetFormat();
    fn GetFormat();
    fn GetNumberOfCapabilities();
    fn GetStreamCaps();
}
impl ::windows::core::RuntimeName for IAMStreamConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMStreamConfig";
}
impl IAMStreamConfigVtbl {
    pub const fn new<Impl: IAMStreamConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMStreamConfigVtbl {
        unsafe extern "system" fn SetFormat<Impl: IAMStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFormat(&*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFormat<Impl: IAMStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmt: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormat(::core::mem::transmute_copy(&ppmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfCapabilities<Impl: IAMStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picount: *mut i32, pisize: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfCapabilities(::core::mem::transmute_copy(&picount), ::core::mem::transmute_copy(&pisize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamCaps<Impl: IAMStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, iindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pscc: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCaps(iindex, ::core::mem::transmute_copy(&ppmt), ::core::mem::transmute_copy(&pscc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMStreamConfig>, base.5, SetFormat::<Impl, OFFSET>, GetFormat::<Impl, OFFSET>, GetNumberOfCapabilities::<Impl, OFFSET>, GetStreamCaps::<Impl, OFFSET>)
    }
}
pub trait IAMStreamControlImpl: Sized {
    fn StartAt();
    fn StopAt();
    fn GetInfo();
}
impl ::windows::core::RuntimeName for IAMStreamControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMStreamControl";
}
impl IAMStreamControlVtbl {
    pub const fn new<Impl: IAMStreamControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMStreamControlVtbl {
        unsafe extern "system" fn StartAt<Impl: IAMStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptstart: *const i64, dwcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartAt(ptstart, dwcookie) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopAt<Impl: IAMStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptstop: *const i64, bsendextra: super::super::Foundation::BOOL, dwcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopAt(ptstop, &*(&bsendextra as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), dwcookie) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInfo<Impl: IAMStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinfo: *mut AM_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInfo(::core::mem::transmute_copy(&pinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMStreamControl>, base.5, StartAt::<Impl, OFFSET>, StopAt::<Impl, OFFSET>, GetInfo::<Impl, OFFSET>)
    }
}
pub trait IAMStreamSelectImpl: Sized {
    fn Count();
    fn Info();
    fn Enable();
}
impl ::windows::core::RuntimeName for IAMStreamSelect {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMStreamSelect";
}
impl IAMStreamSelectVtbl {
    pub const fn new<Impl: IAMStreamSelectImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMStreamSelectVtbl {
        unsafe extern "system" fn Count<Impl: IAMStreamSelectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&pcstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Info<Impl: IAMStreamSelectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pdwflags: *mut u32, plcid: *mut u32, pdwgroup: *mut u32, ppszname: *mut super::super::Foundation::PWSTR, ppobject: *mut *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Info(lindex, ::core::mem::transmute_copy(&ppmt), ::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&plcid), ::core::mem::transmute_copy(&pdwgroup), ::core::mem::transmute_copy(&ppszname), ::core::mem::transmute_copy(&ppobject), ::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Enable<Impl: IAMStreamSelectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Enable(lindex, dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMStreamSelect>, base.5, Count::<Impl, OFFSET>, Info::<Impl, OFFSET>, Enable::<Impl, OFFSET>)
    }
}
pub trait IAMTVAudioImpl: Sized {
    fn GetHardwareSupportedTVAudioModes();
    fn GetAvailableTVAudioModes();
    fn TVAudioMode();
    fn SetTVAudioMode();
    fn RegisterNotificationCallBack();
    fn UnRegisterNotificationCallBack();
}
impl ::windows::core::RuntimeName for IAMTVAudio {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTVAudio";
}
impl IAMTVAudioVtbl {
    pub const fn new<Impl: IAMTVAudioImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTVAudioVtbl {
        unsafe extern "system" fn GetHardwareSupportedTVAudioModes<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHardwareSupportedTVAudioModes(::core::mem::transmute_copy(&plmodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableTVAudioModes<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableTVAudioModes(::core::mem::transmute_copy(&plmodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVAudioMode<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TVAudioMode(::core::mem::transmute_copy(&plmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVAudioMode<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTVAudioMode(lmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr, levents: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterNotificationCallBack(&*(&pnotify as *const <IAMTunerNotification as ::windows::core::Abi>::Abi as *const <IAMTunerNotification as ::windows::core::DefaultType>::DefaultType), levents) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Impl: IAMTVAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnRegisterNotificationCallBack(&*(&pnotify as *const <IAMTunerNotification as ::windows::core::Abi>::Abi as *const <IAMTunerNotification as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTVAudio>, base.5, GetHardwareSupportedTVAudioModes::<Impl, OFFSET>, GetAvailableTVAudioModes::<Impl, OFFSET>, TVAudioMode::<Impl, OFFSET>, SetTVAudioMode::<Impl, OFFSET>, RegisterNotificationCallBack::<Impl, OFFSET>, UnRegisterNotificationCallBack::<Impl, OFFSET>)
    }
}
pub trait IAMTVAudioNotificationImpl: Sized {
    fn OnEvent();
}
impl ::windows::core::RuntimeName for IAMTVAudioNotification {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTVAudioNotification";
}
impl IAMTVAudioNotificationVtbl {
    pub const fn new<Impl: IAMTVAudioNotificationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTVAudioNotificationVtbl {
        unsafe extern "system" fn OnEvent<Impl: IAMTVAudioNotificationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, event: AMTVAudioEventType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnEvent(event) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTVAudioNotification>, base.5, OnEvent::<Impl, OFFSET>)
    }
}
pub trait IAMTVTunerImpl: Sized + IAMTunerImpl {
    fn AvailableTVFormats();
    fn TVFormat();
    fn AutoTune();
    fn StoreAutoTune();
    fn NumInputConnections();
    fn SetInputType();
    fn InputType();
    fn SetConnectInput();
    fn ConnectInput();
    fn VideoFrequency();
    fn AudioFrequency();
}
impl ::windows::core::RuntimeName for IAMTVTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTVTuner";
}
impl IAMTVTunerVtbl {
    pub const fn new<Impl: IAMTVTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTVTunerVtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats(::core::mem::transmute_copy(&lanalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVFormat<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TVFormat(::core::mem::transmute_copy(&planalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoTune<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lchannel: i32, plfoundsignal: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoTune(lchannel, ::core::mem::transmute_copy(&plfoundsignal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StoreAutoTune<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StoreAutoTune() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumInputConnections<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plnuminputconnections: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumInputConnections(::core::mem::transmute_copy(&plnuminputconnections)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, inputtype: TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputType(lindex, inputtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputType<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, pinputtype: *mut TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputType(lindex, ::core::mem::transmute_copy(&pinputtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConnectInput<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetConnectInput(lindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectInput<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectInput(::core::mem::transmute_copy(&plindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoFrequency<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoFrequency(::core::mem::transmute_copy(&lfreq)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioFrequency<Impl: IAMTVTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioFrequency(::core::mem::transmute_copy(&lfreq)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTVTuner>, base.5, AvailableTVFormats::<Impl, OFFSET>, TVFormat::<Impl, OFFSET>, AutoTune::<Impl, OFFSET>, StoreAutoTune::<Impl, OFFSET>, NumInputConnections::<Impl, OFFSET>, SetInputType::<Impl, OFFSET>, InputType::<Impl, OFFSET>, SetConnectInput::<Impl, OFFSET>, ConnectInput::<Impl, OFFSET>, VideoFrequency::<Impl, OFFSET>, AudioFrequency::<Impl, OFFSET>)
    }
}
pub trait IAMTimecodeDisplayImpl: Sized {
    fn GetTCDisplayEnable();
    fn SetTCDisplayEnable();
    fn GetTCDisplay();
    fn SetTCDisplay();
}
impl ::windows::core::RuntimeName for IAMTimecodeDisplay {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTimecodeDisplay";
}
impl IAMTimecodeDisplayVtbl {
    pub const fn new<Impl: IAMTimecodeDisplayImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTimecodeDisplayVtbl {
        unsafe extern "system" fn GetTCDisplayEnable<Impl: IAMTimecodeDisplayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTCDisplayEnable(::core::mem::transmute_copy(&pstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCDisplayEnable<Impl: IAMTimecodeDisplayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTCDisplayEnable(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTCDisplay<Impl: IAMTimecodeDisplayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTCDisplay(param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCDisplay<Impl: IAMTimecodeDisplayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTCDisplay(param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTimecodeDisplay>, base.5, GetTCDisplayEnable::<Impl, OFFSET>, SetTCDisplayEnable::<Impl, OFFSET>, GetTCDisplay::<Impl, OFFSET>, SetTCDisplay::<Impl, OFFSET>)
    }
}
pub trait IAMTimecodeGeneratorImpl: Sized {
    fn GetTCGMode();
    fn SetTCGMode();
    fn SetVITCLine();
    fn VITCLine();
    fn SetTimecode();
    fn GetTimecode();
}
impl ::windows::core::RuntimeName for IAMTimecodeGenerator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTimecodeGenerator";
}
impl IAMTimecodeGeneratorVtbl {
    pub const fn new<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTimecodeGeneratorVtbl {
        unsafe extern "system" fn GetTCGMode<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTCGMode(param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCGMode<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTCGMode(param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVITCLine<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, line: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVITCLine(line) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VITCLine<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VITCLine(::core::mem::transmute_copy(&pline)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimecode<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimecode(&*(&ptimecodesample as *const <super::TIMECODE_SAMPLE as ::windows::core::Abi>::Abi as *const <super::TIMECODE_SAMPLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimecode<Impl: IAMTimecodeGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimecode(::core::mem::transmute_copy(&ptimecodesample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTimecodeGenerator>, base.5, GetTCGMode::<Impl, OFFSET>, SetTCGMode::<Impl, OFFSET>, SetVITCLine::<Impl, OFFSET>, VITCLine::<Impl, OFFSET>, SetTimecode::<Impl, OFFSET>, GetTimecode::<Impl, OFFSET>)
    }
}
pub trait IAMTimecodeReaderImpl: Sized {
    fn GetTCRMode();
    fn SetTCRMode();
    fn SetVITCLine();
    fn VITCLine();
    fn GetTimecode();
}
impl ::windows::core::RuntimeName for IAMTimecodeReader {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTimecodeReader";
}
impl IAMTimecodeReaderVtbl {
    pub const fn new<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTimecodeReaderVtbl {
        unsafe extern "system" fn GetTCRMode<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTCRMode(param, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCRMode<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTCRMode(param, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVITCLine<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, line: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVITCLine(line) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VITCLine<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VITCLine(::core::mem::transmute_copy(&pline)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimecode<Impl: IAMTimecodeReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimecode(::core::mem::transmute_copy(&ptimecodesample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTimecodeReader>, base.5, GetTCRMode::<Impl, OFFSET>, SetTCRMode::<Impl, OFFSET>, SetVITCLine::<Impl, OFFSET>, VITCLine::<Impl, OFFSET>, GetTimecode::<Impl, OFFSET>)
    }
}
pub trait IAMTunerImpl: Sized {
    fn SetChannel();
    fn Channel();
    fn ChannelMinMax();
    fn SetCountryCode();
    fn CountryCode();
    fn SetTuningSpace();
    fn TuningSpace();
    fn Logon();
    fn Logout();
    fn SignalPresent();
    fn SetMode();
    fn Mode();
    fn GetAvailableModes();
    fn RegisterNotificationCallBack();
    fn UnRegisterNotificationCallBack();
}
impl ::windows::core::RuntimeName for IAMTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTuner";
}
impl IAMTunerVtbl {
    pub const fn new<Impl: IAMTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTunerVtbl {
        unsafe extern "system" fn SetChannel<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChannel(lchannel, lvideosubchannel, laudiosubchannel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Channel<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Channel(::core::mem::transmute_copy(&plchannel), ::core::mem::transmute_copy(&plvideosubchannel), ::core::mem::transmute_copy(&plaudiosubchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChannelMinMax<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lchannelmin: *mut i32, lchannelmax: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelMinMax(::core::mem::transmute_copy(&lchannelmin), ::core::mem::transmute_copy(&lchannelmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcountrycode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(lcountrycode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCode<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plcountrycode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&plcountrycode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltuningspace: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTuningSpace(ltuningspace) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuningSpace<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pltuningspace: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpace(::core::mem::transmute_copy(&pltuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Logon<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hcurrentuser: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Logon(&*(&hcurrentuser as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Logout<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Logout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalPresent<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plsignalstrength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalPresent(::core::mem::transmute_copy(&plsignalstrength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lmode: AMTunerModeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(lmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Mode<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmode: *mut AMTunerModeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode(::core::mem::transmute_copy(&plmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableModes<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableModes(::core::mem::transmute_copy(&plmodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr, levents: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterNotificationCallBack(&*(&pnotify as *const <IAMTunerNotification as ::windows::core::Abi>::Abi as *const <IAMTunerNotification as ::windows::core::DefaultType>::DefaultType), levents) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Impl: IAMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnRegisterNotificationCallBack(&*(&pnotify as *const <IAMTunerNotification as ::windows::core::Abi>::Abi as *const <IAMTunerNotification as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMTuner>,
            base.5,
            SetChannel::<Impl, OFFSET>,
            Channel::<Impl, OFFSET>,
            ChannelMinMax::<Impl, OFFSET>,
            SetCountryCode::<Impl, OFFSET>,
            CountryCode::<Impl, OFFSET>,
            SetTuningSpace::<Impl, OFFSET>,
            TuningSpace::<Impl, OFFSET>,
            Logon::<Impl, OFFSET>,
            Logout::<Impl, OFFSET>,
            SignalPresent::<Impl, OFFSET>,
            SetMode::<Impl, OFFSET>,
            Mode::<Impl, OFFSET>,
            GetAvailableModes::<Impl, OFFSET>,
            RegisterNotificationCallBack::<Impl, OFFSET>,
            UnRegisterNotificationCallBack::<Impl, OFFSET>,
        )
    }
}
pub trait IAMTunerNotificationImpl: Sized {
    fn OnEvent();
}
impl ::windows::core::RuntimeName for IAMTunerNotification {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMTunerNotification";
}
impl IAMTunerNotificationVtbl {
    pub const fn new<Impl: IAMTunerNotificationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMTunerNotificationVtbl {
        unsafe extern "system" fn OnEvent<Impl: IAMTunerNotificationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, event: AMTunerEventType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnEvent(event) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMTunerNotification>, base.5, OnEvent::<Impl, OFFSET>)
    }
}
pub trait IAMVfwCaptureDialogsImpl: Sized {
    fn HasDialog();
    fn ShowDialog();
    fn SendDriverMessage();
}
impl ::windows::core::RuntimeName for IAMVfwCaptureDialogs {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVfwCaptureDialogs";
}
impl IAMVfwCaptureDialogsVtbl {
    pub const fn new<Impl: IAMVfwCaptureDialogsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVfwCaptureDialogsVtbl {
        unsafe extern "system" fn HasDialog<Impl: IAMVfwCaptureDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idialog: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasDialog(idialog) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowDialog<Impl: IAMVfwCaptureDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowDialog(idialog, &*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendDriverMessage<Impl: IAMVfwCaptureDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SendDriverMessage(idialog, umsg, dw1, dw2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVfwCaptureDialogs>, base.5, HasDialog::<Impl, OFFSET>, ShowDialog::<Impl, OFFSET>, SendDriverMessage::<Impl, OFFSET>)
    }
}
pub trait IAMVfwCompressDialogsImpl: Sized {
    fn ShowDialog();
    fn GetState();
    fn SetState();
    fn SendDriverMessage();
}
impl ::windows::core::RuntimeName for IAMVfwCompressDialogs {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVfwCompressDialogs";
}
impl IAMVfwCompressDialogsVtbl {
    pub const fn new<Impl: IAMVfwCompressDialogsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVfwCompressDialogsVtbl {
        unsafe extern "system" fn ShowDialog<Impl: IAMVfwCompressDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowDialog(idialog, &*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IAMVfwCompressDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void, pcbstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&pstate), pcbstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetState<Impl: IAMVfwCompressDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *const ::core::ffi::c_void, cbstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetState(&*(&pstate as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), cbstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendDriverMessage<Impl: IAMVfwCompressDialogsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SendDriverMessage(umsg, dw1, dw2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVfwCompressDialogs>, base.5, ShowDialog::<Impl, OFFSET>, GetState::<Impl, OFFSET>, SetState::<Impl, OFFSET>, SendDriverMessage::<Impl, OFFSET>)
    }
}
pub trait IAMVideoAcceleratorImpl: Sized {
    fn GetVideoAcceleratorGUIDs();
    fn GetUncompFormatsSupported();
    fn GetInternalMemInfo();
    fn GetCompBufferInfo();
    fn GetInternalCompBufferInfo();
    fn BeginFrame();
    fn EndFrame();
    fn GetBuffer();
    fn ReleaseBuffer();
    fn Execute();
    fn QueryRenderStatus();
    fn DisplayFrame();
}
impl ::windows::core::RuntimeName for IAMVideoAccelerator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoAccelerator";
}
impl IAMVideoAcceleratorVtbl {
    pub const fn new<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoAcceleratorVtbl {
        unsafe extern "system" fn GetVideoAcceleratorGUIDs<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumguidssupported: *mut u32, pguidssupported: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoAcceleratorGUIDs(pdwnumguidssupported, ::core::mem::transmute_copy(&pguidssupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUncompFormatsSupported<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUncompFormatsSupported(&*(&pguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pdwnumformatssupported, ::core::mem::transmute_copy(&pformatssupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInternalMemInfo<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInternalMemInfo(&*(&pguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pamvauncompdatainfo as *const <AMVAUncompDataInfo as ::windows::core::Abi>::Abi as *const <AMVAUncompDataInfo as ::windows::core::DefaultType>::DefaultType), &*(&pamvainternalmeminfo as *const <AMVAInternalMemInfo as ::windows::core::Abi>::Abi as *const <AMVAInternalMemInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompBufferInfo<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCompBufferInfo(&*(&pguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pamvauncompdatainfo as *const <AMVAUncompDataInfo as ::windows::core::Abi>::Abi as *const <AMVAUncompDataInfo as ::windows::core::DefaultType>::DefaultType), pdwnumtypescompbuffers, ::core::mem::transmute_copy(&pamvacompbufferinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInternalCompBufferInfo<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInternalCompBufferInfo(pdwnumtypescompbuffers, ::core::mem::transmute_copy(&pamvacompbufferinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginFrame<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, amvabeginframeinfo: *const AMVABeginFrameInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginFrame(&*(&amvabeginframeinfo as *const <AMVABeginFrameInfo as ::windows::core::Abi>::Abi as *const <AMVABeginFrameInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndFrame<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pendframeinfo: *const AMVAEndFrameInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndFrame(&*(&pendframeinfo as *const <AMVAEndFrameInfo as ::windows::core::Abi>::Abi as *const <AMVAEndFrameInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBuffer<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, breadonly: super::super::Foundation::BOOL, ppbuffer: *mut *mut ::core::ffi::c_void, lpstride: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBuffer(dwtypeindex, dwbufferindex, &*(&breadonly as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&lpstride)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseBuffer(dwtypeindex, dwbufferindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Execute<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwfunction: u32, lpprivateinputdata: *const ::core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const ::core::ffi::c_void, cbprivateoutputdata: u32, dwnumbuffers: u32, pamvabufferinfo: *const AMVABUFFERINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Execute(
                dwfunction,
                &*(&lpprivateinputdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                cbprivateinputdata,
                &*(&lpprivateoutputdat as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                cbprivateoutputdata,
                dwnumbuffers,
                &*(&pamvabufferinfo as *const <AMVABUFFERINFO as ::windows::core::Abi>::Abi as *const <AMVABUFFERINFO as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryRenderStatus<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryRenderStatus(dwtypeindex, dwbufferindex, dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayFrame<Impl: IAMVideoAcceleratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwfliptoindex: u32, pmediasample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayFrame(dwfliptoindex, &*(&pmediasample as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMVideoAccelerator>,
            base.5,
            GetVideoAcceleratorGUIDs::<Impl, OFFSET>,
            GetUncompFormatsSupported::<Impl, OFFSET>,
            GetInternalMemInfo::<Impl, OFFSET>,
            GetCompBufferInfo::<Impl, OFFSET>,
            GetInternalCompBufferInfo::<Impl, OFFSET>,
            BeginFrame::<Impl, OFFSET>,
            EndFrame::<Impl, OFFSET>,
            GetBuffer::<Impl, OFFSET>,
            ReleaseBuffer::<Impl, OFFSET>,
            Execute::<Impl, OFFSET>,
            QueryRenderStatus::<Impl, OFFSET>,
            DisplayFrame::<Impl, OFFSET>,
        )
    }
}
pub trait IAMVideoAcceleratorNotifyImpl: Sized {
    fn GetUncompSurfacesInfo();
    fn SetUncompSurfacesInfo();
    fn GetCreateVideoAcceleratorData();
}
impl ::windows::core::RuntimeName for IAMVideoAcceleratorNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoAcceleratorNotify";
}
impl IAMVideoAcceleratorNotifyVtbl {
    pub const fn new<Impl: IAMVideoAcceleratorNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoAcceleratorNotifyVtbl {
        unsafe extern "system" fn GetUncompSurfacesInfo<Impl: IAMVideoAcceleratorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUncompSurfacesInfo(&*(&pguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&puncompbufferinfo as *const <AMVAUncompBufferInfo as ::windows::core::Abi>::Abi as *const <AMVAUncompBufferInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUncompSurfacesInfo<Impl: IAMVideoAcceleratorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwactualuncompsurfacesallocated: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUncompSurfacesInfo(dwactualuncompsurfacesallocated) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreateVideoAcceleratorData<Impl: IAMVideoAcceleratorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCreateVideoAcceleratorData(&*(&pguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwsizemiscdata), ::core::mem::transmute_copy(&ppmiscdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVideoAcceleratorNotify>, base.5, GetUncompSurfacesInfo::<Impl, OFFSET>, SetUncompSurfacesInfo::<Impl, OFFSET>, GetCreateVideoAcceleratorData::<Impl, OFFSET>)
    }
}
pub trait IAMVideoCompressionImpl: Sized {
    fn SetKeyFrameRate();
    fn KeyFrameRate();
    fn SetPFramesPerKeyFrame();
    fn PFramesPerKeyFrame();
    fn SetQuality();
    fn Quality();
    fn SetWindowSize();
    fn WindowSize();
    fn GetInfo();
    fn OverrideKeyFrame();
    fn OverrideFrameSize();
}
impl ::windows::core::RuntimeName for IAMVideoCompression {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoCompression";
}
impl IAMVideoCompressionVtbl {
    pub const fn new<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoCompressionVtbl {
        unsafe extern "system" fn SetKeyFrameRate<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keyframerate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetKeyFrameRate(keyframerate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyFrameRate<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkeyframerate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyFrameRate(::core::mem::transmute_copy(&pkeyframerate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPFramesPerKeyFrame<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pframesperkeyframe: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPFramesPerKeyFrame(pframesperkeyframe) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PFramesPerKeyFrame<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppframesperkeyframe: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PFramesPerKeyFrame(::core::mem::transmute_copy(&ppframesperkeyframe)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQuality<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, quality: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetQuality(quality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Quality<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pquality: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Quality(::core::mem::transmute_copy(&pquality)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowSize<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowSize(windowsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WindowSize<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwindowsize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WindowSize(::core::mem::transmute_copy(&pwindowsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInfo<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszversion: super::super::Foundation::PWSTR, pcbversion: *mut i32, pszdescription: super::super::Foundation::PWSTR, pcbdescription: *mut i32, pdefaultkeyframerate: *mut i32, pdefaultpframesperkey: *mut i32, pdefaultquality: *mut f64, pcapabilities: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInfo(::core::mem::transmute_copy(&pszversion), pcbversion, ::core::mem::transmute_copy(&pszdescription), pcbdescription, ::core::mem::transmute_copy(&pdefaultkeyframerate), ::core::mem::transmute_copy(&pdefaultpframesperkey), ::core::mem::transmute_copy(&pdefaultquality), ::core::mem::transmute_copy(&pcapabilities)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverrideKeyFrame<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, framenumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverrideKeyFrame(framenumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverrideFrameSize<Impl: IAMVideoCompressionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, framenumber: i32, size: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverrideFrameSize(framenumber, size) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVideoCompression>, base.5, SetKeyFrameRate::<Impl, OFFSET>, KeyFrameRate::<Impl, OFFSET>, SetPFramesPerKeyFrame::<Impl, OFFSET>, PFramesPerKeyFrame::<Impl, OFFSET>, SetQuality::<Impl, OFFSET>, Quality::<Impl, OFFSET>, SetWindowSize::<Impl, OFFSET>, WindowSize::<Impl, OFFSET>, GetInfo::<Impl, OFFSET>, OverrideKeyFrame::<Impl, OFFSET>, OverrideFrameSize::<Impl, OFFSET>)
    }
}
pub trait IAMVideoControlImpl: Sized {
    fn GetCaps();
    fn SetMode();
    fn GetMode();
    fn GetCurrentActualFrameRate();
    fn GetMaxAvailableFrameRate();
    fn GetFrameRateList();
}
impl ::windows::core::RuntimeName for IAMVideoControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoControl";
}
impl IAMVideoControlVtbl {
    pub const fn new<Impl: IAMVideoControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoControlVtbl {
        unsafe extern "system" fn GetCaps<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaps(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcapsflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMode<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, mode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMode(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&mode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentActualFrameRate<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, actualframerate: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentActualFrameRate(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&actualframerate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxAvailableFrameRate<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, iindex: i32, dimensions: super::super::Foundation::SIZE, maxavailableframerate: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxAvailableFrameRate(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), iindex, &*(&dimensions as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&maxavailableframerate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrameRateList<Impl: IAMVideoControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, iindex: i32, dimensions: super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFrameRateList(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), iindex, &*(&dimensions as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&listsize), ::core::mem::transmute_copy(&framerates)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVideoControl>, base.5, GetCaps::<Impl, OFFSET>, SetMode::<Impl, OFFSET>, GetMode::<Impl, OFFSET>, GetCurrentActualFrameRate::<Impl, OFFSET>, GetMaxAvailableFrameRate::<Impl, OFFSET>, GetFrameRateList::<Impl, OFFSET>)
    }
}
pub trait IAMVideoDecimationPropertiesImpl: Sized {
    fn QueryDecimationUsage();
    fn SetDecimationUsage();
}
impl ::windows::core::RuntimeName for IAMVideoDecimationProperties {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoDecimationProperties";
}
impl IAMVideoDecimationPropertiesVtbl {
    pub const fn new<Impl: IAMVideoDecimationPropertiesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoDecimationPropertiesVtbl {
        unsafe extern "system" fn QueryDecimationUsage<Impl: IAMVideoDecimationPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpusage: *mut DECIMATION_USAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryDecimationUsage(::core::mem::transmute_copy(&lpusage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecimationUsage<Impl: IAMVideoDecimationPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usage: DECIMATION_USAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDecimationUsage(usage) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVideoDecimationProperties>, base.5, QueryDecimationUsage::<Impl, OFFSET>, SetDecimationUsage::<Impl, OFFSET>)
    }
}
pub trait IAMVideoProcAmpImpl: Sized {
    fn GetRange();
    fn Set();
    fn Get();
}
impl ::windows::core::RuntimeName for IAMVideoProcAmp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMVideoProcAmp";
}
impl IAMVideoProcAmpVtbl {
    pub const fn new<Impl: IAMVideoProcAmpImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMVideoProcAmpVtbl {
        unsafe extern "system" fn GetRange<Impl: IAMVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRange(property, ::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set<Impl: IAMVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set(property, lvalue, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Get<Impl: IAMVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Get(property, ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMVideoProcAmp>, base.5, GetRange::<Impl, OFFSET>, Set::<Impl, OFFSET>, Get::<Impl, OFFSET>)
    }
}
pub trait IAMWstDecoderImpl: Sized {
    fn GetDecoderLevel();
    fn GetCurrentService();
    fn GetServiceState();
    fn SetServiceState();
    fn GetOutputFormat();
    fn SetOutputFormat();
    fn GetBackgroundColor();
    fn SetBackgroundColor();
    fn GetRedrawAlways();
    fn SetRedrawAlways();
    fn GetDrawBackgroundMode();
    fn SetDrawBackgroundMode();
    fn SetAnswerMode();
    fn GetAnswerMode();
    fn SetHoldPage();
    fn GetHoldPage();
    fn GetCurrentPage();
    fn SetCurrentPage();
}
impl ::windows::core::RuntimeName for IAMWstDecoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMWstDecoder";
}
impl IAMWstDecoderVtbl {
    pub const fn new<Impl: IAMWstDecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMWstDecoderVtbl {
        unsafe extern "system" fn GetDecoderLevel<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplevel: *mut AM_WST_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderLevel(lplevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentService<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpservice: *mut AM_WST_SERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentService(lpservice) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceState<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpstate: *mut AM_WST_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceState(lpstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServiceState<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: AM_WST_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetServiceState(state) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputFormat<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputFormat(&*(&lpbmih as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFormat<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFormat(&*(&lpbmi as *const <super::super::Graphics::Gdi::BITMAPINFO as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::BITMAPINFO as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwphyscolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor(pdwphyscolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwphyscolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundColor(dwphyscolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRedrawAlways<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpboption: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRedrawAlways(lpboption) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRedrawAlways<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, boption: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRedrawAlways(&*(&boption as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpmode: *mut AM_WST_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDrawBackgroundMode(lpmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: AM_WST_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDrawBackgroundMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnswerMode<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, banswer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAnswerMode(&*(&banswer as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAnswerMode<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbanswer: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAnswerMode(&*(&pbanswer as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHoldPage<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bholdpage: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHoldPage(&*(&bholdpage as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHoldPage<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbholdpage: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHoldPage(&*(&pbholdpage as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentPage<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwstpage: *mut AM_WST_PAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentPage(&*(&pwstpage as *const <AM_WST_PAGE as ::windows::core::Abi>::Abi as *const <AM_WST_PAGE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPage<Impl: IAMWstDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstpage: AM_WST_PAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPage(&*(&wstpage as *const <AM_WST_PAGE as ::windows::core::Abi>::Abi as *const <AM_WST_PAGE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAMWstDecoder>,
            base.5,
            GetDecoderLevel::<Impl, OFFSET>,
            GetCurrentService::<Impl, OFFSET>,
            GetServiceState::<Impl, OFFSET>,
            SetServiceState::<Impl, OFFSET>,
            GetOutputFormat::<Impl, OFFSET>,
            SetOutputFormat::<Impl, OFFSET>,
            GetBackgroundColor::<Impl, OFFSET>,
            SetBackgroundColor::<Impl, OFFSET>,
            GetRedrawAlways::<Impl, OFFSET>,
            SetRedrawAlways::<Impl, OFFSET>,
            GetDrawBackgroundMode::<Impl, OFFSET>,
            SetDrawBackgroundMode::<Impl, OFFSET>,
            SetAnswerMode::<Impl, OFFSET>,
            GetAnswerMode::<Impl, OFFSET>,
            SetHoldPage::<Impl, OFFSET>,
            GetHoldPage::<Impl, OFFSET>,
            GetCurrentPage::<Impl, OFFSET>,
            SetCurrentPage::<Impl, OFFSET>,
        )
    }
}
pub trait IAMovieSetupImpl: Sized {
    fn Register();
    fn Unregister();
}
impl ::windows::core::RuntimeName for IAMovieSetup {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAMovieSetup";
}
impl IAMovieSetupVtbl {
    pub const fn new<Impl: IAMovieSetupImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAMovieSetupVtbl {
        unsafe extern "system" fn Register<Impl: IAMovieSetupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Register() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unregister<Impl: IAMovieSetupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unregister() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAMovieSetup>, base.5, Register::<Impl, OFFSET>, Unregister::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IATSCChannelTuneRequestImpl: Sized + IChannelTuneRequestImpl + ITuneRequestImpl + IDispatchImpl {
    fn MinorChannel();
    fn SetMinorChannel();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IATSCChannelTuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSCChannelTuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCChannelTuneRequestVtbl {
    pub const fn new<Impl: IATSCChannelTuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSCChannelTuneRequestVtbl {
        unsafe extern "system" fn MinorChannel<Impl: IATSCChannelTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minorchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinorChannel(::core::mem::transmute_copy(&minorchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinorChannel<Impl: IATSCChannelTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minorchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinorChannel(minorchannel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSCChannelTuneRequest>, base.5, MinorChannel::<Impl, OFFSET>, SetMinorChannel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IATSCComponentTypeImpl: Sized + IMPEG2ComponentTypeImpl + ILanguageComponentTypeImpl + IComponentTypeImpl + IDispatchImpl {
    fn Flags();
    fn SetFlags();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IATSCComponentType {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSCComponentType";
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCComponentTypeVtbl {
    pub const fn new<Impl: IATSCComponentTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSCComponentTypeVtbl {
        unsafe extern "system" fn Flags<Impl: IATSCComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flags(::core::mem::transmute_copy(&flags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlags<Impl: IATSCComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFlags(flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSCComponentType>, base.5, Flags::<Impl, OFFSET>, SetFlags::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IATSCLocatorImpl: Sized + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn PhysicalChannel();
    fn SetPhysicalChannel();
    fn TSID();
    fn SetTSID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IATSCLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSCLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCLocatorVtbl {
    pub const fn new<Impl: IATSCLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSCLocatorVtbl {
        unsafe extern "system" fn PhysicalChannel<Impl: IATSCLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, physicalchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PhysicalChannel(::core::mem::transmute_copy(&physicalchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPhysicalChannel<Impl: IATSCLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, physicalchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPhysicalChannel(physicalchannel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TSID<Impl: IATSCLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TSID(::core::mem::transmute_copy(&tsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IATSCLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTSID(tsid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSCLocator>, base.5, PhysicalChannel::<Impl, OFFSET>, SetPhysicalChannel::<Impl, OFFSET>, TSID::<Impl, OFFSET>, SetTSID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IATSCLocator2Impl: Sized + IATSCLocatorImpl + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn ProgramNumber();
    fn SetProgramNumber();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IATSCLocator2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSCLocator2";
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCLocator2Vtbl {
    pub const fn new<Impl: IATSCLocator2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSCLocator2Vtbl {
        unsafe extern "system" fn ProgramNumber<Impl: IATSCLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, programnumber: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProgramNumber(::core::mem::transmute_copy(&programnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgramNumber<Impl: IATSCLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, programnumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProgramNumber(programnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSCLocator2>, base.5, ProgramNumber::<Impl, OFFSET>, SetProgramNumber::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IATSCTuningSpaceImpl: Sized + IAnalogTVTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn MinMinorChannel();
    fn SetMinMinorChannel();
    fn MaxMinorChannel();
    fn SetMaxMinorChannel();
    fn MinPhysicalChannel();
    fn SetMinPhysicalChannel();
    fn MaxPhysicalChannel();
    fn SetMaxPhysicalChannel();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IATSCTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSCTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCTuningSpaceVtbl {
    pub const fn new<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSCTuningSpaceVtbl {
        unsafe extern "system" fn MinMinorChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minminorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinMinorChannel(::core::mem::transmute_copy(&minminorchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinMinorChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminminorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinMinorChannel(newminminorchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxMinorChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxminorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxMinorChannel(::core::mem::transmute_copy(&maxminorchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxMinorChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxminorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxMinorChannel(newmaxminorchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinPhysicalChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minphysicalchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinPhysicalChannel(::core::mem::transmute_copy(&minphysicalchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinPhysicalChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminphysicalchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinPhysicalChannel(newminphysicalchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxPhysicalChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxphysicalchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxPhysicalChannel(::core::mem::transmute_copy(&maxphysicalchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxPhysicalChannel<Impl: IATSCTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxphysicalchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxPhysicalChannel(newmaxphysicalchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSCTuningSpace>, base.5, MinMinorChannel::<Impl, OFFSET>, SetMinMinorChannel::<Impl, OFFSET>, MaxMinorChannel::<Impl, OFFSET>, SetMaxMinorChannel::<Impl, OFFSET>, MinPhysicalChannel::<Impl, OFFSET>, SetMinPhysicalChannel::<Impl, OFFSET>, MaxPhysicalChannel::<Impl, OFFSET>, SetMaxPhysicalChannel::<Impl, OFFSET>)
    }
}
pub trait IATSC_EITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetSourceId();
    fn GetProtocolVersion();
    fn GetCountOfRecords();
    fn GetRecordEventId();
    fn GetRecordStartTime();
    fn GetRecordEtmLocation();
    fn GetRecordDuration();
    fn GetRecordTitleText();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
}
impl ::windows::core::RuntimeName for IATSC_EIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSC_EIT";
}
impl IATSC_EITVtbl {
    pub const fn new<Impl: IATSC_EITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSC_EITVtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceId<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(dwrecordindex, ::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEtmLocation<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEtmLocation(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(dwrecordindex, ::core::mem::transmute_copy(&pmdval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTitleText<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTitleText(dwrecordindex, ::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&pptext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IATSC_EIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetSourceId::<Impl, OFFSET>,
            GetProtocolVersion::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordEventId::<Impl, OFFSET>,
            GetRecordStartTime::<Impl, OFFSET>,
            GetRecordEtmLocation::<Impl, OFFSET>,
            GetRecordDuration::<Impl, OFFSET>,
            GetRecordTitleText::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
        )
    }
}
pub trait IATSC_ETTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetProtocolVersion();
    fn GetEtmId();
    fn GetExtendedMessageText();
}
impl ::windows::core::RuntimeName for IATSC_ETT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSC_ETT";
}
impl IATSC_ETTVtbl {
    pub const fn new<Impl: IATSC_ETTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSC_ETTVtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_ETTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_ETTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_ETTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEtmId<Impl: IATSC_ETTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEtmId(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedMessageText<Impl: IATSC_ETTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtendedMessageText(::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&pptext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSC_ETT>, base.5, Initialize::<Impl, OFFSET>, GetVersionNumber::<Impl, OFFSET>, GetProtocolVersion::<Impl, OFFSET>, GetEtmId::<Impl, OFFSET>, GetExtendedMessageText::<Impl, OFFSET>)
    }
}
pub trait IATSC_MGTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetProtocolVersion();
    fn GetCountOfRecords();
    fn GetRecordType();
    fn GetRecordTypePid();
    fn GetRecordVersionNumber();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
}
impl ::windows::core::RuntimeName for IATSC_MGT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSC_MGT";
}
impl IATSC_MGTVtbl {
    pub const fn new<Impl: IATSC_MGTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSC_MGTVtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordType<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordType(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTypePid<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTypePid(dwrecordindex, ::core::mem::transmute_copy(&ppidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVersionNumber<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordVersionNumber(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(pdwval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_MGTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IATSC_MGT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetProtocolVersion::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordType::<Impl, OFFSET>,
            GetRecordTypePid::<Impl, OFFSET>,
            GetRecordVersionNumber::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
        )
    }
}
pub trait IATSC_STTImpl: Sized {
    fn Initialize();
    fn GetProtocolVersion();
    fn GetSystemTime();
    fn GetGpsUtcOffset();
    fn GetDaylightSavings();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
}
impl ::windows::core::RuntimeName for IATSC_STT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSC_STT";
}
impl IATSC_STTVtbl {
    pub const fn new<Impl: IATSC_STTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSC_STTVtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSystemTime<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmdtsystemtime: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSystemTime(::core::mem::transmute_copy(&pmdtsystemtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGpsUtcOffset<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGpsUtcOffset(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDaylightSavings<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDaylightSavings(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_STTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IATSC_STT>, base.5, Initialize::<Impl, OFFSET>, GetProtocolVersion::<Impl, OFFSET>, GetSystemTime::<Impl, OFFSET>, GetGpsUtcOffset::<Impl, OFFSET>, GetDaylightSavings::<Impl, OFFSET>, GetCountOfTableDescriptors::<Impl, OFFSET>, GetTableDescriptorByIndex::<Impl, OFFSET>, GetTableDescriptorByTag::<Impl, OFFSET>)
    }
}
pub trait IATSC_VCTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetTransportStreamId();
    fn GetProtocolVersion();
    fn GetCountOfRecords();
    fn GetRecordName();
    fn GetRecordMajorChannelNumber();
    fn GetRecordMinorChannelNumber();
    fn GetRecordModulationMode();
    fn GetRecordCarrierFrequency();
    fn GetRecordTransportStreamId();
    fn GetRecordProgramNumber();
    fn GetRecordEtmLocation();
    fn GetRecordIsAccessControlledBitSet();
    fn GetRecordIsHiddenBitSet();
    fn GetRecordIsPathSelectBitSet();
    fn GetRecordIsOutOfBandBitSet();
    fn GetRecordIsHideGuideBitSet();
    fn GetRecordServiceType();
    fn GetRecordSourceId();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
}
impl ::windows::core::RuntimeName for IATSC_VCT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IATSC_VCT";
}
impl IATSC_VCTVtbl {
    pub const fn new<Impl: IATSC_VCTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IATSC_VCTVtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordName<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwsname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordName(dwrecordindex, ::core::mem::transmute_copy(&pwsname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMajorChannelNumber<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordMajorChannelNumber(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMinorChannelNumber<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordMinorChannelNumber(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModulationMode<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordModulationMode(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCarrierFrequency<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCarrierFrequency(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramNumber<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramNumber(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEtmLocation<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEtmLocation(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsAccessControlledBitSet<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordIsAccessControlledBitSet(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsHiddenBitSet<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordIsHiddenBitSet(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsPathSelectBitSet<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordIsPathSelectBitSet(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsOutOfBandBitSet<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordIsOutOfBandBitSet(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsHideGuideBitSet<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordIsHideGuideBitSet(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceType<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceType(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordSourceId<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordSourceId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(pdwval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_VCTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IATSC_VCT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetProtocolVersion::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordName::<Impl, OFFSET>,
            GetRecordMajorChannelNumber::<Impl, OFFSET>,
            GetRecordMinorChannelNumber::<Impl, OFFSET>,
            GetRecordModulationMode::<Impl, OFFSET>,
            GetRecordCarrierFrequency::<Impl, OFFSET>,
            GetRecordTransportStreamId::<Impl, OFFSET>,
            GetRecordProgramNumber::<Impl, OFFSET>,
            GetRecordEtmLocation::<Impl, OFFSET>,
            GetRecordIsAccessControlledBitSet::<Impl, OFFSET>,
            GetRecordIsHiddenBitSet::<Impl, OFFSET>,
            GetRecordIsPathSelectBitSet::<Impl, OFFSET>,
            GetRecordIsOutOfBandBitSet::<Impl, OFFSET>,
            GetRecordIsHideGuideBitSet::<Impl, OFFSET>,
            GetRecordServiceType::<Impl, OFFSET>,
            GetRecordSourceId::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAnalogAudioComponentTypeImpl: Sized + IComponentTypeImpl + IDispatchImpl {
    fn AnalogAudioMode();
    fn SetAnalogAudioMode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAnalogAudioComponentType {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAnalogAudioComponentType";
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogAudioComponentTypeVtbl {
    pub const fn new<Impl: IAnalogAudioComponentTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnalogAudioComponentTypeVtbl {
        unsafe extern "system" fn AnalogAudioMode<Impl: IAnalogAudioComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: *mut TVAudioMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AnalogAudioMode(::core::mem::transmute_copy(&mode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnalogAudioMode<Impl: IAnalogAudioComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: TVAudioMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAnalogAudioMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnalogAudioComponentType>, base.5, AnalogAudioMode::<Impl, OFFSET>, SetAnalogAudioMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAnalogLocatorImpl: Sized + ILocatorImpl + IDispatchImpl {
    fn VideoStandard();
    fn SetVideoStandard();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAnalogLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAnalogLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogLocatorVtbl {
    pub const fn new<Impl: IAnalogLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnalogLocatorVtbl {
        unsafe extern "system" fn VideoStandard<Impl: IAnalogLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, avs: *mut AnalogVideoStandard) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoStandard(::core::mem::transmute_copy(&avs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoStandard<Impl: IAnalogLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, avs: AnalogVideoStandard) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoStandard(avs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnalogLocator>, base.5, VideoStandard::<Impl, OFFSET>, SetVideoStandard::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAnalogRadioTuningSpaceImpl: Sized + ITuningSpaceImpl + IDispatchImpl {
    fn MinFrequency();
    fn SetMinFrequency();
    fn MaxFrequency();
    fn SetMaxFrequency();
    fn Step();
    fn SetStep();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAnalogRadioTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAnalogRadioTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogRadioTuningSpaceVtbl {
    pub const fn new<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnalogRadioTuningSpaceVtbl {
        unsafe extern "system" fn MinFrequency<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minfrequencyval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinFrequency(::core::mem::transmute_copy(&minfrequencyval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinFrequency<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminfrequencyval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinFrequency(newminfrequencyval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxFrequency<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxfrequencyval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxFrequency(::core::mem::transmute_copy(&maxfrequencyval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxFrequency<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxfrequencyval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxFrequency(newmaxfrequencyval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Step<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stepval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Step(::core::mem::transmute_copy(&stepval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStep<Impl: IAnalogRadioTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newstepval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStep(newstepval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnalogRadioTuningSpace>, base.5, MinFrequency::<Impl, OFFSET>, SetMinFrequency::<Impl, OFFSET>, MaxFrequency::<Impl, OFFSET>, SetMaxFrequency::<Impl, OFFSET>, Step::<Impl, OFFSET>, SetStep::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAnalogRadioTuningSpace2Impl: Sized + IAnalogRadioTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn CountryCode();
    fn SetCountryCode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAnalogRadioTuningSpace2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAnalogRadioTuningSpace2";
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogRadioTuningSpace2Vtbl {
    pub const fn new<Impl: IAnalogRadioTuningSpace2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnalogRadioTuningSpace2Vtbl {
        unsafe extern "system" fn CountryCode<Impl: IAnalogRadioTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&countrycodeval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAnalogRadioTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(newcountrycodeval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnalogRadioTuningSpace2>, base.5, CountryCode::<Impl, OFFSET>, SetCountryCode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAnalogTVTuningSpaceImpl: Sized + ITuningSpaceImpl + IDispatchImpl {
    fn MinChannel();
    fn SetMinChannel();
    fn MaxChannel();
    fn SetMaxChannel();
    fn InputType();
    fn SetInputType();
    fn CountryCode();
    fn SetCountryCode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAnalogTVTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAnalogTVTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogTVTuningSpaceVtbl {
    pub const fn new<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnalogTVTuningSpaceVtbl {
        unsafe extern "system" fn MinChannel<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinChannel(::core::mem::transmute_copy(&minchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinChannel<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinChannel(newminchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxChannel<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxChannel(::core::mem::transmute_copy(&maxchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxChannel<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxChannel(newmaxchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputType<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputtypeval: *mut TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputType(::core::mem::transmute_copy(&inputtypeval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newinputtypeval: TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputType(newinputtypeval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCode<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&countrycodeval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAnalogTVTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(newcountrycodeval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnalogTVTuningSpace>, base.5, MinChannel::<Impl, OFFSET>, SetMinChannel::<Impl, OFFSET>, MaxChannel::<Impl, OFFSET>, SetMaxChannel::<Impl, OFFSET>, InputType::<Impl, OFFSET>, SetInputType::<Impl, OFFSET>, CountryCode::<Impl, OFFSET>, SetCountryCode::<Impl, OFFSET>)
    }
}
pub trait IAsyncReaderImpl: Sized {
    fn RequestAllocator();
    fn Request();
    fn WaitForNext();
    fn SyncReadAligned();
    fn SyncRead();
    fn Length();
    fn BeginFlush();
    fn EndFlush();
}
impl ::windows::core::RuntimeName for IAsyncReader {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAsyncReader";
}
impl IAsyncReaderVtbl {
    pub const fn new<Impl: IAsyncReaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAsyncReaderVtbl {
        unsafe extern "system" fn RequestAllocator<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppreferred: ::windows::core::RawPtr, pprops: *const ALLOCATOR_PROPERTIES, ppactual: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestAllocator(&*(&ppreferred as *const <IMemAllocator as ::windows::core::Abi>::Abi as *const <IMemAllocator as ::windows::core::DefaultType>::DefaultType), &*(&pprops as *const <ALLOCATOR_PROPERTIES as ::windows::core::Abi>::Abi as *const <ALLOCATOR_PROPERTIES as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppactual)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Request<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr, dwuser: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Request(&*(&psample as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType), dwuser) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WaitForNext<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsample: *mut ::windows::core::RawPtr, pdwuser: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitForNext(dwtimeout, ::core::mem::transmute_copy(&ppsample), ::core::mem::transmute_copy(&pdwuser)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SyncReadAligned<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SyncReadAligned(&*(&psample as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SyncRead<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llposition: i64, llength: i32, pbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SyncRead(llposition, llength, ::core::mem::transmute_copy(&pbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptotal: *mut i64, pavailable: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Length(::core::mem::transmute_copy(&ptotal), ::core::mem::transmute_copy(&pavailable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginFlush<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginFlush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndFlush<Impl: IAsyncReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndFlush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAsyncReader>, base.5, RequestAllocator::<Impl, OFFSET>, Request::<Impl, OFFSET>, WaitForNext::<Impl, OFFSET>, SyncReadAligned::<Impl, OFFSET>, SyncRead::<Impl, OFFSET>, Length::<Impl, OFFSET>, BeginFlush::<Impl, OFFSET>, EndFlush::<Impl, OFFSET>)
    }
}
pub trait IAtscContentAdvisoryDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetRatingRegionCount();
    fn GetRecordRatingRegion();
    fn GetRecordRatedDimensions();
    fn GetRecordRatingDimension();
    fn GetRecordRatingValue();
    fn GetRecordRatingDescriptionText();
}
impl ::windows::core::RuntimeName for IAtscContentAdvisoryDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAtscContentAdvisoryDescriptor";
}
impl IAtscContentAdvisoryDescriptorVtbl {
    pub const fn new<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAtscContentAdvisoryDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRatingRegionCount<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRatingRegionCount(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingRegion<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingRegion(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatedDimensions<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRatedDimensions(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingDimension<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindexouter: u8, bindexinner: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingDimension(bindexouter, bindexinner, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingValue<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindexouter: u8, bindexinner: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingValue(bindexouter, bindexinner, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingDescriptionText<Impl: IAtscContentAdvisoryDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pblength: *mut u8, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingDescriptionText(bindex, ::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&pptext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAtscContentAdvisoryDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetRatingRegionCount::<Impl, OFFSET>, GetRecordRatingRegion::<Impl, OFFSET>, GetRecordRatedDimensions::<Impl, OFFSET>, GetRecordRatingDimension::<Impl, OFFSET>, GetRecordRatingValue::<Impl, OFFSET>, GetRecordRatingDescriptionText::<Impl, OFFSET>)
    }
}
pub trait IAtscPsipParserImpl: Sized {
    fn Initialize();
    fn GetPAT();
    fn GetCAT();
    fn GetPMT();
    fn GetTSDT();
    fn GetMGT();
    fn GetVCT();
    fn GetEIT();
    fn GetETT();
    fn GetSTT();
    fn GetEAS();
}
impl ::windows::core::RuntimeName for IAtscPsipParser {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAtscPsipParser";
}
impl IAtscPsipParserVtbl {
    pub const fn new<Impl: IAtscPsipParserImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAtscPsipParserVtbl {
        unsafe extern "system" fn Initialize<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkmpeg2data: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&punkmpeg2data as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPAT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPAT(::core::mem::transmute_copy(&pppat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCAT(dwtimeout, ::core::mem::transmute_copy(&ppcat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPMT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, pwprogramnumber: *const u16, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPMT(pid, pwprogramnumber, ::core::mem::transmute_copy(&pppmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSDT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTSDT(::core::mem::transmute_copy(&pptsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMGT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmgt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMGT(::core::mem::transmute_copy(&ppmgt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVCT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, fgetnexttable: super::super::Foundation::BOOL, ppvct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVCT(tableid, &*(&fgetnexttable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvct)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEIT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, pwsourceid: *const u16, dwtimeout: u32, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEIT(pid, pwsourceid, dwtimeout, ::core::mem::transmute_copy(&ppeit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetETT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, wsourceid: *const u16, pweventid: *const u16, ppett: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetETT(pid, wsourceid, pweventid, ::core::mem::transmute_copy(&ppett)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSTT<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppstt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSTT(::core::mem::transmute_copy(&ppstt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEAS<Impl: IAtscPsipParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, ppeas: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEAS(pid, ::core::mem::transmute_copy(&ppeas)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAtscPsipParser>, base.5, Initialize::<Impl, OFFSET>, GetPAT::<Impl, OFFSET>, GetCAT::<Impl, OFFSET>, GetPMT::<Impl, OFFSET>, GetTSDT::<Impl, OFFSET>, GetMGT::<Impl, OFFSET>, GetVCT::<Impl, OFFSET>, GetEIT::<Impl, OFFSET>, GetETT::<Impl, OFFSET>, GetSTT::<Impl, OFFSET>, GetEAS::<Impl, OFFSET>)
    }
}
pub trait IAttributeGetImpl: Sized {
    fn GetCount();
    fn GetAttribIndexed();
    fn GetAttrib();
}
impl ::windows::core::RuntimeName for IAttributeGet {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAttributeGet";
}
impl IAttributeGetVtbl {
    pub const fn new<Impl: IAttributeGetImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAttributeGetVtbl {
        unsafe extern "system" fn GetCount<Impl: IAttributeGetImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCount(::core::mem::transmute_copy(&plcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttribIndexed<Impl: IAttributeGetImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, pguidattribute: *mut ::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttribIndexed(lindex, ::core::mem::transmute_copy(&pguidattribute), pbattribute, pdwattributelength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttrib<Impl: IAttributeGetImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidattribute: ::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttrib(&*(&guidattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pbattribute, pdwattributelength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAttributeGet>, base.5, GetCount::<Impl, OFFSET>, GetAttribIndexed::<Impl, OFFSET>, GetAttrib::<Impl, OFFSET>)
    }
}
pub trait IAttributeSetImpl: Sized {
    fn SetAttrib();
}
impl ::windows::core::RuntimeName for IAttributeSet {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAttributeSet";
}
impl IAttributeSetVtbl {
    pub const fn new<Impl: IAttributeSetImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAttributeSetVtbl {
        unsafe extern "system" fn SetAttrib<Impl: IAttributeSetImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidattribute: ::windows::core::GUID, pbattribute: *const u8, dwattributelength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAttrib(&*(&guidattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pbattribute, dwattributelength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAttributeSet>, base.5, SetAttrib::<Impl, OFFSET>)
    }
}
pub trait IAudioDataImpl: Sized + IMemoryDataImpl {
    fn GetFormat();
    fn SetFormat();
}
impl ::windows::core::RuntimeName for IAudioData {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAudioData";
}
impl IAudioDataVtbl {
    pub const fn new<Impl: IAudioDataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAudioDataVtbl {
        unsafe extern "system" fn GetFormat<Impl: IAudioDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormat(::core::mem::transmute_copy(&pwaveformatcurrent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IAudioDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFormat(&*(&lpwaveformat as *const <super::Audio::WAVEFORMATEX as ::windows::core::Abi>::Abi as *const <super::Audio::WAVEFORMATEX as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAudioData>, base.5, GetFormat::<Impl, OFFSET>, SetFormat::<Impl, OFFSET>)
    }
}
pub trait IAudioMediaStreamImpl: Sized + IMediaStreamImpl {
    fn GetFormat();
    fn SetFormat();
    fn CreateSample();
}
impl ::windows::core::RuntimeName for IAudioMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAudioMediaStream";
}
impl IAudioMediaStreamVtbl {
    pub const fn new<Impl: IAudioMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAudioMediaStreamVtbl {
        unsafe extern "system" fn GetFormat<Impl: IAudioMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormat(::core::mem::transmute_copy(&pwaveformatcurrent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IAudioMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFormat(&*(&lpwaveformat as *const <super::Audio::WAVEFORMATEX as ::windows::core::Abi>::Abi as *const <super::Audio::WAVEFORMATEX as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSample<Impl: IAudioMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, paudiodata: ::windows::core::RawPtr, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSample(&*(&paudiodata as *const <IAudioData as ::windows::core::Abi>::Abi as *const <IAudioData as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAudioMediaStream>, base.5, GetFormat::<Impl, OFFSET>, SetFormat::<Impl, OFFSET>, CreateSample::<Impl, OFFSET>)
    }
}
pub trait IAudioStreamSampleImpl: Sized + IStreamSampleImpl {
    fn GetAudioData();
}
impl ::windows::core::RuntimeName for IAudioStreamSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAudioStreamSample";
}
impl IAudioStreamSampleVtbl {
    pub const fn new<Impl: IAudioStreamSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAudioStreamSampleVtbl {
        unsafe extern "system" fn GetAudioData<Impl: IAudioStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppaudio: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioData(::core::mem::transmute_copy(&ppaudio)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAudioStreamSample>, base.5, GetAudioData::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAuxInTuningSpaceImpl: Sized + ITuningSpaceImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAuxInTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAuxInTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IAuxInTuningSpaceVtbl {
    pub const fn new<Impl: IAuxInTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAuxInTuningSpaceVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAuxInTuningSpace>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAuxInTuningSpace2Impl: Sized + IAuxInTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn CountryCode();
    fn SetCountryCode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IAuxInTuningSpace2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IAuxInTuningSpace2";
}
#[cfg(feature = "Win32_System_Com")]
impl IAuxInTuningSpace2Vtbl {
    pub const fn new<Impl: IAuxInTuningSpace2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAuxInTuningSpace2Vtbl {
        unsafe extern "system" fn CountryCode<Impl: IAuxInTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&countrycodeval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAuxInTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(newcountrycodeval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAuxInTuningSpace2>, base.5, CountryCode::<Impl, OFFSET>, SetCountryCode::<Impl, OFFSET>)
    }
}
pub trait IBDAComparableImpl: Sized {
    fn CompareExact();
    fn CompareEquivalent();
    fn HashExact();
    fn HashExactIncremental();
    fn HashEquivalent();
    fn HashEquivalentIncremental();
}
impl ::windows::core::RuntimeName for IBDAComparable {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDAComparable";
}
impl IBDAComparableVtbl {
    pub const fn new<Impl: IBDAComparableImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDAComparableVtbl {
        unsafe extern "system" fn CompareExact<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compareto: ::windows::core::RawPtr, result: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompareExact(&*(&compareto as *const <super::super::System::Com::IDispatch as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IDispatch as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompareEquivalent<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compareto: ::windows::core::RawPtr, dwflags: u32, result: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompareEquivalent(&*(&compareto as *const <super::super::System::Com::IDispatch as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IDispatch as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashExact<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HashExact(::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashExactIncremental<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, partialresult: i64, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HashExactIncremental(partialresult, ::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashEquivalent<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HashEquivalent(dwflags, ::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashEquivalentIncremental<Impl: IBDAComparableImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, partialresult: i64, dwflags: u32, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HashEquivalentIncremental(partialresult, dwflags, ::core::mem::transmute_copy(&result)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDAComparable>, base.5, CompareExact::<Impl, OFFSET>, CompareEquivalent::<Impl, OFFSET>, HashExact::<Impl, OFFSET>, HashExactIncremental::<Impl, OFFSET>, HashEquivalent::<Impl, OFFSET>, HashEquivalentIncremental::<Impl, OFFSET>)
    }
}
pub trait IBDACreateTuneRequestExImpl: Sized {
    fn CreateTuneRequestEx();
}
impl ::windows::core::RuntimeName for IBDACreateTuneRequestEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDACreateTuneRequestEx";
}
impl IBDACreateTuneRequestExVtbl {
    pub const fn new<Impl: IBDACreateTuneRequestExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDACreateTuneRequestExVtbl {
        unsafe extern "system" fn CreateTuneRequestEx<Impl: IBDACreateTuneRequestExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tunerequestiid: *const ::windows::core::GUID, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequestEx(&*(&tunerequestiid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDACreateTuneRequestEx>, base.5, CreateTuneRequestEx::<Impl, OFFSET>)
    }
}
pub trait IBDA_AUXImpl: Sized {
    fn QueryCapabilities();
    fn EnumCapability();
}
impl ::windows::core::RuntimeName for IBDA_AUX {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_AUX";
}
impl IBDA_AUXVtbl {
    pub const fn new<Impl: IBDA_AUXImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_AUXVtbl {
        unsafe extern "system" fn QueryCapabilities<Impl: IBDA_AUXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumauxinputsbstr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryCapabilities(::core::mem::transmute_copy(&pdwnumauxinputsbstr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumCapability<Impl: IBDA_AUXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut ::windows::core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumCapability(dwindex, ::core::mem::transmute_copy(&dwinputid), ::core::mem::transmute_copy(&pconnectortype), ::core::mem::transmute_copy(&conntypenum), ::core::mem::transmute_copy(&numvideostds), ::core::mem::transmute_copy(&analogstds)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_AUX>, base.5, QueryCapabilities::<Impl, OFFSET>, EnumCapability::<Impl, OFFSET>)
    }
}
pub trait IBDA_AutoDemodulateImpl: Sized {
    fn SetAutoDemodulate();
}
impl ::windows::core::RuntimeName for IBDA_AutoDemodulate {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_AutoDemodulate";
}
impl IBDA_AutoDemodulateVtbl {
    pub const fn new<Impl: IBDA_AutoDemodulateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_AutoDemodulateVtbl {
        unsafe extern "system" fn SetAutoDemodulate<Impl: IBDA_AutoDemodulateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAutoDemodulate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_AutoDemodulate>, base.5, SetAutoDemodulate::<Impl, OFFSET>)
    }
}
pub trait IBDA_AutoDemodulateExImpl: Sized + IBDA_AutoDemodulateImpl {
    fn SupportedDeviceNodeTypes();
    fn SupportedVideoFormats();
    fn AuxInputCount();
}
impl ::windows::core::RuntimeName for IBDA_AutoDemodulateEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_AutoDemodulateEx";
}
impl IBDA_AutoDemodulateExVtbl {
    pub const fn new<Impl: IBDA_AutoDemodulateExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_AutoDemodulateExVtbl {
        unsafe extern "system" fn SupportedDeviceNodeTypes<Impl: IBDA_AutoDemodulateExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportedDeviceNodeTypes(ulcdevicenodetypesmax, ::core::mem::transmute_copy(&pulcdevicenodetypes), &*(&pguiddevicenodetypes as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportedVideoFormats<Impl: IBDA_AutoDemodulateExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportedVideoFormats(::core::mem::transmute_copy(&pulamtunermodetype), ::core::mem::transmute_copy(&pulanalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AuxInputCount<Impl: IBDA_AutoDemodulateExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AuxInputCount(pulcompositecount, pulsvideocount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_AutoDemodulateEx>, base.5, SupportedDeviceNodeTypes::<Impl, OFFSET>, SupportedVideoFormats::<Impl, OFFSET>, AuxInputCount::<Impl, OFFSET>)
    }
}
pub trait IBDA_ConditionalAccessImpl: Sized {
    fn SmartCardStatus();
    fn SmartCardInfo();
    fn SmartCardApplications();
    fn Entitlement();
    fn TuneByChannel();
    fn SetProgram();
    fn AddProgram();
    fn RemoveProgram();
    fn GetModuleUI();
    fn InformUIClosed();
}
impl ::windows::core::RuntimeName for IBDA_ConditionalAccess {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_ConditionalAccess";
}
impl IBDA_ConditionalAccessVtbl {
    pub const fn new<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_ConditionalAccessVtbl {
        unsafe extern "system" fn SmartCardStatus<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut super::super::Foundation::BSTR, pfooblocked: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SmartCardStatus(::core::mem::transmute_copy(&pcardstatus), ::core::mem::transmute_copy(&pcardassociation), ::core::mem::transmute_copy(&pbstrcarderror), ::core::mem::transmute_copy(&pfooblocked)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SmartCardInfo<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrcardname: *mut super::super::Foundation::BSTR, pbstrcardmanufacturer: *mut super::super::Foundation::BSTR, pfdaylightsavings: *mut i16, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut super::super::Foundation::BSTR, pealocationcode: *mut EALocationCodeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SmartCardInfo(::core::mem::transmute_copy(&pbstrcardname), ::core::mem::transmute_copy(&pbstrcardmanufacturer), ::core::mem::transmute_copy(&pfdaylightsavings), ::core::mem::transmute_copy(&pbyratingregion), ::core::mem::transmute_copy(&pltimezoneoffsetminutes), ::core::mem::transmute_copy(&pbstrlanguage), ::core::mem::transmute_copy(&pealocationcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SmartCardApplications<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcapplications: *mut u32, ulcapplicationsmax: u32, rgapplications: *mut SmartCardApplication) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SmartCardApplications(pulcapplications, ulcapplicationsmax, &*(&rgapplications as *const <SmartCardApplication as ::windows::core::Abi>::Abi as *const <SmartCardApplication as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Entitlement<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usvirtualchannel: u16, pentitlement: *mut EntitlementType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Entitlement(usvirtualchannel, ::core::mem::transmute_copy(&pentitlement)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuneByChannel<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usvirtualchannel: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuneByChannel(usvirtualchannel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgram<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProgram(usprogramnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProgram<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddProgram(usprogramnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveProgram<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveProgram(usprogramnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModuleUI<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bydialognumber: u8, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetModuleUI(bydialognumber, ::core::mem::transmute_copy(&pbstrurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InformUIClosed<Impl: IBDA_ConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bydialognumber: u8, closereason: UICloseReasonType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InformUIClosed(bydialognumber, closereason) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_ConditionalAccess>, base.5, SmartCardStatus::<Impl, OFFSET>, SmartCardInfo::<Impl, OFFSET>, SmartCardApplications::<Impl, OFFSET>, Entitlement::<Impl, OFFSET>, TuneByChannel::<Impl, OFFSET>, SetProgram::<Impl, OFFSET>, AddProgram::<Impl, OFFSET>, RemoveProgram::<Impl, OFFSET>, GetModuleUI::<Impl, OFFSET>, InformUIClosed::<Impl, OFFSET>)
    }
}
pub trait IBDA_ConditionalAccessExImpl: Sized {
    fn CheckEntitlementToken();
    fn SetCaptureToken();
    fn OpenBroadcastMmi();
    fn CloseMmiDialog();
    fn CreateDialogRequestNumber();
}
impl ::windows::core::RuntimeName for IBDA_ConditionalAccessEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_ConditionalAccessEx";
}
impl IBDA_ConditionalAccessExVtbl {
    pub const fn new<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_ConditionalAccessExVtbl {
        unsafe extern "system" fn CheckEntitlementToken<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckEntitlementToken(uldialogrequest, &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), requesttype, ulcbentitlementtokenlen, pbentitlementtoken, ::core::mem::transmute_copy(&puldescramblestatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaptureToken<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcbcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCaptureToken(ulcbcapturetokenlen, pbcapturetoken) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenBroadcastMmi<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, eventid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenBroadcastMmi(uldialogrequest, &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), eventid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseMmiDialog<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON, pulsessionresult: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseMmiDialog(uldialogrequest, &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), uldialognumber, reasoncode, ::core::mem::transmute_copy(&pulsessionresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateDialogRequestNumber<Impl: IBDA_ConditionalAccessExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puldialogrequestnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateDialogRequestNumber(::core::mem::transmute_copy(&puldialogrequestnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_ConditionalAccessEx>, base.5, CheckEntitlementToken::<Impl, OFFSET>, SetCaptureToken::<Impl, OFFSET>, OpenBroadcastMmi::<Impl, OFFSET>, CloseMmiDialog::<Impl, OFFSET>, CreateDialogRequestNumber::<Impl, OFFSET>)
    }
}
pub trait IBDA_DRIDRMServiceImpl: Sized {
    fn SetDRM();
    fn GetDRMStatus();
    fn GetPairingStatus();
}
impl ::windows::core::RuntimeName for IBDA_DRIDRMService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DRIDRMService";
}
impl IBDA_DRIDRMServiceVtbl {
    pub const fn new<Impl: IBDA_DRIDRMServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DRIDRMServiceVtbl {
        unsafe extern "system" fn SetDRM<Impl: IBDA_DRIDRMServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrnewdrm: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDRM(&*(&bstrnewdrm as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDRMStatus<Impl: IBDA_DRIDRMServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDRMStatus(::core::mem::transmute_copy(&pbstrdrmuuidlist), ::core::mem::transmute_copy(&drmuuid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPairingStatus<Impl: IBDA_DRIDRMServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penumpairingstatus: *mut BDA_DrmPairingError) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPairingStatus(penumpairingstatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DRIDRMService>, base.5, SetDRM::<Impl, OFFSET>, GetDRMStatus::<Impl, OFFSET>, GetPairingStatus::<Impl, OFFSET>)
    }
}
pub trait IBDA_DRIWMDRMSessionImpl: Sized {
    fn AcknowledgeLicense();
    fn ProcessLicenseChallenge();
    fn ProcessRegistrationChallenge();
    fn SetRevInfo();
    fn SetCrl();
    fn GetHMSAssociationData();
    fn GetLastCardeaError();
}
impl ::windows::core::RuntimeName for IBDA_DRIWMDRMSession {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DRIWMDRMSession";
}
impl IBDA_DRIWMDRMSessionVtbl {
    pub const fn new<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DRIWMDRMSessionVtbl {
        unsafe extern "system" fn AcknowledgeLicense<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hrlicenseack: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcknowledgeLicense(hrlicenseack) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessLicenseChallenge<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcblicensemessage: u32, pblicensemessage: *const u8, pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessLicenseChallenge(dwcblicensemessage, pblicensemessage, pdwcblicenseresponse, ppblicenseresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessRegistrationChallenge<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcbregistrationmessage: u32, pbregistrationmessage: *const u8, pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessRegistrationChallenge(dwcbregistrationmessage, pbregistrationmessage, pdwcbregistrationresponse, ppbregistrationresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRevInfo<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrevinfolen: u32, pbrevinfo: *const u8, pdwresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRevInfo(dwrevinfolen, pbrevinfo, pdwresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCrl<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcrllen: u32, pbcrllen: *const u8, pdwresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCrl(dwcrllen, pbcrllen, pdwresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHMSAssociationData<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHMSAssociationData() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastCardeaError<Impl: IBDA_DRIWMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwerror: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastCardeaError(pdwerror) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DRIWMDRMSession>, base.5, AcknowledgeLicense::<Impl, OFFSET>, ProcessLicenseChallenge::<Impl, OFFSET>, ProcessRegistrationChallenge::<Impl, OFFSET>, SetRevInfo::<Impl, OFFSET>, SetCrl::<Impl, OFFSET>, GetHMSAssociationData::<Impl, OFFSET>, GetLastCardeaError::<Impl, OFFSET>)
    }
}
pub trait IBDA_DRMImpl: Sized {
    fn GetDRMPairingStatus();
    fn PerformDRMPairing();
}
impl ::windows::core::RuntimeName for IBDA_DRM {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DRM";
}
impl IBDA_DRMVtbl {
    pub const fn new<Impl: IBDA_DRMImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DRMVtbl {
        unsafe extern "system" fn GetDRMPairingStatus<Impl: IBDA_DRMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstatus: *mut u32, pherror: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDRMPairingStatus(::core::mem::transmute_copy(&pdwstatus), ::core::mem::transmute_copy(&pherror)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PerformDRMPairing<Impl: IBDA_DRMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fsync: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PerformDRMPairing(&*(&fsync as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DRM>, base.5, GetDRMPairingStatus::<Impl, OFFSET>, PerformDRMPairing::<Impl, OFFSET>)
    }
}
pub trait IBDA_DRMServiceImpl: Sized {
    fn SetDRM();
    fn GetDRMStatus();
}
impl ::windows::core::RuntimeName for IBDA_DRMService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DRMService";
}
impl IBDA_DRMServiceVtbl {
    pub const fn new<Impl: IBDA_DRMServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DRMServiceVtbl {
        unsafe extern "system" fn SetDRM<Impl: IBDA_DRMServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puuidnewdrm: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDRM(&*(&puuidnewdrm as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDRMStatus<Impl: IBDA_DRMServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDRMStatus(::core::mem::transmute_copy(&pbstrdrmuuidlist), ::core::mem::transmute_copy(&drmuuid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DRMService>, base.5, SetDRM::<Impl, OFFSET>, GetDRMStatus::<Impl, OFFSET>)
    }
}
pub trait IBDA_DeviceControlImpl: Sized {
    fn StartChanges();
    fn CheckChanges();
    fn CommitChanges();
    fn GetChangeState();
}
impl ::windows::core::RuntimeName for IBDA_DeviceControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DeviceControl";
}
impl IBDA_DeviceControlVtbl {
    pub const fn new<Impl: IBDA_DeviceControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DeviceControlVtbl {
        unsafe extern "system" fn StartChanges<Impl: IBDA_DeviceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartChanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CheckChanges<Impl: IBDA_DeviceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckChanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommitChanges<Impl: IBDA_DeviceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommitChanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetChangeState<Impl: IBDA_DeviceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetChangeState(pstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DeviceControl>, base.5, StartChanges::<Impl, OFFSET>, CheckChanges::<Impl, OFFSET>, CommitChanges::<Impl, OFFSET>, GetChangeState::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
pub trait IBDA_DiagnosticPropertiesImpl: Sized + IPropertyBagImpl {}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::windows::core::RuntimeName for IBDA_DiagnosticProperties {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DiagnosticProperties";
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IBDA_DiagnosticPropertiesVtbl {
    pub const fn new<Impl: IBDA_DiagnosticPropertiesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DiagnosticPropertiesVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DiagnosticProperties>, base.5)
    }
}
pub trait IBDA_DigitalDemodulatorImpl: Sized {
    fn SetModulationType();
    fn ModulationType();
    fn SetInnerFECMethod();
    fn InnerFECMethod();
    fn SetInnerFECRate();
    fn InnerFECRate();
    fn SetOuterFECMethod();
    fn OuterFECMethod();
    fn SetOuterFECRate();
    fn OuterFECRate();
    fn SetSymbolRate();
    fn SymbolRate();
    fn SetSpectralInversion();
    fn SpectralInversion();
}
impl ::windows::core::RuntimeName for IBDA_DigitalDemodulator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DigitalDemodulator";
}
impl IBDA_DigitalDemodulatorVtbl {
    pub const fn new<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DigitalDemodulatorVtbl {
        unsafe extern "system" fn SetModulationType<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmodulationtype: *const ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetModulationType(pmodulationtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ModulationType<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmodulationtype: *mut ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ModulationType(pmodulationtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFECMethod<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecmethod: *const FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInnerFECMethod(pfecmethod) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InnerFECMethod<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecmethod: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InnerFECMethod(pfecmethod) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFECRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInnerFECRate(pfecrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InnerFECRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InnerFECRate(pfecrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFECMethod<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecmethod: *const FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOuterFECMethod(pfecmethod) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OuterFECMethod<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecmethod: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OuterFECMethod(pfecmethod) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFECRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOuterFECRate(pfecrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OuterFECRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OuterFECRate(pfecrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbolRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psymbolrate: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSymbolRate(psymbolrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SymbolRate<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psymbolrate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SymbolRate(psymbolrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpectralInversion<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pspectralinversion: *const SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSpectralInversion(pspectralinversion) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SpectralInversion<Impl: IBDA_DigitalDemodulatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pspectralinversion: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SpectralInversion(pspectralinversion) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IBDA_DigitalDemodulator>,
            base.5,
            SetModulationType::<Impl, OFFSET>,
            ModulationType::<Impl, OFFSET>,
            SetInnerFECMethod::<Impl, OFFSET>,
            InnerFECMethod::<Impl, OFFSET>,
            SetInnerFECRate::<Impl, OFFSET>,
            InnerFECRate::<Impl, OFFSET>,
            SetOuterFECMethod::<Impl, OFFSET>,
            OuterFECMethod::<Impl, OFFSET>,
            SetOuterFECRate::<Impl, OFFSET>,
            OuterFECRate::<Impl, OFFSET>,
            SetSymbolRate::<Impl, OFFSET>,
            SymbolRate::<Impl, OFFSET>,
            SetSpectralInversion::<Impl, OFFSET>,
            SpectralInversion::<Impl, OFFSET>,
        )
    }
}
pub trait IBDA_DigitalDemodulator2Impl: Sized + IBDA_DigitalDemodulatorImpl {
    fn SetGuardInterval();
    fn GuardInterval();
    fn SetTransmissionMode();
    fn TransmissionMode();
    fn SetRollOff();
    fn RollOff();
    fn SetPilot();
    fn Pilot();
}
impl ::windows::core::RuntimeName for IBDA_DigitalDemodulator2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DigitalDemodulator2";
}
impl IBDA_DigitalDemodulator2Vtbl {
    pub const fn new<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DigitalDemodulator2Vtbl {
        unsafe extern "system" fn SetGuardInterval<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguardinterval: *const GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGuardInterval(pguardinterval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GuardInterval<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguardinterval: *mut GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GuardInterval(pguardinterval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransmissionMode<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptransmissionmode: *const TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTransmissionMode(ptransmissionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TransmissionMode<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptransmissionmode: *mut TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransmissionMode(ptransmissionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRollOff<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prolloff: *const RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRollOff(prolloff) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RollOff<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prolloff: *mut RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RollOff(prolloff) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPilot<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppilot: *const Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPilot(ppilot) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pilot<Impl: IBDA_DigitalDemodulator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppilot: *mut Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pilot(ppilot) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DigitalDemodulator2>, base.5, SetGuardInterval::<Impl, OFFSET>, GuardInterval::<Impl, OFFSET>, SetTransmissionMode::<Impl, OFFSET>, TransmissionMode::<Impl, OFFSET>, SetRollOff::<Impl, OFFSET>, RollOff::<Impl, OFFSET>, SetPilot::<Impl, OFFSET>, Pilot::<Impl, OFFSET>)
    }
}
pub trait IBDA_DigitalDemodulator3Impl: Sized + IBDA_DigitalDemodulator2Impl + IBDA_DigitalDemodulatorImpl {
    fn SetSignalTimeouts();
    fn SignalTimeouts();
    fn SetPLPNumber();
    fn PLPNumber();
}
impl ::windows::core::RuntimeName for IBDA_DigitalDemodulator3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DigitalDemodulator3";
}
impl IBDA_DigitalDemodulator3Vtbl {
    pub const fn new<Impl: IBDA_DigitalDemodulator3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DigitalDemodulator3Vtbl {
        unsafe extern "system" fn SetSignalTimeouts<Impl: IBDA_DigitalDemodulator3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalTimeouts(&*(&psignaltimeouts as *const <BDA_SIGNAL_TIMEOUTS as ::windows::core::Abi>::Abi as *const <BDA_SIGNAL_TIMEOUTS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalTimeouts<Impl: IBDA_DigitalDemodulator3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalTimeouts(&*(&psignaltimeouts as *const <BDA_SIGNAL_TIMEOUTS as ::windows::core::Abi>::Abi as *const <BDA_SIGNAL_TIMEOUTS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPLPNumber<Impl: IBDA_DigitalDemodulator3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pplpnumber: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPLPNumber(pplpnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PLPNumber<Impl: IBDA_DigitalDemodulator3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pplpnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PLPNumber(pplpnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DigitalDemodulator3>, base.5, SetSignalTimeouts::<Impl, OFFSET>, SignalTimeouts::<Impl, OFFSET>, SetPLPNumber::<Impl, OFFSET>, PLPNumber::<Impl, OFFSET>)
    }
}
pub trait IBDA_DiseqCommandImpl: Sized {
    fn SetEnableDiseqCommands();
    fn SetDiseqLNBSource();
    fn SetDiseqUseToneBurst();
    fn SetDiseqRepeats();
    fn SetDiseqSendCommand();
    fn DiseqResponse();
}
impl ::windows::core::RuntimeName for IBDA_DiseqCommand {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_DiseqCommand";
}
impl IBDA_DiseqCommandVtbl {
    pub const fn new<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_DiseqCommandVtbl {
        unsafe extern "system" fn SetEnableDiseqCommands<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benable: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableDiseqCommands(&*(&benable as *const <super::super::Foundation::BOOLEAN as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOLEAN as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqLNBSource<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullnbsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiseqLNBSource(ullnbsource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqUseToneBurst<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, busetoneburst: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiseqUseToneBurst(&*(&busetoneburst as *const <super::super::Foundation::BOOLEAN as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOLEAN as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqRepeats<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrepeats: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiseqRepeats(ulrepeats) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqSendCommand<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, ulcbcommandlen: u32, pbcommand: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiseqSendCommand(ulrequestid, ulcbcommandlen, pbcommand) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DiseqResponse<Impl: IBDA_DiseqCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DiseqResponse(ulrequestid, pulcbresponselen, pbresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_DiseqCommand>, base.5, SetEnableDiseqCommands::<Impl, OFFSET>, SetDiseqLNBSource::<Impl, OFFSET>, SetDiseqUseToneBurst::<Impl, OFFSET>, SetDiseqRepeats::<Impl, OFFSET>, SetDiseqSendCommand::<Impl, OFFSET>, DiseqResponse::<Impl, OFFSET>)
    }
}
pub trait IBDA_EasMessageImpl: Sized {
    fn EasMessage();
}
impl ::windows::core::RuntimeName for IBDA_EasMessage {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_EasMessage";
}
impl IBDA_EasMessageVtbl {
    pub const fn new<Impl: IBDA_EasMessageImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_EasMessageVtbl {
        unsafe extern "system" fn EasMessage<Impl: IBDA_EasMessageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uleventid: u32, ppeasobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EasMessage(uleventid, &*(&ppeasobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_EasMessage>, base.5, EasMessage::<Impl, OFFSET>)
    }
}
pub trait IBDA_EncoderImpl: Sized {
    fn QueryCapabilities();
    fn EnumAudioCapability();
    fn EnumVideoCapability();
    fn SetParameters();
    fn GetState();
}
impl ::windows::core::RuntimeName for IBDA_Encoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_Encoder";
}
impl IBDA_EncoderVtbl {
    pub const fn new<Impl: IBDA_EncoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_EncoderVtbl {
        unsafe extern "system" fn QueryCapabilities<Impl: IBDA_EncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryCapabilities(::core::mem::transmute_copy(&numaudiofmts), ::core::mem::transmute_copy(&numvideofmts)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumAudioCapability<Impl: IBDA_EncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumAudioCapability(fmtindex, ::core::mem::transmute_copy(&methodid), ::core::mem::transmute_copy(&algorithmtype), ::core::mem::transmute_copy(&samplingrate), ::core::mem::transmute_copy(&bitdepth), ::core::mem::transmute_copy(&numchannels)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumVideoCapability<Impl: IBDA_EncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumVideoCapability(fmtindex, ::core::mem::transmute_copy(&methodid), ::core::mem::transmute_copy(&algorithmtype), ::core::mem::transmute_copy(&verticalsize), ::core::mem::transmute_copy(&horizontalsize), ::core::mem::transmute_copy(&aspectratio), ::core::mem::transmute_copy(&frameratecode), ::core::mem::transmute_copy(&progressivesequence)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParameters<Impl: IBDA_EncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetParameters(audiobitratemode, audiobitrate, audiomethodid, audioprogram, videobitratemode, videobitrate, videomethodid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IBDA_EncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut super::super::Foundation::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(
                ::core::mem::transmute_copy(&audiobitratemax),
                ::core::mem::transmute_copy(&audiobitratemin),
                ::core::mem::transmute_copy(&audiobitratemode),
                ::core::mem::transmute_copy(&audiobitratestepping),
                ::core::mem::transmute_copy(&audiobitrate),
                ::core::mem::transmute_copy(&audiomethodid),
                ::core::mem::transmute_copy(&availableaudioprograms),
                ::core::mem::transmute_copy(&audioprogram),
                ::core::mem::transmute_copy(&videobitratemax),
                ::core::mem::transmute_copy(&videobitratemin),
                ::core::mem::transmute_copy(&videobitratemode),
                ::core::mem::transmute_copy(&videobitrate),
                ::core::mem::transmute_copy(&videobitratestepping),
                ::core::mem::transmute_copy(&videomethodid),
                ::core::mem::transmute_copy(&signalsourceid),
                ::core::mem::transmute_copy(&signalformat),
                ::core::mem::transmute_copy(&signallock),
                ::core::mem::transmute_copy(&signallevel),
                ::core::mem::transmute_copy(&signaltonoiseratio),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_Encoder>, base.5, QueryCapabilities::<Impl, OFFSET>, EnumAudioCapability::<Impl, OFFSET>, EnumVideoCapability::<Impl, OFFSET>, SetParameters::<Impl, OFFSET>, GetState::<Impl, OFFSET>)
    }
}
pub trait IBDA_EthernetFilterImpl: Sized {
    fn GetMulticastListSize();
    fn PutMulticastList();
    fn GetMulticastList();
    fn PutMulticastMode();
    fn GetMulticastMode();
}
impl ::windows::core::RuntimeName for IBDA_EthernetFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_EthernetFilter";
}
impl IBDA_EthernetFilterVtbl {
    pub const fn new<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_EthernetFilterVtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastListSize(pulcbaddresses) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastList(ulcbaddresses, paddresslist) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastList(pulcbaddresses, paddresslist) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastMode(ulmodemask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_EthernetFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode(::core::mem::transmute_copy(&pulmodemask)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_EthernetFilter>, base.5, GetMulticastListSize::<Impl, OFFSET>, PutMulticastList::<Impl, OFFSET>, GetMulticastList::<Impl, OFFSET>, PutMulticastMode::<Impl, OFFSET>, GetMulticastMode::<Impl, OFFSET>)
    }
}
pub trait IBDA_EventingServiceImpl: Sized {
    fn CompleteEvent();
}
impl ::windows::core::RuntimeName for IBDA_EventingService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_EventingService";
}
impl IBDA_EventingServiceVtbl {
    pub const fn new<Impl: IBDA_EventingServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_EventingServiceVtbl {
        unsafe extern "system" fn CompleteEvent<Impl: IBDA_EventingServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uleventid: u32, uleventresult: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompleteEvent(uleventid, uleventresult) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_EventingService>, base.5, CompleteEvent::<Impl, OFFSET>)
    }
}
pub trait IBDA_FDCImpl: Sized {
    fn GetStatus();
    fn RequestTables();
    fn AddPid();
    fn RemovePid();
    fn AddTid();
    fn RemoveTid();
    fn GetTableSection();
}
impl ::windows::core::RuntimeName for IBDA_FDC {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_FDC";
}
impl IBDA_FDCVtbl {
    pub const fn new<Impl: IBDA_FDCImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_FDCVtbl {
        unsafe extern "system" fn GetStatus<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentbitrate: *mut u32, carrierlock: *mut super::super::Foundation::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut super::super::Foundation::BOOL, currentpidlist: *mut super::super::Foundation::BSTR, currenttidlist: *mut super::super::Foundation::BSTR, overflow: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&currentbitrate), ::core::mem::transmute_copy(&carrierlock), ::core::mem::transmute_copy(&currentfrequency), ::core::mem::transmute_copy(&currentspectruminversion), ::core::mem::transmute_copy(&currentpidlist), ::core::mem::transmute_copy(&currenttidlist), ::core::mem::transmute_copy(&overflow)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestTables<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableids: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestTables(&*(&tableids as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddPid<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pidstoadd: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, remainingfilterentries: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddPid(&*(&pidstoadd as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&remainingfilterentries)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePid<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pidstoremove: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovePid(&*(&pidstoremove as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTid<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tidstoadd: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, currenttidlist: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddTid(&*(&tidstoadd as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&currenttidlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTid<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tidstoremove: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveTid(&*(&tidstoremove as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableSection<Impl: IBDA_FDCImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableSection(::core::mem::transmute_copy(&pid), maxbuffersize, ::core::mem::transmute_copy(&actualsize), ::core::mem::transmute_copy(&secbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_FDC>, base.5, GetStatus::<Impl, OFFSET>, RequestTables::<Impl, OFFSET>, AddPid::<Impl, OFFSET>, RemovePid::<Impl, OFFSET>, AddTid::<Impl, OFFSET>, RemoveTid::<Impl, OFFSET>, GetTableSection::<Impl, OFFSET>)
    }
}
pub trait IBDA_FrequencyFilterImpl: Sized {
    fn SetAutotune();
    fn Autotune();
    fn SetFrequency();
    fn Frequency();
    fn SetPolarity();
    fn Polarity();
    fn SetRange();
    fn Range();
    fn SetBandwidth();
    fn Bandwidth();
    fn SetFrequencyMultiplier();
    fn FrequencyMultiplier();
}
impl ::windows::core::RuntimeName for IBDA_FrequencyFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_FrequencyFilter";
}
impl IBDA_FrequencyFilterVtbl {
    pub const fn new<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_FrequencyFilterVtbl {
        unsafe extern "system" fn SetAutotune<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultransponder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAutotune(ultransponder) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Autotune<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pultransponder: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Autotune(pultransponder) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequency<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulfrequency: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrequency(ulfrequency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Frequency<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulfrequency: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Frequency(pulfrequency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPolarity<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, polarity: Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPolarity(polarity) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Polarity<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppolarity: *mut Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Polarity(ppolarity) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRange<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrange: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRange(ulrange) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Range<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulrange: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Range(pulrange) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBandwidth<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbandwidth: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBandwidth(ulbandwidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Bandwidth<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulbandwidth: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bandwidth(pulbandwidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyMultiplier<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmultiplier: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrequencyMultiplier(ulmultiplier) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FrequencyMultiplier<Impl: IBDA_FrequencyFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulmultiplier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrequencyMultiplier(pulmultiplier) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_FrequencyFilter>, base.5, SetAutotune::<Impl, OFFSET>, Autotune::<Impl, OFFSET>, SetFrequency::<Impl, OFFSET>, Frequency::<Impl, OFFSET>, SetPolarity::<Impl, OFFSET>, Polarity::<Impl, OFFSET>, SetRange::<Impl, OFFSET>, Range::<Impl, OFFSET>, SetBandwidth::<Impl, OFFSET>, Bandwidth::<Impl, OFFSET>, SetFrequencyMultiplier::<Impl, OFFSET>, FrequencyMultiplier::<Impl, OFFSET>)
    }
}
pub trait IBDA_GuideDataDeliveryServiceImpl: Sized {
    fn GetGuideDataType();
    fn GetGuideData();
    fn RequestGuideDataUpdate();
    fn GetTuneXmlFromServiceIdx();
    fn GetServices();
    fn GetServiceInfoFromTuneXml();
}
impl ::windows::core::RuntimeName for IBDA_GuideDataDeliveryService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_GuideDataDeliveryService";
}
impl IBDA_GuideDataDeliveryServiceVtbl {
    pub const fn new<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_GuideDataDeliveryServiceVtbl {
        unsafe extern "system" fn GetGuideDataType<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguiddatatype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuideDataType(::core::mem::transmute_copy(&pguiddatatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuideData<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuideData(pulcbbufferlen, ::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&pulguidedatapercentageprogress)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestGuideDataUpdate<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestGuideDataUpdate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTuneXmlFromServiceIdx<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ul64serviceidx: u64, pbstrtunexml: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTuneXmlFromServiceIdx(ul64serviceidx, ::core::mem::transmute_copy(&pbstrtunexml)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServices<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServices(pulcbbufferlen, ::core::mem::transmute_copy(&pbbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceInfoFromTuneXml<Impl: IBDA_GuideDataDeliveryServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrtunexml: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrservicedescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceInfoFromTuneXml(&*(&bstrtunexml as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbstrservicedescription)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_GuideDataDeliveryService>, base.5, GetGuideDataType::<Impl, OFFSET>, GetGuideData::<Impl, OFFSET>, RequestGuideDataUpdate::<Impl, OFFSET>, GetTuneXmlFromServiceIdx::<Impl, OFFSET>, GetServices::<Impl, OFFSET>, GetServiceInfoFromTuneXml::<Impl, OFFSET>)
    }
}
pub trait IBDA_IPSinkControlImpl: Sized {
    fn GetMulticastList();
    fn GetAdapterIPAddress();
}
impl ::windows::core::RuntimeName for IBDA_IPSinkControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_IPSinkControl";
}
impl IBDA_IPSinkControlVtbl {
    pub const fn new<Impl: IBDA_IPSinkControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_IPSinkControlVtbl {
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPSinkControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastList(pulcbsize, pbbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAdapterIPAddress<Impl: IBDA_IPSinkControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAdapterIPAddress(pulcbsize, pbbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_IPSinkControl>, base.5, GetMulticastList::<Impl, OFFSET>, GetAdapterIPAddress::<Impl, OFFSET>)
    }
}
pub trait IBDA_IPSinkInfoImpl: Sized {
    fn MulticastList();
    fn AdapterIPAddress();
    fn AdapterDescription();
}
impl ::windows::core::RuntimeName for IBDA_IPSinkInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_IPSinkInfo";
}
impl IBDA_IPSinkInfoVtbl {
    pub const fn new<Impl: IBDA_IPSinkInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_IPSinkInfoVtbl {
        unsafe extern "system" fn MulticastList<Impl: IBDA_IPSinkInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MulticastList(pulcbaddresses, ::core::mem::transmute_copy(&ppbaddresslist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdapterIPAddress<Impl: IBDA_IPSinkInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrbuffer: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdapterIPAddress(::core::mem::transmute_copy(&pbstrbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdapterDescription<Impl: IBDA_IPSinkInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrbuffer: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdapterDescription(::core::mem::transmute_copy(&pbstrbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_IPSinkInfo>, base.5, MulticastList::<Impl, OFFSET>, AdapterIPAddress::<Impl, OFFSET>, AdapterDescription::<Impl, OFFSET>)
    }
}
pub trait IBDA_IPV4FilterImpl: Sized {
    fn GetMulticastListSize();
    fn PutMulticastList();
    fn GetMulticastList();
    fn PutMulticastMode();
    fn GetMulticastMode();
}
impl ::windows::core::RuntimeName for IBDA_IPV4Filter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_IPV4Filter";
}
impl IBDA_IPV4FilterVtbl {
    pub const fn new<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_IPV4FilterVtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastListSize(pulcbaddresses) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastList(ulcbaddresses, paddresslist) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastList(pulcbaddresses, ::core::mem::transmute_copy(&paddresslist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastMode(ulmodemask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_IPV4FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode(::core::mem::transmute_copy(&pulmodemask)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_IPV4Filter>, base.5, GetMulticastListSize::<Impl, OFFSET>, PutMulticastList::<Impl, OFFSET>, GetMulticastList::<Impl, OFFSET>, PutMulticastMode::<Impl, OFFSET>, GetMulticastMode::<Impl, OFFSET>)
    }
}
pub trait IBDA_IPV6FilterImpl: Sized {
    fn GetMulticastListSize();
    fn PutMulticastList();
    fn GetMulticastList();
    fn PutMulticastMode();
    fn GetMulticastMode();
}
impl ::windows::core::RuntimeName for IBDA_IPV6Filter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_IPV6Filter";
}
impl IBDA_IPV6FilterVtbl {
    pub const fn new<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_IPV6FilterVtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastListSize(pulcbaddresses) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastList(ulcbaddresses, paddresslist) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastList(pulcbaddresses, ::core::mem::transmute_copy(&paddresslist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutMulticastMode(ulmodemask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_IPV6FilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode(::core::mem::transmute_copy(&pulmodemask)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_IPV6Filter>, base.5, GetMulticastListSize::<Impl, OFFSET>, PutMulticastList::<Impl, OFFSET>, GetMulticastList::<Impl, OFFSET>, PutMulticastMode::<Impl, OFFSET>, GetMulticastMode::<Impl, OFFSET>)
    }
}
pub trait IBDA_ISDBConditionalAccessImpl: Sized {
    fn SetIsdbCasRequest();
}
impl ::windows::core::RuntimeName for IBDA_ISDBConditionalAccess {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_ISDBConditionalAccess";
}
impl IBDA_ISDBConditionalAccessVtbl {
    pub const fn new<Impl: IBDA_ISDBConditionalAccessImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_ISDBConditionalAccessVtbl {
        unsafe extern "system" fn SetIsdbCasRequest<Impl: IBDA_ISDBConditionalAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, ulcbrequestbufferlen: u32, pbrequestbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIsdbCasRequest(ulrequestid, ulcbrequestbufferlen, pbrequestbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_ISDBConditionalAccess>, base.5, SetIsdbCasRequest::<Impl, OFFSET>)
    }
}
pub trait IBDA_LNBInfoImpl: Sized {
    fn SetLocalOscilatorFrequencyLowBand();
    fn LocalOscilatorFrequencyLowBand();
    fn SetLocalOscilatorFrequencyHighBand();
    fn LocalOscilatorFrequencyHighBand();
    fn SetHighLowSwitchFrequency();
    fn HighLowSwitchFrequency();
}
impl ::windows::core::RuntimeName for IBDA_LNBInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_LNBInfo";
}
impl IBDA_LNBInfoVtbl {
    pub const fn new<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_LNBInfoVtbl {
        unsafe extern "system" fn SetLocalOscilatorFrequencyLowBand<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulloflow: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalOscilatorFrequencyLowBand(ulloflow) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalOscilatorFrequencyLowBand<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulloflow: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalOscilatorFrequencyLowBand(pulloflow) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalOscilatorFrequencyHighBand<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullofhigh: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalOscilatorFrequencyHighBand(ullofhigh) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalOscilatorFrequencyHighBand<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pullofhigh: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalOscilatorFrequencyHighBand(pullofhigh) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHighLowSwitchFrequency<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulswitchfrequency: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHighLowSwitchFrequency(ulswitchfrequency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HighLowSwitchFrequency<Impl: IBDA_LNBInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulswitchfrequency: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HighLowSwitchFrequency(pulswitchfrequency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_LNBInfo>, base.5, SetLocalOscilatorFrequencyLowBand::<Impl, OFFSET>, LocalOscilatorFrequencyLowBand::<Impl, OFFSET>, SetLocalOscilatorFrequencyHighBand::<Impl, OFFSET>, LocalOscilatorFrequencyHighBand::<Impl, OFFSET>, SetHighLowSwitchFrequency::<Impl, OFFSET>, HighLowSwitchFrequency::<Impl, OFFSET>)
    }
}
pub trait IBDA_MUXImpl: Sized {
    fn SetPidList();
    fn GetPidList();
}
impl ::windows::core::RuntimeName for IBDA_MUX {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_MUX";
}
impl IBDA_MUXVtbl {
    pub const fn new<Impl: IBDA_MUXImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_MUXVtbl {
        unsafe extern "system" fn SetPidList<Impl: IBDA_MUXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpidlistcount: u32, pbpidlistbuffer: *const BDA_MUX_PIDLISTITEM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPidList(ulpidlistcount, &*(&pbpidlistbuffer as *const <BDA_MUX_PIDLISTITEM as ::windows::core::Abi>::Abi as *const <BDA_MUX_PIDLISTITEM as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPidList<Impl: IBDA_MUXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPidList(pulpidlistcount, &*(&pbpidlistbuffer as *const <BDA_MUX_PIDLISTITEM as ::windows::core::Abi>::Abi as *const <BDA_MUX_PIDLISTITEM as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_MUX>, base.5, SetPidList::<Impl, OFFSET>, GetPidList::<Impl, OFFSET>)
    }
}
pub trait IBDA_NameValueServiceImpl: Sized {
    fn GetValueNameByIndex();
    fn GetValue();
    fn SetValue();
}
impl ::windows::core::RuntimeName for IBDA_NameValueService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_NameValueService";
}
impl IBDA_NameValueServiceVtbl {
    pub const fn new<Impl: IBDA_NameValueServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_NameValueServiceVtbl {
        unsafe extern "system" fn GetValueNameByIndex<Impl: IBDA_NameValueServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulindex: u32, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValueNameByIndex(ulindex, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IBDA_NameValueServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrvalue: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValue(&*(&bstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbstrvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IBDA_NameValueServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrvalue: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ulreserved: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetValue(
                uldialogrequest,
                &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&bstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&bstrvalue as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                ulreserved,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_NameValueService>, base.5, GetValueNameByIndex::<Impl, OFFSET>, GetValue::<Impl, OFFSET>, SetValue::<Impl, OFFSET>)
    }
}
pub trait IBDA_NetworkProviderImpl: Sized {
    fn PutSignalSource();
    fn GetSignalSource();
    fn GetNetworkType();
    fn PutTuningSpace();
    fn GetTuningSpace();
    fn RegisterDeviceFilter();
    fn UnRegisterDeviceFilter();
}
impl ::windows::core::RuntimeName for IBDA_NetworkProvider {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_NetworkProvider";
}
impl IBDA_NetworkProviderVtbl {
    pub const fn new<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_NetworkProviderVtbl {
        unsafe extern "system" fn PutSignalSource<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulsignalsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutSignalSource(ulsignalsource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSignalSource<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulsignalsource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSignalSource(pulsignalsource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkType<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkType(&*(&pguidnetworktype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutTuningSpace<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutTuningSpace(&*(&guidtuningspace as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTuningSpace<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTuningSpace(&*(&pguidtuingspace as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterDeviceFilter<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkfiltercontrol: *mut ::core::ffi::c_void, ppvregisitrationcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterDeviceFilter(&*(&punkfiltercontrol as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), ppvregisitrationcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnRegisterDeviceFilter<Impl: IBDA_NetworkProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnRegisterDeviceFilter(pvregistrationcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_NetworkProvider>, base.5, PutSignalSource::<Impl, OFFSET>, GetSignalSource::<Impl, OFFSET>, GetNetworkType::<Impl, OFFSET>, PutTuningSpace::<Impl, OFFSET>, GetTuningSpace::<Impl, OFFSET>, RegisterDeviceFilter::<Impl, OFFSET>, UnRegisterDeviceFilter::<Impl, OFFSET>)
    }
}
pub trait IBDA_NullTransformImpl: Sized {
    fn Start();
    fn Stop();
}
impl ::windows::core::RuntimeName for IBDA_NullTransform {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_NullTransform";
}
impl IBDA_NullTransformVtbl {
    pub const fn new<Impl: IBDA_NullTransformImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_NullTransformVtbl {
        unsafe extern "system" fn Start<Impl: IBDA_NullTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IBDA_NullTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_NullTransform>, base.5, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>)
    }
}
pub trait IBDA_PinControlImpl: Sized {
    fn GetPinID();
    fn GetPinType();
    fn RegistrationContext();
}
impl ::windows::core::RuntimeName for IBDA_PinControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_PinControl";
}
impl IBDA_PinControlVtbl {
    pub const fn new<Impl: IBDA_PinControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_PinControlVtbl {
        unsafe extern "system" fn GetPinID<Impl: IBDA_PinControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPinID(pulpinid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPinType<Impl: IBDA_PinControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulpintype: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPinType(pulpintype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegistrationContext<Impl: IBDA_PinControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulregistrationctx: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegistrationContext(pulregistrationctx) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_PinControl>, base.5, GetPinID::<Impl, OFFSET>, GetPinType::<Impl, OFFSET>, RegistrationContext::<Impl, OFFSET>)
    }
}
pub trait IBDA_SignalPropertiesImpl: Sized {
    fn PutNetworkType();
    fn GetNetworkType();
    fn PutSignalSource();
    fn GetSignalSource();
    fn PutTuningSpace();
    fn GetTuningSpace();
}
impl ::windows::core::RuntimeName for IBDA_SignalProperties {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_SignalProperties";
}
impl IBDA_SignalPropertiesVtbl {
    pub const fn new<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_SignalPropertiesVtbl {
        unsafe extern "system" fn PutNetworkType<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidnetworktype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutNetworkType(&*(&guidnetworktype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkType<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkType(&*(&pguidnetworktype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutSignalSource<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulsignalsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutSignalSource(ulsignalsource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSignalSource<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulsignalsource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSignalSource(pulsignalsource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PutTuningSpace<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PutTuningSpace(&*(&guidtuningspace as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTuningSpace<Impl: IBDA_SignalPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTuningSpace(&*(&pguidtuingspace as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_SignalProperties>, base.5, PutNetworkType::<Impl, OFFSET>, GetNetworkType::<Impl, OFFSET>, PutSignalSource::<Impl, OFFSET>, GetSignalSource::<Impl, OFFSET>, PutTuningSpace::<Impl, OFFSET>, GetTuningSpace::<Impl, OFFSET>)
    }
}
pub trait IBDA_SignalStatisticsImpl: Sized {
    fn SetSignalStrength();
    fn SignalStrength();
    fn SetSignalQuality();
    fn SignalQuality();
    fn SetSignalPresent();
    fn SignalPresent();
    fn SetSignalLocked();
    fn SignalLocked();
    fn SetSampleTime();
    fn SampleTime();
}
impl ::windows::core::RuntimeName for IBDA_SignalStatistics {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_SignalStatistics";
}
impl IBDA_SignalStatisticsVtbl {
    pub const fn new<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_SignalStatisticsVtbl {
        unsafe extern "system" fn SetSignalStrength<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ldbstrength: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalStrength(ldbstrength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalStrength<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pldbstrength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalStrength(pldbstrength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalQuality<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpercentquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalQuality(lpercentquality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalQuality<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plpercentquality: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalQuality(plpercentquality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalPresent<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fpresent: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalPresent(&*(&fpresent as *const <super::super::Foundation::BOOLEAN as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOLEAN as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalPresent<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfpresent: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalPresent(pfpresent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalLocked<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flocked: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalLocked(&*(&flocked as *const <super::super::Foundation::BOOLEAN as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOLEAN as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalLocked<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflocked: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalLocked(pflocked) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleTime<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lmssampletime: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleTime(lmssampletime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SampleTime<Impl: IBDA_SignalStatisticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plmssampletime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SampleTime(plmssampletime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_SignalStatistics>, base.5, SetSignalStrength::<Impl, OFFSET>, SignalStrength::<Impl, OFFSET>, SetSignalQuality::<Impl, OFFSET>, SignalQuality::<Impl, OFFSET>, SetSignalPresent::<Impl, OFFSET>, SignalPresent::<Impl, OFFSET>, SetSignalLocked::<Impl, OFFSET>, SignalLocked::<Impl, OFFSET>, SetSampleTime::<Impl, OFFSET>, SampleTime::<Impl, OFFSET>)
    }
}
pub trait IBDA_TIF_REGISTRATIONImpl: Sized {
    fn RegisterTIFEx();
    fn UnregisterTIF();
}
impl ::windows::core::RuntimeName for IBDA_TIF_REGISTRATION {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_TIF_REGISTRATION";
}
impl IBDA_TIF_REGISTRATIONVtbl {
    pub const fn new<Impl: IBDA_TIF_REGISTRATIONImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_TIF_REGISTRATIONVtbl {
        unsafe extern "system" fn RegisterTIFEx<Impl: IBDA_TIF_REGISTRATIONImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptifinputpin: ::windows::core::RawPtr, ppvregistrationcontext: *mut u32, ppmpeg2datacontrol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterTIFEx(&*(&ptifinputpin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), ppvregistrationcontext, &*(&ppmpeg2datacontrol as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterTIF<Impl: IBDA_TIF_REGISTRATIONImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterTIF(pvregistrationcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_TIF_REGISTRATION>, base.5, RegisterTIFEx::<Impl, OFFSET>, UnregisterTIF::<Impl, OFFSET>)
    }
}
pub trait IBDA_TopologyImpl: Sized {
    fn GetNodeTypes();
    fn GetNodeDescriptors();
    fn GetNodeInterfaces();
    fn GetPinTypes();
    fn GetTemplateConnections();
    fn CreatePin();
    fn DeletePin();
    fn SetMediaType();
    fn SetMedium();
    fn CreateTopology();
    fn GetControlNode();
}
impl ::windows::core::RuntimeName for IBDA_Topology {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_Topology";
}
impl IBDA_TopologyVtbl {
    pub const fn new<Impl: IBDA_TopologyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_TopologyVtbl {
        unsafe extern "system" fn GetNodeTypes<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcnodetypes: *mut u32, ulcnodetypesmax: u32, rgulnodetypes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeTypes(pulcnodetypes, ulcnodetypesmax, rgulnodetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeDescriptors<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcnodedescriptors: *mut u32, ulcnodedescriptorsmax: u32, rgnodedescriptors: *mut BDANODE_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeDescriptors(ulcnodedescriptors, ulcnodedescriptorsmax, &*(&rgnodedescriptors as *const <BDANODE_DESCRIPTOR as ::windows::core::Abi>::Abi as *const <BDANODE_DESCRIPTOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeInterfaces<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulnodetype: u32, pulcinterfaces: *mut u32, ulcinterfacesmax: u32, rgguidinterfaces: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeInterfaces(ulnodetype, pulcinterfaces, ulcinterfacesmax, &*(&rgguidinterfaces as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPinTypes<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcpintypes: *mut u32, ulcpintypesmax: u32, rgulpintypes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPinTypes(pulcpintypes, ulcpintypesmax, rgulpintypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTemplateConnections<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcconnections: *mut u32, ulcconnectionsmax: u32, rgconnections: *mut BDA_TEMPLATE_CONNECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTemplateConnections(pulcconnections, ulcconnectionsmax, &*(&rgconnections as *const <BDA_TEMPLATE_CONNECTION as ::windows::core::Abi>::Abi as *const <BDA_TEMPLATE_CONNECTION as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreatePin<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpintype: u32, pulpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreatePin(ulpintype, pulpinid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeletePin<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeletePin(ulpinid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpinid: u32, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(ulpinid, &*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMedium<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMedium(ulpinid, &*(&pmedium as *const <REGPINMEDIUM as ::windows::core::Abi>::Abi as *const <REGPINMEDIUM as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTopology<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTopology(ulinputpinid, uloutputpinid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetControlNode<Impl: IBDA_TopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetControlNode(ulinputpinid, uloutputpinid, ulnodetype, &*(&ppcontrolnode as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_Topology>, base.5, GetNodeTypes::<Impl, OFFSET>, GetNodeDescriptors::<Impl, OFFSET>, GetNodeInterfaces::<Impl, OFFSET>, GetPinTypes::<Impl, OFFSET>, GetTemplateConnections::<Impl, OFFSET>, CreatePin::<Impl, OFFSET>, DeletePin::<Impl, OFFSET>, SetMediaType::<Impl, OFFSET>, SetMedium::<Impl, OFFSET>, CreateTopology::<Impl, OFFSET>, GetControlNode::<Impl, OFFSET>)
    }
}
pub trait IBDA_TransportStreamInfoImpl: Sized {
    fn PatTableTickCount();
}
impl ::windows::core::RuntimeName for IBDA_TransportStreamInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_TransportStreamInfo";
}
impl IBDA_TransportStreamInfoVtbl {
    pub const fn new<Impl: IBDA_TransportStreamInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_TransportStreamInfoVtbl {
        unsafe extern "system" fn PatTableTickCount<Impl: IBDA_TransportStreamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattickcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PatTableTickCount(::core::mem::transmute_copy(&ppattickcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_TransportStreamInfo>, base.5, PatTableTickCount::<Impl, OFFSET>)
    }
}
pub trait IBDA_TransportStreamSelectorImpl: Sized {
    fn SetTSID();
    fn GetTSInformation();
}
impl ::windows::core::RuntimeName for IBDA_TransportStreamSelector {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_TransportStreamSelector";
}
impl IBDA_TransportStreamSelectorVtbl {
    pub const fn new<Impl: IBDA_TransportStreamSelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_TransportStreamSelectorVtbl {
        unsafe extern "system" fn SetTSID<Impl: IBDA_TransportStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ustsid: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTSID(ustsid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSInformation<Impl: IBDA_TransportStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTSInformation(pultsinformationbufferlen, ::core::mem::transmute_copy(&pbtsinformationbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_TransportStreamSelector>, base.5, SetTSID::<Impl, OFFSET>, GetTSInformation::<Impl, OFFSET>)
    }
}
pub trait IBDA_UserActivityServiceImpl: Sized {
    fn SetCurrentTunerUseReason();
    fn GetUserActivityInterval();
    fn UserActivityDetected();
}
impl ::windows::core::RuntimeName for IBDA_UserActivityService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_UserActivityService";
}
impl IBDA_UserActivityServiceVtbl {
    pub const fn new<Impl: IBDA_UserActivityServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_UserActivityServiceVtbl {
        unsafe extern "system" fn SetCurrentTunerUseReason<Impl: IBDA_UserActivityServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwusereason: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentTunerUseReason(dwusereason) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUserActivityInterval<Impl: IBDA_UserActivityServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwactivityinterval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUserActivityInterval(::core::mem::transmute_copy(&pdwactivityinterval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UserActivityDetected<Impl: IBDA_UserActivityServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UserActivityDetected() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_UserActivityService>, base.5, SetCurrentTunerUseReason::<Impl, OFFSET>, GetUserActivityInterval::<Impl, OFFSET>, UserActivityDetected::<Impl, OFFSET>)
    }
}
pub trait IBDA_VoidTransformImpl: Sized {
    fn Start();
    fn Stop();
}
impl ::windows::core::RuntimeName for IBDA_VoidTransform {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_VoidTransform";
}
impl IBDA_VoidTransformVtbl {
    pub const fn new<Impl: IBDA_VoidTransformImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_VoidTransformVtbl {
        unsafe extern "system" fn Start<Impl: IBDA_VoidTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IBDA_VoidTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_VoidTransform>, base.5, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>)
    }
}
pub trait IBDA_WMDRMSessionImpl: Sized {
    fn GetStatus();
    fn SetRevInfo();
    fn SetCrl();
    fn TransactMessage();
    fn GetLicense();
    fn ReissueLicense();
    fn RenewLicense();
    fn GetKeyInfo();
}
impl ::windows::core::RuntimeName for IBDA_WMDRMSession {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_WMDRMSession";
}
impl IBDA_WMDRMSessionVtbl {
    pub const fn new<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_WMDRMSessionVtbl {
        unsafe extern "system" fn GetStatus<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&maxcapturetoken), ::core::mem::transmute_copy(&maxstreamingpid), ::core::mem::transmute_copy(&maxlicense), ::core::mem::transmute_copy(&minsecuritylevel), ::core::mem::transmute_copy(&revinfosequencenumber), ::core::mem::transmute_copy(&revinfoissuedtime), ::core::mem::transmute_copy(&revinfottl), ::core::mem::transmute_copy(&revlistversion), ::core::mem::transmute_copy(&ulstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRevInfo<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulrevinfolen: u32, pbrevinfo: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRevInfo(ulrevinfolen, pbrevinfo) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCrl<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcrllen: u32, pbcrllen: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCrl(ulcrllen, pbcrllen) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TransactMessage<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcbrequest: u32, pbrequest: *const u8, pulcbresponse: *mut u32, pbresponse: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransactMessage(ulcbrequest, pbrequest, pulcbresponse, pbresponse) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLicense<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uuidkey: *const ::windows::core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLicense(&*(&uuidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pulpackagelen, pbpackage) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReissueLicense<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uuidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReissueLicense(&*(&uuidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenewLicense<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulinxmrlicenselen: u32, pbinxmrlicense: *const u8, ulentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenewLicense(ulinxmrlicenselen, pbinxmrlicense, ulentitlementtokenlen, pbentitlementtoken, ::core::mem::transmute_copy(&puldescramblestatus), puloutxmrlicenselen, pboutxmrlicense) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeyInfo<Impl: IBDA_WMDRMSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetKeyInfo(pulkeyinfolen, pbkeyinfo) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_WMDRMSession>, base.5, GetStatus::<Impl, OFFSET>, SetRevInfo::<Impl, OFFSET>, SetCrl::<Impl, OFFSET>, TransactMessage::<Impl, OFFSET>, GetLicense::<Impl, OFFSET>, ReissueLicense::<Impl, OFFSET>, RenewLicense::<Impl, OFFSET>, GetKeyInfo::<Impl, OFFSET>)
    }
}
pub trait IBDA_WMDRMTunerImpl: Sized {
    fn PurchaseEntitlement();
    fn CancelCaptureToken();
    fn SetPidProtection();
    fn GetPidProtection();
    fn SetSyncValue();
    fn GetStartCodeProfile();
}
impl ::windows::core::RuntimeName for IBDA_WMDRMTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBDA_WMDRMTuner";
}
impl IBDA_WMDRMTunerVtbl {
    pub const fn new<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBDA_WMDRMTunerVtbl {
        unsafe extern "system" fn PurchaseEntitlement<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ulpurchasetokenlen: u32, pbpurchasetoken: *const u8, puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PurchaseEntitlement(uldialogrequest, &*(&bstrlanguage as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ulpurchasetokenlen, pbpurchasetoken, ::core::mem::transmute_copy(&puldescramblestatus), pulcapturetokenlen, pbcapturetoken) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelCaptureToken<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelCaptureToken(ulcapturetokenlen, pbcapturetoken) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPidProtection<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpid: u32, uuidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPidProtection(ulpid, &*(&uuidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPidProtection<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulpid: u32, uuidkey: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPidProtection(pulpid, ::core::mem::transmute_copy(&uuidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncValue<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulsyncvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncValue(ulsyncvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartCodeProfile<Impl: IBDA_WMDRMTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartCodeProfile(pulstartcodeprofilelen, pbstartcodeprofile) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBDA_WMDRMTuner>, base.5, PurchaseEntitlement::<Impl, OFFSET>, CancelCaptureToken::<Impl, OFFSET>, SetPidProtection::<Impl, OFFSET>, GetPidProtection::<Impl, OFFSET>, SetSyncValue::<Impl, OFFSET>, GetStartCodeProfile::<Impl, OFFSET>)
    }
}
pub trait IBPCSatelliteTunerImpl: Sized + IAMTunerImpl {
    fn DefaultSubChannelTypes();
    fn SetDefaultSubChannelTypes();
    fn IsTapingPermitted();
}
impl ::windows::core::RuntimeName for IBPCSatelliteTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBPCSatelliteTuner";
}
impl IBPCSatelliteTunerVtbl {
    pub const fn new<Impl: IBPCSatelliteTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBPCSatelliteTunerVtbl {
        unsafe extern "system" fn DefaultSubChannelTypes<Impl: IBPCSatelliteTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSubChannelTypes(::core::mem::transmute_copy(&pldefaultvideotype), ::core::mem::transmute_copy(&pldefaultaudiotype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSubChannelTypes<Impl: IBPCSatelliteTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultSubChannelTypes(ldefaultvideotype, ldefaultaudiotype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTapingPermitted<Impl: IBPCSatelliteTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTapingPermitted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBPCSatelliteTuner>, base.5, DefaultSubChannelTypes::<Impl, OFFSET>, SetDefaultSubChannelTypes::<Impl, OFFSET>, IsTapingPermitted::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBaseFilterImpl: Sized + IMediaFilterImpl + IPersistImpl {
    fn EnumPins();
    fn FindPin();
    fn QueryFilterInfo();
    fn JoinFilterGraph();
    fn QueryVendorInfo();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IBaseFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBaseFilter";
}
#[cfg(feature = "Win32_System_Com")]
impl IBaseFilterVtbl {
    pub const fn new<Impl: IBaseFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBaseFilterVtbl {
        unsafe extern "system" fn EnumPins<Impl: IBaseFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumPins(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindPin<Impl: IBaseFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: super::super::Foundation::PWSTR, pppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindPin(&*(&id as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryFilterInfo<Impl: IBaseFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinfo: *mut FILTER_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryFilterInfo(::core::mem::transmute_copy(&pinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn JoinFilterGraph<Impl: IBaseFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr, pname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).JoinFilterGraph(&*(&pgraph as *const <IFilterGraph as ::windows::core::Abi>::Abi as *const <IFilterGraph as ::windows::core::DefaultType>::DefaultType), &*(&pname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryVendorInfo<Impl: IBaseFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvendorinfo: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryVendorInfo(::core::mem::transmute_copy(&pvendorinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBaseFilter>, base.5, EnumPins::<Impl, OFFSET>, FindPin::<Impl, OFFSET>, QueryFilterInfo::<Impl, OFFSET>, JoinFilterGraph::<Impl, OFFSET>, QueryVendorInfo::<Impl, OFFSET>)
    }
}
pub trait IBaseVideoMixerImpl: Sized {
    fn SetLeadPin();
    fn GetLeadPin();
    fn GetInputPinCount();
    fn IsUsingClock();
    fn SetUsingClock();
    fn GetClockPeriod();
    fn SetClockPeriod();
}
impl ::windows::core::RuntimeName for IBaseVideoMixer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBaseVideoMixer";
}
impl IBaseVideoMixerVtbl {
    pub const fn new<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBaseVideoMixerVtbl {
        unsafe extern "system" fn SetLeadPin<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ipin: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLeadPin(ipin) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeadPin<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pipin: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLeadPin(::core::mem::transmute_copy(&pipin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputPinCount<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pipincount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputPinCount(::core::mem::transmute_copy(&pipincount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingClock<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsUsingClock(::core::mem::transmute_copy(&pbvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUsingClock<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bvalue: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUsingClock(bvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClockPeriod<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClockPeriod(::core::mem::transmute_copy(&pbvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockPeriod<Impl: IBaseVideoMixerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bvalue: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetClockPeriod(bvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBaseVideoMixer>, base.5, SetLeadPin::<Impl, OFFSET>, GetLeadPin::<Impl, OFFSET>, GetInputPinCount::<Impl, OFFSET>, IsUsingClock::<Impl, OFFSET>, SetUsingClock::<Impl, OFFSET>, GetClockPeriod::<Impl, OFFSET>, SetClockPeriod::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBasicAudioImpl: Sized + IDispatchImpl {
    fn SetVolume();
    fn Volume();
    fn SetBalance();
    fn Balance();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IBasicAudio {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBasicAudio";
}
#[cfg(feature = "Win32_System_Com")]
impl IBasicAudioVtbl {
    pub const fn new<Impl: IBasicAudioImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBasicAudioVtbl {
        unsafe extern "system" fn SetVolume<Impl: IBasicAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvolume: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVolume(lvolume) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Volume<Impl: IBasicAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plvolume: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Volume(::core::mem::transmute_copy(&plvolume)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IBasicAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lbalance: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBalance(lbalance) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Balance<Impl: IBasicAudioImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plbalance: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Balance(::core::mem::transmute_copy(&plbalance)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBasicAudio>, base.5, SetVolume::<Impl, OFFSET>, Volume::<Impl, OFFSET>, SetBalance::<Impl, OFFSET>, Balance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBasicVideoImpl: Sized + IDispatchImpl {
    fn AvgTimePerFrame();
    fn BitRate();
    fn BitErrorRate();
    fn VideoWidth();
    fn VideoHeight();
    fn SetSourceLeft();
    fn SourceLeft();
    fn SetSourceWidth();
    fn SourceWidth();
    fn SetSourceTop();
    fn SourceTop();
    fn SetSourceHeight();
    fn SourceHeight();
    fn SetDestinationLeft();
    fn DestinationLeft();
    fn SetDestinationWidth();
    fn DestinationWidth();
    fn SetDestinationTop();
    fn DestinationTop();
    fn SetDestinationHeight();
    fn DestinationHeight();
    fn SetSourcePosition();
    fn GetSourcePosition();
    fn SetDefaultSourcePosition();
    fn SetDestinationPosition();
    fn GetDestinationPosition();
    fn SetDefaultDestinationPosition();
    fn GetVideoSize();
    fn GetVideoPaletteEntries();
    fn GetCurrentImage();
    fn IsUsingDefaultSource();
    fn IsUsingDefaultDestination();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IBasicVideo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBasicVideo";
}
#[cfg(feature = "Win32_System_Com")]
impl IBasicVideoVtbl {
    pub const fn new<Impl: IBasicVideoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBasicVideoVtbl {
        unsafe extern "system" fn AvgTimePerFrame<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pavgtimeperframe: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvgTimePerFrame(::core::mem::transmute_copy(&pavgtimeperframe)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BitRate<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbitrate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BitRate(::core::mem::transmute_copy(&pbitrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BitErrorRate<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbiterrorrate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BitErrorRate(::core::mem::transmute_copy(&pbiterrorrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoWidth<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideowidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoWidth(::core::mem::transmute_copy(&pvideowidth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoHeight<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideoheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoHeight(::core::mem::transmute_copy(&pvideoheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceLeft<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourceleft: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceLeft(sourceleft) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceLeft<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourceleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceLeft(::core::mem::transmute_copy(&psourceleft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceWidth<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcewidth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceWidth(sourcewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceWidth<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcewidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceWidth(::core::mem::transmute_copy(&psourcewidth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceTop<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcetop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceTop(sourcetop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceTop<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcetop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceTop(::core::mem::transmute_copy(&psourcetop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceHeight<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourceheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceHeight(sourceheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceHeight<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourceheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceHeight(::core::mem::transmute_copy(&psourceheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationLeft<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destinationleft: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationLeft(destinationleft) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DestinationLeft<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdestinationleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DestinationLeft(::core::mem::transmute_copy(&pdestinationleft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationWidth<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destinationwidth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationWidth(destinationwidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DestinationWidth<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdestinationwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DestinationWidth(::core::mem::transmute_copy(&pdestinationwidth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationTop<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destinationtop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationTop(destinationtop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DestinationTop<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdestinationtop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DestinationTop(::core::mem::transmute_copy(&pdestinationtop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationHeight<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destinationheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationHeight(destinationheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DestinationHeight<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdestinationheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DestinationHeight(::core::mem::transmute_copy(&pdestinationheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourcePosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourcePosition(left, top, width, height) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourcePosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourcePosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSourcePosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultSourcePosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationPosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationPosition(left, top, width, height) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDestinationPosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDestinationPosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultDestinationPosition<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultDestinationPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoSize<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPaletteEntries<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPaletteEntries(startindex, entries, ::core::mem::transmute_copy(&pretrieved), ::core::mem::transmute_copy(&ppalette)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffersize: *mut i32, pdibimage: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentImage(pbuffersize, ::core::mem::transmute_copy(&pdibimage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingDefaultSource<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsUsingDefaultSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingDefaultDestination<Impl: IBasicVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsUsingDefaultDestination() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IBasicVideo>,
            base.5,
            AvgTimePerFrame::<Impl, OFFSET>,
            BitRate::<Impl, OFFSET>,
            BitErrorRate::<Impl, OFFSET>,
            VideoWidth::<Impl, OFFSET>,
            VideoHeight::<Impl, OFFSET>,
            SetSourceLeft::<Impl, OFFSET>,
            SourceLeft::<Impl, OFFSET>,
            SetSourceWidth::<Impl, OFFSET>,
            SourceWidth::<Impl, OFFSET>,
            SetSourceTop::<Impl, OFFSET>,
            SourceTop::<Impl, OFFSET>,
            SetSourceHeight::<Impl, OFFSET>,
            SourceHeight::<Impl, OFFSET>,
            SetDestinationLeft::<Impl, OFFSET>,
            DestinationLeft::<Impl, OFFSET>,
            SetDestinationWidth::<Impl, OFFSET>,
            DestinationWidth::<Impl, OFFSET>,
            SetDestinationTop::<Impl, OFFSET>,
            DestinationTop::<Impl, OFFSET>,
            SetDestinationHeight::<Impl, OFFSET>,
            DestinationHeight::<Impl, OFFSET>,
            SetSourcePosition::<Impl, OFFSET>,
            GetSourcePosition::<Impl, OFFSET>,
            SetDefaultSourcePosition::<Impl, OFFSET>,
            SetDestinationPosition::<Impl, OFFSET>,
            GetDestinationPosition::<Impl, OFFSET>,
            SetDefaultDestinationPosition::<Impl, OFFSET>,
            GetVideoSize::<Impl, OFFSET>,
            GetVideoPaletteEntries::<Impl, OFFSET>,
            GetCurrentImage::<Impl, OFFSET>,
            IsUsingDefaultSource::<Impl, OFFSET>,
            IsUsingDefaultDestination::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBasicVideo2Impl: Sized + IBasicVideoImpl + IDispatchImpl {
    fn GetPreferredAspectRatio();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IBasicVideo2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBasicVideo2";
}
#[cfg(feature = "Win32_System_Com")]
impl IBasicVideo2Vtbl {
    pub const fn new<Impl: IBasicVideo2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBasicVideo2Vtbl {
        unsafe extern "system" fn GetPreferredAspectRatio<Impl: IBasicVideo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plaspectx: *mut i32, plaspecty: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreferredAspectRatio(::core::mem::transmute_copy(&plaspectx), ::core::mem::transmute_copy(&plaspecty)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBasicVideo2>, base.5, GetPreferredAspectRatio::<Impl, OFFSET>)
    }
}
pub trait IBroadcastEventImpl: Sized {
    fn Fire();
}
impl ::windows::core::RuntimeName for IBroadcastEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBroadcastEvent";
}
impl IBroadcastEventVtbl {
    pub const fn new<Impl: IBroadcastEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBroadcastEventVtbl {
        unsafe extern "system" fn Fire<Impl: IBroadcastEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eventid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Fire(&*(&eventid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBroadcastEvent>, base.5, Fire::<Impl, OFFSET>)
    }
}
pub trait IBroadcastEventExImpl: Sized + IBroadcastEventImpl {
    fn FireEx();
}
impl ::windows::core::RuntimeName for IBroadcastEventEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBroadcastEventEx";
}
impl IBroadcastEventExVtbl {
    pub const fn new<Impl: IBroadcastEventExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBroadcastEventExVtbl {
        unsafe extern "system" fn FireEx<Impl: IBroadcastEventExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eventid: ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FireEx(&*(&eventid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), param1, param2, param3, param4) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBroadcastEventEx>, base.5, FireEx::<Impl, OFFSET>)
    }
}
pub trait IBufferingTimeImpl: Sized {
    fn GetBufferingTime();
    fn SetBufferingTime();
}
impl ::windows::core::RuntimeName for IBufferingTime {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IBufferingTime";
}
impl IBufferingTimeVtbl {
    pub const fn new<Impl: IBufferingTimeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBufferingTimeVtbl {
        unsafe extern "system" fn GetBufferingTime<Impl: IBufferingTimeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmilliseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferingTime(pdwmilliseconds) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBufferingTime<Impl: IBufferingTimeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmilliseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBufferingTime(dwmilliseconds) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBufferingTime>, base.5, GetBufferingTime::<Impl, OFFSET>, SetBufferingTime::<Impl, OFFSET>)
    }
}
pub trait ICATImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for ICAT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICAT";
}
impl ICATVtbl {
    pub const fn new<Impl: ICATImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICATVtbl {
        unsafe extern "system" fn Initialize<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(dwtimeout, ::core::mem::transmute_copy(&ppcat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: ICATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICAT>, base.5, Initialize::<Impl, OFFSET>, GetVersionNumber::<Impl, OFFSET>, GetCountOfTableDescriptors::<Impl, OFFSET>, GetTableDescriptorByIndex::<Impl, OFFSET>, GetTableDescriptorByTag::<Impl, OFFSET>, RegisterForNextTable::<Impl, OFFSET>, GetNextTable::<Impl, OFFSET>, RegisterForWhenCurrent::<Impl, OFFSET>, ConvertNextToCurrent::<Impl, OFFSET>)
    }
}
pub trait ICCSubStreamFilteringImpl: Sized {
    fn SubstreamTypes();
    fn SetSubstreamTypes();
}
impl ::windows::core::RuntimeName for ICCSubStreamFiltering {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICCSubStreamFiltering";
}
impl ICCSubStreamFilteringVtbl {
    pub const fn new<Impl: ICCSubStreamFilteringImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICCSubStreamFilteringVtbl {
        unsafe extern "system" fn SubstreamTypes<Impl: ICCSubStreamFilteringImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptypes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SubstreamTypes(::core::mem::transmute_copy(&ptypes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubstreamTypes<Impl: ICCSubStreamFilteringImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, types: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSubstreamTypes(types) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICCSubStreamFiltering>, base.5, SubstreamTypes::<Impl, OFFSET>, SetSubstreamTypes::<Impl, OFFSET>)
    }
}
pub trait ICameraControlImpl: Sized {
    fn Exposure();
    fn SetExposure();
    fn getRange_Exposure();
    fn Focus();
    fn SetFocus();
    fn getRange_Focus();
    fn Iris();
    fn SetIris();
    fn getRange_Iris();
    fn Zoom();
    fn SetZoom();
    fn getRange_Zoom();
    fn FocalLengths();
    fn Pan();
    fn SetPan();
    fn getRange_Pan();
    fn Tilt();
    fn SetTilt();
    fn getRange_Tilt();
    fn PanTilt();
    fn SetPanTilt();
    fn Roll();
    fn SetRoll();
    fn getRange_Roll();
    fn ExposureRelative();
    fn SetExposureRelative();
    fn getRange_ExposureRelative();
    fn FocusRelative();
    fn SetFocusRelative();
    fn getRange_FocusRelative();
    fn IrisRelative();
    fn SetIrisRelative();
    fn getRange_IrisRelative();
    fn ZoomRelative();
    fn SetZoomRelative();
    fn getRange_ZoomRelative();
    fn PanRelative();
    fn SetPanRelative();
    fn TiltRelative();
    fn SetTiltRelative();
    fn getRange_TiltRelative();
    fn PanTiltRelative();
    fn SetPanTiltRelative();
    fn getRange_PanRelative();
    fn RollRelative();
    fn SetRollRelative();
    fn getRange_RollRelative();
    fn ScanMode();
    fn SetScanMode();
    fn PrivacyMode();
    fn SetPrivacyMode();
}
impl ::windows::core::RuntimeName for ICameraControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICameraControl";
}
impl ICameraControlVtbl {
    pub const fn new<Impl: ICameraControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICameraControlVtbl {
        unsafe extern "system" fn Exposure<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Exposure(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExposure<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetExposure(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Exposure<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Exposure(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocus<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFocus(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Focus<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Focus(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Iris<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Iris(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIris<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIris(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Iris<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Iris(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Zoom<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Zoom(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoom<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetZoom(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Zoom<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Zoom(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocalLengths<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocalLengths(::core::mem::transmute_copy(&plocularfocallength), ::core::mem::transmute_copy(&plobjectivefocallengthmin), ::core::mem::transmute_copy(&plobjectivefocallengthmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pan<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pan(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPan<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPan(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Pan<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Pan(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Tilt<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Tilt(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTilt<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTilt(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Tilt<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Tilt(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanTilt<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanTilt(::core::mem::transmute_copy(&ppanvalue), ::core::mem::transmute_copy(&ptiltvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanTilt<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPanTilt(panvalue, tiltvalue, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Roll<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Roll(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRoll<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRoll(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Roll<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Roll(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExposureRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExposureRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExposureRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetExposureRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_ExposureRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_ExposureRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFocusRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_FocusRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_FocusRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IrisRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IrisRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIrisRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIrisRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_IrisRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_IrisRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetZoomRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_ZoomRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_ZoomRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPanRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TiltRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TiltRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTiltRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTiltRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_TiltRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_TiltRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanTiltRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanTiltRelative(::core::mem::transmute_copy(&ppanvalue), ::core::mem::transmute_copy(&ptiltvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanTiltRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPanTiltRelative(panvalue, tiltvalue, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_PanRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_PanRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RollRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RollRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRollRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRollRelative(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_RollRelative<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_RollRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScanMode<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScanMode(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScanMode<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetScanMode(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrivacyMode<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrivacyMode(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrivacyMode<Impl: ICameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPrivacyMode(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICameraControl>,
            base.5,
            Exposure::<Impl, OFFSET>,
            SetExposure::<Impl, OFFSET>,
            getRange_Exposure::<Impl, OFFSET>,
            Focus::<Impl, OFFSET>,
            SetFocus::<Impl, OFFSET>,
            getRange_Focus::<Impl, OFFSET>,
            Iris::<Impl, OFFSET>,
            SetIris::<Impl, OFFSET>,
            getRange_Iris::<Impl, OFFSET>,
            Zoom::<Impl, OFFSET>,
            SetZoom::<Impl, OFFSET>,
            getRange_Zoom::<Impl, OFFSET>,
            FocalLengths::<Impl, OFFSET>,
            Pan::<Impl, OFFSET>,
            SetPan::<Impl, OFFSET>,
            getRange_Pan::<Impl, OFFSET>,
            Tilt::<Impl, OFFSET>,
            SetTilt::<Impl, OFFSET>,
            getRange_Tilt::<Impl, OFFSET>,
            PanTilt::<Impl, OFFSET>,
            SetPanTilt::<Impl, OFFSET>,
            Roll::<Impl, OFFSET>,
            SetRoll::<Impl, OFFSET>,
            getRange_Roll::<Impl, OFFSET>,
            ExposureRelative::<Impl, OFFSET>,
            SetExposureRelative::<Impl, OFFSET>,
            getRange_ExposureRelative::<Impl, OFFSET>,
            FocusRelative::<Impl, OFFSET>,
            SetFocusRelative::<Impl, OFFSET>,
            getRange_FocusRelative::<Impl, OFFSET>,
            IrisRelative::<Impl, OFFSET>,
            SetIrisRelative::<Impl, OFFSET>,
            getRange_IrisRelative::<Impl, OFFSET>,
            ZoomRelative::<Impl, OFFSET>,
            SetZoomRelative::<Impl, OFFSET>,
            getRange_ZoomRelative::<Impl, OFFSET>,
            PanRelative::<Impl, OFFSET>,
            SetPanRelative::<Impl, OFFSET>,
            TiltRelative::<Impl, OFFSET>,
            SetTiltRelative::<Impl, OFFSET>,
            getRange_TiltRelative::<Impl, OFFSET>,
            PanTiltRelative::<Impl, OFFSET>,
            SetPanTiltRelative::<Impl, OFFSET>,
            getRange_PanRelative::<Impl, OFFSET>,
            RollRelative::<Impl, OFFSET>,
            SetRollRelative::<Impl, OFFSET>,
            getRange_RollRelative::<Impl, OFFSET>,
            ScanMode::<Impl, OFFSET>,
            SetScanMode::<Impl, OFFSET>,
            PrivacyMode::<Impl, OFFSET>,
            SetPrivacyMode::<Impl, OFFSET>,
        )
    }
}
pub trait ICaptionServiceDescriptorImpl: Sized {
    fn GetNumberOfServices();
    fn GetLanguageCode();
    fn GetCaptionServiceNumber();
    fn GetCCType();
    fn GetEasyReader();
    fn GetWideAspectRatio();
}
impl ::windows::core::RuntimeName for ICaptionServiceDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICaptionServiceDescriptor";
}
impl ICaptionServiceDescriptorVtbl {
    pub const fn new<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICaptionServiceDescriptorVtbl {
        unsafe extern "system" fn GetNumberOfServices<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfServices(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, langcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(bindex, ::core::mem::transmute_copy(&langcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCaptionServiceNumber<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaptionServiceNumber(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCCType<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCCType(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEasyReader<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEasyReader(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWideAspectRatio<Impl: ICaptionServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWideAspectRatio(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICaptionServiceDescriptor>, base.5, GetNumberOfServices::<Impl, OFFSET>, GetLanguageCode::<Impl, OFFSET>, GetCaptionServiceNumber::<Impl, OFFSET>, GetCCType::<Impl, OFFSET>, GetEasyReader::<Impl, OFFSET>, GetWideAspectRatio::<Impl, OFFSET>)
    }
}
pub trait ICaptureGraphBuilderImpl: Sized {
    fn SetFiltergraph();
    fn GetFiltergraph();
    fn SetOutputFileName();
    fn FindInterface();
    fn RenderStream();
    fn ControlStream();
    fn AllocCapFile();
    fn CopyCaptureFile();
}
impl ::windows::core::RuntimeName for ICaptureGraphBuilder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICaptureGraphBuilder";
}
impl ICaptureGraphBuilderVtbl {
    pub const fn new<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICaptureGraphBuilderVtbl {
        unsafe extern "system" fn SetFiltergraph<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfg: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFiltergraph(&*(&pfg as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFiltergraph<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppfg: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph(::core::mem::transmute_copy(&ppfg)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFileName<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::windows::core::RawPtr, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFileName(&*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&lpstrfile as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppf), ::core::mem::transmute_copy(&ppsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindInterface<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, pf: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindInterface(&*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pf as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppint)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderStream<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, psource: *mut ::core::ffi::c_void, pfcompressor: ::windows::core::RawPtr, pfrenderer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderStream(
                &*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&psource as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pfcompressor as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
                &*(&pfrenderer as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ControlStream<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, pfilter: ::windows::core::RawPtr, pstart: *mut i64, pstop: *mut i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ControlStream(&*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), pstart, pstop, wstartcookie, wstopcookie) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllocCapFile<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocCapFile(&*(&lpstr as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwlsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyCaptureFile<Impl: ICaptureGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyCaptureFile(
                &*(&lpwstrold as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&lpwstrnew as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                fallowescabort,
                &*(&pcallback as *const <IAMCopyCaptureFileProgress as ::windows::core::Abi>::Abi as *const <IAMCopyCaptureFileProgress as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICaptureGraphBuilder>, base.5, SetFiltergraph::<Impl, OFFSET>, GetFiltergraph::<Impl, OFFSET>, SetOutputFileName::<Impl, OFFSET>, FindInterface::<Impl, OFFSET>, RenderStream::<Impl, OFFSET>, ControlStream::<Impl, OFFSET>, AllocCapFile::<Impl, OFFSET>, CopyCaptureFile::<Impl, OFFSET>)
    }
}
pub trait ICaptureGraphBuilder2Impl: Sized {
    fn SetFiltergraph();
    fn GetFiltergraph();
    fn SetOutputFileName();
    fn FindInterface();
    fn RenderStream();
    fn ControlStream();
    fn AllocCapFile();
    fn CopyCaptureFile();
    fn FindPin();
}
impl ::windows::core::RuntimeName for ICaptureGraphBuilder2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICaptureGraphBuilder2";
}
impl ICaptureGraphBuilder2Vtbl {
    pub const fn new<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICaptureGraphBuilder2Vtbl {
        unsafe extern "system" fn SetFiltergraph<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfg: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFiltergraph(&*(&pfg as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFiltergraph<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppfg: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph(::core::mem::transmute_copy(&ppfg)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFileName<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::windows::core::RawPtr, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFileName(&*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&lpstrfile as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppf), ::core::mem::transmute_copy(&ppsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindInterface<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pf: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindInterface(
                &*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pf as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppint),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderStream<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, psource: *mut ::core::ffi::c_void, pfcompressor: ::windows::core::RawPtr, pfrenderer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderStream(
                &*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&psource as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pfcompressor as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
                &*(&pfrenderer as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ControlStream<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pfilter: ::windows::core::RawPtr, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ControlStream(
                &*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
                pstart,
                pstop,
                wstartcookie,
                wstopcookie,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllocCapFile<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocCapFile(&*(&lpstr as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwlsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyCaptureFile<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyCaptureFile(
                &*(&lpwstrold as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&lpwstrnew as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                fallowescabort,
                &*(&pcallback as *const <IAMCopyCaptureFileProgress as ::windows::core::Abi>::Abi as *const <IAMCopyCaptureFileProgress as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindPin<Impl: ICaptureGraphBuilder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psource: *mut ::core::ffi::c_void, pindir: PIN_DIRECTION, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, funconnected: super::super::Foundation::BOOL, num: i32, pppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindPin(
                &*(&psource as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                pindir,
                &*(&pcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&funconnected as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                num,
                ::core::mem::transmute_copy(&pppin),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICaptureGraphBuilder2>, base.5, SetFiltergraph::<Impl, OFFSET>, GetFiltergraph::<Impl, OFFSET>, SetOutputFileName::<Impl, OFFSET>, FindInterface::<Impl, OFFSET>, RenderStream::<Impl, OFFSET>, ControlStream::<Impl, OFFSET>, AllocCapFile::<Impl, OFFSET>, CopyCaptureFile::<Impl, OFFSET>, FindPin::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IChannelIDTuneRequestImpl: Sized + ITuneRequestImpl + IDispatchImpl {
    fn ChannelID();
    fn SetChannelID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IChannelIDTuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IChannelIDTuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IChannelIDTuneRequestVtbl {
    pub const fn new<Impl: IChannelIDTuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IChannelIDTuneRequestVtbl {
        unsafe extern "system" fn ChannelID<Impl: IChannelIDTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channelid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelID(::core::mem::transmute_copy(&channelid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannelID<Impl: IChannelIDTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channelid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChannelID(&*(&channelid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IChannelIDTuneRequest>, base.5, ChannelID::<Impl, OFFSET>, SetChannelID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IChannelTuneRequestImpl: Sized + ITuneRequestImpl + IDispatchImpl {
    fn Channel();
    fn SetChannel();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IChannelTuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IChannelTuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IChannelTuneRequestVtbl {
    pub const fn new<Impl: IChannelTuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IChannelTuneRequestVtbl {
        unsafe extern "system" fn Channel<Impl: IChannelTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Channel(::core::mem::transmute_copy(&channel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannel<Impl: IChannelTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChannel(channel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IChannelTuneRequest>, base.5, Channel::<Impl, OFFSET>, SetChannel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IComponentImpl: Sized + IDispatchImpl {
    fn Type();
    fn SetType();
    fn DescLangID();
    fn SetDescLangID();
    fn Status();
    fn SetStatus();
    fn Description();
    fn SetDescription();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IComponent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IComponent";
}
#[cfg(feature = "Win32_System_Com")]
impl IComponentVtbl {
    pub const fn new<Impl: IComponentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComponentVtbl {
        unsafe extern "system" fn Type<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Type(::core::mem::transmute_copy(&ct)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ct: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetType(&*(&ct as *const <IComponentType as ::windows::core::Abi>::Abi as *const <IComponentType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescLangID<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, langid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescLangID(::core::mem::transmute_copy(&langid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescLangID<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, langid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescLangID(langid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Status<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, status: *mut ComponentStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Status(::core::mem::transmute_copy(&status)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStatus<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, status: ComponentStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStatus(status) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, description: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description(::core::mem::transmute_copy(&description)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, description: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescription(&*(&description as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newcomponent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComponent>, base.5, Type::<Impl, OFFSET>, SetType::<Impl, OFFSET>, DescLangID::<Impl, OFFSET>, SetDescLangID::<Impl, OFFSET>, Status::<Impl, OFFSET>, SetStatus::<Impl, OFFSET>, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IComponentTypeImpl: Sized + IDispatchImpl {
    fn Category();
    fn SetCategory();
    fn MediaMajorType();
    fn SetMediaMajorType();
    fn _MediaMajorType();
    fn Set_MediaMajorType();
    fn MediaSubType();
    fn SetMediaSubType();
    fn _MediaSubType();
    fn Set_MediaSubType();
    fn MediaFormatType();
    fn SetMediaFormatType();
    fn _MediaFormatType();
    fn Set_MediaFormatType();
    fn MediaType();
    fn SetMediaType();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IComponentType {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IComponentType";
}
#[cfg(feature = "Win32_System_Com")]
impl IComponentTypeVtbl {
    pub const fn new<Impl: IComponentTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComponentTypeVtbl {
        unsafe extern "system" fn Category<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, category: *mut ComponentCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Category(::core::mem::transmute_copy(&category)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCategory<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, category: ComponentCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCategory(category) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaMajorType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediamajortype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaMajorType(::core::mem::transmute_copy(&mediamajortype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaMajorType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediamajortype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaMajorType(&*(&mediamajortype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _MediaMajorType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediamajortypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._MediaMajorType(::core::mem::transmute_copy(&mediamajortypeguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaMajorType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_MediaMajorType(&*(&mediamajortypeguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaSubType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediasubtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaSubType(::core::mem::transmute_copy(&mediasubtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaSubType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediasubtype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaSubType(&*(&mediasubtype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _MediaSubType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediasubtypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._MediaSubType(::core::mem::transmute_copy(&mediasubtypeguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaSubType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_MediaSubType(&*(&mediasubtypeguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaFormatType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediaformattype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaFormatType(::core::mem::transmute_copy(&mediaformattype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaFormatType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediaformattype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaFormatType(&*(&mediaformattype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _MediaFormatType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediaformattypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._MediaFormatType(::core::mem::transmute_copy(&mediaformattypeguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaFormatType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_MediaFormatType(&*(&mediaformattypeguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediatype: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaType(::core::mem::transmute_copy(&mediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(&*(&mediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newct)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IComponentType>,
            base.5,
            Category::<Impl, OFFSET>,
            SetCategory::<Impl, OFFSET>,
            MediaMajorType::<Impl, OFFSET>,
            SetMediaMajorType::<Impl, OFFSET>,
            _MediaMajorType::<Impl, OFFSET>,
            Set_MediaMajorType::<Impl, OFFSET>,
            MediaSubType::<Impl, OFFSET>,
            SetMediaSubType::<Impl, OFFSET>,
            _MediaSubType::<Impl, OFFSET>,
            Set_MediaSubType::<Impl, OFFSET>,
            MediaFormatType::<Impl, OFFSET>,
            SetMediaFormatType::<Impl, OFFSET>,
            _MediaFormatType::<Impl, OFFSET>,
            Set_MediaFormatType::<Impl, OFFSET>,
            MediaType::<Impl, OFFSET>,
            SetMediaType::<Impl, OFFSET>,
            Clone::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IComponentTypesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn EnumComponentTypes();
    fn Item();
    fn SetItem();
    fn Add();
    fn Remove();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IComponentTypes {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IComponentTypes";
}
#[cfg(feature = "Win32_System_Com")]
impl IComponentTypesVtbl {
    pub const fn new<Impl: IComponentTypesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComponentTypesVtbl {
        unsafe extern "system" fn Count<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponentTypes<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumComponentTypes(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, componenttype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&componenttype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, componenttype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetItem(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), &*(&componenttype as *const <IComponentType as ::windows::core::Abi>::Abi as *const <IComponentType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, componenttype: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&componenttype as *const <IComponentType as ::windows::core::Abi>::Abi as *const <IComponentType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComponentTypes>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, EnumComponentTypes::<Impl, OFFSET>, Item::<Impl, OFFSET>, SetItem::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IComponentsImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn EnumComponents();
    fn Item();
    fn Add();
    fn Remove();
    fn Clone();
    fn SetItem();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IComponents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IComponents";
}
#[cfg(feature = "Win32_System_Com")]
impl IComponentsVtbl {
    pub const fn new<Impl: IComponentsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComponentsVtbl {
        unsafe extern "system" fn Count<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponents<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumComponents(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppcomponent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, component: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&component as *const <IComponent as ::windows::core::Abi>::Abi as *const <IComponent as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetItem(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), &*(&ppcomponent as *const <IComponent as ::windows::core::Abi>::Abi as *const <IComponent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComponents>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, EnumComponents::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>, Clone::<Impl, OFFSET>, SetItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IComponentsOldImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn EnumComponents();
    fn Item();
    fn Add();
    fn Remove();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IComponentsOld {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IComponentsOld";
}
#[cfg(feature = "Win32_System_Com")]
impl IComponentsOldVtbl {
    pub const fn new<Impl: IComponentsOldImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComponentsOldVtbl {
        unsafe extern "system" fn Count<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponents<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumComponents(::core::mem::transmute_copy(&ppnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppcomponent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, component: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&component as *const <IComponent as ::windows::core::Abi>::Abi as *const <IComponent as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IComponentsOldImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComponentsOld>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, EnumComponents::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IConfigAsfWriterImpl: Sized {
    fn ConfigureFilterUsingProfileId();
    fn GetCurrentProfileId();
    fn ConfigureFilterUsingProfileGuid();
    fn GetCurrentProfileGuid();
    fn ConfigureFilterUsingProfile();
    fn GetCurrentProfile();
    fn SetIndexMode();
    fn GetIndexMode();
}
impl ::windows::core::RuntimeName for IConfigAsfWriter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IConfigAsfWriter";
}
impl IConfigAsfWriterVtbl {
    pub const fn new<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IConfigAsfWriterVtbl {
        unsafe extern "system" fn ConfigureFilterUsingProfileId<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwprofileid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigureFilterUsingProfileId(dwprofileid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentProfileId<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwprofileid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfileId(::core::mem::transmute_copy(&pdwprofileid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfileGuid<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidprofile: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigureFilterUsingProfileGuid(&*(&guidprofile as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentProfileGuid<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprofileguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfileGuid(::core::mem::transmute_copy(&pprofileguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfile<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigureFilterUsingProfile(&*(&pprofile as *const <super::WindowsMediaFormat::IWMProfile as ::windows::core::Abi>::Abi as *const <super::WindowsMediaFormat::IWMProfile as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentProfile<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfile(::core::mem::transmute_copy(&ppprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexMode<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindexfile: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIndexMode(&*(&bindexfile as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexMode<Impl: IConfigAsfWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbindexfile: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndexMode(::core::mem::transmute_copy(&pbindexfile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IConfigAsfWriter>, base.5, ConfigureFilterUsingProfileId::<Impl, OFFSET>, GetCurrentProfileId::<Impl, OFFSET>, ConfigureFilterUsingProfileGuid::<Impl, OFFSET>, GetCurrentProfileGuid::<Impl, OFFSET>, ConfigureFilterUsingProfile::<Impl, OFFSET>, GetCurrentProfile::<Impl, OFFSET>, SetIndexMode::<Impl, OFFSET>, GetIndexMode::<Impl, OFFSET>)
    }
}
pub trait IConfigAsfWriter2Impl: Sized + IConfigAsfWriterImpl {
    fn StreamNumFromPin();
    fn SetParam();
    fn GetParam();
    fn ResetMultiPassState();
}
impl ::windows::core::RuntimeName for IConfigAsfWriter2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IConfigAsfWriter2";
}
impl IConfigAsfWriter2Vtbl {
    pub const fn new<Impl: IConfigAsfWriter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IConfigAsfWriter2Vtbl {
        unsafe extern "system" fn StreamNumFromPin<Impl: IConfigAsfWriter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pwstreamnum: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StreamNumFromPin(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pwstreamnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParam<Impl: IConfigAsfWriter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparam: u32, dwparam1: u32, dwparam2: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetParam(dwparam, dwparam1, dwparam2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParam<Impl: IConfigAsfWriter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParam(dwparam, ::core::mem::transmute_copy(&pdwparam1), ::core::mem::transmute_copy(&pdwparam2)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetMultiPassState<Impl: IConfigAsfWriter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetMultiPassState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IConfigAsfWriter2>, base.5, StreamNumFromPin::<Impl, OFFSET>, SetParam::<Impl, OFFSET>, GetParam::<Impl, OFFSET>, ResetMultiPassState::<Impl, OFFSET>)
    }
}
pub trait IConfigAviMuxImpl: Sized {
    fn SetMasterStream();
    fn GetMasterStream();
    fn SetOutputCompatibilityIndex();
    fn GetOutputCompatibilityIndex();
}
impl ::windows::core::RuntimeName for IConfigAviMux {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IConfigAviMux";
}
impl IConfigAviMuxVtbl {
    pub const fn new<Impl: IConfigAviMuxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IConfigAviMuxVtbl {
        unsafe extern "system" fn SetMasterStream<Impl: IConfigAviMuxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, istream: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMasterStream(istream) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMasterStream<Impl: IConfigAviMuxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstream: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMasterStream(::core::mem::transmute_copy(&pstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputCompatibilityIndex<Impl: IConfigAviMuxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, foldindex: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputCompatibilityIndex(&*(&foldindex as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCompatibilityIndex<Impl: IConfigAviMuxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfoldindex: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputCompatibilityIndex(::core::mem::transmute_copy(&pfoldindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IConfigAviMux>, base.5, SetMasterStream::<Impl, OFFSET>, GetMasterStream::<Impl, OFFSET>, SetOutputCompatibilityIndex::<Impl, OFFSET>, GetOutputCompatibilityIndex::<Impl, OFFSET>)
    }
}
pub trait IConfigInterleavingImpl: Sized {
    fn SetMode();
    fn Mode();
    fn SetInterleaving();
    fn Interleaving();
}
impl ::windows::core::RuntimeName for IConfigInterleaving {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IConfigInterleaving";
}
impl IConfigInterleavingVtbl {
    pub const fn new<Impl: IConfigInterleavingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IConfigInterleavingVtbl {
        unsafe extern "system" fn SetMode<Impl: IConfigInterleavingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: InterleavingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Mode<Impl: IConfigInterleavingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut InterleavingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode(::core::mem::transmute_copy(&pmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInterleaving<Impl: IConfigInterleavingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtinterleave: *const i64, prtpreroll: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInterleaving(prtinterleave, prtpreroll) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Interleaving<Impl: IConfigInterleavingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtinterleave: *mut i64, prtpreroll: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Interleaving(::core::mem::transmute_copy(&prtinterleave), ::core::mem::transmute_copy(&prtpreroll)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IConfigInterleaving>, base.5, SetMode::<Impl, OFFSET>, Mode::<Impl, OFFSET>, SetInterleaving::<Impl, OFFSET>, Interleaving::<Impl, OFFSET>)
    }
}
pub trait ICreateDevEnumImpl: Sized {
    fn CreateClassEnumerator();
}
impl ::windows::core::RuntimeName for ICreateDevEnum {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICreateDevEnum";
}
impl ICreateDevEnumVtbl {
    pub const fn new<Impl: ICreateDevEnumImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICreateDevEnumVtbl {
        unsafe extern "system" fn CreateClassEnumerator<Impl: ICreateDevEnumImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsiddeviceclass: *const ::windows::core::GUID, ppenummoniker: *mut ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateClassEnumerator(&*(&clsiddeviceclass as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppenummoniker), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICreateDevEnum>, base.5, CreateClassEnumerator::<Impl, OFFSET>)
    }
}
pub trait ICreatePropBagOnRegKeyImpl: Sized {
    fn Create();
}
impl ::windows::core::RuntimeName for ICreatePropBagOnRegKey {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ICreatePropBagOnRegKey";
}
impl ICreatePropBagOnRegKeyVtbl {
    pub const fn new<Impl: ICreatePropBagOnRegKeyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICreatePropBagOnRegKeyVtbl {
        unsafe extern "system" fn Create<Impl: ICreatePropBagOnRegKeyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hkey: super::super::System::Registry::HKEY, subkey: super::super::Foundation::PWSTR, uloptions: u32, samdesired: u32, iid: *const ::windows::core::GUID, ppbag: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Create(
                &*(&hkey as *const <super::super::System::Registry::HKEY as ::windows::core::Abi>::Abi as *const <super::super::System::Registry::HKEY as ::windows::core::DefaultType>::DefaultType),
                &*(&subkey as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                uloptions,
                samdesired,
                &*(&iid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppbag),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICreatePropBagOnRegKey>, base.5, Create::<Impl, OFFSET>)
    }
}
pub trait IDDrawExclModeVideoImpl: Sized {
    fn SetDDrawObject();
    fn GetDDrawObject();
    fn SetDDrawSurface();
    fn GetDDrawSurface();
    fn SetDrawParameters();
    fn GetNativeVideoProps();
    fn SetCallbackInterface();
}
impl ::windows::core::RuntimeName for IDDrawExclModeVideo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDDrawExclModeVideo";
}
impl IDDrawExclModeVideoVtbl {
    pub const fn new<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDDrawExclModeVideoVtbl {
        unsafe extern "system" fn SetDDrawObject<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pddrawobject: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDDrawObject(&*(&pddrawobject as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDDrawObject<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppddrawobject: *mut ::windows::core::RawPtr, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDDrawObject(::core::mem::transmute_copy(&ppddrawobject), ::core::mem::transmute_copy(&pbusingexternal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDDrawSurface<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pddrawsurface: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDDrawSurface(&*(&pddrawsurface as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDDrawSurface<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppddrawsurface: *mut ::windows::core::RawPtr, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDDrawSurface(::core::mem::transmute_copy(&ppddrawsurface), ::core::mem::transmute_copy(&pbusingexternal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDrawParameters<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDrawParameters(&*(&prcsource as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&prctarget as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNativeVideoProps<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoProps(::core::mem::transmute_copy(&pdwvideowidth), ::core::mem::transmute_copy(&pdwvideoheight), ::core::mem::transmute_copy(&pdwpictaspectratiox), ::core::mem::transmute_copy(&pdwpictaspectratioy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCallbackInterface<Impl: IDDrawExclModeVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCallbackInterface(&*(&pcallback as *const <IDDrawExclModeVideoCallback as ::windows::core::Abi>::Abi as *const <IDDrawExclModeVideoCallback as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDDrawExclModeVideo>, base.5, SetDDrawObject::<Impl, OFFSET>, GetDDrawObject::<Impl, OFFSET>, SetDDrawSurface::<Impl, OFFSET>, GetDDrawSurface::<Impl, OFFSET>, SetDrawParameters::<Impl, OFFSET>, GetNativeVideoProps::<Impl, OFFSET>, SetCallbackInterface::<Impl, OFFSET>)
    }
}
pub trait IDDrawExclModeVideoCallbackImpl: Sized {
    fn OnUpdateOverlay();
    fn OnUpdateColorKey();
    fn OnUpdateSize();
}
impl ::windows::core::RuntimeName for IDDrawExclModeVideoCallback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDDrawExclModeVideoCallback";
}
impl IDDrawExclModeVideoCallbackVtbl {
    pub const fn new<Impl: IDDrawExclModeVideoCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDDrawExclModeVideoCallbackVtbl {
        unsafe extern "system" fn OnUpdateOverlay<Impl: IDDrawExclModeVideoCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bbefore: super::super::Foundation::BOOL, dwflags: u32, boldvisible: super::super::Foundation::BOOL, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: super::super::Foundation::BOOL, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnUpdateOverlay(
                &*(&bbefore as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&boldvisible as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&prcoldsrc as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&prcolddest as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&bnewvisible as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&prcnewsrc as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&prcnewdest as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnUpdateColorKey<Impl: IDDrawExclModeVideoCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkey: *const COLORKEY, dwcolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnUpdateColorKey(&*(&pkey as *const <COLORKEY as ::windows::core::Abi>::Abi as *const <COLORKEY as ::windows::core::DefaultType>::DefaultType), dwcolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnUpdateSize<Impl: IDDrawExclModeVideoCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnUpdateSize(dwwidth, dwheight, dwarwidth, dwarheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDDrawExclModeVideoCallback>, base.5, OnUpdateOverlay::<Impl, OFFSET>, OnUpdateColorKey::<Impl, OFFSET>, OnUpdateSize::<Impl, OFFSET>)
    }
}
pub trait IDMOWrapperFilterImpl: Sized {
    fn Init();
}
impl ::windows::core::RuntimeName for IDMOWrapperFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDMOWrapperFilter";
}
impl IDMOWrapperFilterVtbl {
    pub const fn new<Impl: IDMOWrapperFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDMOWrapperFilterVtbl {
        unsafe extern "system" fn Init<Impl: IDMOWrapperFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsiddmo: *const ::windows::core::GUID, catdmo: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init(&*(&clsiddmo as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&catdmo as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDMOWrapperFilter>, base.5, Init::<Impl, OFFSET>)
    }
}
pub trait IDShowPluginImpl: Sized {
    fn URL();
    fn UserAgent();
}
impl ::windows::core::RuntimeName for IDShowPlugin {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDShowPlugin";
}
impl IDShowPluginVtbl {
    pub const fn new<Impl: IDShowPluginImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDShowPluginVtbl {
        unsafe extern "system" fn URL<Impl: IDShowPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, purl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).URL(&*(&purl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UserAgent<Impl: IDShowPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puseragent: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UserAgent(&*(&puseragent as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDShowPlugin>, base.5, URL::<Impl, OFFSET>, UserAgent::<Impl, OFFSET>)
    }
}
pub trait IDTFilterImpl: Sized {
    fn EvalRatObjOK();
    fn GetCurrRating();
    fn BlockedRatingAttributes();
    fn SetBlockedRatingAttributes();
    fn BlockUnRated();
    fn SetBlockUnRated();
    fn BlockUnRatedDelay();
    fn SetBlockUnRatedDelay();
}
impl ::windows::core::RuntimeName for IDTFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilter";
}
impl IDTFilterVtbl {
    pub const fn new<Impl: IDTFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilterVtbl {
        unsafe extern "system" fn EvalRatObjOK<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EvalRatObjOK(::core::mem::transmute_copy(&phrcocreateretval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrRating<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrRating(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&plbfenattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlockedRatingAttributes<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlockedRatingAttributes(ensystem, enlevel, ::core::mem::transmute_copy(&plbfenattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockedRatingAttributes<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockedRatingAttributes(ensystem, enlevel, lbfattrs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlockUnRated<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfblockunratedshows: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlockUnRated(::core::mem::transmute_copy(&pfblockunratedshows)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRated<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockUnRated(&*(&fblockunratedshows as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlockUnRatedDelay<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmsecsdelaybeforeblock: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlockUnRatedDelay(::core::mem::transmute_copy(&pmsecsdelaybeforeblock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRatedDelay<Impl: IDTFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, msecsdelaybeforeblock: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockUnRatedDelay(msecsdelaybeforeblock) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilter>, base.5, EvalRatObjOK::<Impl, OFFSET>, GetCurrRating::<Impl, OFFSET>, BlockedRatingAttributes::<Impl, OFFSET>, SetBlockedRatingAttributes::<Impl, OFFSET>, BlockUnRated::<Impl, OFFSET>, SetBlockUnRated::<Impl, OFFSET>, BlockUnRatedDelay::<Impl, OFFSET>, SetBlockUnRatedDelay::<Impl, OFFSET>)
    }
}
pub trait IDTFilter2Impl: Sized + IDTFilterImpl {
    fn ChallengeUrl();
    fn GetCurrLicenseExpDate();
    fn GetLastErrorCode();
}
impl ::windows::core::RuntimeName for IDTFilter2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilter2";
}
impl IDTFilter2Vtbl {
    pub const fn new<Impl: IDTFilter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilter2Vtbl {
        unsafe extern "system" fn ChallengeUrl<Impl: IDTFilter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrchallengeurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChallengeUrl(::core::mem::transmute_copy(&pbstrchallengeurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IDTFilter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(prottype, ::core::mem::transmute_copy(&lpdatetime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IDTFilter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilter2>, base.5, ChallengeUrl::<Impl, OFFSET>, GetCurrLicenseExpDate::<Impl, OFFSET>, GetLastErrorCode::<Impl, OFFSET>)
    }
}
pub trait IDTFilter3Impl: Sized + IDTFilter2Impl + IDTFilterImpl {
    fn GetProtectionType();
    fn LicenseHasExpirationDate();
    fn SetRights();
}
impl ::windows::core::RuntimeName for IDTFilter3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilter3";
}
impl IDTFilter3Vtbl {
    pub const fn new<Impl: IDTFilter3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilter3Vtbl {
        unsafe extern "system" fn GetProtectionType<Impl: IDTFilter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprotectiontype: *mut ProtType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectionType(::core::mem::transmute_copy(&pprotectiontype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LicenseHasExpirationDate<Impl: IDTFilter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflicensehasexpirationdate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LicenseHasExpirationDate(::core::mem::transmute_copy(&pflicensehasexpirationdate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRights<Impl: IDTFilter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrrights: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRights(&*(&bstrrights as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilter3>, base.5, GetProtectionType::<Impl, OFFSET>, LicenseHasExpirationDate::<Impl, OFFSET>, SetRights::<Impl, OFFSET>)
    }
}
pub trait IDTFilterConfigImpl: Sized {
    fn GetSecureChannelObject();
}
impl ::windows::core::RuntimeName for IDTFilterConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilterConfig";
}
impl IDTFilterConfigVtbl {
    pub const fn new<Impl: IDTFilterConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilterConfigVtbl {
        unsafe extern "system" fn GetSecureChannelObject<Impl: IDTFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject(::core::mem::transmute_copy(&ppunkdrmsecurechannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilterConfig>, base.5, GetSecureChannelObject::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDTFilterEventsImpl: Sized + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDTFilterEvents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilterEvents";
}
#[cfg(feature = "Win32_System_Com")]
impl IDTFilterEventsVtbl {
    pub const fn new<Impl: IDTFilterEventsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilterEventsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilterEvents>, base.5)
    }
}
pub trait IDTFilterLicenseRenewalImpl: Sized {
    fn GetLicenseRenewalData();
}
impl ::windows::core::RuntimeName for IDTFilterLicenseRenewal {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDTFilterLicenseRenewal";
}
impl IDTFilterLicenseRenewalVtbl {
    pub const fn new<Impl: IDTFilterLicenseRenewalImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDTFilterLicenseRenewalVtbl {
        unsafe extern "system" fn GetLicenseRenewalData<Impl: IDTFilterLicenseRenewalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppwszfilename: *mut super::super::Foundation::PWSTR, ppwszexpiredkid: *mut super::super::Foundation::PWSTR, ppwsztunerid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLicenseRenewalData(::core::mem::transmute_copy(&ppwszfilename), ::core::mem::transmute_copy(&ppwszexpiredkid), ::core::mem::transmute_copy(&ppwsztunerid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDTFilterLicenseRenewal>, base.5, GetLicenseRenewalData::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBCLocatorImpl: Sized + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBCLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBCLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBCLocatorVtbl {
    pub const fn new<Impl: IDVBCLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBCLocatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBCLocator>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBSLocatorImpl: Sized + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn SignalPolarisation();
    fn SetSignalPolarisation();
    fn WestPosition();
    fn SetWestPosition();
    fn OrbitalPosition();
    fn SetOrbitalPosition();
    fn Azimuth();
    fn SetAzimuth();
    fn Elevation();
    fn SetElevation();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBSLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBSLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSLocatorVtbl {
    pub const fn new<Impl: IDVBSLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBSLocatorVtbl {
        unsafe extern "system" fn SignalPolarisation<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, polarisationval: *mut Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalPolarisation(::core::mem::transmute_copy(&polarisationval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalPolarisation<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, polarisationval: Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalPolarisation(polarisationval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WestPosition<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, westlongitude: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WestPosition(::core::mem::transmute_copy(&westlongitude)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWestPosition<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, westlongitude: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWestPosition(westlongitude) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrbitalPosition<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, longitude: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrbitalPosition(::core::mem::transmute_copy(&longitude)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrbitalPosition<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, longitude: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOrbitalPosition(longitude) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Azimuth<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, azimuth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Azimuth(::core::mem::transmute_copy(&azimuth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAzimuth<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, azimuth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAzimuth(azimuth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Elevation<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, elevation: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Elevation(::core::mem::transmute_copy(&elevation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetElevation<Impl: IDVBSLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, elevation: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetElevation(elevation) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBSLocator>, base.5, SignalPolarisation::<Impl, OFFSET>, SetSignalPolarisation::<Impl, OFFSET>, WestPosition::<Impl, OFFSET>, SetWestPosition::<Impl, OFFSET>, OrbitalPosition::<Impl, OFFSET>, SetOrbitalPosition::<Impl, OFFSET>, Azimuth::<Impl, OFFSET>, SetAzimuth::<Impl, OFFSET>, Elevation::<Impl, OFFSET>, SetElevation::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBSLocator2Impl: Sized + IDVBSLocatorImpl + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn DiseqLNBSource();
    fn SetDiseqLNBSource();
    fn LocalOscillatorOverrideLow();
    fn SetLocalOscillatorOverrideLow();
    fn LocalOscillatorOverrideHigh();
    fn SetLocalOscillatorOverrideHigh();
    fn LocalLNBSwitchOverride();
    fn SetLocalLNBSwitchOverride();
    fn LocalSpectralInversionOverride();
    fn SetLocalSpectralInversionOverride();
    fn SignalRollOff();
    fn SetSignalRollOff();
    fn SignalPilot();
    fn SetSignalPilot();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBSLocator2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBSLocator2";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSLocator2Vtbl {
    pub const fn new<Impl: IDVBSLocator2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBSLocator2Vtbl {
        unsafe extern "system" fn DiseqLNBSource<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, diseqlnbsourceval: *mut LNB_Source) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DiseqLNBSource(::core::mem::transmute_copy(&diseqlnbsourceval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqLNBSource<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, diseqlnbsourceval: LNB_Source) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiseqLNBSource(diseqlnbsourceval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalOscillatorOverrideLow<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localoscillatoroverridelowval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalOscillatorOverrideLow(::core::mem::transmute_copy(&localoscillatoroverridelowval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalOscillatorOverrideLow<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localoscillatoroverridelowval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalOscillatorOverrideLow(localoscillatoroverridelowval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalOscillatorOverrideHigh<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localoscillatoroverridehighval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalOscillatorOverrideHigh(::core::mem::transmute_copy(&localoscillatoroverridehighval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalOscillatorOverrideHigh<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localoscillatoroverridehighval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalOscillatorOverrideHigh(localoscillatoroverridehighval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalLNBSwitchOverride<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locallnbswitchoverrideval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalLNBSwitchOverride(::core::mem::transmute_copy(&locallnbswitchoverrideval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalLNBSwitchOverride<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locallnbswitchoverrideval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalLNBSwitchOverride(locallnbswitchoverrideval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LocalSpectralInversionOverride<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localspectralinversionoverrideval: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LocalSpectralInversionOverride(::core::mem::transmute_copy(&localspectralinversionoverrideval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalSpectralInversionOverride<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, localspectralinversionoverrideval: SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocalSpectralInversionOverride(localspectralinversionoverrideval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalRollOff<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rolloffval: *mut RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalRollOff(::core::mem::transmute_copy(&rolloffval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalRollOff<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rolloffval: RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalRollOff(rolloffval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalPilot<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pilotval: *mut Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalPilot(::core::mem::transmute_copy(&pilotval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalPilot<Impl: IDVBSLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pilotval: Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSignalPilot(pilotval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVBSLocator2>,
            base.5,
            DiseqLNBSource::<Impl, OFFSET>,
            SetDiseqLNBSource::<Impl, OFFSET>,
            LocalOscillatorOverrideLow::<Impl, OFFSET>,
            SetLocalOscillatorOverrideLow::<Impl, OFFSET>,
            LocalOscillatorOverrideHigh::<Impl, OFFSET>,
            SetLocalOscillatorOverrideHigh::<Impl, OFFSET>,
            LocalLNBSwitchOverride::<Impl, OFFSET>,
            SetLocalLNBSwitchOverride::<Impl, OFFSET>,
            LocalSpectralInversionOverride::<Impl, OFFSET>,
            SetLocalSpectralInversionOverride::<Impl, OFFSET>,
            SignalRollOff::<Impl, OFFSET>,
            SetSignalRollOff::<Impl, OFFSET>,
            SignalPilot::<Impl, OFFSET>,
            SetSignalPilot::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBSTuningSpaceImpl: Sized + IDVBTuningSpace2Impl + IDVBTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn LowOscillator();
    fn SetLowOscillator();
    fn HighOscillator();
    fn SetHighOscillator();
    fn LNBSwitch();
    fn SetLNBSwitch();
    fn InputRange();
    fn SetInputRange();
    fn SpectralInversion();
    fn SetSpectralInversion();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBSTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBSTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSTuningSpaceVtbl {
    pub const fn new<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBSTuningSpaceVtbl {
        unsafe extern "system" fn LowOscillator<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lowoscillator: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LowOscillator(::core::mem::transmute_copy(&lowoscillator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLowOscillator<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lowoscillator: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLowOscillator(lowoscillator) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HighOscillator<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, highoscillator: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HighOscillator(::core::mem::transmute_copy(&highoscillator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHighOscillator<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, highoscillator: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHighOscillator(highoscillator) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LNBSwitch<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lnbswitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LNBSwitch(::core::mem::transmute_copy(&lnbswitch)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLNBSwitch<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lnbswitch: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLNBSwitch(lnbswitch) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputRange<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputrange: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputRange(::core::mem::transmute_copy(&inputrange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputRange<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputrange: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputRange(&*(&inputrange as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SpectralInversion<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, spectralinversionval: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SpectralInversion(::core::mem::transmute_copy(&spectralinversionval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpectralInversion<Impl: IDVBSTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, spectralinversionval: SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSpectralInversion(spectralinversionval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBSTuningSpace>, base.5, LowOscillator::<Impl, OFFSET>, SetLowOscillator::<Impl, OFFSET>, HighOscillator::<Impl, OFFSET>, SetHighOscillator::<Impl, OFFSET>, LNBSwitch::<Impl, OFFSET>, SetLNBSwitch::<Impl, OFFSET>, InputRange::<Impl, OFFSET>, SetInputRange::<Impl, OFFSET>, SpectralInversion::<Impl, OFFSET>, SetSpectralInversion::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBTLocatorImpl: Sized + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn Bandwidth();
    fn SetBandwidth();
    fn LPInnerFEC();
    fn SetLPInnerFEC();
    fn LPInnerFECRate();
    fn SetLPInnerFECRate();
    fn HAlpha();
    fn SetHAlpha();
    fn Guard();
    fn SetGuard();
    fn Mode();
    fn SetMode();
    fn OtherFrequencyInUse();
    fn SetOtherFrequencyInUse();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBTLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBTLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTLocatorVtbl {
    pub const fn new<Impl: IDVBTLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBTLocatorVtbl {
        unsafe extern "system" fn Bandwidth<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bandwidthval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bandwidth(::core::mem::transmute_copy(&bandwidthval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBandwidth<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bandwidthval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBandwidth(bandwidthval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LPInnerFEC<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LPInnerFEC(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLPInnerFEC<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLPInnerFEC(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LPInnerFECRate<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LPInnerFECRate(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLPInnerFECRate<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLPInnerFECRate(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HAlpha<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, alpha: *mut HierarchyAlpha) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HAlpha(::core::mem::transmute_copy(&alpha)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHAlpha<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, alpha: HierarchyAlpha) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHAlpha(alpha) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Guard<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, gi: *mut GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Guard(::core::mem::transmute_copy(&gi)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGuard<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, gi: GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGuard(gi) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Mode<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: *mut TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode(::core::mem::transmute_copy(&mode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OtherFrequencyInUse<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, otherfrequencyinuseval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OtherFrequencyInUse(::core::mem::transmute_copy(&otherfrequencyinuseval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOtherFrequencyInUse<Impl: IDVBTLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, otherfrequencyinuseval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOtherFrequencyInUse(otherfrequencyinuseval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVBTLocator>,
            base.5,
            Bandwidth::<Impl, OFFSET>,
            SetBandwidth::<Impl, OFFSET>,
            LPInnerFEC::<Impl, OFFSET>,
            SetLPInnerFEC::<Impl, OFFSET>,
            LPInnerFECRate::<Impl, OFFSET>,
            SetLPInnerFECRate::<Impl, OFFSET>,
            HAlpha::<Impl, OFFSET>,
            SetHAlpha::<Impl, OFFSET>,
            Guard::<Impl, OFFSET>,
            SetGuard::<Impl, OFFSET>,
            Mode::<Impl, OFFSET>,
            SetMode::<Impl, OFFSET>,
            OtherFrequencyInUse::<Impl, OFFSET>,
            SetOtherFrequencyInUse::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBTLocator2Impl: Sized + IDVBTLocatorImpl + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {
    fn PhysicalLayerPipeId();
    fn SetPhysicalLayerPipeId();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBTLocator2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBTLocator2";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTLocator2Vtbl {
    pub const fn new<Impl: IDVBTLocator2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBTLocator2Vtbl {
        unsafe extern "system" fn PhysicalLayerPipeId<Impl: IDVBTLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, physicallayerpipeidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PhysicalLayerPipeId(::core::mem::transmute_copy(&physicallayerpipeidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPhysicalLayerPipeId<Impl: IDVBTLocator2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, physicallayerpipeidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPhysicalLayerPipeId(physicallayerpipeidval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBTLocator2>, base.5, PhysicalLayerPipeId::<Impl, OFFSET>, SetPhysicalLayerPipeId::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBTuneRequestImpl: Sized + ITuneRequestImpl + IDispatchImpl {
    fn ONID();
    fn SetONID();
    fn TSID();
    fn SetTSID();
    fn SID();
    fn SetSID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBTuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBTuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuneRequestVtbl {
    pub const fn new<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBTuneRequestVtbl {
        unsafe extern "system" fn ONID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, onid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ONID(::core::mem::transmute_copy(&onid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetONID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, onid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetONID(onid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TSID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TSID(::core::mem::transmute_copy(&tsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTSID(tsid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SID(::core::mem::transmute_copy(&sid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSID<Impl: IDVBTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSID(sid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBTuneRequest>, base.5, ONID::<Impl, OFFSET>, SetONID::<Impl, OFFSET>, TSID::<Impl, OFFSET>, SetTSID::<Impl, OFFSET>, SID::<Impl, OFFSET>, SetSID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBTuningSpaceImpl: Sized + ITuningSpaceImpl + IDispatchImpl {
    fn SystemType();
    fn SetSystemType();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuningSpaceVtbl {
    pub const fn new<Impl: IDVBTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBTuningSpaceVtbl {
        unsafe extern "system" fn SystemType<Impl: IDVBTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, systype: *mut DVBSystemType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SystemType(::core::mem::transmute_copy(&systype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSystemType<Impl: IDVBTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, systype: DVBSystemType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSystemType(systype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBTuningSpace>, base.5, SystemType::<Impl, OFFSET>, SetSystemType::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDVBTuningSpace2Impl: Sized + IDVBTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn NetworkID();
    fn SetNetworkID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDVBTuningSpace2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVBTuningSpace2";
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuningSpace2Vtbl {
    pub const fn new<Impl: IDVBTuningSpace2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVBTuningSpace2Vtbl {
        unsafe extern "system" fn NetworkID<Impl: IDVBTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networkid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NetworkID(::core::mem::transmute_copy(&networkid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNetworkID<Impl: IDVBTuningSpace2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networkid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNetworkID(networkid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVBTuningSpace2>, base.5, NetworkID::<Impl, OFFSET>, SetNetworkID::<Impl, OFFSET>)
    }
}
pub trait IDVB_BATImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetBouquetId();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetCountOfRecords();
    fn GetRecordTransportStreamId();
    fn GetRecordOriginalNetworkId();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for IDVB_BAT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_BAT";
}
impl IDVB_BATVtbl {
    pub const fn new<Impl: IDVB_BATImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_BATVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBouquetId<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBouquetId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, &*(&ppdescriptor as *const <IGenericDescriptor as ::windows::core::Abi>::Abi as *const <IGenericDescriptor as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&ppbat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_BATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVB_BAT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetBouquetId::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordTransportStreamId::<Impl, OFFSET>,
            GetRecordOriginalNetworkId::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
        )
    }
}
pub trait IDVB_DITImpl: Sized {
    fn Initialize();
    fn GetTransitionFlag();
}
impl ::windows::core::RuntimeName for IDVB_DIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_DIT";
}
impl IDVB_DITVtbl {
    pub const fn new<Impl: IDVB_DITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_DITVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_DITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransitionFlag<Impl: IDVB_DITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransitionFlag(::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_DIT>, base.5, Initialize::<Impl, OFFSET>, GetTransitionFlag::<Impl, OFFSET>)
    }
}
pub trait IDVB_EITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetServiceId();
    fn GetTransportStreamId();
    fn GetOriginalNetworkId();
    fn GetSegmentLastSectionNumber();
    fn GetLastTableId();
    fn GetCountOfRecords();
    fn GetRecordEventId();
    fn GetRecordStartTime();
    fn GetRecordDuration();
    fn GetRecordRunningStatus();
    fn GetRecordFreeCAMode();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IDVB_EIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_EIT";
}
impl IDVB_EITVtbl {
    pub const fn new<Impl: IDVB_EITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_EITVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSegmentLastSectionNumber<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSegmentLastSectionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastTableId<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastTableId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(dwrecordindex, ::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(dwrecordindex, ::core::mem::transmute_copy(&pmdval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFreeCAMode<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordFreeCAMode(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&ppeit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVB_EIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetServiceId::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetSegmentLastSectionNumber::<Impl, OFFSET>,
            GetLastTableId::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordEventId::<Impl, OFFSET>,
            GetRecordStartTime::<Impl, OFFSET>,
            GetRecordDuration::<Impl, OFFSET>,
            GetRecordRunningStatus::<Impl, OFFSET>,
            GetRecordFreeCAMode::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IDVB_EIT2Impl: Sized + IDVB_EITImpl {
    fn GetSegmentInfo();
    fn GetRecordSection();
}
impl ::windows::core::RuntimeName for IDVB_EIT2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_EIT2";
}
impl IDVB_EIT2Vtbl {
    pub const fn new<Impl: IDVB_EIT2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_EIT2Vtbl {
        unsafe extern "system" fn GetSegmentInfo<Impl: IDVB_EIT2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbtid: *mut u8, pbsegment: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSegmentInfo(::core::mem::transmute_copy(&pbtid), ::core::mem::transmute_copy(&pbsegment)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordSection<Impl: IDVB_EIT2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordSection(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_EIT2>, base.5, GetSegmentInfo::<Impl, OFFSET>, GetRecordSection::<Impl, OFFSET>)
    }
}
pub trait IDVB_NITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetNetworkId();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetCountOfRecords();
    fn GetRecordTransportStreamId();
    fn GetRecordOriginalNetworkId();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IDVB_NIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_NIT";
}
impl IDVB_NITVtbl {
    pub const fn new<Impl: IDVB_NITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_NITVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkId<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppnit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&ppnit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_NITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVB_NIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetNetworkId::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordTransportStreamId::<Impl, OFFSET>,
            GetRecordOriginalNetworkId::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IDVB_RSTImpl: Sized {
    fn Initialize();
    fn GetCountOfRecords();
    fn GetRecordTransportStreamId();
    fn GetRecordOriginalNetworkId();
    fn GetRecordServiceId();
    fn GetRecordEventId();
    fn GetRecordRunningStatus();
}
impl ::windows::core::RuntimeName for IDVB_RST {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_RST";
}
impl IDVB_RSTVtbl {
    pub const fn new<Impl: IDVB_RSTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_RSTVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_RSTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_RST>, base.5, Initialize::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordTransportStreamId::<Impl, OFFSET>, GetRecordOriginalNetworkId::<Impl, OFFSET>, GetRecordServiceId::<Impl, OFFSET>, GetRecordEventId::<Impl, OFFSET>, GetRecordRunningStatus::<Impl, OFFSET>)
    }
}
pub trait IDVB_SDTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetTransportStreamId();
    fn GetOriginalNetworkId();
    fn GetCountOfRecords();
    fn GetRecordServiceId();
    fn GetRecordEITScheduleFlag();
    fn GetRecordEITPresentFollowingFlag();
    fn GetRecordRunningStatus();
    fn GetRecordFreeCAMode();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IDVB_SDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_SDT";
}
impl IDVB_SDTVtbl {
    pub const fn new<Impl: IDVB_SDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_SDTVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEITScheduleFlag<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEITScheduleFlag(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEITPresentFollowingFlag<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEITPresentFollowingFlag(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFreeCAMode<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordFreeCAMode(dwrecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&ppsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVB_SDT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordServiceId::<Impl, OFFSET>,
            GetRecordEITScheduleFlag::<Impl, OFFSET>,
            GetRecordEITPresentFollowingFlag::<Impl, OFFSET>,
            GetRecordRunningStatus::<Impl, OFFSET>,
            GetRecordFreeCAMode::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IDVB_SITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetCountOfRecords();
    fn GetRecordServiceId();
    fn GetRecordRunningStatus();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for IDVB_SIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_SIT";
}
impl IDVB_SITVtbl {
    pub const fn new<Impl: IDVB_SITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_SITVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(dwtimeout, ::core::mem::transmute_copy(&ppsit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_SITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDVB_SIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordServiceId::<Impl, OFFSET>,
            GetRecordRunningStatus::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
        )
    }
}
pub trait IDVB_STImpl: Sized {
    fn Initialize();
    fn GetDataLength();
    fn GetData();
}
impl ::windows::core::RuntimeName for IDVB_ST {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_ST";
}
impl IDVB_STVtbl {
    pub const fn new<Impl: IDVB_STImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_STVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_STImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataLength<Impl: IDVB_STImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataLength(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetData<Impl: IDVB_STImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&ppdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_ST>, base.5, Initialize::<Impl, OFFSET>, GetDataLength::<Impl, OFFSET>, GetData::<Impl, OFFSET>)
    }
}
pub trait IDVB_TDTImpl: Sized {
    fn Initialize();
    fn GetUTCTime();
}
impl ::windows::core::RuntimeName for IDVB_TDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_TDT";
}
impl IDVB_TDTVtbl {
    pub const fn new<Impl: IDVB_TDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_TDTVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_TDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUTCTime<Impl: IDVB_TDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUTCTime(::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_TDT>, base.5, Initialize::<Impl, OFFSET>, GetUTCTime::<Impl, OFFSET>)
    }
}
pub trait IDVB_TOTImpl: Sized {
    fn Initialize();
    fn GetUTCTime();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
}
impl ::windows::core::RuntimeName for IDVB_TOT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVB_TOT";
}
impl IDVB_TOTVtbl {
    pub const fn new<Impl: IDVB_TOTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVB_TOTVtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_TOTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUTCTime<Impl: IDVB_TOTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUTCTime(::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_TOTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_TOTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_TOTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVB_TOT>, base.5, Initialize::<Impl, OFFSET>, GetUTCTime::<Impl, OFFSET>, GetCountOfTableDescriptors::<Impl, OFFSET>, GetTableDescriptorByIndex::<Impl, OFFSET>, GetTableDescriptorByTag::<Impl, OFFSET>)
    }
}
pub trait IDVEncImpl: Sized {
    fn IFormatResolution();
    fn SetIFormatResolution();
}
impl ::windows::core::RuntimeName for IDVEnc {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVEnc";
}
impl IDVEncVtbl {
    pub const fn new<Impl: IDVEncImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVEncVtbl {
        unsafe extern "system" fn IFormatResolution<Impl: IDVEncImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IFormatResolution(::core::mem::transmute_copy(&videoformat), ::core::mem::transmute_copy(&dvformat), ::core::mem::transmute_copy(&resolution), fdvinfo, ::core::mem::transmute_copy(&sdvinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIFormatResolution<Impl: IDVEncImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIFormatResolution(videoformat, dvformat, resolution, fdvinfo, &*(&sdvinfo as *const <DVINFO as ::windows::core::Abi>::Abi as *const <DVINFO as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVEnc>, base.5, IFormatResolution::<Impl, OFFSET>, SetIFormatResolution::<Impl, OFFSET>)
    }
}
pub trait IDVRGB219Impl: Sized {
    fn SetRGB219();
}
impl ::windows::core::RuntimeName for IDVRGB219 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVRGB219";
}
impl IDVRGB219Vtbl {
    pub const fn new<Impl: IDVRGB219Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVRGB219Vtbl {
        unsafe extern "system" fn SetRGB219<Impl: IDVRGB219Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRGB219(&*(&bstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVRGB219>, base.5, SetRGB219::<Impl, OFFSET>)
    }
}
pub trait IDVSplitterImpl: Sized {
    fn DiscardAlternateVideoFrames();
}
impl ::windows::core::RuntimeName for IDVSplitter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDVSplitter";
}
impl IDVSplitterVtbl {
    pub const fn new<Impl: IDVSplitterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDVSplitterVtbl {
        unsafe extern "system" fn DiscardAlternateVideoFrames<Impl: IDVSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ndiscard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DiscardAlternateVideoFrames(ndiscard) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDVSplitter>, base.5, DiscardAlternateVideoFrames::<Impl, OFFSET>)
    }
}
pub trait IDecimateVideoImageImpl: Sized {
    fn SetDecimationImageSize();
    fn ResetDecimationImageSize();
}
impl ::windows::core::RuntimeName for IDecimateVideoImage {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDecimateVideoImage";
}
impl IDecimateVideoImageVtbl {
    pub const fn new<Impl: IDecimateVideoImageImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDecimateVideoImageVtbl {
        unsafe extern "system" fn SetDecimationImageSize<Impl: IDecimateVideoImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lwidth: i32, lheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDecimationImageSize(lwidth, lheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetDecimationImageSize<Impl: IDecimateVideoImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetDecimationImageSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDecimateVideoImage>, base.5, SetDecimationImageSize::<Impl, OFFSET>, ResetDecimationImageSize::<Impl, OFFSET>)
    }
}
pub trait IDeferredCommandImpl: Sized {
    fn Cancel();
    fn Confidence();
    fn Postpone();
    fn GetHResult();
}
impl ::windows::core::RuntimeName for IDeferredCommand {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDeferredCommand";
}
impl IDeferredCommandVtbl {
    pub const fn new<Impl: IDeferredCommandImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDeferredCommandVtbl {
        unsafe extern "system" fn Cancel<Impl: IDeferredCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Confidence<Impl: IDeferredCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pconfidence: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Confidence(::core::mem::transmute_copy(&pconfidence)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Postpone<Impl: IDeferredCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Postpone(newtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHResult<Impl: IDeferredCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phrresult: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHResult(::core::mem::transmute_copy(&phrresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDeferredCommand>, base.5, Cancel::<Impl, OFFSET>, Confidence::<Impl, OFFSET>, Postpone::<Impl, OFFSET>, GetHResult::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDigitalCableLocatorImpl: Sized + IATSCLocator2Impl + IATSCLocatorImpl + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDigitalCableLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDigitalCableLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableLocatorVtbl {
    pub const fn new<Impl: IDigitalCableLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDigitalCableLocatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDigitalCableLocator>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDigitalCableTuneRequestImpl: Sized + IATSCChannelTuneRequestImpl + IChannelTuneRequestImpl + ITuneRequestImpl + IDispatchImpl {
    fn MajorChannel();
    fn SetMajorChannel();
    fn SourceID();
    fn SetSourceID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDigitalCableTuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDigitalCableTuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableTuneRequestVtbl {
    pub const fn new<Impl: IDigitalCableTuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDigitalCableTuneRequestVtbl {
        unsafe extern "system" fn MajorChannel<Impl: IDigitalCableTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmajorchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MajorChannel(::core::mem::transmute_copy(&pmajorchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMajorChannel<Impl: IDigitalCableTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, majorchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMajorChannel(majorchannel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceID<Impl: IDigitalCableTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourceid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceID(::core::mem::transmute_copy(&psourceid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceID<Impl: IDigitalCableTuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourceid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceID(sourceid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDigitalCableTuneRequest>, base.5, MajorChannel::<Impl, OFFSET>, SetMajorChannel::<Impl, OFFSET>, SourceID::<Impl, OFFSET>, SetSourceID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDigitalCableTuningSpaceImpl: Sized + IATSCTuningSpaceImpl + IAnalogTVTuningSpaceImpl + ITuningSpaceImpl + IDispatchImpl {
    fn MinMajorChannel();
    fn SetMinMajorChannel();
    fn MaxMajorChannel();
    fn SetMaxMajorChannel();
    fn MinSourceID();
    fn SetMinSourceID();
    fn MaxSourceID();
    fn SetMaxSourceID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDigitalCableTuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDigitalCableTuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableTuningSpaceVtbl {
    pub const fn new<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDigitalCableTuningSpaceVtbl {
        unsafe extern "system" fn MinMajorChannel<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minmajorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinMajorChannel(::core::mem::transmute_copy(&minmajorchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinMajorChannel<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminmajorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinMajorChannel(newminmajorchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxMajorChannel<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxmajorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxMajorChannel(::core::mem::transmute_copy(&maxmajorchannelval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxMajorChannel<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxmajorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxMajorChannel(newmaxmajorchannelval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinSourceID<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, minsourceidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinSourceID(::core::mem::transmute_copy(&minsourceidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinSourceID<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newminsourceidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinSourceID(newminsourceidval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxSourceID<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxsourceidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxSourceID(::core::mem::transmute_copy(&maxsourceidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSourceID<Impl: IDigitalCableTuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newmaxsourceidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxSourceID(newmaxsourceidval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDigitalCableTuningSpace>, base.5, MinMajorChannel::<Impl, OFFSET>, SetMinMajorChannel::<Impl, OFFSET>, MaxMajorChannel::<Impl, OFFSET>, SetMaxMajorChannel::<Impl, OFFSET>, MinSourceID::<Impl, OFFSET>, SetMinSourceID::<Impl, OFFSET>, MaxSourceID::<Impl, OFFSET>, SetMaxSourceID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IDigitalLocatorImpl: Sized + ILocatorImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IDigitalLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDigitalLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalLocatorVtbl {
    pub const fn new<Impl: IDigitalLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDigitalLocatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDigitalLocator>, base.5)
    }
}
pub trait IDirectDrawMediaSampleImpl: Sized {
    fn GetSurfaceAndReleaseLock();
    fn LockMediaSamplePointer();
}
impl ::windows::core::RuntimeName for IDirectDrawMediaSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDirectDrawMediaSample";
}
impl IDirectDrawMediaSampleVtbl {
    pub const fn new<Impl: IDirectDrawMediaSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectDrawMediaSampleVtbl {
        unsafe extern "system" fn GetSurfaceAndReleaseLock<Impl: IDirectDrawMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirectdrawsurface: *mut ::windows::core::RawPtr, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurfaceAndReleaseLock(::core::mem::transmute_copy(&ppdirectdrawsurface), ::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockMediaSamplePointer<Impl: IDirectDrawMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockMediaSamplePointer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectDrawMediaSample>, base.5, GetSurfaceAndReleaseLock::<Impl, OFFSET>, LockMediaSamplePointer::<Impl, OFFSET>)
    }
}
pub trait IDirectDrawMediaSampleAllocatorImpl: Sized {
    fn GetDirectDraw();
}
impl ::windows::core::RuntimeName for IDirectDrawMediaSampleAllocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDirectDrawMediaSampleAllocator";
}
impl IDirectDrawMediaSampleAllocatorVtbl {
    pub const fn new<Impl: IDirectDrawMediaSampleAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectDrawMediaSampleAllocatorVtbl {
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawMediaSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw(::core::mem::transmute_copy(&ppdirectdraw)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectDrawMediaSampleAllocator>, base.5, GetDirectDraw::<Impl, OFFSET>)
    }
}
pub trait IDirectDrawMediaStreamImpl: Sized + IMediaStreamImpl {
    fn GetFormat();
    fn SetFormat();
    fn GetDirectDraw();
    fn SetDirectDraw();
    fn CreateSample();
    fn GetTimePerFrame();
}
impl ::windows::core::RuntimeName for IDirectDrawMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDirectDrawMediaStream";
}
impl IDirectDrawMediaStreamVtbl {
    pub const fn new<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectDrawMediaStreamVtbl {
        unsafe extern "system" fn GetFormat<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: *mut ::windows::core::RawPtr, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormat(::core::mem::transmute_copy(&pddsdcurrent), ::core::mem::transmute_copy(&ppdirectdrawpalette), ::core::mem::transmute_copy(&pddsddesired), ::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFormat(&*(&pddsurfacedesc as *const <super::super::Graphics::DirectDraw::DDSURFACEDESC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDSURFACEDESC as ::windows::core::DefaultType>::DefaultType), &*(&pdirectdrawpalette as *const <super::super::Graphics::DirectDraw::IDirectDrawPalette as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawPalette as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw(::core::mem::transmute_copy(&ppdirectdraw)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDirectDraw<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdirectdraw: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectDraw(&*(&pdirectdraw as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSample<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psurface: ::windows::core::RawPtr, prect: *const super::super::Foundation::RECT, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSample(&*(&psurface as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface as ::windows::core::DefaultType>::DefaultType), &*(&prect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimePerFrame<Impl: IDirectDrawMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pframetime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimePerFrame(::core::mem::transmute_copy(&pframetime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectDrawMediaStream>, base.5, GetFormat::<Impl, OFFSET>, SetFormat::<Impl, OFFSET>, GetDirectDraw::<Impl, OFFSET>, SetDirectDraw::<Impl, OFFSET>, CreateSample::<Impl, OFFSET>, GetTimePerFrame::<Impl, OFFSET>)
    }
}
pub trait IDirectDrawStreamSampleImpl: Sized + IStreamSampleImpl {
    fn GetSurface();
    fn SetRect();
}
impl ::windows::core::RuntimeName for IDirectDrawStreamSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDirectDrawStreamSample";
}
impl IDirectDrawStreamSampleVtbl {
    pub const fn new<Impl: IDirectDrawStreamSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectDrawStreamSampleVtbl {
        unsafe extern "system" fn GetSurface<Impl: IDirectDrawStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirectdrawsurface: *mut ::windows::core::RawPtr, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurface(::core::mem::transmute_copy(&ppdirectdrawsurface), ::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRect<Impl: IDirectDrawStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRect(&*(&prect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectDrawStreamSample>, base.5, GetSurface::<Impl, OFFSET>, SetRect::<Impl, OFFSET>)
    }
}
pub trait IDirectDrawVideoImpl: Sized {
    fn GetSwitches();
    fn SetSwitches();
    fn GetCaps();
    fn GetEmulatedCaps();
    fn GetSurfaceDesc();
    fn GetFourCCCodes();
    fn SetDirectDraw();
    fn GetDirectDraw();
    fn GetSurfaceType();
    fn SetDefault();
    fn UseScanLine();
    fn CanUseScanLine();
    fn UseOverlayStretch();
    fn CanUseOverlayStretch();
    fn UseWhenFullScreen();
    fn WillUseFullScreen();
}
impl ::windows::core::RuntimeName for IDirectDrawVideo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDirectDrawVideo";
}
impl IDirectDrawVideoVtbl {
    pub const fn new<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectDrawVideoVtbl {
        unsafe extern "system" fn GetSwitches<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pswitches: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSwitches(::core::mem::transmute_copy(&pswitches)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSwitches<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, switches: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSwitches(switches) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCaps<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaps(::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEmulatedCaps<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEmulatedCaps(::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurfaceDesc<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurfaceDesc(&*(&psurfacedesc as *const <super::super::Graphics::DirectDraw::DDSURFACEDESC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDSURFACEDESC as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFourCCCodes<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcount: *mut u32, pcodes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFourCCCodes(::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pcodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDirectDraw<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdirectdraw: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectDraw(&*(&pdirectdraw as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw(::core::mem::transmute_copy(&ppdirectdraw)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurfaceType<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psurfacetype: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurfaceType(::core::mem::transmute_copy(&psurfacetype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefault<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefault() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseScanLine<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usescanline: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseScanLine(usescanline) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUseScanLine<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usescanline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanUseScanLine(::core::mem::transmute_copy(&usescanline)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseOverlayStretch<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlaystretch: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseOverlayStretch(useoverlaystretch) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUseOverlayStretch<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlaystretch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanUseOverlayStretch(::core::mem::transmute_copy(&useoverlaystretch)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseWhenFullScreen<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usewhenfullscreen: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseWhenFullScreen(usewhenfullscreen) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WillUseFullScreen<Impl: IDirectDrawVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, usewhenfullscreen: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WillUseFullScreen(::core::mem::transmute_copy(&usewhenfullscreen)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDirectDrawVideo>,
            base.5,
            GetSwitches::<Impl, OFFSET>,
            SetSwitches::<Impl, OFFSET>,
            GetCaps::<Impl, OFFSET>,
            GetEmulatedCaps::<Impl, OFFSET>,
            GetSurfaceDesc::<Impl, OFFSET>,
            GetFourCCCodes::<Impl, OFFSET>,
            SetDirectDraw::<Impl, OFFSET>,
            GetDirectDraw::<Impl, OFFSET>,
            GetSurfaceType::<Impl, OFFSET>,
            SetDefault::<Impl, OFFSET>,
            UseScanLine::<Impl, OFFSET>,
            CanUseScanLine::<Impl, OFFSET>,
            UseOverlayStretch::<Impl, OFFSET>,
            CanUseOverlayStretch::<Impl, OFFSET>,
            UseWhenFullScreen::<Impl, OFFSET>,
            WillUseFullScreen::<Impl, OFFSET>,
        )
    }
}
pub trait IDistributorNotifyImpl: Sized {
    fn Stop();
    fn Pause();
    fn Run();
    fn SetSyncSource();
    fn NotifyGraphChange();
}
impl ::windows::core::RuntimeName for IDistributorNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDistributorNotify";
}
impl IDistributorNotifyVtbl {
    pub const fn new<Impl: IDistributorNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDistributorNotifyVtbl {
        unsafe extern "system" fn Stop<Impl: IDistributorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IDistributorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Run<Impl: IDistributorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tstart: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Run(tstart) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncSource<Impl: IDistributorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncSource(&*(&pclock as *const <super::IReferenceClock as ::windows::core::Abi>::Abi as *const <super::IReferenceClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyGraphChange<Impl: IDistributorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyGraphChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDistributorNotify>, base.5, Stop::<Impl, OFFSET>, Pause::<Impl, OFFSET>, Run::<Impl, OFFSET>, SetSyncSource::<Impl, OFFSET>, NotifyGraphChange::<Impl, OFFSET>)
    }
}
pub trait IDrawVideoImageImpl: Sized {
    fn DrawVideoImageBegin();
    fn DrawVideoImageEnd();
    fn DrawVideoImageDraw();
}
impl ::windows::core::RuntimeName for IDrawVideoImage {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDrawVideoImage";
}
impl IDrawVideoImageVtbl {
    pub const fn new<Impl: IDrawVideoImageImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDrawVideoImageVtbl {
        unsafe extern "system" fn DrawVideoImageBegin<Impl: IDrawVideoImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DrawVideoImageBegin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DrawVideoImageEnd<Impl: IDrawVideoImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DrawVideoImageEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DrawVideoImageDraw<Impl: IDrawVideoImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DrawVideoImageDraw(
                &*(&hdc as *const <super::super::Graphics::Gdi::HDC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HDC as ::windows::core::DefaultType>::DefaultType),
                &*(&lprcsrc as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&lprcdst as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDrawVideoImage>, base.5, DrawVideoImageBegin::<Impl, OFFSET>, DrawVideoImageEnd::<Impl, OFFSET>, DrawVideoImageDraw::<Impl, OFFSET>)
    }
}
pub trait IDvbCableDeliverySystemDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetFrequency();
    fn GetFECOuter();
    fn GetModulation();
    fn GetSymbolRate();
    fn GetFECInner();
}
impl ::windows::core::RuntimeName for IDvbCableDeliverySystemDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbCableDeliverySystemDescriptor";
}
impl IDvbCableDeliverySystemDescriptorVtbl {
    pub const fn new<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbCableDeliverySystemDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrequency<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFrequency(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECOuter<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFECOuter(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModulation<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetModulation(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolRate<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSymbolRate(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECInner<Impl: IDvbCableDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFECInner(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbCableDeliverySystemDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetFrequency::<Impl, OFFSET>, GetFECOuter::<Impl, OFFSET>, GetModulation::<Impl, OFFSET>, GetSymbolRate::<Impl, OFFSET>, GetFECInner::<Impl, OFFSET>)
    }
}
pub trait IDvbComponentDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetStreamContent();
    fn GetComponentType();
    fn GetComponentTag();
    fn GetLanguageCode();
    fn GetTextW();
}
impl ::windows::core::RuntimeName for IDvbComponentDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbComponentDescriptor";
}
impl IDvbComponentDescriptorVtbl {
    pub const fn new<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbComponentDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamContent<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamContent(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentType<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbComponentDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetStreamContent::<Impl, OFFSET>, GetComponentType::<Impl, OFFSET>, GetComponentTag::<Impl, OFFSET>, GetLanguageCode::<Impl, OFFSET>, GetTextW::<Impl, OFFSET>)
    }
}
pub trait IDvbContentDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordContentNibbles();
    fn GetRecordUserNibbles();
}
impl ::windows::core::RuntimeName for IDvbContentDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbContentDescriptor";
}
impl IDvbContentDescriptorVtbl {
    pub const fn new<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbContentDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordContentNibbles<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbvallevel1: *mut u8, pbvallevel2: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordContentNibbles(brecordindex, ::core::mem::transmute_copy(&pbvallevel1), ::core::mem::transmute_copy(&pbvallevel2)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordUserNibbles<Impl: IDvbContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval1: *mut u8, pbval2: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordUserNibbles(brecordindex, ::core::mem::transmute_copy(&pbval1), ::core::mem::transmute_copy(&pbval2)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbContentDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordContentNibbles::<Impl, OFFSET>, GetRecordUserNibbles::<Impl, OFFSET>)
    }
}
pub trait IDvbContentIdentifierDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordCrid();
}
impl ::windows::core::RuntimeName for IDvbContentIdentifierDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbContentIdentifierDescriptor";
}
impl IDvbContentIdentifierDescriptorVtbl {
    pub const fn new<Impl: IDvbContentIdentifierDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbContentIdentifierDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbContentIdentifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbContentIdentifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbContentIdentifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCrid<Impl: IDvbContentIdentifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbtype: *mut u8, pblocation: *mut u8, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCrid(brecordindex, ::core::mem::transmute_copy(&pbtype), ::core::mem::transmute_copy(&pblocation), ::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&ppbbytes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbContentIdentifierDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordCrid::<Impl, OFFSET>)
    }
}
pub trait IDvbDataBroadcastDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetDataBroadcastID();
    fn GetComponentTag();
    fn GetSelectorLength();
    fn GetSelectorBytes();
    fn GetLangID();
    fn GetTextLength();
    fn GetText();
}
impl ::windows::core::RuntimeName for IDvbDataBroadcastDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbDataBroadcastDescriptor";
}
impl IDvbDataBroadcastDescriptorVtbl {
    pub const fn new<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbDataBroadcastDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBroadcastID<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataBroadcastID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorLength<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectorLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorBytes<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectorBytes(pblen, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLangID<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLangID(::core::mem::transmute_copy(&pulval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextLength<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetText<Impl: IDvbDataBroadcastDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetText(pblen, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbDataBroadcastDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetDataBroadcastID::<Impl, OFFSET>, GetComponentTag::<Impl, OFFSET>, GetSelectorLength::<Impl, OFFSET>, GetSelectorBytes::<Impl, OFFSET>, GetLangID::<Impl, OFFSET>, GetTextLength::<Impl, OFFSET>, GetText::<Impl, OFFSET>)
    }
}
pub trait IDvbDataBroadcastIDDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetDataBroadcastID();
    fn GetIDSelectorBytes();
}
impl ::windows::core::RuntimeName for IDvbDataBroadcastIDDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbDataBroadcastIDDescriptor";
}
impl IDvbDataBroadcastIDDescriptorVtbl {
    pub const fn new<Impl: IDvbDataBroadcastIDDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbDataBroadcastIDDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDataBroadcastIDDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDataBroadcastIDDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBroadcastID<Impl: IDvbDataBroadcastIDDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataBroadcastID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIDSelectorBytes<Impl: IDvbDataBroadcastIDDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIDSelectorBytes(pblen, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbDataBroadcastIDDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetDataBroadcastID::<Impl, OFFSET>, GetIDSelectorBytes::<Impl, OFFSET>)
    }
}
pub trait IDvbDefaultAuthorityDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetDefaultAuthority();
}
impl ::windows::core::RuntimeName for IDvbDefaultAuthorityDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbDefaultAuthorityDescriptor";
}
impl IDvbDefaultAuthorityDescriptorVtbl {
    pub const fn new<Impl: IDvbDefaultAuthorityDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbDefaultAuthorityDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDefaultAuthorityDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDefaultAuthorityDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultAuthority<Impl: IDvbDefaultAuthorityDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultAuthority(::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&ppbbytes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbDefaultAuthorityDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetDefaultAuthority::<Impl, OFFSET>)
    }
}
pub trait IDvbExtendedEventDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetDescriptorNumber();
    fn GetLastDescriptorNumber();
    fn GetLanguageCode();
    fn GetCountOfRecords();
    fn GetRecordItemW();
    fn GetConcatenatedItemW();
    fn GetTextW();
    fn GetConcatenatedTextW();
    fn GetRecordItemRawBytes();
}
impl ::windows::core::RuntimeName for IDvbExtendedEventDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbExtendedEventDescriptor";
}
impl IDvbExtendedEventDescriptorVtbl {
    pub const fn new<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbExtendedEventDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescriptorNumber<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescriptorNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastDescriptorNumber<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastDescriptorNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordItemW<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordItemW(brecordindex, convmode, ::core::mem::transmute_copy(&pbstrdesc), ::core::mem::transmute_copy(&pbstritem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConcatenatedItemW<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfollowingdescriptor: ::windows::core::RawPtr, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConcatenatedItemW(&*(&pfollowingdescriptor as *const <IDvbExtendedEventDescriptor as ::windows::core::Abi>::Abi as *const <IDvbExtendedEventDescriptor as ::windows::core::DefaultType>::DefaultType), convmode, ::core::mem::transmute_copy(&pbstrdesc), ::core::mem::transmute_copy(&pbstritem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConcatenatedTextW<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, followingdescriptor: ::windows::core::RawPtr, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConcatenatedTextW(&*(&followingdescriptor as *const <IDvbExtendedEventDescriptor as ::windows::core::Abi>::Abi as *const <IDvbExtendedEventDescriptor as ::windows::core::DefaultType>::DefaultType), convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordItemRawBytes<Impl: IDvbExtendedEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ppbrawitem: *mut *mut u8, pbitemlength: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordItemRawBytes(brecordindex, ::core::mem::transmute_copy(&ppbrawitem), ::core::mem::transmute_copy(&pbitemlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbExtendedEventDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetDescriptorNumber::<Impl, OFFSET>, GetLastDescriptorNumber::<Impl, OFFSET>, GetLanguageCode::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordItemW::<Impl, OFFSET>, GetConcatenatedItemW::<Impl, OFFSET>, GetTextW::<Impl, OFFSET>, GetConcatenatedTextW::<Impl, OFFSET>, GetRecordItemRawBytes::<Impl, OFFSET>)
    }
}
pub trait IDvbFrequencyListDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCodingType();
    fn GetCountOfRecords();
    fn GetRecordCentreFrequency();
}
impl ::windows::core::RuntimeName for IDvbFrequencyListDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbFrequencyListDescriptor";
}
impl IDvbFrequencyListDescriptorVtbl {
    pub const fn new<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbFrequencyListDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodingType<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodingType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCentreFrequency<Impl: IDvbFrequencyListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCentreFrequency(brecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbFrequencyListDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCodingType::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordCentreFrequency::<Impl, OFFSET>)
    }
}
pub trait IDvbHDSimulcastLogicalChannelDescriptorImpl: Sized + IDvbLogicalChannelDescriptor2Impl + IDvbLogicalChannelDescriptorImpl {}
impl ::windows::core::RuntimeName for IDvbHDSimulcastLogicalChannelDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbHDSimulcastLogicalChannelDescriptor";
}
impl IDvbHDSimulcastLogicalChannelDescriptorVtbl {
    pub const fn new<Impl: IDvbHDSimulcastLogicalChannelDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbHDSimulcastLogicalChannelDescriptorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbHDSimulcastLogicalChannelDescriptor>, base.5)
    }
}
pub trait IDvbLinkageDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetTSId();
    fn GetONId();
    fn GetServiceId();
    fn GetLinkageType();
    fn GetPrivateDataLength();
    fn GetPrivateData();
}
impl ::windows::core::RuntimeName for IDvbLinkageDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbLinkageDescriptor";
}
impl IDvbLinkageDescriptorVtbl {
    pub const fn new<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbLinkageDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSId<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTSId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetONId<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetONId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLinkageType<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLinkageType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataLength<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateData<Impl: IDvbLinkageDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateData(pblen, ::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbLinkageDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetTSId::<Impl, OFFSET>, GetONId::<Impl, OFFSET>, GetServiceId::<Impl, OFFSET>, GetLinkageType::<Impl, OFFSET>, GetPrivateDataLength::<Impl, OFFSET>, GetPrivateData::<Impl, OFFSET>)
    }
}
pub trait IDvbLogicalChannel2DescriptorImpl: Sized + IDvbLogicalChannelDescriptor2Impl + IDvbLogicalChannelDescriptorImpl {
    fn GetCountOfLists();
    fn GetListId();
    fn GetListNameW();
    fn GetListCountryCode();
    fn GetListCountOfRecords();
    fn GetListRecordServiceId();
    fn GetListRecordLogicalChannelNumber();
    fn GetListRecordLogicalChannelAndVisibility();
}
impl ::windows::core::RuntimeName for IDvbLogicalChannel2Descriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbLogicalChannel2Descriptor";
}
impl IDvbLogicalChannel2DescriptorVtbl {
    pub const fn new<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbLogicalChannel2DescriptorVtbl {
        unsafe extern "system" fn GetCountOfLists<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfLists(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListId<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListId(blistindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListNameW<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListNameW(blistindex, convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListCountryCode<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListCountryCode(blistindex, ::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListCountOfRecords<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bchannellistindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListCountOfRecords(bchannellistindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordServiceId<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListRecordServiceId(blistindex, brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordLogicalChannelNumber<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListRecordLogicalChannelNumber(blistindex, brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordLogicalChannelAndVisibility<Impl: IDvbLogicalChannel2DescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetListRecordLogicalChannelAndVisibility(blistindex, brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbLogicalChannel2Descriptor>, base.5, GetCountOfLists::<Impl, OFFSET>, GetListId::<Impl, OFFSET>, GetListNameW::<Impl, OFFSET>, GetListCountryCode::<Impl, OFFSET>, GetListCountOfRecords::<Impl, OFFSET>, GetListRecordServiceId::<Impl, OFFSET>, GetListRecordLogicalChannelNumber::<Impl, OFFSET>, GetListRecordLogicalChannelAndVisibility::<Impl, OFFSET>)
    }
}
pub trait IDvbLogicalChannelDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordServiceId();
    fn GetRecordLogicalChannelNumber();
}
impl ::windows::core::RuntimeName for IDvbLogicalChannelDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbLogicalChannelDescriptor";
}
impl IDvbLogicalChannelDescriptorVtbl {
    pub const fn new<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbLogicalChannelDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLogicalChannelNumber<Impl: IDvbLogicalChannelDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordLogicalChannelNumber(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbLogicalChannelDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordServiceId::<Impl, OFFSET>, GetRecordLogicalChannelNumber::<Impl, OFFSET>)
    }
}
pub trait IDvbLogicalChannelDescriptor2Impl: Sized + IDvbLogicalChannelDescriptorImpl {
    fn GetRecordLogicalChannelAndVisibility();
}
impl ::windows::core::RuntimeName for IDvbLogicalChannelDescriptor2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbLogicalChannelDescriptor2";
}
impl IDvbLogicalChannelDescriptor2Vtbl {
    pub const fn new<Impl: IDvbLogicalChannelDescriptor2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbLogicalChannelDescriptor2Vtbl {
        unsafe extern "system" fn GetRecordLogicalChannelAndVisibility<Impl: IDvbLogicalChannelDescriptor2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordLogicalChannelAndVisibility(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbLogicalChannelDescriptor2>, base.5, GetRecordLogicalChannelAndVisibility::<Impl, OFFSET>)
    }
}
pub trait IDvbMultilingualServiceNameDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordLangId();
    fn GetRecordServiceProviderNameW();
    fn GetRecordServiceNameW();
}
impl ::windows::core::RuntimeName for IDvbMultilingualServiceNameDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbMultilingualServiceNameDescriptor";
}
impl IDvbMultilingualServiceNameDescriptorVtbl {
    pub const fn new<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbMultilingualServiceNameDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(brecordindex, ::core::mem::transmute_copy(&ulval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceProviderNameW<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceProviderNameW(brecordindex, convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceNameW<Impl: IDvbMultilingualServiceNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceNameW(brecordindex, convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbMultilingualServiceNameDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordLangId::<Impl, OFFSET>, GetRecordServiceProviderNameW::<Impl, OFFSET>, GetRecordServiceNameW::<Impl, OFFSET>)
    }
}
pub trait IDvbNetworkNameDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetNetworkName();
    fn GetNetworkNameW();
}
impl ::windows::core::RuntimeName for IDvbNetworkNameDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbNetworkNameDescriptor";
}
impl IDvbNetworkNameDescriptorVtbl {
    pub const fn new<Impl: IDvbNetworkNameDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbNetworkNameDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbNetworkNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbNetworkNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkName<Impl: IDvbNetworkNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkName(::core::mem::transmute_copy(&pszname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkNameW<Impl: IDvbNetworkNameDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbNetworkNameDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetNetworkName::<Impl, OFFSET>, GetNetworkNameW::<Impl, OFFSET>)
    }
}
pub trait IDvbParentalRatingDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordRating();
}
impl ::windows::core::RuntimeName for IDvbParentalRatingDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbParentalRatingDescriptor";
}
impl IDvbParentalRatingDescriptorVtbl {
    pub const fn new<Impl: IDvbParentalRatingDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbParentalRatingDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbParentalRatingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbParentalRatingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbParentalRatingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRating<Impl: IDvbParentalRatingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pszcountrycode: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordRating(brecordindex, ::core::mem::transmute_copy(&pszcountrycode), ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbParentalRatingDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordRating::<Impl, OFFSET>)
    }
}
pub trait IDvbPrivateDataSpecifierDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetPrivateDataSpecifier();
}
impl ::windows::core::RuntimeName for IDvbPrivateDataSpecifierDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbPrivateDataSpecifierDescriptor";
}
impl IDvbPrivateDataSpecifierDescriptorVtbl {
    pub const fn new<Impl: IDvbPrivateDataSpecifierDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbPrivateDataSpecifierDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbPrivateDataSpecifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbPrivateDataSpecifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataSpecifier<Impl: IDvbPrivateDataSpecifierDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataSpecifier(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbPrivateDataSpecifierDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetPrivateDataSpecifier::<Impl, OFFSET>)
    }
}
pub trait IDvbSatelliteDeliverySystemDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetFrequency();
    fn GetOrbitalPosition();
    fn GetWestEastFlag();
    fn GetPolarization();
    fn GetModulation();
    fn GetSymbolRate();
    fn GetFECInner();
}
impl ::windows::core::RuntimeName for IDvbSatelliteDeliverySystemDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbSatelliteDeliverySystemDescriptor";
}
impl IDvbSatelliteDeliverySystemDescriptorVtbl {
    pub const fn new<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbSatelliteDeliverySystemDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrequency<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFrequency(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOrbitalPosition<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOrbitalPosition(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWestEastFlag<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWestEastFlag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPolarization<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPolarization(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModulation<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetModulation(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolRate<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSymbolRate(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECInner<Impl: IDvbSatelliteDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFECInner(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbSatelliteDeliverySystemDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetFrequency::<Impl, OFFSET>, GetOrbitalPosition::<Impl, OFFSET>, GetWestEastFlag::<Impl, OFFSET>, GetPolarization::<Impl, OFFSET>, GetModulation::<Impl, OFFSET>, GetSymbolRate::<Impl, OFFSET>, GetFECInner::<Impl, OFFSET>)
    }
}
pub trait IDvbServiceAttributeDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordServiceId();
    fn GetRecordNumericSelectionFlag();
    fn GetRecordVisibleServiceFlag();
}
impl ::windows::core::RuntimeName for IDvbServiceAttributeDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbServiceAttributeDescriptor";
}
impl IDvbServiceAttributeDescriptorVtbl {
    pub const fn new<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbServiceAttributeDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumericSelectionFlag<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNumericSelectionFlag(brecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVisibleServiceFlag<Impl: IDvbServiceAttributeDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordVisibleServiceFlag(brecordindex, ::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbServiceAttributeDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordServiceId::<Impl, OFFSET>, GetRecordNumericSelectionFlag::<Impl, OFFSET>, GetRecordVisibleServiceFlag::<Impl, OFFSET>)
    }
}
pub trait IDvbServiceDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetServiceType();
    fn GetServiceProviderName();
    fn GetServiceProviderNameW();
    fn GetServiceName();
    fn GetProcessedServiceName();
    fn GetServiceNameEmphasized();
}
impl ::windows::core::RuntimeName for IDvbServiceDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbServiceDescriptor";
}
impl IDvbServiceDescriptorVtbl {
    pub const fn new<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbServiceDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceType<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProviderName<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderName(::core::mem::transmute_copy(&pszname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProviderNameW<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderNameW(::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceName<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceName(::core::mem::transmute_copy(&pszname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessedServiceName<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcessedServiceName(::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceNameEmphasized<Impl: IDvbServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceNameEmphasized(::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbServiceDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetServiceType::<Impl, OFFSET>, GetServiceProviderName::<Impl, OFFSET>, GetServiceProviderNameW::<Impl, OFFSET>, GetServiceName::<Impl, OFFSET>, GetProcessedServiceName::<Impl, OFFSET>, GetServiceNameEmphasized::<Impl, OFFSET>)
    }
}
pub trait IDvbServiceDescriptor2Impl: Sized + IDvbServiceDescriptorImpl {
    fn GetServiceProviderNameW();
    fn GetServiceNameW();
}
impl ::windows::core::RuntimeName for IDvbServiceDescriptor2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbServiceDescriptor2";
}
impl IDvbServiceDescriptor2Vtbl {
    pub const fn new<Impl: IDvbServiceDescriptor2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbServiceDescriptor2Vtbl {
        unsafe extern "system" fn GetServiceProviderNameW<Impl: IDvbServiceDescriptor2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceNameW<Impl: IDvbServiceDescriptor2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbServiceDescriptor2>, base.5, GetServiceProviderNameW::<Impl, OFFSET>, GetServiceNameW::<Impl, OFFSET>)
    }
}
pub trait IDvbServiceListDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordServiceId();
    fn GetRecordServiceType();
}
impl ::windows::core::RuntimeName for IDvbServiceListDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbServiceListDescriptor";
}
impl IDvbServiceListDescriptorVtbl {
    pub const fn new<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbServiceListDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceType<Impl: IDvbServiceListDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceType(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbServiceListDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordServiceId::<Impl, OFFSET>, GetRecordServiceType::<Impl, OFFSET>)
    }
}
pub trait IDvbShortEventDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetLanguageCode();
    fn GetEventNameW();
    fn GetTextW();
}
impl ::windows::core::RuntimeName for IDvbShortEventDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbShortEventDescriptor";
}
impl IDvbShortEventDescriptorVtbl {
    pub const fn new<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbShortEventDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEventNameW<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEventNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbShortEventDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbShortEventDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetLanguageCode::<Impl, OFFSET>, GetEventNameW::<Impl, OFFSET>, GetTextW::<Impl, OFFSET>)
    }
}
pub trait IDvbSiParserImpl: Sized {
    fn Initialize();
    fn GetPAT();
    fn GetCAT();
    fn GetPMT();
    fn GetTSDT();
    fn GetNIT();
    fn GetSDT();
    fn GetEIT();
    fn GetBAT();
    fn GetRST();
    fn GetST();
    fn GetTDT();
    fn GetTOT();
    fn GetDIT();
    fn GetSIT();
}
impl ::windows::core::RuntimeName for IDvbSiParser {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbSiParser";
}
impl IDvbSiParserVtbl {
    pub const fn new<Impl: IDvbSiParserImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbSiParserVtbl {
        unsafe extern "system" fn Initialize<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkmpeg2data: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&punkmpeg2data as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPAT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPAT(::core::mem::transmute_copy(&pppat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCAT(dwtimeout, ::core::mem::transmute_copy(&ppcat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPMT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, pwprogramnumber: *const u16, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPMT(pid, pwprogramnumber, ::core::mem::transmute_copy(&pppmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSDT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTSDT(::core::mem::transmute_copy(&pptsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNIT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwnetworkid: *const u16, ppnit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNIT(tableid, pwnetworkid, ::core::mem::transmute_copy(&ppnit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSDT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtransportstreamid: *const u16, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSDT(tableid, pwtransportstreamid, ::core::mem::transmute_copy(&ppsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEIT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwserviceid: *const u16, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEIT(tableid, pwserviceid, ::core::mem::transmute_copy(&ppeit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBAT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwbouquetid: *const u16, ppbat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBAT(pwbouquetid, ::core::mem::transmute_copy(&ppbat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRST<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, pprst: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRST(dwtimeout, ::core::mem::transmute_copy(&pprst)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetST<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, dwtimeout: u32, ppst: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetST(pid, dwtimeout, ::core::mem::transmute_copy(&ppst)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTDT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTDT(::core::mem::transmute_copy(&pptdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTOT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptot: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTOT(::core::mem::transmute_copy(&pptot)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDIT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppdit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDIT(dwtimeout, ::core::mem::transmute_copy(&ppdit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSIT<Impl: IDvbSiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSIT(dwtimeout, ::core::mem::transmute_copy(&ppsit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbSiParser>, base.5, Initialize::<Impl, OFFSET>, GetPAT::<Impl, OFFSET>, GetCAT::<Impl, OFFSET>, GetPMT::<Impl, OFFSET>, GetTSDT::<Impl, OFFSET>, GetNIT::<Impl, OFFSET>, GetSDT::<Impl, OFFSET>, GetEIT::<Impl, OFFSET>, GetBAT::<Impl, OFFSET>, GetRST::<Impl, OFFSET>, GetST::<Impl, OFFSET>, GetTDT::<Impl, OFFSET>, GetTOT::<Impl, OFFSET>, GetDIT::<Impl, OFFSET>, GetSIT::<Impl, OFFSET>)
    }
}
pub trait IDvbSiParser2Impl: Sized + IDvbSiParserImpl {
    fn GetEIT2();
}
impl ::windows::core::RuntimeName for IDvbSiParser2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbSiParser2";
}
impl IDvbSiParser2Vtbl {
    pub const fn new<Impl: IDvbSiParser2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbSiParser2Vtbl {
        unsafe extern "system" fn GetEIT2<Impl: IDvbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwserviceid: *const u16, pbsegment: *const u8, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEIT2(tableid, pwserviceid, pbsegment, ::core::mem::transmute_copy(&ppeit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbSiParser2>, base.5, GetEIT2::<Impl, OFFSET>)
    }
}
pub trait IDvbSubtitlingDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordLangId();
    fn GetRecordSubtitlingType();
    fn GetRecordCompositionPageID();
    fn GetRecordAncillaryPageID();
}
impl ::windows::core::RuntimeName for IDvbSubtitlingDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbSubtitlingDescriptor";
}
impl IDvbSubtitlingDescriptorVtbl {
    pub const fn new<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbSubtitlingDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(brecordindex, ::core::mem::transmute_copy(&pulval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordSubtitlingType<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordSubtitlingType(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCompositionPageID<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCompositionPageID(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordAncillaryPageID<Impl: IDvbSubtitlingDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordAncillaryPageID(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbSubtitlingDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordLangId::<Impl, OFFSET>, GetRecordSubtitlingType::<Impl, OFFSET>, GetRecordCompositionPageID::<Impl, OFFSET>, GetRecordAncillaryPageID::<Impl, OFFSET>)
    }
}
pub trait IDvbTeletextDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetRecordLangId();
    fn GetRecordTeletextType();
    fn GetRecordMagazineNumber();
    fn GetRecordPageNumber();
}
impl ::windows::core::RuntimeName for IDvbTeletextDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbTeletextDescriptor";
}
impl IDvbTeletextDescriptorVtbl {
    pub const fn new<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbTeletextDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(brecordindex, ::core::mem::transmute_copy(&pulval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTeletextType<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTeletextType(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMagazineNumber<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordMagazineNumber(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordPageNumber<Impl: IDvbTeletextDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordPageNumber(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvbTeletextDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordLangId::<Impl, OFFSET>, GetRecordTeletextType::<Impl, OFFSET>, GetRecordMagazineNumber::<Impl, OFFSET>, GetRecordPageNumber::<Impl, OFFSET>)
    }
}
pub trait IDvbTerrestrial2DeliverySystemDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetTagExtension();
    fn GetCentreFrequency();
    fn GetPLPId();
    fn GetT2SystemId();
    fn GetMultipleInputMode();
    fn GetBandwidth();
    fn GetGuardInterval();
    fn GetTransmissionMode();
    fn GetCellId();
    fn GetOtherFrequencyFlag();
    fn GetTFSFlag();
}
impl ::windows::core::RuntimeName for IDvbTerrestrial2DeliverySystemDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbTerrestrial2DeliverySystemDescriptor";
}
impl IDvbTerrestrial2DeliverySystemDescriptorVtbl {
    pub const fn new<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbTerrestrial2DeliverySystemDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTagExtension<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTagExtension(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCentreFrequency<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCentreFrequency(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPLPId<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPLPId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetT2SystemId<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetT2SystemId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMultipleInputMode<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMultipleInputMode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidth<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBandwidth(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCellId<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCellId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOtherFrequencyFlag<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOtherFrequencyFlag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTFSFlag<Impl: IDvbTerrestrial2DeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTFSFlag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvbTerrestrial2DeliverySystemDescriptor>,
            base.5,
            GetTag::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            GetTagExtension::<Impl, OFFSET>,
            GetCentreFrequency::<Impl, OFFSET>,
            GetPLPId::<Impl, OFFSET>,
            GetT2SystemId::<Impl, OFFSET>,
            GetMultipleInputMode::<Impl, OFFSET>,
            GetBandwidth::<Impl, OFFSET>,
            GetGuardInterval::<Impl, OFFSET>,
            GetTransmissionMode::<Impl, OFFSET>,
            GetCellId::<Impl, OFFSET>,
            GetOtherFrequencyFlag::<Impl, OFFSET>,
            GetTFSFlag::<Impl, OFFSET>,
        )
    }
}
pub trait IDvbTerrestrialDeliverySystemDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCentreFrequency();
    fn GetBandwidth();
    fn GetConstellation();
    fn GetHierarchyInformation();
    fn GetCodeRateHPStream();
    fn GetCodeRateLPStream();
    fn GetGuardInterval();
    fn GetTransmissionMode();
    fn GetOtherFrequencyFlag();
}
impl ::windows::core::RuntimeName for IDvbTerrestrialDeliverySystemDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvbTerrestrialDeliverySystemDescriptor";
}
impl IDvbTerrestrialDeliverySystemDescriptorVtbl {
    pub const fn new<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvbTerrestrialDeliverySystemDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCentreFrequency<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCentreFrequency(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidth<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBandwidth(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConstellation<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConstellation(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHierarchyInformation<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHierarchyInformation(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodeRateHPStream<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodeRateHPStream(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodeRateLPStream<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodeRateLPStream(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOtherFrequencyFlag<Impl: IDvbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOtherFrequencyFlag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvbTerrestrialDeliverySystemDescriptor>,
            base.5,
            GetTag::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            GetCentreFrequency::<Impl, OFFSET>,
            GetBandwidth::<Impl, OFFSET>,
            GetConstellation::<Impl, OFFSET>,
            GetHierarchyInformation::<Impl, OFFSET>,
            GetCodeRateHPStream::<Impl, OFFSET>,
            GetCodeRateLPStream::<Impl, OFFSET>,
            GetGuardInterval::<Impl, OFFSET>,
            GetTransmissionMode::<Impl, OFFSET>,
            GetOtherFrequencyFlag::<Impl, OFFSET>,
        )
    }
}
pub trait IDvdCmdImpl: Sized {
    fn WaitForStart();
    fn WaitForEnd();
}
impl ::windows::core::RuntimeName for IDvdCmd {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdCmd";
}
impl IDvdCmdVtbl {
    pub const fn new<Impl: IDvdCmdImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdCmdVtbl {
        unsafe extern "system" fn WaitForStart<Impl: IDvdCmdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitForStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WaitForEnd<Impl: IDvdCmdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitForEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvdCmd>, base.5, WaitForStart::<Impl, OFFSET>, WaitForEnd::<Impl, OFFSET>)
    }
}
pub trait IDvdControlImpl: Sized {
    fn TitlePlay();
    fn ChapterPlay();
    fn TimePlay();
    fn StopForResume();
    fn GoUp();
    fn TimeSearch();
    fn ChapterSearch();
    fn PrevPGSearch();
    fn TopPGSearch();
    fn NextPGSearch();
    fn ForwardScan();
    fn BackwardScan();
    fn MenuCall();
    fn Resume();
    fn UpperButtonSelect();
    fn LowerButtonSelect();
    fn LeftButtonSelect();
    fn RightButtonSelect();
    fn ButtonActivate();
    fn ButtonSelectAndActivate();
    fn StillOff();
    fn PauseOn();
    fn PauseOff();
    fn MenuLanguageSelect();
    fn AudioStreamChange();
    fn SubpictureStreamChange();
    fn AngleChange();
    fn ParentalLevelSelect();
    fn ParentalCountrySelect();
    fn KaraokeAudioPresentationModeChange();
    fn VideoModePreferrence();
    fn SetRoot();
    fn MouseActivate();
    fn MouseSelect();
    fn ChapterPlayAutoStop();
}
impl ::windows::core::RuntimeName for IDvdControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdControl";
}
impl IDvdControlVtbl {
    pub const fn new<Impl: IDvdControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdControlVtbl {
        unsafe extern "system" fn TitlePlay<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitlePlay(ultitle) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChapterPlay<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChapterPlay(ultitle, ulchapter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimePlay<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, bcdtime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimePlay(ultitle, bcdtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopForResume<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopForResume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GoUp<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GoUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeSearch<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bcdtime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeSearch(bcdtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChapterSearch<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulchapter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChapterSearch(ulchapter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrevPGSearch<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrevPGSearch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPGSearch<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopPGSearch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NextPGSearch<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NextPGSearch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardScan<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwspeed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForwardScan(dwspeed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackwardScan<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwspeed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackwardScan(dwspeed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuCall<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, menuid: DVD_MENU_ID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuCall(menuid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Resume<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Resume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpperButtonSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpperButtonSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LowerButtonSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LowerButtonSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftButtonSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftButtonSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightButtonSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightButtonSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonActivate<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonActivate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonSelectAndActivate<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonSelectAndActivate(ulbutton) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StillOff<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StillOff() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PauseOn<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PauseOn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PauseOff<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PauseOff() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuLanguageSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, language: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuLanguageSelect(language) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamChange<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulaudio: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamChange(ulaudio) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SubpictureStreamChange<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulsubpicture: u32, bdisplay: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SubpictureStreamChange(ulsubpicture, &*(&bdisplay as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AngleChange<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulangle: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AngleChange(ulangle) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParentalLevelSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulparentallevel: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParentalLevelSelect(ulparentallevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParentalCountrySelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wcountry: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParentalCountrySelect(wcountry) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeAudioPresentationModeChange<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KaraokeAudioPresentationModeChange(ulmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoModePreferrence<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpreferreddisplaymode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoModePreferrence(ulpreferreddisplaymode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRoot<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRoot(&*(&pszpath as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MouseActivate<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MouseActivate(&*(&point as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MouseSelect<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MouseSelect(&*(&point as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChapterPlayAutoStop<Impl: IDvdControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChapterPlayAutoStop(ultitle, ulchapter, ulchapterstoplay) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvdControl>,
            base.5,
            TitlePlay::<Impl, OFFSET>,
            ChapterPlay::<Impl, OFFSET>,
            TimePlay::<Impl, OFFSET>,
            StopForResume::<Impl, OFFSET>,
            GoUp::<Impl, OFFSET>,
            TimeSearch::<Impl, OFFSET>,
            ChapterSearch::<Impl, OFFSET>,
            PrevPGSearch::<Impl, OFFSET>,
            TopPGSearch::<Impl, OFFSET>,
            NextPGSearch::<Impl, OFFSET>,
            ForwardScan::<Impl, OFFSET>,
            BackwardScan::<Impl, OFFSET>,
            MenuCall::<Impl, OFFSET>,
            Resume::<Impl, OFFSET>,
            UpperButtonSelect::<Impl, OFFSET>,
            LowerButtonSelect::<Impl, OFFSET>,
            LeftButtonSelect::<Impl, OFFSET>,
            RightButtonSelect::<Impl, OFFSET>,
            ButtonActivate::<Impl, OFFSET>,
            ButtonSelectAndActivate::<Impl, OFFSET>,
            StillOff::<Impl, OFFSET>,
            PauseOn::<Impl, OFFSET>,
            PauseOff::<Impl, OFFSET>,
            MenuLanguageSelect::<Impl, OFFSET>,
            AudioStreamChange::<Impl, OFFSET>,
            SubpictureStreamChange::<Impl, OFFSET>,
            AngleChange::<Impl, OFFSET>,
            ParentalLevelSelect::<Impl, OFFSET>,
            ParentalCountrySelect::<Impl, OFFSET>,
            KaraokeAudioPresentationModeChange::<Impl, OFFSET>,
            VideoModePreferrence::<Impl, OFFSET>,
            SetRoot::<Impl, OFFSET>,
            MouseActivate::<Impl, OFFSET>,
            MouseSelect::<Impl, OFFSET>,
            ChapterPlayAutoStop::<Impl, OFFSET>,
        )
    }
}
pub trait IDvdControl2Impl: Sized {
    fn PlayTitle();
    fn PlayChapterInTitle();
    fn PlayAtTimeInTitle();
    fn Stop();
    fn ReturnFromSubmenu();
    fn PlayAtTime();
    fn PlayChapter();
    fn PlayPrevChapter();
    fn ReplayChapter();
    fn PlayNextChapter();
    fn PlayForwards();
    fn PlayBackwards();
    fn ShowMenu();
    fn Resume();
    fn SelectRelativeButton();
    fn ActivateButton();
    fn SelectButton();
    fn SelectAndActivateButton();
    fn StillOff();
    fn Pause();
    fn SelectAudioStream();
    fn SelectSubpictureStream();
    fn SetSubpictureState();
    fn SelectAngle();
    fn SelectParentalLevel();
    fn SelectParentalCountry();
    fn SelectKaraokeAudioPresentationMode();
    fn SelectVideoModePreference();
    fn SetDVDDirectory();
    fn ActivateAtPosition();
    fn SelectAtPosition();
    fn PlayChaptersAutoStop();
    fn AcceptParentalLevelChange();
    fn SetOption();
    fn SetState();
    fn PlayPeriodInTitleAutoStop();
    fn SetGPRM();
    fn SelectDefaultMenuLanguage();
    fn SelectDefaultAudioLanguage();
    fn SelectDefaultSubpictureLanguage();
}
impl ::windows::core::RuntimeName for IDvdControl2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdControl2";
}
impl IDvdControl2Vtbl {
    pub const fn new<Impl: IDvdControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdControl2Vtbl {
        unsafe extern "system" fn PlayTitle<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayTitle(ultitle, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapterInTitle(ultitle, ulchapter, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTimeInTitle(ultitle, &*(&pstarttime as *const <DVD_HMSF_TIMECODE as ::windows::core::Abi>::Abi as *const <DVD_HMSF_TIMECODE as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReturnFromSubmenu(dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTime<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTime(&*(&ptime as *const <DVD_HMSF_TIMECODE as ::windows::core::Abi>::Abi as *const <DVD_HMSF_TIMECODE as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapter<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulchapter: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapter(ulchapter, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayPrevChapter(dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReplayChapter<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReplayChapter(dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayNextChapter(dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayForwards<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayForwards(dspeed, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayBackwards<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayBackwards(dspeed, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowMenu<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, menuid: DVD_MENU_ID, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowMenu(menuid, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Resume<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Resume(dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectRelativeButton<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buttondir: DVD_RELATIVE_BUTTON) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectRelativeButton(buttondir) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActivateButton<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectButton<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectButton(ulbutton) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAndActivateButton<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAndActivateButton(ulbutton) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StillOff<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StillOff() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause(&*(&bstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAudioStream<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulaudio: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAudioStream(ulaudio, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectSubpictureStream<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulsubpicture: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectSubpictureStream(ulsubpicture, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubpictureState<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSubpictureState(&*(&bstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAngle<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulangle: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAngle(ulangle, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectParentalLevel<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulparentallevel: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectParentalLevel(ulparentallevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectParentalCountry<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bcountry: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectParentalCountry(bcountry) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectKaraokeAudioPresentationMode<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectKaraokeAudioPresentationMode(ulmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectVideoModePreference<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulpreferreddisplaymode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectVideoModePreference(ulpreferreddisplaymode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDVDDirectory<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDVDDirectory(&*(&pszwpath as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActivateAtPosition<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateAtPosition(&*(&point as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAtPosition<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAtPosition(&*(&point as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChaptersAutoStop<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChaptersAutoStop(ultitle, ulchapter, ulchapterstoplay, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptParentalLevelChange<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baccept: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptParentalLevelChange(&*(&baccept as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOption<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flag: DVD_OPTION_FLAG, fstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOption(flag, &*(&fstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetState<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstate: ::windows::core::RawPtr, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetState(&*(&pstate as *const <IDvdState as ::windows::core::Abi>::Abi as *const <IDvdState as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPeriodInTitleAutoStop<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, pendtime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayPeriodInTitleAutoStop(ultitle, &*(&pstarttime as *const <DVD_HMSF_TIMECODE as ::windows::core::Abi>::Abi as *const <DVD_HMSF_TIMECODE as ::windows::core::DefaultType>::DefaultType), &*(&pendtime as *const <DVD_HMSF_TIMECODE as ::windows::core::Abi>::Abi as *const <DVD_HMSF_TIMECODE as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGPRM<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulindex: u32, wvalue: u16, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGPRM(ulindex, wvalue, dwflags, ::core::mem::transmute_copy(&ppcmd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultMenuLanguage<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, language: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectDefaultMenuLanguage(language) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultAudioLanguage<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectDefaultAudioLanguage(language, audioextension) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultSubpictureLanguage<Impl: IDvdControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectDefaultSubpictureLanguage(language, subpictureextension) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvdControl2>,
            base.5,
            PlayTitle::<Impl, OFFSET>,
            PlayChapterInTitle::<Impl, OFFSET>,
            PlayAtTimeInTitle::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            ReturnFromSubmenu::<Impl, OFFSET>,
            PlayAtTime::<Impl, OFFSET>,
            PlayChapter::<Impl, OFFSET>,
            PlayPrevChapter::<Impl, OFFSET>,
            ReplayChapter::<Impl, OFFSET>,
            PlayNextChapter::<Impl, OFFSET>,
            PlayForwards::<Impl, OFFSET>,
            PlayBackwards::<Impl, OFFSET>,
            ShowMenu::<Impl, OFFSET>,
            Resume::<Impl, OFFSET>,
            SelectRelativeButton::<Impl, OFFSET>,
            ActivateButton::<Impl, OFFSET>,
            SelectButton::<Impl, OFFSET>,
            SelectAndActivateButton::<Impl, OFFSET>,
            StillOff::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            SelectAudioStream::<Impl, OFFSET>,
            SelectSubpictureStream::<Impl, OFFSET>,
            SetSubpictureState::<Impl, OFFSET>,
            SelectAngle::<Impl, OFFSET>,
            SelectParentalLevel::<Impl, OFFSET>,
            SelectParentalCountry::<Impl, OFFSET>,
            SelectKaraokeAudioPresentationMode::<Impl, OFFSET>,
            SelectVideoModePreference::<Impl, OFFSET>,
            SetDVDDirectory::<Impl, OFFSET>,
            ActivateAtPosition::<Impl, OFFSET>,
            SelectAtPosition::<Impl, OFFSET>,
            PlayChaptersAutoStop::<Impl, OFFSET>,
            AcceptParentalLevelChange::<Impl, OFFSET>,
            SetOption::<Impl, OFFSET>,
            SetState::<Impl, OFFSET>,
            PlayPeriodInTitleAutoStop::<Impl, OFFSET>,
            SetGPRM::<Impl, OFFSET>,
            SelectDefaultMenuLanguage::<Impl, OFFSET>,
            SelectDefaultAudioLanguage::<Impl, OFFSET>,
            SelectDefaultSubpictureLanguage::<Impl, OFFSET>,
        )
    }
}
pub trait IDvdGraphBuilderImpl: Sized {
    fn GetFiltergraph();
    fn GetDvdInterface();
    fn RenderDvdVideoVolume();
}
impl ::windows::core::RuntimeName for IDvdGraphBuilder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdGraphBuilder";
}
impl IDvdGraphBuilderVtbl {
    pub const fn new<Impl: IDvdGraphBuilderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdGraphBuilderVtbl {
        unsafe extern "system" fn GetFiltergraph<Impl: IDvdGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppgb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph(::core::mem::transmute_copy(&ppgb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDvdInterface<Impl: IDvdGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvif: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDvdInterface(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvif)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderDvdVideoVolume<Impl: IDvdGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpcwszpathname: super::super::Foundation::PWSTR, dwflags: u32, pstatus: *mut AM_DVD_RENDERSTATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderDvdVideoVolume(&*(&lpcwszpathname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&pstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvdGraphBuilder>, base.5, GetFiltergraph::<Impl, OFFSET>, GetDvdInterface::<Impl, OFFSET>, RenderDvdVideoVolume::<Impl, OFFSET>)
    }
}
pub trait IDvdInfoImpl: Sized {
    fn GetCurrentDomain();
    fn GetCurrentLocation();
    fn GetTotalTitleTime();
    fn GetCurrentButton();
    fn GetCurrentAngle();
    fn GetCurrentAudio();
    fn GetCurrentSubpicture();
    fn GetCurrentUOPS();
    fn GetAllSPRMs();
    fn GetAllGPRMs();
    fn GetAudioLanguage();
    fn GetSubpictureLanguage();
    fn GetTitleAttributes();
    fn GetVMGAttributes();
    fn GetCurrentVideoAttributes();
    fn GetCurrentAudioAttributes();
    fn GetCurrentSubpictureAttributes();
    fn GetCurrentVolumeInfo();
    fn GetDVDTextInfo();
    fn GetPlayerParentalLevel();
    fn GetNumberOfChapters();
    fn GetTitleParentalLevels();
    fn GetRoot();
}
impl ::windows::core::RuntimeName for IDvdInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdInfo";
}
impl IDvdInfoVtbl {
    pub const fn new<Impl: IDvdInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdInfoVtbl {
        unsafe extern "system" fn GetCurrentDomain<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentDomain(pdomain) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentLocation<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentLocation(::core::mem::transmute_copy(&plocation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pultotaltime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTotalTitleTime(::core::mem::transmute_copy(&pultotaltime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentButton<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentButton(::core::mem::transmute_copy(&pulbuttonsavailable), ::core::mem::transmute_copy(&pulcurrentbutton)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAngle<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentAngle(::core::mem::transmute_copy(&pulanglesavailable), ::core::mem::transmute_copy(&pulcurrentangle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAudio<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentAudio(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentSubpicture<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentSubpicture(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream), ::core::mem::transmute_copy(&pisdisabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentUOPS<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puop: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentUOPS(::core::mem::transmute_copy(&puop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllSPRMs(::core::mem::transmute_copy(&pregisterarray)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllGPRMs(::core::mem::transmute_copy(&pregisterarray)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioLanguage(ulstream, ::core::mem::transmute_copy(&planguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubpictureLanguage(ulstream, ::core::mem::transmute_copy(&planguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, patr: *mut DVD_ATR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTitleAttributes(ultitle, ::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVMGAttributes<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_ATR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVMGAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentVideoAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAudioAttributes<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentAudioAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentSubpictureAttributes<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentSubpictureAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVolumeInfo<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentVolumeInfo(::core::mem::transmute_copy(&pulnumofvol), ::core::mem::transmute_copy(&pulthisvolnum), ::core::mem::transmute_copy(&pside), ::core::mem::transmute_copy(&pulnumoftitles)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextInfo<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptextmanager: *mut u8, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDTextInfo(::core::mem::transmute_copy(&ptextmanager), ulbufsize, ::core::mem::transmute_copy(&pulactualsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlayerParentalLevel(::core::mem::transmute_copy(&pulparentallevel), ::core::mem::transmute_copy(&pulcountrycode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfChapters<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulnumberofchapters: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfChapters(ultitle, ::core::mem::transmute_copy(&pulnumberofchapters)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTitleParentalLevels(ultitle, ::core::mem::transmute_copy(&pulparentallevels)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRoot<Impl: IDvdInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, proot: super::super::Foundation::PSTR, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRoot(::core::mem::transmute_copy(&proot), ulbufsize, ::core::mem::transmute_copy(&pulactualsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvdInfo>,
            base.5,
            GetCurrentDomain::<Impl, OFFSET>,
            GetCurrentLocation::<Impl, OFFSET>,
            GetTotalTitleTime::<Impl, OFFSET>,
            GetCurrentButton::<Impl, OFFSET>,
            GetCurrentAngle::<Impl, OFFSET>,
            GetCurrentAudio::<Impl, OFFSET>,
            GetCurrentSubpicture::<Impl, OFFSET>,
            GetCurrentUOPS::<Impl, OFFSET>,
            GetAllSPRMs::<Impl, OFFSET>,
            GetAllGPRMs::<Impl, OFFSET>,
            GetAudioLanguage::<Impl, OFFSET>,
            GetSubpictureLanguage::<Impl, OFFSET>,
            GetTitleAttributes::<Impl, OFFSET>,
            GetVMGAttributes::<Impl, OFFSET>,
            GetCurrentVideoAttributes::<Impl, OFFSET>,
            GetCurrentAudioAttributes::<Impl, OFFSET>,
            GetCurrentSubpictureAttributes::<Impl, OFFSET>,
            GetCurrentVolumeInfo::<Impl, OFFSET>,
            GetDVDTextInfo::<Impl, OFFSET>,
            GetPlayerParentalLevel::<Impl, OFFSET>,
            GetNumberOfChapters::<Impl, OFFSET>,
            GetTitleParentalLevels::<Impl, OFFSET>,
            GetRoot::<Impl, OFFSET>,
        )
    }
}
pub trait IDvdInfo2Impl: Sized {
    fn GetCurrentDomain();
    fn GetCurrentLocation();
    fn GetTotalTitleTime();
    fn GetCurrentButton();
    fn GetCurrentAngle();
    fn GetCurrentAudio();
    fn GetCurrentSubpicture();
    fn GetCurrentUOPS();
    fn GetAllSPRMs();
    fn GetAllGPRMs();
    fn GetAudioLanguage();
    fn GetSubpictureLanguage();
    fn GetTitleAttributes();
    fn GetVMGAttributes();
    fn GetCurrentVideoAttributes();
    fn GetAudioAttributes();
    fn GetKaraokeAttributes();
    fn GetSubpictureAttributes();
    fn GetDVDVolumeInfo();
    fn GetDVDTextNumberOfLanguages();
    fn GetDVDTextLanguageInfo();
    fn GetDVDTextStringAsNative();
    fn GetDVDTextStringAsUnicode();
    fn GetPlayerParentalLevel();
    fn GetNumberOfChapters();
    fn GetTitleParentalLevels();
    fn GetDVDDirectory();
    fn IsAudioStreamEnabled();
    fn GetDiscID();
    fn GetState();
    fn GetMenuLanguages();
    fn GetButtonAtPosition();
    fn GetCmdFromEvent();
    fn GetDefaultMenuLanguage();
    fn GetDefaultAudioLanguage();
    fn GetDefaultSubpictureLanguage();
    fn GetDecoderCaps();
    fn GetButtonRect();
    fn IsSubpictureStreamEnabled();
}
impl ::windows::core::RuntimeName for IDvdInfo2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdInfo2";
}
impl IDvdInfo2Vtbl {
    pub const fn new<Impl: IDvdInfo2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdInfo2Vtbl {
        unsafe extern "system" fn GetCurrentDomain<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentDomain(::core::mem::transmute_copy(&pdomain)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentLocation<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION2) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentLocation(::core::mem::transmute_copy(&plocation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTotalTitleTime(::core::mem::transmute_copy(&ptotaltime), ::core::mem::transmute_copy(&ultimecodeflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentButton<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentButton(::core::mem::transmute_copy(&pulbuttonsavailable), ::core::mem::transmute_copy(&pulcurrentbutton)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAngle<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentAngle(::core::mem::transmute_copy(&pulanglesavailable), ::core::mem::transmute_copy(&pulcurrentangle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAudio<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentAudio(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentSubpicture<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentSubpicture(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream), ::core::mem::transmute_copy(&pbisdisabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentUOPS<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puluops: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentUOPS(::core::mem::transmute_copy(&puluops)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllSPRMs(::core::mem::transmute_copy(&pregisterarray)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllGPRMs(::core::mem::transmute_copy(&pregisterarray)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioLanguage(ulstream, ::core::mem::transmute_copy(&planguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubpictureLanguage(ulstream, ::core::mem::transmute_copy(&planguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTitleAttributes(ultitle, ::core::mem::transmute_copy(&pmenu), ::core::mem::transmute_copy(&ptitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVMGAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_MenuAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVMGAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_VideoAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentVideoAttributes(::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, patr: *mut DVD_AudioAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioAttributes(ulstream, ::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKaraokeAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, pattributes: *mut DVD_KaraokeAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetKaraokeAttributes(ulstream, ::core::mem::transmute_copy(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureAttributes<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstream: u32, patr: *mut DVD_SubpictureAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubpictureAttributes(ulstream, ::core::mem::transmute_copy(&patr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDVolumeInfo<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDVolumeInfo(::core::mem::transmute_copy(&pulnumofvolumes), ::core::mem::transmute_copy(&pulvolume), ::core::mem::transmute_copy(&pside), ::core::mem::transmute_copy(&pulnumoftitles)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextNumberOfLanguages<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulnumoflangs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDTextNumberOfLanguages(::core::mem::transmute_copy(&pulnumoflangs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextLanguageInfo<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDTextLanguageInfo(ullangindex, ::core::mem::transmute_copy(&pulnumofstrings), ::core::mem::transmute_copy(&plangcode), ::core::mem::transmute_copy(&pbcharacterset)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextStringAsNative<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDTextStringAsNative(ullangindex, ulstringindex, ::core::mem::transmute_copy(&pbbuffer), ulmaxbuffersize, ::core::mem::transmute_copy(&pulactualsize), ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextStringAsUnicode<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pchwbuffer: super::super::Foundation::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDTextStringAsUnicode(ullangindex, ulstringindex, ::core::mem::transmute_copy(&pchwbuffer), ulmaxbuffersize, ::core::mem::transmute_copy(&pulactualsize), ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32, pbcountrycode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlayerParentalLevel(::core::mem::transmute_copy(&pulparentallevel), ::core::mem::transmute_copy(&pbcountrycode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfChapters<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulnumofchapters: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfChapters(ultitle, ::core::mem::transmute_copy(&pulnumofchapters)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTitleParentalLevels(ultitle, ::core::mem::transmute_copy(&pulparentallevels)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDDirectory<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR, ulmaxsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDVDDirectory(::core::mem::transmute_copy(&pszwpath), ulmaxsize, ::core::mem::transmute_copy(&pulactualsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioStreamEnabled<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAudioStreamEnabled(ulstreamnum, ::core::mem::transmute_copy(&pbenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDiscID<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR, pulldiscid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDiscID(&*(&pszwpath as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pulldiscid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatedata: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&pstatedata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMenuLanguages<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMenuLanguages(::core::mem::transmute_copy(&planguages), ulmaxlanguages, ::core::mem::transmute_copy(&pulactuallanguages)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetButtonAtPosition<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT, pulbuttonindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetButtonAtPosition(&*(&point as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pulbuttonindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCmdFromEvent<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lparam1: isize, pcmdobj: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCmdFromEvent(lparam1, ::core::mem::transmute_copy(&pcmdobj)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultMenuLanguage<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultMenuLanguage(::core::mem::transmute_copy(&planguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultAudioLanguage<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultAudioLanguage(::core::mem::transmute_copy(&planguage), ::core::mem::transmute_copy(&paudioextension)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultSubpictureLanguage<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultSubpictureLanguage(::core::mem::transmute_copy(&planguage), ::core::mem::transmute_copy(&psubpictureextension)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDecoderCaps<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcaps: *mut DVD_DECODER_CAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderCaps(::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetButtonRect<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbutton: u32, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetButtonRect(ulbutton, ::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSubpictureStreamEnabled<Impl: IDvdInfo2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSubpictureStreamEnabled(ulstreamnum, ::core::mem::transmute_copy(&pbenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDvdInfo2>,
            base.5,
            GetCurrentDomain::<Impl, OFFSET>,
            GetCurrentLocation::<Impl, OFFSET>,
            GetTotalTitleTime::<Impl, OFFSET>,
            GetCurrentButton::<Impl, OFFSET>,
            GetCurrentAngle::<Impl, OFFSET>,
            GetCurrentAudio::<Impl, OFFSET>,
            GetCurrentSubpicture::<Impl, OFFSET>,
            GetCurrentUOPS::<Impl, OFFSET>,
            GetAllSPRMs::<Impl, OFFSET>,
            GetAllGPRMs::<Impl, OFFSET>,
            GetAudioLanguage::<Impl, OFFSET>,
            GetSubpictureLanguage::<Impl, OFFSET>,
            GetTitleAttributes::<Impl, OFFSET>,
            GetVMGAttributes::<Impl, OFFSET>,
            GetCurrentVideoAttributes::<Impl, OFFSET>,
            GetAudioAttributes::<Impl, OFFSET>,
            GetKaraokeAttributes::<Impl, OFFSET>,
            GetSubpictureAttributes::<Impl, OFFSET>,
            GetDVDVolumeInfo::<Impl, OFFSET>,
            GetDVDTextNumberOfLanguages::<Impl, OFFSET>,
            GetDVDTextLanguageInfo::<Impl, OFFSET>,
            GetDVDTextStringAsNative::<Impl, OFFSET>,
            GetDVDTextStringAsUnicode::<Impl, OFFSET>,
            GetPlayerParentalLevel::<Impl, OFFSET>,
            GetNumberOfChapters::<Impl, OFFSET>,
            GetTitleParentalLevels::<Impl, OFFSET>,
            GetDVDDirectory::<Impl, OFFSET>,
            IsAudioStreamEnabled::<Impl, OFFSET>,
            GetDiscID::<Impl, OFFSET>,
            GetState::<Impl, OFFSET>,
            GetMenuLanguages::<Impl, OFFSET>,
            GetButtonAtPosition::<Impl, OFFSET>,
            GetCmdFromEvent::<Impl, OFFSET>,
            GetDefaultMenuLanguage::<Impl, OFFSET>,
            GetDefaultAudioLanguage::<Impl, OFFSET>,
            GetDefaultSubpictureLanguage::<Impl, OFFSET>,
            GetDecoderCaps::<Impl, OFFSET>,
            GetButtonRect::<Impl, OFFSET>,
            IsSubpictureStreamEnabled::<Impl, OFFSET>,
        )
    }
}
pub trait IDvdStateImpl: Sized {
    fn GetDiscID();
    fn GetParentalLevel();
}
impl ::windows::core::RuntimeName for IDvdState {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IDvdState";
}
impl IDvdStateVtbl {
    pub const fn new<Impl: IDvdStateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDvdStateVtbl {
        unsafe extern "system" fn GetDiscID<Impl: IDvdStateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulluniqueid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDiscID(::core::mem::transmute_copy(&pulluniqueid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalLevel<Impl: IDvdStateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParentalLevel(::core::mem::transmute_copy(&pulparentallevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDvdState>, base.5, GetDiscID::<Impl, OFFSET>, GetParentalLevel::<Impl, OFFSET>)
    }
}
pub trait IESCloseMmiEventImpl: Sized + IESEventImpl {
    fn GetDialogNumber();
}
impl ::windows::core::RuntimeName for IESCloseMmiEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESCloseMmiEvent";
}
impl IESCloseMmiEventVtbl {
    pub const fn new<Impl: IESCloseMmiEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESCloseMmiEventVtbl {
        unsafe extern "system" fn GetDialogNumber<Impl: IESCloseMmiEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdialognumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDialogNumber(::core::mem::transmute_copy(&pdialognumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESCloseMmiEvent>, base.5, GetDialogNumber::<Impl, OFFSET>)
    }
}
pub trait IESEventImpl: Sized {
    fn GetEventId();
    fn GetEventType();
    fn SetCompletionStatus();
    fn GetData();
    fn GetStringData();
}
impl ::windows::core::RuntimeName for IESEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESEvent";
}
impl IESEventVtbl {
    pub const fn new<Impl: IESEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESEventVtbl {
        unsafe extern "system" fn GetEventId<Impl: IESEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdweventid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEventId(::core::mem::transmute_copy(&pdweventid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEventType<Impl: IESEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguideventtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEventType(::core::mem::transmute_copy(&pguideventtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompletionStatus<Impl: IESEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwresult: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCompletionStatus(dwresult) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetData<Impl: IESEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStringData<Impl: IESEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrdata: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStringData(::core::mem::transmute_copy(&pbstrdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESEvent>, base.5, GetEventId::<Impl, OFFSET>, GetEventType::<Impl, OFFSET>, SetCompletionStatus::<Impl, OFFSET>, GetData::<Impl, OFFSET>, GetStringData::<Impl, OFFSET>)
    }
}
pub trait IESEventFactoryImpl: Sized {
    fn CreateESEvent();
}
impl ::windows::core::RuntimeName for IESEventFactory {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESEventFactory";
}
impl IESEventFactoryVtbl {
    pub const fn new<Impl: IESEventFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESEventFactoryVtbl {
        unsafe extern "system" fn CreateESEvent<Impl: IESEventFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pserviceprovider: *mut ::core::ffi::c_void, dweventid: u32, guideventtype: ::windows::core::GUID, dweventdatalength: u32, peventdata: *const u8, bstrbaseurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pinitcontext: *mut ::core::ffi::c_void, ppesevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateESEvent(
                &*(&pserviceprovider as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                dweventid,
                &*(&guideventtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                dweventdatalength,
                peventdata,
                &*(&bstrbaseurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pinitcontext as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppesevent),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESEventFactory>, base.5, CreateESEvent::<Impl, OFFSET>)
    }
}
pub trait IESEventServiceImpl: Sized {
    fn FireESEvent();
}
impl ::windows::core::RuntimeName for IESEventService {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESEventService";
}
impl IESEventServiceVtbl {
    pub const fn new<Impl: IESEventServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESEventServiceVtbl {
        unsafe extern "system" fn FireESEvent<Impl: IESEventServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pesevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FireESEvent(&*(&pesevent as *const <IESEvent as ::windows::core::Abi>::Abi as *const <IESEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESEventService>, base.5, FireESEvent::<Impl, OFFSET>)
    }
}
pub trait IESEventServiceConfigurationImpl: Sized {
    fn SetParent();
    fn RemoveParent();
    fn SetOwner();
    fn RemoveOwner();
    fn SetGraph();
    fn RemoveGraph();
}
impl ::windows::core::RuntimeName for IESEventServiceConfiguration {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESEventServiceConfiguration";
}
impl IESEventServiceConfigurationVtbl {
    pub const fn new<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESEventServiceConfigurationVtbl {
        unsafe extern "system" fn SetParent<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peventservice: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetParent(&*(&peventservice as *const <IESEventService as ::windows::core::Abi>::Abi as *const <IESEventService as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveParent<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveParent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOwner<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pesevents: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOwner(&*(&pesevents as *const <IESEvents as ::windows::core::Abi>::Abi as *const <IESEvents as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOwner<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGraph<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGraph(&*(&pgraph as *const <IFilterGraph as ::windows::core::Abi>::Abi as *const <IFilterGraph as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveGraph<Impl: IESEventServiceConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveGraph(&*(&pgraph as *const <IFilterGraph as ::windows::core::Abi>::Abi as *const <IFilterGraph as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESEventServiceConfiguration>, base.5, SetParent::<Impl, OFFSET>, RemoveParent::<Impl, OFFSET>, SetOwner::<Impl, OFFSET>, RemoveOwner::<Impl, OFFSET>, SetGraph::<Impl, OFFSET>, RemoveGraph::<Impl, OFFSET>)
    }
}
pub trait IESEventsImpl: Sized {
    fn OnESEventReceived();
}
impl ::windows::core::RuntimeName for IESEvents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESEvents";
}
impl IESEventsVtbl {
    pub const fn new<Impl: IESEventsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESEventsVtbl {
        unsafe extern "system" fn OnESEventReceived<Impl: IESEventsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guideventtype: ::windows::core::GUID, pesevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnESEventReceived(&*(&guideventtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pesevent as *const <IESEvent as ::windows::core::Abi>::Abi as *const <IESEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESEvents>, base.5, OnESEventReceived::<Impl, OFFSET>)
    }
}
pub trait IESFileExpiryDateEventImpl: Sized + IESEventImpl {
    fn GetTunerId();
    fn GetExpiryDate();
    fn GetFinalExpiryDate();
    fn GetMaxRenewalCount();
    fn IsEntitlementTokenPresent();
    fn DoesExpireAfterFirstUse();
}
impl ::windows::core::RuntimeName for IESFileExpiryDateEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESFileExpiryDateEvent";
}
impl IESFileExpiryDateEventVtbl {
    pub const fn new<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESFileExpiryDateEventVtbl {
        unsafe extern "system" fn GetTunerId<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtunerid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTunerId(::core::mem::transmute_copy(&pguidtunerid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiryDate<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExpiryDate(::core::mem::transmute_copy(&pqwexpirydate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFinalExpiryDate<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFinalExpiryDate(::core::mem::transmute_copy(&pqwexpirydate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxRenewalCount<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxrenewalcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxRenewalCount(::core::mem::transmute_copy(&dwmaxrenewalcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEntitlementTokenPresent<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfenttokenpresent: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEntitlementTokenPresent(::core::mem::transmute_copy(&pfenttokenpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DoesExpireAfterFirstUse<Impl: IESFileExpiryDateEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfexpireafterfirstuse: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DoesExpireAfterFirstUse(::core::mem::transmute_copy(&pfexpireafterfirstuse)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESFileExpiryDateEvent>, base.5, GetTunerId::<Impl, OFFSET>, GetExpiryDate::<Impl, OFFSET>, GetFinalExpiryDate::<Impl, OFFSET>, GetMaxRenewalCount::<Impl, OFFSET>, IsEntitlementTokenPresent::<Impl, OFFSET>, DoesExpireAfterFirstUse::<Impl, OFFSET>)
    }
}
pub trait IESIsdbCasResponseEventImpl: Sized + IESEventImpl {
    fn GetRequestId();
    fn GetStatus();
    fn GetDataLength();
    fn GetResponseData();
}
impl ::windows::core::RuntimeName for IESIsdbCasResponseEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESIsdbCasResponseEvent";
}
impl IESIsdbCasResponseEventVtbl {
    pub const fn new<Impl: IESIsdbCasResponseEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESIsdbCasResponseEventVtbl {
        unsafe extern "system" fn GetRequestId<Impl: IESIsdbCasResponseEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prequestid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRequestId(::core::mem::transmute_copy(&prequestid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IESIsdbCasResponseEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&pstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataLength<Impl: IESIsdbCasResponseEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prequestlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataLength(::core::mem::transmute_copy(&prequestlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetResponseData<Impl: IESIsdbCasResponseEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetResponseData(::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESIsdbCasResponseEvent>, base.5, GetRequestId::<Impl, OFFSET>, GetStatus::<Impl, OFFSET>, GetDataLength::<Impl, OFFSET>, GetResponseData::<Impl, OFFSET>)
    }
}
pub trait IESLicenseRenewalResultEventImpl: Sized + IESEventImpl {
    fn GetCallersId();
    fn GetFileName();
    fn IsRenewalSuccessful();
    fn IsCheckEntitlementCallRequired();
    fn GetDescrambledStatus();
    fn GetRenewalResultCode();
    fn GetCASFailureCode();
    fn GetRenewalHResult();
    fn GetEntitlementTokenLength();
    fn GetEntitlementToken();
    fn GetExpiryDate();
}
impl ::windows::core::RuntimeName for IESLicenseRenewalResultEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESLicenseRenewalResultEvent";
}
impl IESLicenseRenewalResultEventVtbl {
    pub const fn new<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESLicenseRenewalResultEventVtbl {
        unsafe extern "system" fn GetCallersId<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcallersid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCallersId(::core::mem::transmute_copy(&pdwcallersid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFileName<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrfilename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFileName(::core::mem::transmute_copy(&pbstrfilename)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRenewalSuccessful<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfrenewalsuccessful: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRenewalSuccessful(::core::mem::transmute_copy(&pfrenewalsuccessful)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCheckEntitlementCallRequired<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfcheckenttokencallneeded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCheckEntitlementCallRequired(::core::mem::transmute_copy(&pfcheckenttokencallneeded)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescrambledStatus<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdescrambledstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescrambledStatus(::core::mem::transmute_copy(&pdescrambledstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenewalResultCode<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrenewalresultcode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenewalResultCode(::core::mem::transmute_copy(&pdwrenewalresultcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASFailureCode<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcasfailurecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCASFailureCode(::core::mem::transmute_copy(&pdwcasfailurecode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenewalHResult<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phr: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenewalHResult(::core::mem::transmute_copy(&phr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntitlementTokenLength<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntitlementTokenLength(::core::mem::transmute_copy(&pdwlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntitlementToken<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntitlementToken(::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiryDate<Impl: IESLicenseRenewalResultEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExpiryDate(::core::mem::transmute_copy(&pqwexpirydate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IESLicenseRenewalResultEvent>,
            base.5,
            GetCallersId::<Impl, OFFSET>,
            GetFileName::<Impl, OFFSET>,
            IsRenewalSuccessful::<Impl, OFFSET>,
            IsCheckEntitlementCallRequired::<Impl, OFFSET>,
            GetDescrambledStatus::<Impl, OFFSET>,
            GetRenewalResultCode::<Impl, OFFSET>,
            GetCASFailureCode::<Impl, OFFSET>,
            GetRenewalHResult::<Impl, OFFSET>,
            GetEntitlementTokenLength::<Impl, OFFSET>,
            GetEntitlementToken::<Impl, OFFSET>,
            GetExpiryDate::<Impl, OFFSET>,
        )
    }
}
pub trait IESOpenMmiEventImpl: Sized + IESEventImpl {
    fn GetDialogNumber();
    fn GetDialogType();
    fn GetDialogData();
    fn GetDialogStringData();
}
impl ::windows::core::RuntimeName for IESOpenMmiEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESOpenMmiEvent";
}
impl IESOpenMmiEventVtbl {
    pub const fn new<Impl: IESOpenMmiEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESOpenMmiEventVtbl {
        unsafe extern "system" fn GetDialogNumber<Impl: IESOpenMmiEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdialogrequest: *mut u32, pdialognumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDialogNumber(::core::mem::transmute_copy(&pdialogrequest), ::core::mem::transmute_copy(&pdialognumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDialogType<Impl: IESOpenMmiEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guiddialogtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDialogType(::core::mem::transmute_copy(&guiddialogtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDialogData<Impl: IESOpenMmiEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDialogData(::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDialogStringData<Impl: IESOpenMmiEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrbaseurl: *mut super::super::Foundation::BSTR, pbstrdata: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDialogStringData(::core::mem::transmute_copy(&pbstrbaseurl), ::core::mem::transmute_copy(&pbstrdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESOpenMmiEvent>, base.5, GetDialogNumber::<Impl, OFFSET>, GetDialogType::<Impl, OFFSET>, GetDialogData::<Impl, OFFSET>, GetDialogStringData::<Impl, OFFSET>)
    }
}
pub trait IESRequestTunerEventImpl: Sized + IESEventImpl {
    fn GetPriority();
    fn GetReason();
    fn GetConsequences();
    fn GetEstimatedTime();
}
impl ::windows::core::RuntimeName for IESRequestTunerEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESRequestTunerEvent";
}
impl IESRequestTunerEventVtbl {
    pub const fn new<Impl: IESRequestTunerEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESRequestTunerEventVtbl {
        unsafe extern "system" fn GetPriority<Impl: IESRequestTunerEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbypriority: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPriority(::core::mem::transmute_copy(&pbypriority)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReason<Impl: IESRequestTunerEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbyreason: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReason(::core::mem::transmute_copy(&pbyreason)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConsequences<Impl: IESRequestTunerEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbyconsequences: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConsequences(::core::mem::transmute_copy(&pbyconsequences)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEstimatedTime<Impl: IESRequestTunerEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwestimatedtime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEstimatedTime(::core::mem::transmute_copy(&pdwestimatedtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESRequestTunerEvent>, base.5, GetPriority::<Impl, OFFSET>, GetReason::<Impl, OFFSET>, GetConsequences::<Impl, OFFSET>, GetEstimatedTime::<Impl, OFFSET>)
    }
}
pub trait IESValueUpdatedEventImpl: Sized + IESEventImpl {
    fn GetValueNames();
}
impl ::windows::core::RuntimeName for IESValueUpdatedEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IESValueUpdatedEvent";
}
impl IESValueUpdatedEventVtbl {
    pub const fn new<Impl: IESValueUpdatedEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IESValueUpdatedEventVtbl {
        unsafe extern "system" fn GetValueNames<Impl: IESValueUpdatedEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrnames: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValueNames(::core::mem::transmute_copy(&pbstrnames)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IESValueUpdatedEvent>, base.5, GetValueNames::<Impl, OFFSET>)
    }
}
pub trait IETFilterImpl: Sized {
    fn EvalRatObjOK();
    fn GetCurrRating();
    fn GetCurrLicenseExpDate();
    fn GetLastErrorCode();
    fn SetRecordingOn();
}
impl ::windows::core::RuntimeName for IETFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IETFilter";
}
impl IETFilterVtbl {
    pub const fn new<Impl: IETFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IETFilterVtbl {
        unsafe extern "system" fn EvalRatObjOK<Impl: IETFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EvalRatObjOK(::core::mem::transmute_copy(&phrcocreateretval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrRating<Impl: IETFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrRating(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&plbfenattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IETFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(prottype, ::core::mem::transmute_copy(&lpdatetime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IETFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRecordingOn<Impl: IETFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, frecstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRecordingOn(&*(&frecstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IETFilter>, base.5, EvalRatObjOK::<Impl, OFFSET>, GetCurrRating::<Impl, OFFSET>, GetCurrLicenseExpDate::<Impl, OFFSET>, GetLastErrorCode::<Impl, OFFSET>, SetRecordingOn::<Impl, OFFSET>)
    }
}
pub trait IETFilterConfigImpl: Sized {
    fn InitLicense();
    fn GetSecureChannelObject();
}
impl ::windows::core::RuntimeName for IETFilterConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IETFilterConfig";
}
impl IETFilterConfigVtbl {
    pub const fn new<Impl: IETFilterConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IETFilterConfigVtbl {
        unsafe extern "system" fn InitLicense<Impl: IETFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, licenseid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitLicense(licenseid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSecureChannelObject<Impl: IETFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject(::core::mem::transmute_copy(&ppunkdrmsecurechannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IETFilterConfig>, base.5, InitLicense::<Impl, OFFSET>, GetSecureChannelObject::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IETFilterEventsImpl: Sized + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IETFilterEvents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IETFilterEvents";
}
#[cfg(feature = "Win32_System_Com")]
impl IETFilterEventsVtbl {
    pub const fn new<Impl: IETFilterEventsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IETFilterEventsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IETFilterEvents>, base.5)
    }
}
pub trait IEncoderAPIImpl: Sized {
    fn IsSupported();
    fn IsAvailable();
    fn GetParameterRange();
    fn GetParameterValues();
    fn GetDefaultValue();
    fn GetValue();
    fn SetValue();
}
impl ::windows::core::RuntimeName for IEncoderAPI {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEncoderAPI";
}
impl IEncoderAPIVtbl {
    pub const fn new<Impl: IEncoderAPIImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEncoderAPIVtbl {
        unsafe extern "system" fn IsSupported<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSupported(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAvailable<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAvailable(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterRange<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameterRange(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&valuemin), ::core::mem::transmute_copy(&valuemax), ::core::mem::transmute_copy(&steppingdelta)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterValues<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameterValues(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&values), ::core::mem::transmute_copy(&valuescount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultValue<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IEncoderAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEncoderAPI>, base.5, IsSupported::<Impl, OFFSET>, IsAvailable::<Impl, OFFSET>, GetParameterRange::<Impl, OFFSET>, GetParameterValues::<Impl, OFFSET>, GetDefaultValue::<Impl, OFFSET>, GetValue::<Impl, OFFSET>, SetValue::<Impl, OFFSET>)
    }
}
pub trait IEnumComponentTypesImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumComponentTypes {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumComponentTypes";
}
impl IEnumComponentTypesVtbl {
    pub const fn new<Impl: IEnumComponentTypesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumComponentTypesVtbl {
        unsafe extern "system" fn Next<Impl: IEnumComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumComponentTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumComponentTypes>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumComponentsImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumComponents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumComponents";
}
impl IEnumComponentsVtbl {
    pub const fn new<Impl: IEnumComponentsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumComponentsVtbl {
        unsafe extern "system" fn Next<Impl: IEnumComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumComponentsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumComponents>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumFiltersImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumFilters {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumFilters";
}
impl IEnumFiltersVtbl {
    pub const fn new<Impl: IEnumFiltersImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumFiltersVtbl {
        unsafe extern "system" fn Next<Impl: IEnumFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cfilters: u32, ppfilter: *mut ::windows::core::RawPtr, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(cfilters, ::core::mem::transmute_copy(&ppfilter), ::core::mem::transmute_copy(&pcfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cfilters: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(cfilters) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumFilters>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumGuideDataPropertiesImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumGuideDataProperties {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumGuideDataProperties";
}
impl IEnumGuideDataPropertiesVtbl {
    pub const fn new<Impl: IEnumGuideDataPropertiesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumGuideDataPropertiesVtbl {
        unsafe extern "system" fn Next<Impl: IEnumGuideDataPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, ppprop: *mut ::windows::core::RawPtr, pcelt: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&ppprop), ::core::mem::transmute_copy(&pcelt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumGuideDataPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumGuideDataPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumGuideDataPropertiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumGuideDataProperties>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumMSVidGraphSegmentImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumMSVidGraphSegment {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumMSVidGraphSegment";
}
impl IEnumMSVidGraphSegmentVtbl {
    pub const fn new<Impl: IEnumMSVidGraphSegmentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumMSVidGraphSegmentVtbl {
        unsafe extern "system" fn Next<Impl: IEnumMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumMSVidGraphSegment>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumMediaTypesImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumMediaTypes {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumMediaTypes";
}
impl IEnumMediaTypesVtbl {
    pub const fn new<Impl: IEnumMediaTypesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumMediaTypesVtbl {
        unsafe extern "system" fn Next<Impl: IEnumMediaTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cmediatypes: u32, ppmediatypes: *mut *mut AM_MEDIA_TYPE, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(cmediatypes, ::core::mem::transmute_copy(&ppmediatypes), ::core::mem::transmute_copy(&pcfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumMediaTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cmediatypes: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(cmediatypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumMediaTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumMediaTypesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumMediaTypes>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumPIDMapImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumPIDMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumPIDMap";
}
impl IEnumPIDMapVtbl {
    pub const fn new<Impl: IEnumPIDMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumPIDMapVtbl {
        unsafe extern "system" fn Next<Impl: IEnumPIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crequest: u32, ppidmap: *mut PID_MAP, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(crequest, &*(&ppidmap as *const <PID_MAP as ::windows::core::Abi>::Abi as *const <PID_MAP as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcreceived)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumPIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(crecords) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumPIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumPIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumpidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppienumpidmap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumPIDMap>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumPinsImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumPins {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumPins";
}
impl IEnumPinsVtbl {
    pub const fn new<Impl: IEnumPinsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumPinsVtbl {
        unsafe extern "system" fn Next<Impl: IEnumPinsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cpins: u32, pppins: *mut ::windows::core::RawPtr, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(cpins, ::core::mem::transmute_copy(&pppins), ::core::mem::transmute_copy(&pcfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumPinsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cpins: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(cpins) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumPinsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumPinsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumPins>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumRegFiltersImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumRegFilters {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumRegFilters";
}
impl IEnumRegFiltersVtbl {
    pub const fn new<Impl: IEnumRegFiltersImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumRegFiltersVtbl {
        unsafe extern "system" fn Next<Impl: IEnumRegFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cfilters: u32, apregfilter: *mut *mut REGFILTER, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(cfilters, ::core::mem::transmute_copy(&apregfilter), pcfetched) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumRegFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cfilters: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(cfilters) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumRegFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumRegFiltersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumRegFilters>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumStreamBufferRecordingAttribImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumStreamBufferRecordingAttrib {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumStreamBufferRecordingAttrib";
}
impl IEnumStreamBufferRecordingAttribVtbl {
    pub const fn new<Impl: IEnumStreamBufferRecordingAttribImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumStreamBufferRecordingAttribVtbl {
        unsafe extern "system" fn Next<Impl: IEnumStreamBufferRecordingAttribImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreambufferattribute: *mut STREAMBUFFER_ATTRIBUTE, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(crequest, &*(&pstreambufferattribute as *const <STREAMBUFFER_ATTRIBUTE as ::windows::core::Abi>::Abi as *const <STREAMBUFFER_ATTRIBUTE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcreceived)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumStreamBufferRecordingAttribImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(crecords) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumStreamBufferRecordingAttribImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumStreamBufferRecordingAttribImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumstreambufferattrib: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppienumstreambufferattrib)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumStreamBufferRecordingAttrib>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumStreamIdMapImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumStreamIdMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumStreamIdMap";
}
impl IEnumStreamIdMapVtbl {
    pub const fn new<Impl: IEnumStreamIdMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumStreamIdMapVtbl {
        unsafe extern "system" fn Next<Impl: IEnumStreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreamidmap: *mut STREAM_ID_MAP, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(crequest, ::core::mem::transmute_copy(&pstreamidmap), ::core::mem::transmute_copy(&pcreceived)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumStreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(crecords) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumStreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumStreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumstreamidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppienumstreamidmap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumStreamIdMap>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumTuneRequestsImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumTuneRequests {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumTuneRequests";
}
impl IEnumTuneRequestsVtbl {
    pub const fn new<Impl: IEnumTuneRequestsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumTuneRequestsVtbl {
        unsafe extern "system" fn Next<Impl: IEnumTuneRequestsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, ppprop: *mut ::windows::core::RawPtr, pcelt: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&ppprop), ::core::mem::transmute_copy(&pcelt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumTuneRequestsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumTuneRequestsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumTuneRequestsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumTuneRequests>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IEnumTuningSpacesImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for IEnumTuningSpaces {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEnumTuningSpaces";
}
impl IEnumTuningSpacesVtbl {
    pub const fn new<Impl: IEnumTuningSpacesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEnumTuningSpacesVtbl {
        unsafe extern "system" fn Next<Impl: IEnumTuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(celt, ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: IEnumTuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(celt) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IEnumTuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IEnumTuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEnumTuningSpaces>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEvalRatImpl: Sized + IDispatchImpl {
    fn BlockedRatingAttributes();
    fn SetBlockedRatingAttributes();
    fn BlockUnRated();
    fn SetBlockUnRated();
    fn MostRestrictiveRating();
    fn TestRating();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IEvalRat {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IEvalRat";
}
#[cfg(feature = "Win32_System_Com")]
impl IEvalRatVtbl {
    pub const fn new<Impl: IEvalRatImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEvalRatVtbl {
        unsafe extern "system" fn BlockedRatingAttributes<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, plbfattrs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlockedRatingAttributes(ensystem, enlevel, ::core::mem::transmute_copy(&plbfattrs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockedRatingAttributes<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockedRatingAttributes(ensystem, enlevel, lbfattrs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlockUnRated<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfblockunratedshows: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlockUnRated(::core::mem::transmute_copy(&pfblockunratedshows)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRated<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockUnRated(&*(&fblockunratedshows as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MostRestrictiveRating<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem1: EnTvRat_System, enenlevel1: EnTvRat_GenericLevel, lbfenattr1: i32, ensystem2: EnTvRat_System, enenlevel2: EnTvRat_GenericLevel, lbfenattr2: i32, pensystem: *mut EnTvRat_System, penenlevel: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MostRestrictiveRating(ensystem1, enenlevel1, lbfenattr1, ensystem2, enenlevel2, lbfenattr2, ::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penenlevel), ::core::mem::transmute_copy(&plbfenattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TestRating<Impl: IEvalRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enshowsystem: EnTvRat_System, enshowlevel: EnTvRat_GenericLevel, lbfenshowattributes: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TestRating(enshowsystem, enshowlevel, lbfenshowattributes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEvalRat>, base.5, BlockedRatingAttributes::<Impl, OFFSET>, SetBlockedRatingAttributes::<Impl, OFFSET>, BlockUnRated::<Impl, OFFSET>, SetBlockUnRated::<Impl, OFFSET>, MostRestrictiveRating::<Impl, OFFSET>, TestRating::<Impl, OFFSET>)
    }
}
pub trait IFileSinkFilterImpl: Sized {
    fn SetFileName();
    fn GetCurFile();
}
impl ::windows::core::RuntimeName for IFileSinkFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFileSinkFilter";
}
impl IFileSinkFilterVtbl {
    pub const fn new<Impl: IFileSinkFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFileSinkFilterVtbl {
        unsafe extern "system" fn SetFileName<Impl: IFileSinkFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFileName(&*(&pszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurFile<Impl: IFileSinkFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurFile(::core::mem::transmute_copy(&ppszfilename), ::core::mem::transmute_copy(&pmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFileSinkFilter>, base.5, SetFileName::<Impl, OFFSET>, GetCurFile::<Impl, OFFSET>)
    }
}
pub trait IFileSinkFilter2Impl: Sized + IFileSinkFilterImpl {
    fn SetMode();
    fn GetMode();
}
impl ::windows::core::RuntimeName for IFileSinkFilter2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFileSinkFilter2";
}
impl IFileSinkFilter2Vtbl {
    pub const fn new<Impl: IFileSinkFilter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFileSinkFilter2Vtbl {
        unsafe extern "system" fn SetMode<Impl: IFileSinkFilter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMode<Impl: IFileSinkFilter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMode(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFileSinkFilter2>, base.5, SetMode::<Impl, OFFSET>, GetMode::<Impl, OFFSET>)
    }
}
pub trait IFileSourceFilterImpl: Sized {
    fn Load();
    fn GetCurFile();
}
impl ::windows::core::RuntimeName for IFileSourceFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFileSourceFilter";
}
impl IFileSourceFilterVtbl {
    pub const fn new<Impl: IFileSourceFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFileSourceFilterVtbl {
        unsafe extern "system" fn Load<Impl: IFileSourceFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&pszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurFile<Impl: IFileSourceFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurFile(::core::mem::transmute_copy(&ppszfilename), ::core::mem::transmute_copy(&pmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFileSourceFilter>, base.5, Load::<Impl, OFFSET>, GetCurFile::<Impl, OFFSET>)
    }
}
pub trait IFilterChainImpl: Sized {
    fn StartChain();
    fn PauseChain();
    fn StopChain();
    fn RemoveChain();
}
impl ::windows::core::RuntimeName for IFilterChain {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterChain";
}
impl IFilterChainVtbl {
    pub const fn new<Impl: IFilterChainImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterChainVtbl {
        unsafe extern "system" fn StartChain<Impl: IFilterChainImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartChain(&*(&pstartfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&pendfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PauseChain<Impl: IFilterChainImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PauseChain(&*(&pstartfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&pendfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopChain<Impl: IFilterChainImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopChain(&*(&pstartfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&pendfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChain<Impl: IFilterChainImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveChain(&*(&pstartfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&pendfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterChain>, base.5, StartChain::<Impl, OFFSET>, PauseChain::<Impl, OFFSET>, StopChain::<Impl, OFFSET>, RemoveChain::<Impl, OFFSET>)
    }
}
pub trait IFilterGraphImpl: Sized {
    fn AddFilter();
    fn RemoveFilter();
    fn EnumFilters();
    fn FindFilterByName();
    fn ConnectDirect();
    fn Reconnect();
    fn Disconnect();
    fn SetDefaultSyncSource();
}
impl ::windows::core::RuntimeName for IFilterGraph {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterGraph";
}
impl IFilterGraphVtbl {
    pub const fn new<Impl: IFilterGraphImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterGraphVtbl {
        unsafe extern "system" fn AddFilter<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, pname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddFilter(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&pname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFilter<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveFilter(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumFilters<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumFilters(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindFilterByName<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindFilterByName(&*(&pname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppfilter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectDirect<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, ppinin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectDirect(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&ppinin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reconnect<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reconnect(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Disconnect<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Disconnect(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSyncSource<Impl: IFilterGraphImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultSyncSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterGraph>, base.5, AddFilter::<Impl, OFFSET>, RemoveFilter::<Impl, OFFSET>, EnumFilters::<Impl, OFFSET>, FindFilterByName::<Impl, OFFSET>, ConnectDirect::<Impl, OFFSET>, Reconnect::<Impl, OFFSET>, Disconnect::<Impl, OFFSET>, SetDefaultSyncSource::<Impl, OFFSET>)
    }
}
pub trait IFilterGraph2Impl: Sized + IGraphBuilderImpl + IFilterGraphImpl {
    fn AddSourceFilterForMoniker();
    fn ReconnectEx();
    fn RenderEx();
}
impl ::windows::core::RuntimeName for IFilterGraph2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterGraph2";
}
impl IFilterGraph2Vtbl {
    pub const fn new<Impl: IFilterGraph2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterGraph2Vtbl {
        unsafe extern "system" fn AddSourceFilterForMoniker<Impl: IFilterGraph2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmoniker: ::windows::core::RawPtr, pctx: ::windows::core::RawPtr, lpcwstrfiltername: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddSourceFilterForMoniker(
                &*(&pmoniker as *const <super::super::System::Com::IMoniker as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IMoniker as ::windows::core::DefaultType>::DefaultType),
                &*(&pctx as *const <super::super::System::Com::IBindCtx as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IBindCtx as ::windows::core::DefaultType>::DefaultType),
                &*(&lpcwstrfiltername as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppfilter),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReconnectEx<Impl: IFilterGraph2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReconnectEx(&*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderEx<Impl: IFilterGraph2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, dwflags: u32, pvcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderEx(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), dwflags, pvcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterGraph2>, base.5, AddSourceFilterForMoniker::<Impl, OFFSET>, ReconnectEx::<Impl, OFFSET>, RenderEx::<Impl, OFFSET>)
    }
}
pub trait IFilterGraph3Impl: Sized + IFilterGraph2Impl + IGraphBuilderImpl + IFilterGraphImpl {
    fn SetSyncSourceEx();
}
impl ::windows::core::RuntimeName for IFilterGraph3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterGraph3";
}
impl IFilterGraph3Vtbl {
    pub const fn new<Impl: IFilterGraph3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterGraph3Vtbl {
        unsafe extern "system" fn SetSyncSourceEx<Impl: IFilterGraph3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclockformostoffiltergraph: ::windows::core::RawPtr, pclockforfilter: ::windows::core::RawPtr, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncSourceEx(&*(&pclockformostoffiltergraph as *const <super::IReferenceClock as ::windows::core::Abi>::Abi as *const <super::IReferenceClock as ::windows::core::DefaultType>::DefaultType), &*(&pclockforfilter as *const <super::IReferenceClock as ::windows::core::Abi>::Abi as *const <super::IReferenceClock as ::windows::core::DefaultType>::DefaultType), &*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterGraph3>, base.5, SetSyncSourceEx::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IFilterInfoImpl: Sized + IDispatchImpl {
    fn FindPin();
    fn Name();
    fn VendorInfo();
    fn Filter();
    fn Pins();
    fn IsFileSource();
    fn Filename();
    fn SetFilename();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IFilterInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IFilterInfoVtbl {
    pub const fn new<Impl: IFilterInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterInfoVtbl {
        unsafe extern "system" fn FindPin<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strpinid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindPin(&*(&strpinid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Name<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Name(::core::mem::transmute_copy(&strname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VendorInfo<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strvendorinfo: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VendorInfo(::core::mem::transmute_copy(&strvendorinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filter<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Filter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pins<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pins(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFileSource<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbissource: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFileSource(::core::mem::transmute_copy(&pbissource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filename<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstrfilename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Filename(::core::mem::transmute_copy(&pstrfilename)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilename<Impl: IFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFilename(&*(&strfilename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterInfo>, base.5, FindPin::<Impl, OFFSET>, Name::<Impl, OFFSET>, VendorInfo::<Impl, OFFSET>, Filter::<Impl, OFFSET>, Pins::<Impl, OFFSET>, IsFileSource::<Impl, OFFSET>, Filename::<Impl, OFFSET>, SetFilename::<Impl, OFFSET>)
    }
}
pub trait IFilterMapperImpl: Sized {
    fn RegisterFilter();
    fn RegisterFilterInstance();
    fn RegisterPin();
    fn RegisterPinType();
    fn UnregisterFilter();
    fn UnregisterFilterInstance();
    fn UnregisterPin();
    fn EnumMatchingFilters();
}
impl ::windows::core::RuntimeName for IFilterMapper {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterMapper";
}
impl IFilterMapperVtbl {
    pub const fn new<Impl: IFilterMapperImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterMapperVtbl {
        unsafe extern "system" fn RegisterFilter<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: ::windows::core::GUID, name: super::super::Foundation::PWSTR, dwmerit: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterFilter(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&name as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwmerit) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterFilterInstance<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: ::windows::core::GUID, name: super::super::Foundation::PWSTR, mrid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterFilterInstance(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&name as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&mrid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterPin<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID, name: super::super::Foundation::PWSTR, brendered: super::super::Foundation::BOOL, boutput: super::super::Foundation::BOOL, bzero: super::super::Foundation::BOOL, bmany: super::super::Foundation::BOOL, connectstofilter: ::windows::core::GUID, connectstopin: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterPin(
                &*(&filter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&name as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&brendered as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&boutput as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&bzero as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&bmany as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&connectstofilter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&connectstopin as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterPinType<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsfilter: ::windows::core::GUID, strname: super::super::Foundation::PWSTR, clsmajortype: ::windows::core::GUID, clssubtype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterPinType(
                &*(&clsfilter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&strname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&clsmajortype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&clssubtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterFilter<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterFilter(&*(&filter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterFilterInstance<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mrid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterFilterInstance(&*(&mrid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterPin<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID, name: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterPin(&*(&filter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&name as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMatchingFilters<Impl: IFilterMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, clsinmaj: ::windows::core::GUID, clsinsub: ::windows::core::GUID, brender: super::super::Foundation::BOOL, boututneeded: super::super::Foundation::BOOL, clsoutmaj: ::windows::core::GUID, clsoutsub: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMatchingFilters(
                ::core::mem::transmute_copy(&ppenum),
                dwmerit,
                &*(&binputneeded as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&clsinmaj as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&clsinsub as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&brender as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&boututneeded as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&clsoutmaj as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&clsoutsub as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterMapper>, base.5, RegisterFilter::<Impl, OFFSET>, RegisterFilterInstance::<Impl, OFFSET>, RegisterPin::<Impl, OFFSET>, RegisterPinType::<Impl, OFFSET>, UnregisterFilter::<Impl, OFFSET>, UnregisterFilterInstance::<Impl, OFFSET>, UnregisterPin::<Impl, OFFSET>, EnumMatchingFilters::<Impl, OFFSET>)
    }
}
pub trait IFilterMapper2Impl: Sized {
    fn CreateCategory();
    fn UnregisterFilter();
    fn RegisterFilter();
    fn EnumMatchingFilters();
}
impl ::windows::core::RuntimeName for IFilterMapper2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterMapper2";
}
impl IFilterMapper2Vtbl {
    pub const fn new<Impl: IFilterMapper2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterMapper2Vtbl {
        unsafe extern "system" fn CreateCategory<Impl: IFilterMapper2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsidcategory: *const ::windows::core::GUID, dwcategorymerit: u32, description: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateCategory(&*(&clsidcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), dwcategorymerit, &*(&description as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterFilter<Impl: IFilterMapper2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, filter: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterFilter(
                &*(&pclsidcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&szinstance as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&filter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterFilter<Impl: IFilterMapper2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsidfilter: *const ::windows::core::GUID, name: super::super::Foundation::PWSTR, ppmoniker: *mut ::windows::core::RawPtr, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, prf2: *const REGFILTER2) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterFilter(
                &*(&clsidfilter as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&name as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&ppmoniker as *const <super::super::System::Com::IMoniker as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IMoniker as ::windows::core::DefaultType>::DefaultType),
                &*(&pclsidcategory as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&szinstance as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&prf2 as *const <REGFILTER2 as ::windows::core::Abi>::Abi as *const <REGFILTER2 as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMatchingFilters<Impl: IFilterMapper2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr, dwflags: u32, bexactmatch: super::super::Foundation::BOOL, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, cinputtypes: u32, pinputtypes: *const ::windows::core::GUID, pmedin: *const REGPINMEDIUM, ppincategoryin: *const ::windows::core::GUID, brender: super::super::Foundation::BOOL, boutputneeded: super::super::Foundation::BOOL, coutputtypes: u32, poutputtypes: *const ::windows::core::GUID, pmedout: *const REGPINMEDIUM, ppincategoryout: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMatchingFilters(
                ::core::mem::transmute_copy(&ppenum),
                dwflags,
                &*(&bexactmatch as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                dwmerit,
                &*(&binputneeded as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                cinputtypes,
                &*(&pinputtypes as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pmedin as *const <REGPINMEDIUM as ::windows::core::Abi>::Abi as *const <REGPINMEDIUM as ::windows::core::DefaultType>::DefaultType),
                &*(&ppincategoryin as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&brender as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&boutputneeded as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                coutputtypes,
                &*(&poutputtypes as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pmedout as *const <REGPINMEDIUM as ::windows::core::Abi>::Abi as *const <REGPINMEDIUM as ::windows::core::DefaultType>::DefaultType),
                &*(&ppincategoryout as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterMapper2>, base.5, CreateCategory::<Impl, OFFSET>, UnregisterFilter::<Impl, OFFSET>, RegisterFilter::<Impl, OFFSET>, EnumMatchingFilters::<Impl, OFFSET>)
    }
}
pub trait IFilterMapper3Impl: Sized + IFilterMapper2Impl {
    fn GetICreateDevEnum();
}
impl ::windows::core::RuntimeName for IFilterMapper3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFilterMapper3";
}
impl IFilterMapper3Vtbl {
    pub const fn new<Impl: IFilterMapper3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFilterMapper3Vtbl {
        unsafe extern "system" fn GetICreateDevEnum<Impl: IFilterMapper3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetICreateDevEnum(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFilterMapper3>, base.5, GetICreateDevEnum::<Impl, OFFSET>)
    }
}
pub trait IFrequencyMapImpl: Sized {
    fn FrequencyMapping();
    fn SetFrequencyMapping();
    fn CountryCode();
    fn SetCountryCode();
    fn DefaultFrequencyMapping();
    fn CountryCodeList();
}
impl ::windows::core::RuntimeName for IFrequencyMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFrequencyMap";
}
impl IFrequencyMapVtbl {
    pub const fn new<Impl: IFrequencyMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrequencyMapVtbl {
        unsafe extern "system" fn FrequencyMapping<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrequencyMapping(::core::mem::transmute_copy(&ulcount), ::core::mem::transmute_copy(&ppullist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyMapping<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcount: u32, plist: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrequencyMapping(ulcount, plist) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCode<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcountrycode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&pulcountrycode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcountrycode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(ulcountrycode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultFrequencyMapping<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultFrequencyMapping(ulcountrycode, ::core::mem::transmute_copy(&pulcount), ::core::mem::transmute_copy(&ppullist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCodeList<Impl: IFrequencyMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCodeList(::core::mem::transmute_copy(&pulcount), ::core::mem::transmute_copy(&ppullist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrequencyMap>, base.5, FrequencyMapping::<Impl, OFFSET>, SetFrequencyMapping::<Impl, OFFSET>, CountryCode::<Impl, OFFSET>, SetCountryCode::<Impl, OFFSET>, DefaultFrequencyMapping::<Impl, OFFSET>, CountryCodeList::<Impl, OFFSET>)
    }
}
pub trait IFullScreenVideoImpl: Sized {
    fn CountModes();
    fn GetModeInfo();
    fn GetCurrentMode();
    fn IsModeAvailable();
    fn IsModeEnabled();
    fn SetEnabled();
    fn GetClipFactor();
    fn SetClipFactor();
    fn SetMessageDrain();
    fn GetMessageDrain();
    fn SetMonitor();
    fn GetMonitor();
    fn HideOnDeactivate();
    fn IsHideOnDeactivate();
    fn SetCaption();
    fn GetCaption();
    fn SetDefault();
}
impl ::windows::core::RuntimeName for IFullScreenVideo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFullScreenVideo";
}
impl IFullScreenVideoVtbl {
    pub const fn new<Impl: IFullScreenVideoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFullScreenVideoVtbl {
        unsafe extern "system" fn CountModes<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountModes(::core::mem::transmute_copy(&pmodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModeInfo<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetModeInfo(mode, ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight), ::core::mem::transmute_copy(&pdepth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMode<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentMode(::core::mem::transmute_copy(&pmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsModeAvailable<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsModeAvailable(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsModeEnabled<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsModeEnabled(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnabled<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: i32, benabled: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnabled(mode, benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClipFactor<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclipfactor: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClipFactor(::core::mem::transmute_copy(&pclipfactor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipFactor<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clipfactor: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetClipFactor(clipfactor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMessageDrain<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMessageDrain(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMessageDrain<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMessageDrain(::core::mem::transmute_copy(&hwnd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonitor<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, monitor: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMonitor(monitor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMonitor<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, monitor: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMonitor(::core::mem::transmute_copy(&monitor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HideOnDeactivate<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hide: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HideOnDeactivate(hide) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHideOnDeactivate<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHideOnDeactivate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaption<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strcaption: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCaption(&*(&strcaption as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCaption<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstrcaption: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaption(::core::mem::transmute_copy(&pstrcaption)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefault<Impl: IFullScreenVideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefault() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IFullScreenVideo>,
            base.5,
            CountModes::<Impl, OFFSET>,
            GetModeInfo::<Impl, OFFSET>,
            GetCurrentMode::<Impl, OFFSET>,
            IsModeAvailable::<Impl, OFFSET>,
            IsModeEnabled::<Impl, OFFSET>,
            SetEnabled::<Impl, OFFSET>,
            GetClipFactor::<Impl, OFFSET>,
            SetClipFactor::<Impl, OFFSET>,
            SetMessageDrain::<Impl, OFFSET>,
            GetMessageDrain::<Impl, OFFSET>,
            SetMonitor::<Impl, OFFSET>,
            GetMonitor::<Impl, OFFSET>,
            HideOnDeactivate::<Impl, OFFSET>,
            IsHideOnDeactivate::<Impl, OFFSET>,
            SetCaption::<Impl, OFFSET>,
            GetCaption::<Impl, OFFSET>,
            SetDefault::<Impl, OFFSET>,
        )
    }
}
pub trait IFullScreenVideoExImpl: Sized + IFullScreenVideoImpl {
    fn SetAcceleratorTable();
    fn GetAcceleratorTable();
    fn KeepPixelAspectRatio();
    fn IsKeepPixelAspectRatio();
}
impl ::windows::core::RuntimeName for IFullScreenVideoEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IFullScreenVideoEx";
}
impl IFullScreenVideoExVtbl {
    pub const fn new<Impl: IFullScreenVideoExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFullScreenVideoExVtbl {
        unsafe extern "system" fn SetAcceleratorTable<Impl: IFullScreenVideoExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAcceleratorTable(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType), &*(&haccel as *const <super::super::UI::WindowsAndMessaging::HACCEL as ::windows::core::Abi>::Abi as *const <super::super::UI::WindowsAndMessaging::HACCEL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAcceleratorTable<Impl: IFullScreenVideoExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAcceleratorTable(::core::mem::transmute_copy(&phwnd), &*(&phaccel as *const <super::super::UI::WindowsAndMessaging::HACCEL as ::windows::core::Abi>::Abi as *const <super::super::UI::WindowsAndMessaging::HACCEL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeepPixelAspectRatio<Impl: IFullScreenVideoExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keepaspect: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeepPixelAspectRatio(keepaspect) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsKeepPixelAspectRatio<Impl: IFullScreenVideoExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkeepaspect: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsKeepPixelAspectRatio(::core::mem::transmute_copy(&pkeepaspect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFullScreenVideoEx>, base.5, SetAcceleratorTable::<Impl, OFFSET>, GetAcceleratorTable::<Impl, OFFSET>, KeepPixelAspectRatio::<Impl, OFFSET>, IsKeepPixelAspectRatio::<Impl, OFFSET>)
    }
}
pub trait IGenericDescriptorImpl: Sized {
    fn Initialize();
    fn GetTag();
    fn GetLength();
    fn GetBody();
}
impl ::windows::core::RuntimeName for IGenericDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGenericDescriptor";
}
impl IGenericDescriptorVtbl {
    pub const fn new<Impl: IGenericDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGenericDescriptorVtbl {
        unsafe extern "system" fn Initialize<Impl: IGenericDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdesc: *const u8, bcount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(pbdesc, bcount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTag<Impl: IGenericDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IGenericDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBody<Impl: IGenericDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbval: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBody(::core::mem::transmute_copy(&ppbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGenericDescriptor>, base.5, Initialize::<Impl, OFFSET>, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetBody::<Impl, OFFSET>)
    }
}
pub trait IGenericDescriptor2Impl: Sized + IGenericDescriptorImpl {
    fn Initialize();
    fn GetLength();
}
impl ::windows::core::RuntimeName for IGenericDescriptor2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGenericDescriptor2";
}
impl IGenericDescriptor2Vtbl {
    pub const fn new<Impl: IGenericDescriptor2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGenericDescriptor2Vtbl {
        unsafe extern "system" fn Initialize<Impl: IGenericDescriptor2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdesc: *const u8, wcount: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(pbdesc, wcount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IGenericDescriptor2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGenericDescriptor2>, base.5, Initialize::<Impl, OFFSET>, GetLength::<Impl, OFFSET>)
    }
}
pub trait IGetCapabilitiesKeyImpl: Sized {
    fn GetCapabilitiesKey();
}
impl ::windows::core::RuntimeName for IGetCapabilitiesKey {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGetCapabilitiesKey";
}
impl IGetCapabilitiesKeyVtbl {
    pub const fn new<Impl: IGetCapabilitiesKeyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGetCapabilitiesKeyVtbl {
        unsafe extern "system" fn GetCapabilitiesKey<Impl: IGetCapabilitiesKeyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phkey: *mut super::super::System::Registry::HKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapabilitiesKey(::core::mem::transmute_copy(&phkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGetCapabilitiesKey>, base.5, GetCapabilitiesKey::<Impl, OFFSET>)
    }
}
pub trait IGpnvsCommonBaseImpl: Sized {
    fn GetValueUpdateName();
}
impl ::windows::core::RuntimeName for IGpnvsCommonBase {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGpnvsCommonBase";
}
impl IGpnvsCommonBaseVtbl {
    pub const fn new<Impl: IGpnvsCommonBaseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGpnvsCommonBaseVtbl {
        unsafe extern "system" fn GetValueUpdateName<Impl: IGpnvsCommonBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValueUpdateName(::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGpnvsCommonBase>, base.5, GetValueUpdateName::<Impl, OFFSET>)
    }
}
pub trait IGraphBuilderImpl: Sized + IFilterGraphImpl {
    fn Connect();
    fn Render();
    fn RenderFile();
    fn AddSourceFilter();
    fn SetLogFile();
    fn Abort();
    fn ShouldOperationContinue();
}
impl ::windows::core::RuntimeName for IGraphBuilder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGraphBuilder";
}
impl IGraphBuilderVtbl {
    pub const fn new<Impl: IGraphBuilderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGraphBuilderVtbl {
        unsafe extern "system" fn Connect<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, ppinin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Connect(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&ppinin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Render<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Render(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderFile<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpcwstrfile: super::super::Foundation::PWSTR, lpcwstrplaylist: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderFile(&*(&lpcwstrfile as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&lpcwstrplaylist as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSourceFilter<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpcwstrfilename: super::super::Foundation::PWSTR, lpcwstrfiltername: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddSourceFilter(&*(&lpcwstrfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&lpcwstrfiltername as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppfilter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLogFile<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hfile: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLogFile(hfile) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Abort<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Abort() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShouldOperationContinue<Impl: IGraphBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShouldOperationContinue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGraphBuilder>, base.5, Connect::<Impl, OFFSET>, Render::<Impl, OFFSET>, RenderFile::<Impl, OFFSET>, AddSourceFilter::<Impl, OFFSET>, SetLogFile::<Impl, OFFSET>, Abort::<Impl, OFFSET>, ShouldOperationContinue::<Impl, OFFSET>)
    }
}
pub trait IGraphConfigImpl: Sized {
    fn Reconnect();
    fn Reconfigure();
    fn AddFilterToCache();
    fn EnumCacheFilter();
    fn RemoveFilterFromCache();
    fn GetStartTime();
    fn PushThroughData();
    fn SetFilterFlags();
    fn GetFilterFlags();
    fn RemoveFilterEx();
}
impl ::windows::core::RuntimeName for IGraphConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGraphConfig";
}
impl IGraphConfigVtbl {
    pub const fn new<Impl: IGraphConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGraphConfigVtbl {
        unsafe extern "system" fn Reconnect<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poutputpin: ::windows::core::RawPtr, pinputpin: ::windows::core::RawPtr, pmtfirstconnection: *const AM_MEDIA_TYPE, pusingfilter: ::windows::core::RawPtr, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reconnect(
                &*(&poutputpin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType),
                &*(&pinputpin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType),
                &*(&pmtfirstconnection as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType),
                &*(&pusingfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType),
                &*(&habortevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
                dwflags,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reconfigure<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pvcontext: *mut ::core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reconfigure(
                &*(&pcallback as *const <IGraphConfigCallback as ::windows::core::Abi>::Abi as *const <IGraphConfigCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pvcontext as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&habortevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddFilterToCache<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddFilterToCache(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumCacheFilter<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumCacheFilter(::core::mem::transmute_copy(&penum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFilterFromCache<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveFilterFromCache(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartTime<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartTime(prtstart) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PushThroughData<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poutputpin: ::windows::core::RawPtr, pconnection: ::windows::core::RawPtr, heventabort: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PushThroughData(&*(&poutputpin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pconnection as *const <IPinConnection as ::windows::core::Abi>::Abi as *const <IPinConnection as ::windows::core::DefaultType>::DefaultType), &*(&heventabort as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilterFlags<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFilterFlags(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterFlags<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilterFlags(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), pdwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFilterEx<Impl: IGraphConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, flags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveFilterEx(&*(&pfilter as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGraphConfig>, base.5, Reconnect::<Impl, OFFSET>, Reconfigure::<Impl, OFFSET>, AddFilterToCache::<Impl, OFFSET>, EnumCacheFilter::<Impl, OFFSET>, RemoveFilterFromCache::<Impl, OFFSET>, GetStartTime::<Impl, OFFSET>, PushThroughData::<Impl, OFFSET>, SetFilterFlags::<Impl, OFFSET>, GetFilterFlags::<Impl, OFFSET>, RemoveFilterEx::<Impl, OFFSET>)
    }
}
pub trait IGraphConfigCallbackImpl: Sized {
    fn Reconfigure();
}
impl ::windows::core::RuntimeName for IGraphConfigCallback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGraphConfigCallback";
}
impl IGraphConfigCallbackVtbl {
    pub const fn new<Impl: IGraphConfigCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGraphConfigCallbackVtbl {
        unsafe extern "system" fn Reconfigure<Impl: IGraphConfigCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvcontext: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reconfigure(&*(&pvcontext as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGraphConfigCallback>, base.5, Reconfigure::<Impl, OFFSET>)
    }
}
pub trait IGraphVersionImpl: Sized {
    fn QueryVersion();
}
impl ::windows::core::RuntimeName for IGraphVersion {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGraphVersion";
}
impl IGraphVersionVtbl {
    pub const fn new<Impl: IGraphVersionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGraphVersionVtbl {
        unsafe extern "system" fn QueryVersion<Impl: IGraphVersionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pversion: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryVersion(::core::mem::transmute_copy(&pversion)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGraphVersion>, base.5, QueryVersion::<Impl, OFFSET>)
    }
}
pub trait IGuideDataImpl: Sized {
    fn GetServices();
    fn GetServiceProperties();
    fn GetGuideProgramIDs();
    fn GetProgramProperties();
    fn GetScheduleEntryIDs();
    fn GetScheduleEntryProperties();
}
impl ::windows::core::RuntimeName for IGuideData {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGuideData";
}
impl IGuideDataVtbl {
    pub const fn new<Impl: IGuideDataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGuideDataVtbl {
        unsafe extern "system" fn GetServices<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenumtunerequests: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServices(::core::mem::transmute_copy(&ppenumtunerequests)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProperties<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptunerequest: ::windows::core::RawPtr, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceProperties(&*(&ptunerequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppenumproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuideProgramIDs<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penumprograms: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuideProgramIDs(::core::mem::transmute_copy(&penumprograms)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramProperties<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProgramProperties(&*(&varprogramdescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppenumproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScheduleEntryIDs<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penumscheduleentries: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetScheduleEntryIDs(::core::mem::transmute_copy(&penumscheduleentries)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScheduleEntryProperties<Impl: IGuideDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetScheduleEntryProperties(&*(&varscheduleentrydescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppenumproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGuideData>, base.5, GetServices::<Impl, OFFSET>, GetServiceProperties::<Impl, OFFSET>, GetGuideProgramIDs::<Impl, OFFSET>, GetProgramProperties::<Impl, OFFSET>, GetScheduleEntryIDs::<Impl, OFFSET>, GetScheduleEntryProperties::<Impl, OFFSET>)
    }
}
pub trait IGuideDataEventImpl: Sized {
    fn GuideDataAcquired();
    fn ProgramChanged();
    fn ServiceChanged();
    fn ScheduleEntryChanged();
    fn ProgramDeleted();
    fn ServiceDeleted();
    fn ScheduleDeleted();
}
impl ::windows::core::RuntimeName for IGuideDataEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGuideDataEvent";
}
impl IGuideDataEventVtbl {
    pub const fn new<Impl: IGuideDataEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGuideDataEventVtbl {
        unsafe extern "system" fn GuideDataAcquired<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GuideDataAcquired() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProgramChanged<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProgramChanged(&*(&varprogramdescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ServiceChanged<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varservicedescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ServiceChanged(&*(&varservicedescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScheduleEntryChanged<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScheduleEntryChanged(&*(&varscheduleentrydescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProgramDeleted<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProgramDeleted(&*(&varprogramdescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ServiceDeleted<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varservicedescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ServiceDeleted(&*(&varservicedescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScheduleDeleted<Impl: IGuideDataEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScheduleDeleted(&*(&varscheduleentrydescriptionid as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGuideDataEvent>, base.5, GuideDataAcquired::<Impl, OFFSET>, ProgramChanged::<Impl, OFFSET>, ServiceChanged::<Impl, OFFSET>, ScheduleEntryChanged::<Impl, OFFSET>, ProgramDeleted::<Impl, OFFSET>, ServiceDeleted::<Impl, OFFSET>, ScheduleDeleted::<Impl, OFFSET>)
    }
}
pub trait IGuideDataLoaderImpl: Sized {
    fn Init();
    fn Terminate();
}
impl ::windows::core::RuntimeName for IGuideDataLoader {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGuideDataLoader";
}
impl IGuideDataLoaderVtbl {
    pub const fn new<Impl: IGuideDataLoaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGuideDataLoaderVtbl {
        unsafe extern "system" fn Init<Impl: IGuideDataLoaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidestore: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init(&*(&pguidestore as *const <IGuideData as ::windows::core::Abi>::Abi as *const <IGuideData as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Terminate<Impl: IGuideDataLoaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Terminate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGuideDataLoader>, base.5, Init::<Impl, OFFSET>, Terminate::<Impl, OFFSET>)
    }
}
pub trait IGuideDataPropertyImpl: Sized {
    fn Name();
    fn Language();
    fn Value();
}
impl ::windows::core::RuntimeName for IGuideDataProperty {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IGuideDataProperty";
}
impl IGuideDataPropertyVtbl {
    pub const fn new<Impl: IGuideDataPropertyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGuideDataPropertyVtbl {
        unsafe extern "system" fn Name<Impl: IGuideDataPropertyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Name(::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: IGuideDataPropertyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idlang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Language(::core::mem::transmute_copy(&idlang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Value<Impl: IGuideDataPropertyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvar: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Value(::core::mem::transmute_copy(&pvar)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGuideDataProperty>, base.5, Name::<Impl, OFFSET>, Language::<Impl, OFFSET>, Value::<Impl, OFFSET>)
    }
}
pub trait IIPDVDecImpl: Sized {
    fn IPDisplay();
    fn SetIPDisplay();
}
impl ::windows::core::RuntimeName for IIPDVDec {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIPDVDec";
}
impl IIPDVDecVtbl {
    pub const fn new<Impl: IIPDVDecImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIPDVDecVtbl {
        unsafe extern "system" fn IPDisplay<Impl: IIPDVDecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, displaypix: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IPDisplay(::core::mem::transmute_copy(&displaypix)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIPDisplay<Impl: IIPDVDecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, displaypix: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIPDisplay(displaypix) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIPDVDec>, base.5, IPDisplay::<Impl, OFFSET>, SetIPDisplay::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IISDBSLocatorImpl: Sized + IDVBSLocatorImpl + IDigitalLocatorImpl + ILocatorImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IISDBSLocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDBSLocator";
}
#[cfg(feature = "Win32_System_Com")]
impl IISDBSLocatorVtbl {
    pub const fn new<Impl: IISDBSLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDBSLocatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IISDBSLocator>, base.5)
    }
}
pub trait IISDB_BITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetOriginalNetworkId();
    fn GetBroadcastViewPropriety();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetCountOfRecords();
    fn GetRecordBroadcasterId();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_BIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_BIT";
}
impl IISDB_BITVtbl {
    pub const fn new<Impl: IISDB_BITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_BITVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBroadcastViewPropriety<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBroadcastViewPropriety(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordBroadcasterId<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordBroadcasterId(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_BITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IISDB_BIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetBroadcastViewPropriety::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordBroadcasterId::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IISDB_CDTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetDownloadDataId();
    fn GetSectionNumber();
    fn GetOriginalNetworkId();
    fn GetDataType();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetSizeOfDataModule();
    fn GetDataModule();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_CDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_CDT";
}
impl IISDB_CDTVtbl {
    pub const fn new<Impl: IISDB_CDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_CDTVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr, bsectionnumber: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType), bsectionnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadDataId<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDownloadDataId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSectionNumber<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSectionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataType<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSizeOfDataModule<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSizeOfDataModule(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataModule<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataModule(::core::mem::transmute_copy(&pbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_CDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IISDB_CDT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetDownloadDataId::<Impl, OFFSET>,
            GetSectionNumber::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetDataType::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetSizeOfDataModule::<Impl, OFFSET>,
            GetDataModule::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IISDB_EMMImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetTableIdExtension();
    fn GetDataBytes();
    fn GetSharedEmmMessage();
    fn GetIndividualEmmMessage();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_EMM {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_EMM";
}
impl IISDB_EMMVtbl {
    pub const fn new<Impl: IISDB_EMMImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_EMMVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableIdExtension<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableIdExtension(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBytes<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwbufferlength: *mut u16, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataBytes(pwbufferlength, ::core::mem::transmute_copy(&pbbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSharedEmmMessage<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSharedEmmMessage(pwlength, ppbmessage) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndividualEmmMessage<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punknown: *mut ::core::ffi::c_void, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndividualEmmMessage(&*(&punknown as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), pwlength, ppbmessage) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_EMMImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IISDB_EMM>, base.5, Initialize::<Impl, OFFSET>, GetVersionNumber::<Impl, OFFSET>, GetTableIdExtension::<Impl, OFFSET>, GetDataBytes::<Impl, OFFSET>, GetSharedEmmMessage::<Impl, OFFSET>, GetIndividualEmmMessage::<Impl, OFFSET>, GetVersionHash::<Impl, OFFSET>)
    }
}
pub trait IISDB_LDTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetOriginalServiceId();
    fn GetTransportStreamId();
    fn GetOriginalNetworkId();
    fn GetCountOfRecords();
    fn GetRecordDescriptionId();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_LDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_LDT";
}
impl IISDB_LDTVtbl {
    pub const fn new<Impl: IISDB_LDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_LDTVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalServiceId<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalServiceId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptionId<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptionId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_LDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IISDB_LDT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetOriginalServiceId::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordDescriptionId::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IISDB_NBITImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetOriginalNetworkId();
    fn GetCountOfRecords();
    fn GetRecordInformationId();
    fn GetRecordInformationType();
    fn GetRecordDescriptionBodyLocation();
    fn GetRecordMessageSectionNumber();
    fn GetRecordUserDefined();
    fn GetRecordNumberOfKeys();
    fn GetRecordKeys();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_NBIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_NBIT";
}
impl IISDB_NBITVtbl {
    pub const fn new<Impl: IISDB_NBITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_NBITVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordInformationId<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordInformationId(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordInformationType<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordInformationType(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptionBodyLocation<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptionBodyLocation(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMessageSectionNumber<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordMessageSectionNumber(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordUserDefined<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordUserDefined(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfKeys<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfKeys(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordKeys<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbkeys: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordKeys(dwrecordindex, ::core::mem::transmute_copy(&pbkeys)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_NBITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IISDB_NBIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordInformationId::<Impl, OFFSET>,
            GetRecordInformationType::<Impl, OFFSET>,
            GetRecordDescriptionBodyLocation::<Impl, OFFSET>,
            GetRecordMessageSectionNumber::<Impl, OFFSET>,
            GetRecordUserDefined::<Impl, OFFSET>,
            GetRecordNumberOfKeys::<Impl, OFFSET>,
            GetRecordKeys::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IISDB_SDTImpl: Sized + IDVB_SDTImpl {
    fn GetRecordEITUserDefinedFlags();
}
impl ::windows::core::RuntimeName for IISDB_SDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_SDT";
}
impl IISDB_SDTVtbl {
    pub const fn new<Impl: IISDB_SDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_SDTVtbl {
        unsafe extern "system" fn GetRecordEITUserDefinedFlags<Impl: IISDB_SDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEITUserDefinedFlags(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IISDB_SDT>, base.5, GetRecordEITUserDefinedFlags::<Impl, OFFSET>)
    }
}
pub trait IISDB_SDTTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetTableIdExt();
    fn GetTransportStreamId();
    fn GetOriginalNetworkId();
    fn GetServiceId();
    fn GetCountOfRecords();
    fn GetRecordGroup();
    fn GetRecordTargetVersion();
    fn GetRecordNewVersion();
    fn GetRecordDownloadLevel();
    fn GetRecordVersionIndicator();
    fn GetRecordScheduleTimeShiftInformation();
    fn GetRecordCountOfSchedules();
    fn GetRecordStartTimeByIndex();
    fn GetRecordDurationByIndex();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn GetVersionHash();
}
impl ::windows::core::RuntimeName for IISDB_SDTT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IISDB_SDTT";
}
impl IISDB_SDTTVtbl {
    pub const fn new<Impl: IISDB_SDTTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IISDB_SDTTVtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableIdExt<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableIdExt(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordGroup<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordGroup(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTargetVersion<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTargetVersion(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNewVersion<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNewVersion(dwrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDownloadLevel<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDownloadLevel(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVersionIndicator<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordVersionIndicator(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordScheduleTimeShiftInformation<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordScheduleTimeShiftInformation(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfSchedules<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfSchedules(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTimeByIndex<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTimeByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDurationByIndex<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDurationByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&pmdval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_SDTTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionHash(::core::mem::transmute_copy(&pdwversionhash)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IISDB_SDTT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetTableIdExt::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetOriginalNetworkId::<Impl, OFFSET>,
            GetServiceId::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordGroup::<Impl, OFFSET>,
            GetRecordTargetVersion::<Impl, OFFSET>,
            GetRecordNewVersion::<Impl, OFFSET>,
            GetRecordDownloadLevel::<Impl, OFFSET>,
            GetRecordVersionIndicator::<Impl, OFFSET>,
            GetRecordScheduleTimeShiftInformation::<Impl, OFFSET>,
            GetRecordCountOfSchedules::<Impl, OFFSET>,
            GetRecordStartTimeByIndex::<Impl, OFFSET>,
            GetRecordDurationByIndex::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            GetVersionHash::<Impl, OFFSET>,
        )
    }
}
pub trait IIsdbAudioComponentDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetStreamContent();
    fn GetComponentType();
    fn GetComponentTag();
    fn GetStreamType();
    fn GetSimulcastGroupTag();
    fn GetESMultiLingualFlag();
    fn GetMainComponentFlag();
    fn GetQualityIndicator();
    fn GetSamplingRate();
    fn GetLanguageCode();
    fn GetLanguageCode2();
    fn GetTextW();
}
impl ::windows::core::RuntimeName for IIsdbAudioComponentDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbAudioComponentDescriptor";
}
impl IIsdbAudioComponentDescriptorVtbl {
    pub const fn new<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbAudioComponentDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamContent<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamContent(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentType<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamType<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSimulcastGroupTag<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSimulcastGroupTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetESMultiLingualFlag<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetESMultiLingualFlag(::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMainComponentFlag<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMainComponentFlag(::core::mem::transmute_copy(&pfval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityIndicator<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetQualityIndicator(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSamplingRate<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSamplingRate(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode2<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode2(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbAudioComponentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IIsdbAudioComponentDescriptor>,
            base.5,
            GetTag::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            GetStreamContent::<Impl, OFFSET>,
            GetComponentType::<Impl, OFFSET>,
            GetComponentTag::<Impl, OFFSET>,
            GetStreamType::<Impl, OFFSET>,
            GetSimulcastGroupTag::<Impl, OFFSET>,
            GetESMultiLingualFlag::<Impl, OFFSET>,
            GetMainComponentFlag::<Impl, OFFSET>,
            GetQualityIndicator::<Impl, OFFSET>,
            GetSamplingRate::<Impl, OFFSET>,
            GetLanguageCode::<Impl, OFFSET>,
            GetLanguageCode2::<Impl, OFFSET>,
            GetTextW::<Impl, OFFSET>,
        )
    }
}
pub trait IIsdbCAContractInformationDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCASystemId();
    fn GetCAUnitId();
    fn GetCountOfRecords();
    fn GetRecordComponentTag();
    fn GetContractVerificationInfoLength();
    fn GetContractVerificationInfo();
    fn GetFeeNameW();
}
impl ::windows::core::RuntimeName for IIsdbCAContractInformationDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbCAContractInformationDescriptor";
}
impl IIsdbCAContractInformationDescriptorVtbl {
    pub const fn new<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbCAContractInformationDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCASystemId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAUnitId<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCAUnitId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordComponentTag<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordComponentTag(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContractVerificationInfoLength<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContractVerificationInfoLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContractVerificationInfo<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bbuflength: u8, pbbuf: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContractVerificationInfo(bbuflength, ::core::mem::transmute_copy(&pbbuf)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFeeNameW<Impl: IIsdbCAContractInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFeeNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbCAContractInformationDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCASystemId::<Impl, OFFSET>, GetCAUnitId::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordComponentTag::<Impl, OFFSET>, GetContractVerificationInfoLength::<Impl, OFFSET>, GetContractVerificationInfo::<Impl, OFFSET>, GetFeeNameW::<Impl, OFFSET>)
    }
}
pub trait IIsdbCADescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCASystemId();
    fn GetReservedBits();
    fn GetCAPID();
    fn GetPrivateDataBytes();
}
impl ::windows::core::RuntimeName for IIsdbCADescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbCADescriptor";
}
impl IIsdbCADescriptorVtbl {
    pub const fn new<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbCADescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCASystemId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReservedBits<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReservedBits(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAPID<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCAPID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataBytes<Impl: IIsdbCADescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataBytes(pbbufferlength, ::core::mem::transmute_copy(&pbbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbCADescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCASystemId::<Impl, OFFSET>, GetReservedBits::<Impl, OFFSET>, GetCAPID::<Impl, OFFSET>, GetPrivateDataBytes::<Impl, OFFSET>)
    }
}
pub trait IIsdbCAServiceDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCASystemId();
    fn GetCABroadcasterGroupId();
    fn GetMessageControl();
    fn GetServiceIds();
}
impl ::windows::core::RuntimeName for IIsdbCAServiceDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbCAServiceDescriptor";
}
impl IIsdbCAServiceDescriptorVtbl {
    pub const fn new<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbCAServiceDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCASystemId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCABroadcasterGroupId<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCABroadcasterGroupId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMessageControl<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMessageControl(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceIds<Impl: IIsdbCAServiceDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbnumserviceids: *mut u8, pwserviceids: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceIds(pbnumserviceids, ::core::mem::transmute_copy(&pwserviceids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbCAServiceDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCASystemId::<Impl, OFFSET>, GetCABroadcasterGroupId::<Impl, OFFSET>, GetMessageControl::<Impl, OFFSET>, GetServiceIds::<Impl, OFFSET>)
    }
}
pub trait IIsdbComponentGroupDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetComponentGroupType();
    fn GetCountOfRecords();
    fn GetRecordGroupId();
    fn GetRecordNumberOfCAUnit();
    fn GetRecordCAUnitCAUnitId();
    fn GetRecordCAUnitNumberOfComponents();
    fn GetRecordCAUnitComponentTag();
    fn GetRecordTotalBitRate();
    fn GetRecordTextW();
}
impl ::windows::core::RuntimeName for IIsdbComponentGroupDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbComponentGroupDescriptor";
}
impl IIsdbComponentGroupDescriptorVtbl {
    pub const fn new<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbComponentGroupDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentGroupType<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentGroupType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordGroupId<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordGroupId(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfCAUnit<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfCAUnit(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitCAUnitId<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitCAUnitId(brecordindex, bcaunitindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitNumberOfComponents<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitNumberOfComponents(brecordindex, bcaunitindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitComponentTag<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, bcomponentindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitComponentTag(brecordindex, bcaunitindex, bcomponentindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTotalBitRate<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTotalBitRate(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTextW<Impl: IIsdbComponentGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTextW(brecordindex, convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IIsdbComponentGroupDescriptor>,
            base.5,
            GetTag::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            GetComponentGroupType::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordGroupId::<Impl, OFFSET>,
            GetRecordNumberOfCAUnit::<Impl, OFFSET>,
            GetRecordCAUnitCAUnitId::<Impl, OFFSET>,
            GetRecordCAUnitNumberOfComponents::<Impl, OFFSET>,
            GetRecordCAUnitComponentTag::<Impl, OFFSET>,
            GetRecordTotalBitRate::<Impl, OFFSET>,
            GetRecordTextW::<Impl, OFFSET>,
        )
    }
}
pub trait IIsdbDataContentDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetDataComponentId();
    fn GetEntryComponent();
    fn GetSelectorLength();
    fn GetSelectorBytes();
    fn GetCountOfRecords();
    fn GetRecordComponentRef();
    fn GetLanguageCode();
    fn GetTextW();
}
impl ::windows::core::RuntimeName for IIsdbDataContentDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbDataContentDescriptor";
}
impl IIsdbDataContentDescriptorVtbl {
    pub const fn new<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbDataContentDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataComponentId<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataComponentId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryComponent<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryComponent(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorLength<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectorLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorBytes<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bbuflength: u8, pbbuf: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectorBytes(bbuflength, ::core::mem::transmute_copy(&pbbuf)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordComponentRef<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordComponentRef(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbDataContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbDataContentDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetDataComponentId::<Impl, OFFSET>, GetEntryComponent::<Impl, OFFSET>, GetSelectorLength::<Impl, OFFSET>, GetSelectorBytes::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordComponentRef::<Impl, OFFSET>, GetLanguageCode::<Impl, OFFSET>, GetTextW::<Impl, OFFSET>)
    }
}
pub trait IIsdbDigitalCopyControlDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCopyControl();
    fn GetCountOfRecords();
    fn GetRecordCopyControl();
}
impl ::windows::core::RuntimeName for IIsdbDigitalCopyControlDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbDigitalCopyControlDescriptor";
}
impl IIsdbDigitalCopyControlDescriptorVtbl {
    pub const fn new<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbDigitalCopyControlDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCopyControl<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCopyControl(::core::mem::transmute_copy(&pbdigitalrecordingcontroldata), ::core::mem::transmute_copy(&pbcopycontroltype), ::core::mem::transmute_copy(&pbapscontroldata), ::core::mem::transmute_copy(&pbmaximumbitrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCopyControl<Impl: IIsdbDigitalCopyControlDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbcomponenttag: *mut u8, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCopyControl(brecordindex, ::core::mem::transmute_copy(&pbcomponenttag), ::core::mem::transmute_copy(&pbdigitalrecordingcontroldata), ::core::mem::transmute_copy(&pbcopycontroltype), ::core::mem::transmute_copy(&pbapscontroldata), ::core::mem::transmute_copy(&pbmaximumbitrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbDigitalCopyControlDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCopyControl::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordCopyControl::<Impl, OFFSET>)
    }
}
pub trait IIsdbDownloadContentDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetFlags();
    fn GetComponentSize();
    fn GetDownloadId();
    fn GetTimeOutValueDII();
    fn GetLeakRate();
    fn GetComponentTag();
    fn GetCompatiblityDescriptorLength();
    fn GetCompatiblityDescriptor();
    fn GetCountOfRecords();
    fn GetRecordModuleId();
    fn GetRecordModuleSize();
    fn GetRecordModuleInfoLength();
    fn GetRecordModuleInfo();
    fn GetTextLanguageCode();
    fn GetTextW();
}
impl ::windows::core::RuntimeName for IIsdbDownloadContentDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbDownloadContentDescriptor";
}
impl IIsdbDownloadContentDescriptorVtbl {
    pub const fn new<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbDownloadContentDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfreboot: *mut super::super::Foundation::BOOL, pfaddon: *mut super::super::Foundation::BOOL, pfcompatibility: *mut super::super::Foundation::BOOL, pfmoduleinfo: *mut super::super::Foundation::BOOL, pftextinfo: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pfreboot), ::core::mem::transmute_copy(&pfaddon), ::core::mem::transmute_copy(&pfcompatibility), ::core::mem::transmute_copy(&pfmoduleinfo), ::core::mem::transmute_copy(&pftextinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentSize<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentSize(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadId<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDownloadId(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeOutValueDII<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeOutValueDII(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeakRate<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLeakRate(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompatiblityDescriptorLength<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwlength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCompatiblityDescriptorLength(::core::mem::transmute_copy(&pwlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompatiblityDescriptor<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCompatiblityDescriptor(::core::mem::transmute_copy(&ppbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleId<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleId(wrecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleSize<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleSize(wrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleInfoLength<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleInfoLength(wrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleInfo<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, ppbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleInfo(wrecordindex, ::core::mem::transmute_copy(&ppbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextLanguageCode<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextLanguageCode(::core::mem::transmute_copy(&szcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbDownloadContentDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IIsdbDownloadContentDescriptor>,
            base.5,
            GetTag::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            GetFlags::<Impl, OFFSET>,
            GetComponentSize::<Impl, OFFSET>,
            GetDownloadId::<Impl, OFFSET>,
            GetTimeOutValueDII::<Impl, OFFSET>,
            GetLeakRate::<Impl, OFFSET>,
            GetComponentTag::<Impl, OFFSET>,
            GetCompatiblityDescriptorLength::<Impl, OFFSET>,
            GetCompatiblityDescriptor::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordModuleId::<Impl, OFFSET>,
            GetRecordModuleSize::<Impl, OFFSET>,
            GetRecordModuleInfoLength::<Impl, OFFSET>,
            GetRecordModuleInfo::<Impl, OFFSET>,
            GetTextLanguageCode::<Impl, OFFSET>,
            GetTextW::<Impl, OFFSET>,
        )
    }
}
pub trait IIsdbEmergencyInformationDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetCountOfRecords();
    fn GetServiceId();
    fn GetStartEndFlag();
    fn GetSignalLevel();
    fn GetAreaCode();
}
impl ::windows::core::RuntimeName for IIsdbEmergencyInformationDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbEmergencyInformationDescriptor";
}
impl IIsdbEmergencyInformationDescriptorVtbl {
    pub const fn new<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbEmergencyInformationDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceId(brecordindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartEndFlag<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartEndFlag(brecordindex, ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSignalLevel<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSignalLevel(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAreaCode<Impl: IIsdbEmergencyInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ppwval: *mut *mut u16, pbnumareacodes: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAreaCode(brecordindex, ::core::mem::transmute_copy(&ppwval), ::core::mem::transmute_copy(&pbnumareacodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbEmergencyInformationDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetServiceId::<Impl, OFFSET>, GetStartEndFlag::<Impl, OFFSET>, GetSignalLevel::<Impl, OFFSET>, GetAreaCode::<Impl, OFFSET>)
    }
}
pub trait IIsdbEventGroupDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetGroupType();
    fn GetCountOfRecords();
    fn GetRecordEvent();
    fn GetCountOfRefRecords();
    fn GetRefRecordEvent();
}
impl ::windows::core::RuntimeName for IIsdbEventGroupDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbEventGroupDescriptor";
}
impl IIsdbEventGroupDescriptorVtbl {
    pub const fn new<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbEventGroupDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGroupType<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGroupType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEvent<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEvent(brecordindex, ::core::mem::transmute_copy(&pwserviceid), ::core::mem::transmute_copy(&pweventid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRefRecords<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRefRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRefRecordEvent<Impl: IIsdbEventGroupDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pworiginalnetworkid: *mut u16, pwtransportstreamid: *mut u16, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRefRecordEvent(brecordindex, ::core::mem::transmute_copy(&pworiginalnetworkid), ::core::mem::transmute_copy(&pwtransportstreamid), ::core::mem::transmute_copy(&pwserviceid), ::core::mem::transmute_copy(&pweventid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbEventGroupDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetGroupType::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordEvent::<Impl, OFFSET>, GetCountOfRefRecords::<Impl, OFFSET>, GetRefRecordEvent::<Impl, OFFSET>)
    }
}
pub trait IIsdbHierarchicalTransmissionDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetFutureUse1();
    fn GetQualityLevel();
    fn GetFutureUse2();
    fn GetReferencePid();
}
impl ::windows::core::RuntimeName for IIsdbHierarchicalTransmissionDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbHierarchicalTransmissionDescriptor";
}
impl IIsdbHierarchicalTransmissionDescriptorVtbl {
    pub const fn new<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbHierarchicalTransmissionDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFutureUse1<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFutureUse1(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityLevel<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetQualityLevel(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFutureUse2<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFutureUse2(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReferencePid<Impl: IIsdbHierarchicalTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReferencePid(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbHierarchicalTransmissionDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetFutureUse1::<Impl, OFFSET>, GetQualityLevel::<Impl, OFFSET>, GetFutureUse2::<Impl, OFFSET>, GetReferencePid::<Impl, OFFSET>)
    }
}
pub trait IIsdbLogoTransmissionDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetLogoTransmissionType();
    fn GetLogoId();
    fn GetLogoVersion();
    fn GetDownloadDataId();
    fn GetLogoCharW();
}
impl ::windows::core::RuntimeName for IIsdbLogoTransmissionDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbLogoTransmissionDescriptor";
}
impl IIsdbLogoTransmissionDescriptorVtbl {
    pub const fn new<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbLogoTransmissionDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoTransmissionType<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLogoTransmissionType(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoId<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLogoId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoVersion<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLogoVersion(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadDataId<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDownloadDataId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoCharW<Impl: IIsdbLogoTransmissionDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrchar: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLogoCharW(convmode, ::core::mem::transmute_copy(&pbstrchar)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbLogoTransmissionDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetLogoTransmissionType::<Impl, OFFSET>, GetLogoId::<Impl, OFFSET>, GetLogoVersion::<Impl, OFFSET>, GetDownloadDataId::<Impl, OFFSET>, GetLogoCharW::<Impl, OFFSET>)
    }
}
pub trait IIsdbSIParameterDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetParameterVersion();
    fn GetUpdateTime();
    fn GetRecordNumberOfTable();
    fn GetTableId();
    fn GetTableDescriptionLength();
    fn GetTableDescriptionBytes();
}
impl ::windows::core::RuntimeName for IIsdbSIParameterDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbSIParameterDescriptor";
}
impl IIsdbSIParameterDescriptorVtbl {
    pub const fn new<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbSIParameterDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterVersion<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameterVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUpdateTime<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut MPEG_DATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUpdateTime(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfTable<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfTable(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableId<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableId(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptionLength<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptionLength(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptionBytes<Impl: IIsdbSIParameterDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptionBytes(brecordindex, pbbufferlength, ::core::mem::transmute_copy(&pbbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbSIParameterDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetParameterVersion::<Impl, OFFSET>, GetUpdateTime::<Impl, OFFSET>, GetRecordNumberOfTable::<Impl, OFFSET>, GetTableId::<Impl, OFFSET>, GetTableDescriptionLength::<Impl, OFFSET>, GetTableDescriptionBytes::<Impl, OFFSET>)
    }
}
pub trait IIsdbSeriesDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetSeriesId();
    fn GetRepeatLabel();
    fn GetProgramPattern();
    fn GetExpireDate();
    fn GetEpisodeNumber();
    fn GetLastEpisodeNumber();
    fn GetSeriesNameW();
}
impl ::windows::core::RuntimeName for IIsdbSeriesDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbSeriesDescriptor";
}
impl IIsdbSeriesDescriptorVtbl {
    pub const fn new<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbSeriesDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeriesId<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSeriesId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepeatLabel<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRepeatLabel(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramPattern<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProgramPattern(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpireDate<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfvalid: *mut super::super::Foundation::BOOL, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExpireDate(::core::mem::transmute_copy(&pfvalid), ::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEpisodeNumber<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEpisodeNumber(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastEpisodeNumber<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastEpisodeNumber(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeriesNameW<Impl: IIsdbSeriesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSeriesNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbSeriesDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetSeriesId::<Impl, OFFSET>, GetRepeatLabel::<Impl, OFFSET>, GetProgramPattern::<Impl, OFFSET>, GetExpireDate::<Impl, OFFSET>, GetEpisodeNumber::<Impl, OFFSET>, GetLastEpisodeNumber::<Impl, OFFSET>, GetSeriesNameW::<Impl, OFFSET>)
    }
}
pub trait IIsdbSiParser2Impl: Sized + IDvbSiParser2Impl + IDvbSiParserImpl {
    fn GetSDT();
    fn GetBIT();
    fn GetNBIT();
    fn GetLDT();
    fn GetSDTT();
    fn GetCDT();
    fn GetEMM();
}
impl ::windows::core::RuntimeName for IIsdbSiParser2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbSiParser2";
}
impl IIsdbSiParser2Vtbl {
    pub const fn new<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbSiParser2Vtbl {
        unsafe extern "system" fn GetSDT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtransportstreamid: *const u16, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSDT(tableid, pwtransportstreamid, ::core::mem::transmute_copy(&ppsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBIT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalnetworkid: *const u16, ppbit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBIT(tableid, pworiginalnetworkid, ::core::mem::transmute_copy(&ppbit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNBIT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalnetworkid: *const u16, ppnbit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNBIT(tableid, pworiginalnetworkid, ::core::mem::transmute_copy(&ppnbit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLDT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalserviceid: *const u16, ppldt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLDT(tableid, pworiginalserviceid, ::core::mem::transmute_copy(&ppldt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSDTT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtableidext: *const u16, ppsdtt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSDTT(tableid, pwtableidext, ::core::mem::transmute_copy(&ppsdtt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCDT<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tableid: u8, bsectionnumber: u8, pwdownloaddataid: *const u16, ppcdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCDT(tableid, bsectionnumber, pwdownloaddataid, ::core::mem::transmute_copy(&ppcdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEMM<Impl: IIsdbSiParser2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, wtableidext: u16, ppemm: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEMM(pid, wtableidext, ::core::mem::transmute_copy(&ppemm)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbSiParser2>, base.5, GetSDT::<Impl, OFFSET>, GetBIT::<Impl, OFFSET>, GetNBIT::<Impl, OFFSET>, GetLDT::<Impl, OFFSET>, GetSDTT::<Impl, OFFSET>, GetCDT::<Impl, OFFSET>, GetEMM::<Impl, OFFSET>)
    }
}
pub trait IIsdbTSInformationDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetRemoteControlKeyId();
    fn GetTSNameW();
    fn GetCountOfRecords();
    fn GetRecordTransmissionTypeInfo();
    fn GetRecordNumberOfServices();
    fn GetRecordServiceIdByIndex();
}
impl ::windows::core::RuntimeName for IIsdbTSInformationDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbTSInformationDescriptor";
}
impl IIsdbTSInformationDescriptorVtbl {
    pub const fn new<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbTSInformationDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRemoteControlKeyId<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRemoteControlKeyId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSNameW<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTSNameW(convmode, ::core::mem::transmute_copy(&pbstrname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransmissionTypeInfo<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordTransmissionTypeInfo(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfServices<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfServices(brecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceIdByIndex<Impl: IIsdbTSInformationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bserviceindex: u8, pdwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceIdByIndex(brecordindex, bserviceindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbTSInformationDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetRemoteControlKeyId::<Impl, OFFSET>, GetTSNameW::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordTransmissionTypeInfo::<Impl, OFFSET>, GetRecordNumberOfServices::<Impl, OFFSET>, GetRecordServiceIdByIndex::<Impl, OFFSET>)
    }
}
pub trait IIsdbTerrestrialDeliverySystemDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetAreaCode();
    fn GetGuardInterval();
    fn GetTransmissionMode();
    fn GetCountOfRecords();
    fn GetRecordFrequency();
}
impl ::windows::core::RuntimeName for IIsdbTerrestrialDeliverySystemDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IIsdbTerrestrialDeliverySystemDescriptor";
}
impl IIsdbTerrestrialDeliverySystemDescriptorVtbl {
    pub const fn new<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsdbTerrestrialDeliverySystemDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAreaCode<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAreaCode(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFrequency<Impl: IIsdbTerrestrialDeliverySystemDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordFrequency(brecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsdbTerrestrialDeliverySystemDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetAreaCode::<Impl, OFFSET>, GetGuardInterval::<Impl, OFFSET>, GetTransmissionMode::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordFrequency::<Impl, OFFSET>)
    }
}
pub trait IKsNodeControlImpl: Sized {
    fn SetNodeId();
    fn SetKsControl();
}
impl ::windows::core::RuntimeName for IKsNodeControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IKsNodeControl";
}
impl IKsNodeControlVtbl {
    pub const fn new<Impl: IKsNodeControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IKsNodeControlVtbl {
        unsafe extern "system" fn SetNodeId<Impl: IKsNodeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnodeid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNodeId(dwnodeid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKsControl<Impl: IKsNodeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkscontrol: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetKsControl(&*(&pkscontrol as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IKsNodeControl>, base.5, SetNodeId::<Impl, OFFSET>, SetKsControl::<Impl, OFFSET>)
    }
}
pub trait IKsTopologyInfoImpl: Sized {
    fn NumCategories();
    fn Category();
    fn NumConnections();
    fn ConnectionInfo();
    fn NodeName();
    fn NumNodes();
    fn NodeType();
    fn CreateNodeInstance();
}
impl ::windows::core::RuntimeName for IKsTopologyInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IKsTopologyInfo";
}
impl IKsTopologyInfoVtbl {
    pub const fn new<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IKsTopologyInfoVtbl {
        unsafe extern "system" fn NumCategories<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumcategories: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumCategories(::core::mem::transmute_copy(&pdwnumcategories)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pcategory: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Category(dwindex, ::core::mem::transmute_copy(&pcategory)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumConnections<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumconnections: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumConnections(::core::mem::transmute_copy(&pdwnumconnections)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionInfo<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pconnectioninfo: *mut super::KernelStreaming::KSTOPOLOGY_CONNECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectionInfo(dwindex, ::core::mem::transmute_copy(&pconnectioninfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NodeName<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, pwchnodename: super::super::Foundation::PWSTR, dwbufsize: u32, pdwnamelen: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NodeName(dwnodeid, ::core::mem::transmute_copy(&pwchnodename), dwbufsize, ::core::mem::transmute_copy(&pdwnamelen)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumNodes<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumnodes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumNodes(::core::mem::transmute_copy(&pdwnumnodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NodeType<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, pnodetype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NodeType(dwnodeid, ::core::mem::transmute_copy(&pnodetype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateNodeInstance<Impl: IKsTopologyInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, iid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateNodeInstance(dwnodeid, &*(&iid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IKsTopologyInfo>, base.5, NumCategories::<Impl, OFFSET>, Category::<Impl, OFFSET>, NumConnections::<Impl, OFFSET>, ConnectionInfo::<Impl, OFFSET>, NodeName::<Impl, OFFSET>, NumNodes::<Impl, OFFSET>, NodeType::<Impl, OFFSET>, CreateNodeInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ILanguageComponentTypeImpl: Sized + IComponentTypeImpl + IDispatchImpl {
    fn LangID();
    fn SetLangID();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ILanguageComponentType {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ILanguageComponentType";
}
#[cfg(feature = "Win32_System_Com")]
impl ILanguageComponentTypeVtbl {
    pub const fn new<Impl: ILanguageComponentTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ILanguageComponentTypeVtbl {
        unsafe extern "system" fn LangID<Impl: ILanguageComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, langid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LangID(::core::mem::transmute_copy(&langid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLangID<Impl: ILanguageComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, langid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLangID(langid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ILanguageComponentType>, base.5, LangID::<Impl, OFFSET>, SetLangID::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ILocatorImpl: Sized + IDispatchImpl {
    fn CarrierFrequency();
    fn SetCarrierFrequency();
    fn InnerFEC();
    fn SetInnerFEC();
    fn InnerFECRate();
    fn SetInnerFECRate();
    fn OuterFEC();
    fn SetOuterFEC();
    fn OuterFECRate();
    fn SetOuterFECRate();
    fn Modulation();
    fn SetModulation();
    fn SymbolRate();
    fn SetSymbolRate();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ILocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ILocator";
}
#[cfg(feature = "Win32_System_Com")]
impl ILocatorVtbl {
    pub const fn new<Impl: ILocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ILocatorVtbl {
        unsafe extern "system" fn CarrierFrequency<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, frequency: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CarrierFrequency(::core::mem::transmute_copy(&frequency)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCarrierFrequency<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, frequency: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCarrierFrequency(frequency) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InnerFEC<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InnerFEC(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFEC<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInnerFEC(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InnerFECRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InnerFECRate(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFECRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInnerFECRate(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OuterFEC<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OuterFEC(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFEC<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOuterFEC(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OuterFECRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OuterFECRate(::core::mem::transmute_copy(&fec)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFECRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOuterFECRate(fec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Modulation<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, modulation: *mut ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Modulation(::core::mem::transmute_copy(&modulation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetModulation<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, modulation: ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetModulation(modulation) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SymbolRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SymbolRate(::core::mem::transmute_copy(&rate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbolRate<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSymbolRate(rate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: ILocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newlocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newlocator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ILocator>,
            base.5,
            CarrierFrequency::<Impl, OFFSET>,
            SetCarrierFrequency::<Impl, OFFSET>,
            InnerFEC::<Impl, OFFSET>,
            SetInnerFEC::<Impl, OFFSET>,
            InnerFECRate::<Impl, OFFSET>,
            SetInnerFECRate::<Impl, OFFSET>,
            OuterFEC::<Impl, OFFSET>,
            SetOuterFEC::<Impl, OFFSET>,
            OuterFECRate::<Impl, OFFSET>,
            SetOuterFECRate::<Impl, OFFSET>,
            Modulation::<Impl, OFFSET>,
            SetModulation::<Impl, OFFSET>,
            SymbolRate::<Impl, OFFSET>,
            SetSymbolRate::<Impl, OFFSET>,
            Clone::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMPEG2ComponentImpl: Sized + IComponentImpl + IDispatchImpl {
    fn PID();
    fn SetPID();
    fn PCRPID();
    fn SetPCRPID();
    fn ProgramNumber();
    fn SetProgramNumber();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMPEG2Component {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2Component";
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2ComponentVtbl {
    pub const fn new<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2ComponentVtbl {
        unsafe extern "system" fn PID<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PID(::core::mem::transmute_copy(&pid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPID<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPID(pid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PCRPID<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcrpid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PCRPID(::core::mem::transmute_copy(&pcrpid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPCRPID<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcrpid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPCRPID(pcrpid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProgramNumber<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, programnumber: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProgramNumber(::core::mem::transmute_copy(&programnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgramNumber<Impl: IMPEG2ComponentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, programnumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProgramNumber(programnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2Component>, base.5, PID::<Impl, OFFSET>, SetPID::<Impl, OFFSET>, PCRPID::<Impl, OFFSET>, SetPCRPID::<Impl, OFFSET>, ProgramNumber::<Impl, OFFSET>, SetProgramNumber::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMPEG2ComponentTypeImpl: Sized + ILanguageComponentTypeImpl + IComponentTypeImpl + IDispatchImpl {
    fn StreamType();
    fn SetStreamType();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMPEG2ComponentType {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2ComponentType";
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2ComponentTypeVtbl {
    pub const fn new<Impl: IMPEG2ComponentTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2ComponentTypeVtbl {
        unsafe extern "system" fn StreamType<Impl: IMPEG2ComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mp2streamtype: *mut MPEG2StreamType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StreamType(::core::mem::transmute_copy(&mp2streamtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamType<Impl: IMPEG2ComponentTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mp2streamtype: MPEG2StreamType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamType(mp2streamtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2ComponentType>, base.5, StreamType::<Impl, OFFSET>, SetStreamType::<Impl, OFFSET>)
    }
}
pub trait IMPEG2PIDMapImpl: Sized {
    fn MapPID();
    fn UnmapPID();
    fn EnumPIDMap();
}
impl ::windows::core::RuntimeName for IMPEG2PIDMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2PIDMap";
}
impl IMPEG2PIDMapVtbl {
    pub const fn new<Impl: IMPEG2PIDMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2PIDMapVtbl {
        unsafe extern "system" fn MapPID<Impl: IMPEG2PIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MapPID(culpid, pulpid, mediasamplecontent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnmapPID<Impl: IMPEG2PIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, culpid: u32, pulpid: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnmapPID(culpid, pulpid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumPIDMap<Impl: IMPEG2PIDMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pienumpidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumPIDMap(::core::mem::transmute_copy(&pienumpidmap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2PIDMap>, base.5, MapPID::<Impl, OFFSET>, UnmapPID::<Impl, OFFSET>, EnumPIDMap::<Impl, OFFSET>)
    }
}
pub trait IMPEG2StreamIdMapImpl: Sized {
    fn MapStreamId();
    fn UnmapStreamId();
    fn EnumStreamIdMap();
}
impl ::windows::core::RuntimeName for IMPEG2StreamIdMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2StreamIdMap";
}
impl IMPEG2StreamIdMapVtbl {
    pub const fn new<Impl: IMPEG2StreamIdMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2StreamIdMapVtbl {
        unsafe extern "system" fn MapStreamId<Impl: IMPEG2StreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MapStreamId(ulstreamid, mediasamplecontent, ulsubstreamfiltervalue, idataoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnmapStreamId<Impl: IMPEG2StreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, culstreamid: u32, pulstreamid: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnmapStreamId(culstreamid, pulstreamid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumStreamIdMap<Impl: IMPEG2StreamIdMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumstreamidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumStreamIdMap(::core::mem::transmute_copy(&ppienumstreamidmap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2StreamIdMap>, base.5, MapStreamId::<Impl, OFFSET>, UnmapStreamId::<Impl, OFFSET>, EnumStreamIdMap::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMPEG2TuneRequestImpl: Sized + ITuneRequestImpl + IDispatchImpl {
    fn TSID();
    fn SetTSID();
    fn ProgNo();
    fn SetProgNo();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMPEG2TuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2TuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2TuneRequestVtbl {
    pub const fn new<Impl: IMPEG2TuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2TuneRequestVtbl {
        unsafe extern "system" fn TSID<Impl: IMPEG2TuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TSID(::core::mem::transmute_copy(&tsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IMPEG2TuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTSID(tsid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProgNo<Impl: IMPEG2TuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, progno: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProgNo(::core::mem::transmute_copy(&progno)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgNo<Impl: IMPEG2TuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, progno: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProgNo(progno) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2TuneRequest>, base.5, TSID::<Impl, OFFSET>, SetTSID::<Impl, OFFSET>, ProgNo::<Impl, OFFSET>, SetProgNo::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMPEG2TuneRequestFactoryImpl: Sized + IDispatchImpl {
    fn CreateTuneRequest();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMPEG2TuneRequestFactory {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2TuneRequestFactory";
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2TuneRequestFactoryVtbl {
    pub const fn new<Impl: IMPEG2TuneRequestFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2TuneRequestFactoryVtbl {
        unsafe extern "system" fn CreateTuneRequest<Impl: IMPEG2TuneRequestFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequest(&*(&tuningspace as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2TuneRequestFactory>, base.5, CreateTuneRequest::<Impl, OFFSET>)
    }
}
pub trait IMPEG2TuneRequestSupportImpl: Sized {}
impl ::windows::core::RuntimeName for IMPEG2TuneRequestSupport {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2TuneRequestSupport";
}
impl IMPEG2TuneRequestSupportVtbl {
    pub const fn new<Impl: IMPEG2TuneRequestSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2TuneRequestSupportVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2TuneRequestSupport>, base.5)
    }
}
pub trait IMPEG2_TIF_CONTROLImpl: Sized {
    fn RegisterTIF();
    fn UnregisterTIF();
    fn AddPIDs();
    fn DeletePIDs();
    fn GetPIDCount();
    fn GetPIDs();
}
impl ::windows::core::RuntimeName for IMPEG2_TIF_CONTROL {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMPEG2_TIF_CONTROL";
}
impl IMPEG2_TIF_CONTROLVtbl {
    pub const fn new<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMPEG2_TIF_CONTROLVtbl {
        unsafe extern "system" fn RegisterTIF<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punktif: *mut ::core::ffi::c_void, ppvregistrationcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterTIF(&*(&punktif as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), ppvregistrationcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterTIF<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterTIF(pvregistrationcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddPIDs<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcpids: u32, pulpids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddPIDs(ulcpids, pulpids) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeletePIDs<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcpids: u32, pulpids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeletePIDs(ulcpids, pulpids) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPIDCount<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcpids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPIDCount(::core::mem::transmute_copy(&pulcpids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPIDs<Impl: IMPEG2_TIF_CONTROLImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcpids: *mut u32, pulpids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPIDs(::core::mem::transmute_copy(&pulcpids), ::core::mem::transmute_copy(&pulpids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMPEG2_TIF_CONTROL>, base.5, RegisterTIF::<Impl, OFFSET>, UnregisterTIF::<Impl, OFFSET>, AddPIDs::<Impl, OFFSET>, DeletePIDs::<Impl, OFFSET>, GetPIDCount::<Impl, OFFSET>, GetPIDs::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSEventBinderImpl: Sized + IDispatchImpl {
    fn Bind();
    fn Unbind();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSEventBinder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSEventBinder";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSEventBinderVtbl {
    pub const fn new<Impl: IMSEventBinderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSEventBinderVtbl {
        unsafe extern "system" fn Bind<Impl: IMSEventBinderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peventobject: ::windows::core::RawPtr, eventname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, eventhandler: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, cancelid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bind(
                &*(&peventobject as *const <super::super::System::Com::IDispatch as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IDispatch as ::windows::core::DefaultType>::DefaultType),
                &*(&eventname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&eventhandler as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&cancelid),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unbind<Impl: IMSEventBinderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cancelcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unbind(cancelcookie) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSEventBinder>, base.5, Bind::<Impl, OFFSET>, Unbind::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAnalogTunerImpl: Sized + IMSVidTunerImpl + IMSVidVideoInputDeviceImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Channel();
    fn SetChannel();
    fn VideoFrequency();
    fn AudioFrequency();
    fn CountryCode();
    fn SetCountryCode();
    fn SAP();
    fn SetSAP();
    fn ChannelAvailable();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAnalogTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAnalogTuner";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTunerVtbl {
    pub const fn new<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAnalogTunerVtbl {
        unsafe extern "system" fn Channel<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Channel(::core::mem::transmute_copy(&channel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannel<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChannel(channel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoFrequency<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoFrequency(::core::mem::transmute_copy(&lcc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioFrequency<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioFrequency(::core::mem::transmute_copy(&lcc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCode<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CountryCode(::core::mem::transmute_copy(&lcc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcc: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCountryCode(lcc) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SAP<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfsapon: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SAP(::core::mem::transmute_copy(&pfsapon)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSAP<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fsapon: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSAP(fsapon) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChannelAvailable<Impl: IMSVidAnalogTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, nchannel: i32, signalstrength: *mut i32, fsignalpresent: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelAvailable(nchannel, ::core::mem::transmute_copy(&signalstrength), ::core::mem::transmute_copy(&fsignalpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAnalogTuner>, base.5, Channel::<Impl, OFFSET>, SetChannel::<Impl, OFFSET>, VideoFrequency::<Impl, OFFSET>, AudioFrequency::<Impl, OFFSET>, CountryCode::<Impl, OFFSET>, SetCountryCode::<Impl, OFFSET>, SAP::<Impl, OFFSET>, SetSAP::<Impl, OFFSET>, ChannelAvailable::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAnalogTuner2Impl: Sized + IMSVidAnalogTunerImpl + IMSVidTunerImpl + IMSVidVideoInputDeviceImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn TVFormats();
    fn TunerModes();
    fn NumAuxInputs();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAnalogTuner2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAnalogTuner2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTuner2Vtbl {
    pub const fn new<Impl: IMSVidAnalogTuner2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAnalogTuner2Vtbl {
        unsafe extern "system" fn TVFormats<Impl: IMSVidAnalogTuner2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, formats: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TVFormats(::core::mem::transmute_copy(&formats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TunerModes<Impl: IMSVidAnalogTuner2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, modes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TunerModes(::core::mem::transmute_copy(&modes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumAuxInputs<Impl: IMSVidAnalogTuner2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumAuxInputs(::core::mem::transmute_copy(&inputs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAnalogTuner2>, base.5, TVFormats::<Impl, OFFSET>, TunerModes::<Impl, OFFSET>, NumAuxInputs::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAnalogTunerEventImpl: Sized + IMSVidTunerEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAnalogTunerEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAnalogTunerEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTunerEventVtbl {
    pub const fn new<Impl: IMSVidAnalogTunerEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAnalogTunerEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAnalogTunerEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAudioRendererImpl: Sized + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn SetVolume();
    fn Volume();
    fn SetBalance();
    fn Balance();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAudioRenderer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAudioRenderer";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererVtbl {
    pub const fn new<Impl: IMSVidAudioRendererImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAudioRendererVtbl {
        unsafe extern "system" fn SetVolume<Impl: IMSVidAudioRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvol: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVolume(lvol) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Volume<Impl: IMSVidAudioRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lvol: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Volume(::core::mem::transmute_copy(&lvol)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMSVidAudioRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lbal: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBalance(lbal) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Balance<Impl: IMSVidAudioRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lbal: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Balance(::core::mem::transmute_copy(&lbal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAudioRenderer>, base.5, SetVolume::<Impl, OFFSET>, Volume::<Impl, OFFSET>, SetBalance::<Impl, OFFSET>, Balance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAudioRendererDevicesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn Add();
    fn Remove();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAudioRendererDevices {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAudioRendererDevices";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererDevicesVtbl {
    pub const fn new<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAudioRendererDevicesVtbl {
        unsafe extern "system" fn Count<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&lcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&pd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&pdb as *const <IMSVidAudioRenderer as ::windows::core::Abi>::Abi as *const <IMSVidAudioRenderer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMSVidAudioRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAudioRendererDevices>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAudioRendererEventImpl: Sized + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAudioRendererEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAudioRendererEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererEventVtbl {
    pub const fn new<Impl: IMSVidAudioRendererEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAudioRendererEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAudioRendererEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidAudioRendererEvent2Impl: Sized + IMSVidAudioRendererEventImpl + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn AVDecAudioDualMono();
    fn AVAudioSampleRate();
    fn AVAudioChannelConfig();
    fn AVAudioChannelCount();
    fn AVDecCommonMeanBitRate();
    fn AVDDSurroundMode();
    fn AVDecCommonInputFormat();
    fn AVDecCommonOutputFormat();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidAudioRendererEvent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidAudioRendererEvent2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererEvent2Vtbl {
    pub const fn new<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidAudioRendererEvent2Vtbl {
        unsafe extern "system" fn AVDecAudioDualMono<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVDecAudioDualMono() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVAudioSampleRate<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVAudioSampleRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVAudioChannelConfig<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVAudioChannelConfig() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVAudioChannelCount<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVAudioChannelCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVDecCommonMeanBitRate<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVDecCommonMeanBitRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVDDSurroundMode<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVDDSurroundMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVDecCommonInputFormat<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVDecCommonInputFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AVDecCommonOutputFormat<Impl: IMSVidAudioRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AVDecCommonOutputFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidAudioRendererEvent2>, base.5, AVDecAudioDualMono::<Impl, OFFSET>, AVAudioSampleRate::<Impl, OFFSET>, AVAudioChannelConfig::<Impl, OFFSET>, AVAudioChannelCount::<Impl, OFFSET>, AVDecCommonMeanBitRate::<Impl, OFFSET>, AVDDSurroundMode::<Impl, OFFSET>, AVDecCommonInputFormat::<Impl, OFFSET>, AVDecCommonOutputFormat::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidClosedCaptioningImpl: Sized + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Enable();
    fn SetEnable();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidClosedCaptioning {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidClosedCaptioning";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioningVtbl {
    pub const fn new<Impl: IMSVidClosedCaptioningImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidClosedCaptioningVtbl {
        unsafe extern "system" fn Enable<Impl: IMSVidClosedCaptioningImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, on: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Enable(::core::mem::transmute_copy(&on)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnable<Impl: IMSVidClosedCaptioningImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, on: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnable(on) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidClosedCaptioning>, base.5, Enable::<Impl, OFFSET>, SetEnable::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidClosedCaptioning2Impl: Sized + IMSVidClosedCaptioningImpl + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Service();
    fn SetService();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidClosedCaptioning2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidClosedCaptioning2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioning2Vtbl {
    pub const fn new<Impl: IMSVidClosedCaptioning2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidClosedCaptioning2Vtbl {
        unsafe extern "system" fn Service<Impl: IMSVidClosedCaptioning2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, on: *mut MSVidCCService) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Service(::core::mem::transmute_copy(&on)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetService<Impl: IMSVidClosedCaptioning2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, on: MSVidCCService) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetService(on) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidClosedCaptioning2>, base.5, Service::<Impl, OFFSET>, SetService::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidClosedCaptioning3Impl: Sized + IMSVidClosedCaptioning2Impl + IMSVidClosedCaptioningImpl + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn TeleTextFilter();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidClosedCaptioning3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidClosedCaptioning3";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioning3Vtbl {
    pub const fn new<Impl: IMSVidClosedCaptioning3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidClosedCaptioning3Vtbl {
        unsafe extern "system" fn TeleTextFilter<Impl: IMSVidClosedCaptioning3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkttfilter: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TeleTextFilter(::core::mem::transmute_copy(&punkttfilter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidClosedCaptioning3>, base.5, TeleTextFilter::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidCompositionSegmentImpl: Sized + IMSVidGraphSegmentImpl + IPersistImpl {
    fn Compose();
    fn Up();
    fn Down();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidCompositionSegment {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidCompositionSegment";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidCompositionSegmentVtbl {
    pub const fn new<Impl: IMSVidCompositionSegmentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidCompositionSegmentVtbl {
        unsafe extern "system" fn Compose<Impl: IMSVidCompositionSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, upstream: ::windows::core::RawPtr, downstream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Compose(&*(&upstream as *const <IMSVidGraphSegment as ::windows::core::Abi>::Abi as *const <IMSVidGraphSegment as ::windows::core::DefaultType>::DefaultType), &*(&downstream as *const <IMSVidGraphSegment as ::windows::core::Abi>::Abi as *const <IMSVidGraphSegment as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Up<Impl: IMSVidCompositionSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, upstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Up(::core::mem::transmute_copy(&upstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Down<Impl: IMSVidCompositionSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, downstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Down(::core::mem::transmute_copy(&downstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidCompositionSegment>, base.5, Compose::<Impl, OFFSET>, Up::<Impl, OFFSET>, Down::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidCtlImpl: Sized + IDispatchImpl {
    fn AutoSize();
    fn SetAutoSize();
    fn BackColor();
    fn SetBackColor();
    fn Enabled();
    fn SetEnabled();
    fn TabStop();
    fn SetTabStop();
    fn Window();
    fn Refresh();
    fn DisplaySize();
    fn SetDisplaySize();
    fn MaintainAspectRatio();
    fn SetMaintainAspectRatio();
    fn ColorKey();
    fn SetColorKey();
    fn InputsAvailable();
    fn OutputsAvailable();
    fn _InputsAvailable();
    fn _OutputsAvailable();
    fn VideoRenderersAvailable();
    fn AudioRenderersAvailable();
    fn FeaturesAvailable();
    fn InputActive();
    fn SetInputActive();
    fn OutputsActive();
    fn SetOutputsActive();
    fn VideoRendererActive();
    fn SetVideoRendererActive();
    fn AudioRendererActive();
    fn SetAudioRendererActive();
    fn FeaturesActive();
    fn SetFeaturesActive();
    fn State();
    fn View();
    fn Build();
    fn Pause();
    fn Run();
    fn Stop();
    fn Decompose();
    fn DisableVideo();
    fn DisableAudio();
    fn ViewNext();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidCtl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidCtl";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidCtlVtbl {
    pub const fn new<Impl: IMSVidCtlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidCtlVtbl {
        unsafe extern "system" fn AutoSize<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoSize(::core::mem::transmute_copy(&pbool)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoSize<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAutoSize(vbool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackColor<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, backcolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackColor(::core::mem::transmute_copy(&backcolor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackColor<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, backcolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackColor(backcolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Enabled<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Enabled(::core::mem::transmute_copy(&pbool)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnabled<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnabled(vbool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabStop<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TabStop(::core::mem::transmute_copy(&pbool)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabStop<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTabStop(vbool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Window<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Window(::core::mem::transmute_copy(&phwnd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Refresh<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Refresh() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplaySize<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentvalue: *mut DisplaySizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplaySize(::core::mem::transmute_copy(&currentvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplaySize<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newvalue: DisplaySizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDisplaySize(newvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaintainAspectRatio<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentvalue: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaintainAspectRatio(::core::mem::transmute_copy(&currentvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaintainAspectRatio<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newvalue: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaintainAspectRatio(newvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorKey<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorKey(::core::mem::transmute_copy(&currentvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(newvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputsAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, categoryguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputsAvailable(&*(&categoryguid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutputsAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, categoryguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutputsAvailable(&*(&categoryguid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _InputsAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, categoryguid: *const ::windows::core::GUID, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._InputsAvailable(&*(&categoryguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _OutputsAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, categoryguid: *const ::windows::core::GUID, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._OutputsAvailable(&*(&categoryguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoRenderersAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoRenderersAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioRenderersAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioRenderersAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FeaturesAvailable<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FeaturesAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputActive(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputActive(&*(&pval as *const <IMSVidInputDevice as ::windows::core::Abi>::Abi as *const <IMSVidInputDevice as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutputsActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutputsActive(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputsActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputsActive(&*(&pval as *const <IMSVidOutputDevices as ::windows::core::Abi>::Abi as *const <IMSVidOutputDevices as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoRendererActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoRendererActive(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoRendererActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoRendererActive(&*(&pval as *const <IMSVidVideoRenderer as ::windows::core::Abi>::Abi as *const <IMSVidVideoRenderer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioRendererActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioRendererActive(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioRendererActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioRendererActive(&*(&pval as *const <IMSVidAudioRenderer as ::windows::core::Abi>::Abi as *const <IMSVidAudioRenderer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FeaturesActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FeaturesActive(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFeaturesActive<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFeaturesActive(&*(&pval as *const <IMSVidFeatures as ::windows::core::Abi>::Abi as *const <IMSVidFeatures as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn State<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstate: *mut MSVidCtlStateList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).State(::core::mem::transmute_copy(&lstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn View<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).View(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Build<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Build() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Run<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Run() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Decompose() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisableVideo<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisableVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisableAudio<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisableAudio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewNext<Impl: IMSVidCtlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewNext(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidCtl>,
            base.5,
            AutoSize::<Impl, OFFSET>,
            SetAutoSize::<Impl, OFFSET>,
            BackColor::<Impl, OFFSET>,
            SetBackColor::<Impl, OFFSET>,
            Enabled::<Impl, OFFSET>,
            SetEnabled::<Impl, OFFSET>,
            TabStop::<Impl, OFFSET>,
            SetTabStop::<Impl, OFFSET>,
            Window::<Impl, OFFSET>,
            Refresh::<Impl, OFFSET>,
            DisplaySize::<Impl, OFFSET>,
            SetDisplaySize::<Impl, OFFSET>,
            MaintainAspectRatio::<Impl, OFFSET>,
            SetMaintainAspectRatio::<Impl, OFFSET>,
            ColorKey::<Impl, OFFSET>,
            SetColorKey::<Impl, OFFSET>,
            InputsAvailable::<Impl, OFFSET>,
            OutputsAvailable::<Impl, OFFSET>,
            _InputsAvailable::<Impl, OFFSET>,
            _OutputsAvailable::<Impl, OFFSET>,
            VideoRenderersAvailable::<Impl, OFFSET>,
            AudioRenderersAvailable::<Impl, OFFSET>,
            FeaturesAvailable::<Impl, OFFSET>,
            InputActive::<Impl, OFFSET>,
            SetInputActive::<Impl, OFFSET>,
            OutputsActive::<Impl, OFFSET>,
            SetOutputsActive::<Impl, OFFSET>,
            VideoRendererActive::<Impl, OFFSET>,
            SetVideoRendererActive::<Impl, OFFSET>,
            AudioRendererActive::<Impl, OFFSET>,
            SetAudioRendererActive::<Impl, OFFSET>,
            FeaturesActive::<Impl, OFFSET>,
            SetFeaturesActive::<Impl, OFFSET>,
            State::<Impl, OFFSET>,
            View::<Impl, OFFSET>,
            Build::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            Run::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            Decompose::<Impl, OFFSET>,
            DisableVideo::<Impl, OFFSET>,
            DisableAudio::<Impl, OFFSET>,
            ViewNext::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidDataServicesImpl: Sized + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidDataServices {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidDataServices";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDataServicesVtbl {
    pub const fn new<Impl: IMSVidDataServicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidDataServicesVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidDataServices>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidDataServicesEventImpl: Sized + IMSVidDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidDataServicesEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidDataServicesEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDataServicesEventVtbl {
    pub const fn new<Impl: IMSVidDataServicesEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidDataServicesEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidDataServicesEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidDeviceImpl: Sized + IDispatchImpl {
    fn Name();
    fn Status();
    fn SetPower();
    fn Power();
    fn Category();
    fn ClassID();
    fn _Category();
    fn _ClassID();
    fn IsEqualDevice();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidDevice {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidDevice";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDeviceVtbl {
    pub const fn new<Impl: IMSVidDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidDeviceVtbl {
        unsafe extern "system" fn Name<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Name(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Status<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, status: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Status(::core::mem::transmute_copy(&status)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPower<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, power: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPower(power) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Power<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, power: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Power(::core::mem::transmute_copy(&power)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Category(::core::mem::transmute_copy(&guid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClassID<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClassID(::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _Category<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._Category(::core::mem::transmute_copy(&guid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _ClassID<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._ClassID(::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEqualDevice<Impl: IMSVidDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, device: ::windows::core::RawPtr, isequal: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEqualDevice(&*(&device as *const <IMSVidDevice as ::windows::core::Abi>::Abi as *const <IMSVidDevice as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&isequal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidDevice>, base.5, Name::<Impl, OFFSET>, Status::<Impl, OFFSET>, SetPower::<Impl, OFFSET>, Power::<Impl, OFFSET>, Category::<Impl, OFFSET>, ClassID::<Impl, OFFSET>, _Category::<Impl, OFFSET>, _ClassID::<Impl, OFFSET>, IsEqualDevice::<Impl, OFFSET>)
    }
}
pub trait IMSVidDevice2Impl: Sized {
    fn DevicePath();
}
impl ::windows::core::RuntimeName for IMSVidDevice2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidDevice2";
}
impl IMSVidDevice2Vtbl {
    pub const fn new<Impl: IMSVidDevice2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidDevice2Vtbl {
        unsafe extern "system" fn DevicePath<Impl: IMSVidDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, devpath: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DevicePath(::core::mem::transmute_copy(&devpath)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidDevice2>, base.5, DevicePath::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidDeviceEventImpl: Sized + IDispatchImpl {
    fn StateChange();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidDeviceEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidDeviceEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDeviceEventVtbl {
    pub const fn new<Impl: IMSVidDeviceEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidDeviceEventVtbl {
        unsafe extern "system" fn StateChange<Impl: IMSVidDeviceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr, oldstate: i32, newstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StateChange(&*(&lpd as *const <IMSVidDevice as ::windows::core::Abi>::Abi as *const <IMSVidDevice as ::windows::core::DefaultType>::DefaultType), oldstate, newstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidDeviceEvent>, base.5, StateChange::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidEVRImpl: Sized + IMSVidVideoRendererImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Presenter();
    fn SetPresenter();
    fn SetSuppressEffects();
    fn SuppressEffects();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidEVR {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidEVR";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEVRVtbl {
    pub const fn new<Impl: IMSVidEVRImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidEVRVtbl {
        unsafe extern "system" fn Presenter<Impl: IMSVidEVRImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppallocpresent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Presenter(::core::mem::transmute_copy(&ppallocpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPresenter<Impl: IMSVidEVRImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pallocpresent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPresenter(&*(&pallocpresent as *const <super::MediaFoundation::IMFVideoPresenter as ::windows::core::Abi>::Abi as *const <super::MediaFoundation::IMFVideoPresenter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidEVRImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSuppressEffects(bsuppress) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidEVRImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuppressEffects(::core::mem::transmute_copy(&bsuppress)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidEVR>, base.5, Presenter::<Impl, OFFSET>, SetPresenter::<Impl, OFFSET>, SetSuppressEffects::<Impl, OFFSET>, SuppressEffects::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidEVREventImpl: Sized + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn OnUserEvent();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidEVREvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidEVREvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEVREventVtbl {
    pub const fn new<Impl: IMSVidEVREventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidEVREventVtbl {
        unsafe extern "system" fn OnUserEvent<Impl: IMSVidEVREventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leventcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnUserEvent(leventcode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidEVREvent>, base.5, OnUserEvent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidEncoderImpl: Sized + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn VideoEncoderInterface();
    fn AudioEncoderInterface();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidEncoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidEncoder";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEncoderVtbl {
    pub const fn new<Impl: IMSVidEncoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidEncoderVtbl {
        unsafe extern "system" fn VideoEncoderInterface<Impl: IMSVidEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppencint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoEncoderInterface(::core::mem::transmute_copy(&ppencint)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioEncoderInterface<Impl: IMSVidEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppencint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioEncoderInterface(::core::mem::transmute_copy(&ppencint)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidEncoder>, base.5, VideoEncoderInterface::<Impl, OFFSET>, AudioEncoderInterface::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFeatureImpl: Sized + IMSVidDeviceImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFeature {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFeature";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFeatureVtbl {
    pub const fn new<Impl: IMSVidFeatureImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFeatureVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFeature>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFeatureEventImpl: Sized + IMSVidDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFeatureEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFeatureEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFeatureEventVtbl {
    pub const fn new<Impl: IMSVidFeatureEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFeatureEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFeatureEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFeaturesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn Add();
    fn Remove();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFeatures {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFeatures";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFeaturesVtbl {
    pub const fn new<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFeaturesVtbl {
        unsafe extern "system" fn Count<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&lcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&pd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&pdb as *const <IMSVidFeature as ::windows::core::Abi>::Abi as *const <IMSVidFeature as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMSVidFeaturesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFeatures>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFilePlaybackImpl: Sized + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn FileName();
    fn SetFileName();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFilePlayback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFilePlayback";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlaybackVtbl {
    pub const fn new<Impl: IMSVidFilePlaybackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFilePlaybackVtbl {
        unsafe extern "system" fn FileName<Impl: IMSVidFilePlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FileName(::core::mem::transmute_copy(&filename)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFileName<Impl: IMSVidFilePlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFileName(&*(&filename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFilePlayback>, base.5, FileName::<Impl, OFFSET>, SetFileName::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFilePlayback2Impl: Sized + IMSVidFilePlaybackImpl + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Set_SourceFilter();
    fn Set__SourceFilter();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFilePlayback2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFilePlayback2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlayback2Vtbl {
    pub const fn new<Impl: IMSVidFilePlayback2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFilePlayback2Vtbl {
        unsafe extern "system" fn Set_SourceFilter<Impl: IMSVidFilePlayback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_SourceFilter(&*(&filename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set__SourceFilter<Impl: IMSVidFilePlayback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set__SourceFilter(&*(&filename as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFilePlayback2>, base.5, Set_SourceFilter::<Impl, OFFSET>, Set__SourceFilter::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidFilePlaybackEventImpl: Sized + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidFilePlaybackEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidFilePlaybackEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlaybackEventVtbl {
    pub const fn new<Impl: IMSVidFilePlaybackEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidFilePlaybackEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidFilePlaybackEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidGenericSinkImpl: Sized + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn SetSinkFilter();
    fn SinkStreams();
    fn SetSinkStreams();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidGenericSink {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidGenericSink";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGenericSinkVtbl {
    pub const fn new<Impl: IMSVidGenericSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidGenericSinkVtbl {
        unsafe extern "system" fn SetSinkFilter<Impl: IMSVidGenericSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSinkFilter(&*(&bstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SinkStreams<Impl: IMSVidGenericSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstreams: *mut MSVidSinkStreams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SinkStreams(::core::mem::transmute_copy(&pstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSinkStreams<Impl: IMSVidGenericSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streams: MSVidSinkStreams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSinkStreams(streams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidGenericSink>, base.5, SetSinkFilter::<Impl, OFFSET>, SinkStreams::<Impl, OFFSET>, SetSinkStreams::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidGenericSink2Impl: Sized + IMSVidGenericSinkImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn AddFilter();
    fn ResetFilterList();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidGenericSink2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidGenericSink2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGenericSink2Vtbl {
    pub const fn new<Impl: IMSVidGenericSink2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidGenericSink2Vtbl {
        unsafe extern "system" fn AddFilter<Impl: IMSVidGenericSink2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddFilter(&*(&bstrname as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetFilterList<Impl: IMSVidGenericSink2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetFilterList() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidGenericSink2>, base.5, AddFilter::<Impl, OFFSET>, ResetFilterList::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidGraphSegmentImpl: Sized + IPersistImpl {
    fn Init();
    fn SetInit();
    fn EnumFilters();
    fn Container();
    fn SetContainer();
    fn Type();
    fn Category();
    fn Build();
    fn PostBuild();
    fn PreRun();
    fn PostRun();
    fn PreStop();
    fn PostStop();
    fn OnEventNotify();
    fn Decompose();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidGraphSegment {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidGraphSegment";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGraphSegmentVtbl {
    pub const fn new<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidGraphSegmentVtbl {
        unsafe extern "system" fn Init<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinit: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init(::core::mem::transmute_copy(&pinit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInit<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinit: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInit(&*(&pinit as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumFilters<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumFilters(::core::mem::transmute_copy(&pnewenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Container<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppctl: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Container(::core::mem::transmute_copy(&ppctl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainer<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pctl: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContainer(&*(&pctl as *const <IMSVidGraphSegmentContainer as ::windows::core::Abi>::Abi as *const <IMSVidGraphSegmentContainer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Type<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut MSVidSegmentType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Type(::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Category(::core::mem::transmute_copy(&pguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Build<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Build() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PostBuild<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PostBuild() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreRun<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreRun() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PostRun<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PostRun() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreStop<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreStop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PostStop<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PostStop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnEventNotify<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leventcode: i32, leventparm1: isize, leventparm2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnEventNotify(leventcode, leventparm1, leventparm2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Decompose() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidGraphSegment>,
            base.5,
            Init::<Impl, OFFSET>,
            SetInit::<Impl, OFFSET>,
            EnumFilters::<Impl, OFFSET>,
            Container::<Impl, OFFSET>,
            SetContainer::<Impl, OFFSET>,
            Type::<Impl, OFFSET>,
            Category::<Impl, OFFSET>,
            Build::<Impl, OFFSET>,
            PostBuild::<Impl, OFFSET>,
            PreRun::<Impl, OFFSET>,
            PostRun::<Impl, OFFSET>,
            PreStop::<Impl, OFFSET>,
            PostStop::<Impl, OFFSET>,
            OnEventNotify::<Impl, OFFSET>,
            Decompose::<Impl, OFFSET>,
        )
    }
}
pub trait IMSVidGraphSegmentContainerImpl: Sized {
    fn Graph();
    fn Input();
    fn Outputs();
    fn VideoRenderer();
    fn AudioRenderer();
    fn Features();
    fn Composites();
    fn ParentContainer();
    fn Decompose();
    fn IsWindowless();
    fn GetFocus();
}
impl ::windows::core::RuntimeName for IMSVidGraphSegmentContainer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidGraphSegmentContainer";
}
impl IMSVidGraphSegmentContainerVtbl {
    pub const fn new<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidGraphSegmentContainerVtbl {
        unsafe extern "system" fn Graph<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppgraph: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Graph(::core::mem::transmute_copy(&ppgraph)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Input<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinput: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Input(::core::mem::transmute_copy(&ppinput)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Outputs<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppoutputs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Outputs(::core::mem::transmute_copy(&ppoutputs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoRenderer<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppvr: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoRenderer(::core::mem::transmute_copy(&ppvr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioRenderer<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppar: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioRenderer(::core::mem::transmute_copy(&ppar)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Features<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppfeatures: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Features(::core::mem::transmute_copy(&ppfeatures)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Composites<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppcomposites: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Composites(::core::mem::transmute_copy(&ppcomposites)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParentContainer<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppcontainer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParentContainer(::core::mem::transmute_copy(&ppcontainer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psegment: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Decompose(&*(&psegment as *const <IMSVidGraphSegment as ::windows::core::Abi>::Abi as *const <IMSVidGraphSegment as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsWindowless<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsWindowless() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFocus<Impl: IMSVidGraphSegmentContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidGraphSegmentContainer>, base.5, Graph::<Impl, OFFSET>, Input::<Impl, OFFSET>, Outputs::<Impl, OFFSET>, VideoRenderer::<Impl, OFFSET>, AudioRenderer::<Impl, OFFSET>, Features::<Impl, OFFSET>, Composites::<Impl, OFFSET>, ParentContainer::<Impl, OFFSET>, Decompose::<Impl, OFFSET>, IsWindowless::<Impl, OFFSET>, GetFocus::<Impl, OFFSET>)
    }
}
pub trait IMSVidGraphSegmentUserInputImpl: Sized {
    fn Click();
    fn DblClick();
    fn KeyDown();
    fn KeyPress();
    fn KeyUp();
    fn MouseDown();
    fn MouseMove();
    fn MouseUp();
}
impl ::windows::core::RuntimeName for IMSVidGraphSegmentUserInput {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidGraphSegmentUserInput";
}
impl IMSVidGraphSegmentUserInputVtbl {
    pub const fn new<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidGraphSegmentUserInputVtbl {
        unsafe extern "system" fn Click<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Click() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DblClick<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DblClick() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyDown<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keycode: *const i16, shiftstate: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyDown(keycode, shiftstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyPress<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keyascii: *const i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyPress(keyascii) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyUp<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keycode: *const i16, shiftstate: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyUp(keycode, shiftstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MouseDown<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MouseDown(buttonstate, shiftstate, x, y) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MouseMove<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MouseMove(buttonstate, shiftstate, x, y) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MouseUp<Impl: IMSVidGraphSegmentUserInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MouseUp(buttonstate, shiftstate, x, y) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidGraphSegmentUserInput>, base.5, Click::<Impl, OFFSET>, DblClick::<Impl, OFFSET>, KeyDown::<Impl, OFFSET>, KeyPress::<Impl, OFFSET>, KeyUp::<Impl, OFFSET>, MouseDown::<Impl, OFFSET>, MouseMove::<Impl, OFFSET>, MouseUp::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidInputDeviceImpl: Sized + IMSVidDeviceImpl + IDispatchImpl {
    fn IsViewable();
    fn View();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidInputDevice {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidInputDevice";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidInputDeviceVtbl {
    pub const fn new<Impl: IMSVidInputDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidInputDeviceVtbl {
        unsafe extern "system" fn IsViewable<Impl: IMSVidInputDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT, pfviewable: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsViewable(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfviewable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn View<Impl: IMSVidInputDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).View(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidInputDevice>, base.5, IsViewable::<Impl, OFFSET>, View::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidInputDeviceEventImpl: Sized + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidInputDeviceEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidInputDeviceEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidInputDeviceEventVtbl {
    pub const fn new<Impl: IMSVidInputDeviceEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidInputDeviceEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidInputDeviceEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidInputDevicesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn Add();
    fn Remove();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidInputDevices {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidInputDevices";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidInputDevicesVtbl {
    pub const fn new<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidInputDevicesVtbl {
        unsafe extern "system" fn Count<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&lcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&pd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&pdb as *const <IMSVidInputDevice as ::windows::core::Abi>::Abi as *const <IMSVidInputDevice as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMSVidInputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidInputDevices>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidOutputDeviceImpl: Sized + IMSVidDeviceImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidOutputDevice {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidOutputDevice";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidOutputDeviceVtbl {
    pub const fn new<Impl: IMSVidOutputDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidOutputDeviceVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidOutputDevice>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidOutputDeviceEventImpl: Sized + IMSVidDeviceEventImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidOutputDeviceEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidOutputDeviceEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidOutputDeviceEventVtbl {
    pub const fn new<Impl: IMSVidOutputDeviceEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidOutputDeviceEventVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidOutputDeviceEvent>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidOutputDevicesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn Add();
    fn Remove();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidOutputDevices {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidOutputDevices";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidOutputDevicesVtbl {
    pub const fn new<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidOutputDevicesVtbl {
        unsafe extern "system" fn Count<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&lcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&pd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&pdb as *const <IMSVidOutputDevice as ::windows::core::Abi>::Abi as *const <IMSVidOutputDevice as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMSVidOutputDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidOutputDevices>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidPlaybackImpl: Sized + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn EnableResetOnStop();
    fn SetEnableResetOnStop();
    fn Run();
    fn Pause();
    fn Stop();
    fn CanStep();
    fn Step();
    fn SetRate();
    fn Rate();
    fn SetCurrentPosition();
    fn CurrentPosition();
    fn SetPositionMode();
    fn PositionMode();
    fn Length();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidPlayback {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidPlayback";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidPlaybackVtbl {
    pub const fn new<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidPlaybackVtbl {
        unsafe extern "system" fn EnableResetOnStop<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableResetOnStop(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableResetOnStop<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEnableResetOnStop(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Run<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Run() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanStep<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fbackwards: i16, pfcan: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanStep(fbackwards, ::core::mem::transmute_copy(&pfcan)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Step<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstep: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Step(lstep) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(plrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Rate<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Rate(::core::mem::transmute_copy(&plrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lposition: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPosition(lposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentPosition<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lposition: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentPosition(::core::mem::transmute_copy(&lposition)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPositionMode<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpositionmode: PositionModeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPositionMode(lpositionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PositionMode<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpositionmode: *mut PositionModeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PositionMode(::core::mem::transmute_copy(&lpositionmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: IMSVidPlaybackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Length(::core::mem::transmute_copy(&llength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidPlayback>,
            base.5,
            EnableResetOnStop::<Impl, OFFSET>,
            SetEnableResetOnStop::<Impl, OFFSET>,
            Run::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            CanStep::<Impl, OFFSET>,
            Step::<Impl, OFFSET>,
            SetRate::<Impl, OFFSET>,
            Rate::<Impl, OFFSET>,
            SetCurrentPosition::<Impl, OFFSET>,
            CurrentPosition::<Impl, OFFSET>,
            SetPositionMode::<Impl, OFFSET>,
            PositionMode::<Impl, OFFSET>,
            Length::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidPlaybackEventImpl: Sized + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn EndOfMedia();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidPlaybackEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidPlaybackEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidPlaybackEventVtbl {
    pub const fn new<Impl: IMSVidPlaybackEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidPlaybackEventVtbl {
        unsafe extern "system" fn EndOfMedia<Impl: IMSVidPlaybackEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndOfMedia(&*(&lpd as *const <IMSVidPlayback as ::windows::core::Abi>::Abi as *const <IMSVidPlayback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidPlaybackEvent>, base.5, EndOfMedia::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidRectImpl: Sized + IDispatchImpl {
    fn Top();
    fn SetTop();
    fn Left();
    fn SetLeft();
    fn Width();
    fn SetWidth();
    fn Height();
    fn SetHeight();
    fn HWnd();
    fn SetHWnd();
    fn SetRect();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidRect {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidRect";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidRectVtbl {
    pub const fn new<Impl: IMSVidRectImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidRectVtbl {
        unsafe extern "system" fn Top<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, topval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Top(::core::mem::transmute_copy(&topval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, topval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTop(topval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Left<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leftval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Left(::core::mem::transmute_copy(&leftval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leftval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLeft(leftval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Width<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, widthval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Width(::core::mem::transmute_copy(&widthval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, widthval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWidth(widthval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Height<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, heightval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Height(::core::mem::transmute_copy(&heightval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, heightval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHeight(heightval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HWnd<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwndval: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HWnd(::core::mem::transmute_copy(&hwndval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHWnd<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwndval: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHWnd(&*(&hwndval as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRect<Impl: IMSVidRectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rectval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRect(&*(&rectval as *const <IMSVidRect as ::windows::core::Abi>::Abi as *const <IMSVidRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidRect>, base.5, Top::<Impl, OFFSET>, SetTop::<Impl, OFFSET>, Left::<Impl, OFFSET>, SetLeft::<Impl, OFFSET>, Width::<Impl, OFFSET>, SetWidth::<Impl, OFFSET>, Height::<Impl, OFFSET>, SetHeight::<Impl, OFFSET>, HWnd::<Impl, OFFSET>, SetHWnd::<Impl, OFFSET>, SetRect::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferRecordingControlImpl: Sized + IDispatchImpl {
    fn StartTime();
    fn SetStartTime();
    fn StopTime();
    fn SetStopTime();
    fn RecordingStopped();
    fn RecordingStarted();
    fn RecordingType();
    fn RecordingAttribute();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferRecordingControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferRecordingControl";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferRecordingControlVtbl {
    pub const fn new<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferRecordingControlVtbl {
        unsafe extern "system" fn StartTime<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtstart: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartTime(::core::mem::transmute_copy(&rtstart)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStartTime<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtstart: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStartTime(rtstart) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopTime<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtstop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopTime(::core::mem::transmute_copy(&rtstop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopTime<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtstop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStopTime(rtstop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingStopped<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phresult: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecordingStopped(::core::mem::transmute_copy(&phresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingStarted<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phresult: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecordingStarted(::core::mem::transmute_copy(&phresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingType<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtype: *mut RecordingType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecordingType(::core::mem::transmute_copy(&dwtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingAttribute<Impl: IMSVidStreamBufferRecordingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, precordingattribute: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecordingAttribute(::core::mem::transmute_copy(&precordingattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferRecordingControl>, base.5, StartTime::<Impl, OFFSET>, SetStartTime::<Impl, OFFSET>, StopTime::<Impl, OFFSET>, SetStopTime::<Impl, OFFSET>, RecordingStopped::<Impl, OFFSET>, RecordingStarted::<Impl, OFFSET>, RecordingType::<Impl, OFFSET>, RecordingAttribute::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSinkImpl: Sized + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn ContentRecorder();
    fn ReferenceRecorder();
    fn SinkName();
    fn SetSinkName();
    fn NameSetLock();
    fn SBESink();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSink {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSink";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkVtbl {
    pub const fn new<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSinkVtbl {
        unsafe extern "system" fn ContentRecorder<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, precordingiunknown: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentRecorder(&*(&pszfilename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&precordingiunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReferenceRecorder<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, precordingiunknown: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReferenceRecorder(&*(&pszfilename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&precordingiunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SinkName<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SinkName(::core::mem::transmute_copy(&pname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSinkName<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSinkName(&*(&name as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NameSetLock<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NameSetLock() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SBESink<Impl: IMSVidStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sbeconfig: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SBESink(::core::mem::transmute_copy(&sbeconfig)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSink>, base.5, ContentRecorder::<Impl, OFFSET>, ReferenceRecorder::<Impl, OFFSET>, SinkName::<Impl, OFFSET>, SetSinkName::<Impl, OFFSET>, NameSetLock::<Impl, OFFSET>, SBESink::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSink2Impl: Sized + IMSVidStreamBufferSinkImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn UnlockProfile();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSink2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSink2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSink2Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSink2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSink2Vtbl {
        unsafe extern "system" fn UnlockProfile<Impl: IMSVidStreamBufferSink2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockProfile() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSink2>, base.5, UnlockProfile::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSink3Impl: Sized + IMSVidStreamBufferSink2Impl + IMSVidStreamBufferSinkImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn SetMinSeek();
    fn AudioCounter();
    fn VideoCounter();
    fn CCCounter();
    fn WSTCounter();
    fn SetAudioAnalysisFilter();
    fn AudioAnalysisFilter();
    fn Set_AudioAnalysisFilter();
    fn _AudioAnalysisFilter();
    fn SetVideoAnalysisFilter();
    fn VideoAnalysisFilter();
    fn Set_VideoAnalysisFilter();
    fn _VideoAnalysisFilter();
    fn SetDataAnalysisFilter();
    fn DataAnalysisFilter();
    fn Set_DataAnalysisFilter();
    fn _DataAnalysisFilter();
    fn LicenseErrorCode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSink3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSink3";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSink3Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSink3Vtbl {
        unsafe extern "system" fn SetMinSeek<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmin: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMinSeek(::core::mem::transmute_copy(&pdwmin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCounter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoCounter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCCounter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CCCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WSTCounter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WSTCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioAnalysisFilter(&*(&szclsid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioAnalysisFilter(::core::mem::transmute_copy(&pszclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_AudioAnalysisFilter(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._AudioAnalysisFilter(::core::mem::transmute_copy(&pguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoAnalysisFilter(&*(&szclsid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoAnalysisFilter(::core::mem::transmute_copy(&pszclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_VideoAnalysisFilter(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._VideoAnalysisFilter(::core::mem::transmute_copy(&pguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDataAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDataAnalysisFilter(&*(&szclsid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataAnalysisFilter(::core::mem::transmute_copy(&pszclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_DataAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_DataAnalysisFilter(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _DataAnalysisFilter<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._DataAnalysisFilter(::core::mem::transmute_copy(&pguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LicenseErrorCode<Impl: IMSVidStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hres: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LicenseErrorCode(::core::mem::transmute_copy(&hres)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSink3>,
            base.5,
            SetMinSeek::<Impl, OFFSET>,
            AudioCounter::<Impl, OFFSET>,
            VideoCounter::<Impl, OFFSET>,
            CCCounter::<Impl, OFFSET>,
            WSTCounter::<Impl, OFFSET>,
            SetAudioAnalysisFilter::<Impl, OFFSET>,
            AudioAnalysisFilter::<Impl, OFFSET>,
            Set_AudioAnalysisFilter::<Impl, OFFSET>,
            _AudioAnalysisFilter::<Impl, OFFSET>,
            SetVideoAnalysisFilter::<Impl, OFFSET>,
            VideoAnalysisFilter::<Impl, OFFSET>,
            Set_VideoAnalysisFilter::<Impl, OFFSET>,
            _VideoAnalysisFilter::<Impl, OFFSET>,
            SetDataAnalysisFilter::<Impl, OFFSET>,
            DataAnalysisFilter::<Impl, OFFSET>,
            Set_DataAnalysisFilter::<Impl, OFFSET>,
            _DataAnalysisFilter::<Impl, OFFSET>,
            LicenseErrorCode::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSinkEventImpl: Sized + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn CertificateFailure();
    fn CertificateSuccess();
    fn WriteFailure();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSinkEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSinkEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEventVtbl {
    pub const fn new<Impl: IMSVidStreamBufferSinkEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSinkEventVtbl {
        unsafe extern "system" fn CertificateFailure<Impl: IMSVidStreamBufferSinkEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CertificateFailure() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CertificateSuccess<Impl: IMSVidStreamBufferSinkEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CertificateSuccess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WriteFailure<Impl: IMSVidStreamBufferSinkEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WriteFailure() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSinkEvent>, base.5, CertificateFailure::<Impl, OFFSET>, CertificateSuccess::<Impl, OFFSET>, WriteFailure::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSinkEvent2Impl: Sized + IMSVidStreamBufferSinkEventImpl + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn EncryptionOn();
    fn EncryptionOff();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSinkEvent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSinkEvent2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent2Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSinkEvent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSinkEvent2Vtbl {
        unsafe extern "system" fn EncryptionOn<Impl: IMSVidStreamBufferSinkEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EncryptionOn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EncryptionOff<Impl: IMSVidStreamBufferSinkEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EncryptionOff() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSinkEvent2>, base.5, EncryptionOn::<Impl, OFFSET>, EncryptionOff::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSinkEvent3Impl: Sized + IMSVidStreamBufferSinkEvent2Impl + IMSVidStreamBufferSinkEventImpl + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn LicenseChange();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSinkEvent3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSinkEvent3";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent3Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSinkEvent3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSinkEvent3Vtbl {
        unsafe extern "system" fn LicenseChange<Impl: IMSVidStreamBufferSinkEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwprot: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LicenseChange(dwprot) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSinkEvent3>, base.5, LicenseChange::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSinkEvent4Impl: Sized + IMSVidStreamBufferSinkEvent3Impl + IMSVidStreamBufferSinkEvent2Impl + IMSVidStreamBufferSinkEventImpl + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn WriteFailureClear();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSinkEvent4 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSinkEvent4";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent4Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSinkEvent4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSinkEvent4Vtbl {
        unsafe extern "system" fn WriteFailureClear<Impl: IMSVidStreamBufferSinkEvent4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WriteFailureClear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSinkEvent4>, base.5, WriteFailureClear::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSourceImpl: Sized + IMSVidFilePlaybackImpl + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Start();
    fn RecordingAttribute();
    fn CurrentRatings();
    fn MaxRatingsLevel();
    fn SetBlockUnrated();
    fn SetUnratedDelay();
    fn SBESource();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSource {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSource";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceVtbl {
    pub const fn new<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSourceVtbl {
        unsafe extern "system" fn Start<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstart: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(::core::mem::transmute_copy(&lstart)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingAttribute<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, precordingattribute: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecordingAttribute(::core::mem::transmute_copy(&precordingattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentRatings<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, pbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentRatings(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&pbfenattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxRatingsLevel<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enrating: EnTvRat_GenericLevel, lbfenattr: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxRatingsLevel(ensystem, enrating, lbfenattr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnrated<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bblock: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlockUnrated(bblock) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnratedDelay<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdelay: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUnratedDelay(dwdelay) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SBESource<Impl: IMSVidStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sbefilter: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SBESource(::core::mem::transmute_copy(&sbefilter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSource>, base.5, Start::<Impl, OFFSET>, RecordingAttribute::<Impl, OFFSET>, CurrentRatings::<Impl, OFFSET>, MaxRatingsLevel::<Impl, OFFSET>, SetBlockUnrated::<Impl, OFFSET>, SetUnratedDelay::<Impl, OFFSET>, SBESource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSource2Impl: Sized + IMSVidStreamBufferSourceImpl + IMSVidFilePlaybackImpl + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn SetRateEx();
    fn AudioCounter();
    fn VideoCounter();
    fn CCCounter();
    fn WSTCounter();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSource2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSource2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSource2Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSource2Vtbl {
        unsafe extern "system" fn SetRateEx<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrate: f64, dwframespersecond: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRateEx(dwrate, dwframespersecond) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCounter<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoCounter<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCCounter<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CCCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WSTCounter<Impl: IMSVidStreamBufferSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WSTCounter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSource2>, base.5, SetRateEx::<Impl, OFFSET>, AudioCounter::<Impl, OFFSET>, VideoCounter::<Impl, OFFSET>, CCCounter::<Impl, OFFSET>, WSTCounter::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSourceEventImpl: Sized + IMSVidFilePlaybackEventImpl + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn CertificateFailure();
    fn CertificateSuccess();
    fn RatingsBlocked();
    fn RatingsUnblocked();
    fn RatingsChanged();
    fn TimeHole();
    fn StaleDataRead();
    fn ContentBecomingStale();
    fn StaleFileDeleted();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSourceEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSourceEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEventVtbl {
    pub const fn new<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSourceEventVtbl {
        unsafe extern "system" fn CertificateFailure<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CertificateFailure() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CertificateSuccess<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CertificateSuccess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RatingsBlocked<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RatingsBlocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RatingsUnblocked<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RatingsUnblocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RatingsChanged<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RatingsChanged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeHole<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamoffsetms: i32, sizems: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeHole(streamoffsetms, sizems) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StaleDataRead<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StaleDataRead() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentBecomingStale<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentBecomingStale() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StaleFileDeleted<Impl: IMSVidStreamBufferSourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StaleFileDeleted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSourceEvent>, base.5, CertificateFailure::<Impl, OFFSET>, CertificateSuccess::<Impl, OFFSET>, RatingsBlocked::<Impl, OFFSET>, RatingsUnblocked::<Impl, OFFSET>, RatingsChanged::<Impl, OFFSET>, TimeHole::<Impl, OFFSET>, StaleDataRead::<Impl, OFFSET>, ContentBecomingStale::<Impl, OFFSET>, StaleFileDeleted::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSourceEvent2Impl: Sized + IMSVidStreamBufferSourceEventImpl + IMSVidFilePlaybackEventImpl + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn RateChange();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSourceEvent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSourceEvent2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEvent2Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSourceEvent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSourceEvent2Vtbl {
        unsafe extern "system" fn RateChange<Impl: IMSVidStreamBufferSourceEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RateChange(qwnewrate, qwoldrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSourceEvent2>, base.5, RateChange::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferSourceEvent3Impl: Sized + IMSVidStreamBufferSourceEvent2Impl + IMSVidStreamBufferSourceEventImpl + IMSVidFilePlaybackEventImpl + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn BroadcastEvent();
    fn BroadcastEventEx();
    fn COPPBlocked();
    fn COPPUnblocked();
    fn ContentPrimarilyAudio();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferSourceEvent3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferSourceEvent3";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEvent3Vtbl {
    pub const fn new<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferSourceEvent3Vtbl {
        unsafe extern "system" fn BroadcastEvent<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BroadcastEvent(&*(&guid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BroadcastEventEx<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BroadcastEventEx(&*(&guid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), param1, param2, param3, param4) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn COPPBlocked<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).COPPBlocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn COPPUnblocked<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).COPPUnblocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentPrimarilyAudio<Impl: IMSVidStreamBufferSourceEvent3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentPrimarilyAudio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferSourceEvent3>, base.5, BroadcastEvent::<Impl, OFFSET>, BroadcastEventEx::<Impl, OFFSET>, COPPBlocked::<Impl, OFFSET>, COPPUnblocked::<Impl, OFFSET>, ContentPrimarilyAudio::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidStreamBufferV2SourceEventImpl: Sized + IMSVidFilePlaybackEventImpl + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn RatingsChanged();
    fn TimeHole();
    fn StaleDataRead();
    fn ContentBecomingStale();
    fn StaleFileDeleted();
    fn RateChange();
    fn BroadcastEvent();
    fn BroadcastEventEx();
    fn ContentPrimarilyAudio();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidStreamBufferV2SourceEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidStreamBufferV2SourceEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferV2SourceEventVtbl {
    pub const fn new<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidStreamBufferV2SourceEventVtbl {
        unsafe extern "system" fn RatingsChanged<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RatingsChanged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeHole<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamoffsetms: i32, sizems: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeHole(streamoffsetms, sizems) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StaleDataRead<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StaleDataRead() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentBecomingStale<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentBecomingStale() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StaleFileDeleted<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StaleFileDeleted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RateChange<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RateChange(qwnewrate, qwoldrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BroadcastEvent<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BroadcastEvent(&*(&guid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BroadcastEventEx<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BroadcastEventEx(&*(&guid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), param1, param2, param3, param4) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentPrimarilyAudio<Impl: IMSVidStreamBufferV2SourceEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentPrimarilyAudio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidStreamBufferV2SourceEvent>, base.5, RatingsChanged::<Impl, OFFSET>, TimeHole::<Impl, OFFSET>, StaleDataRead::<Impl, OFFSET>, ContentBecomingStale::<Impl, OFFSET>, StaleFileDeleted::<Impl, OFFSET>, RateChange::<Impl, OFFSET>, BroadcastEvent::<Impl, OFFSET>, BroadcastEventEx::<Impl, OFFSET>, ContentPrimarilyAudio::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidTunerImpl: Sized + IMSVidVideoInputDeviceImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Tune();
    fn SetTune();
    fn TuningSpace();
    fn SetTuningSpace();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidTuner";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidTunerVtbl {
    pub const fn new<Impl: IMSVidTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidTunerVtbl {
        unsafe extern "system" fn Tune<Impl: IMSVidTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptr: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Tune(::core::mem::transmute_copy(&pptr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTune<Impl: IMSVidTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptr: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTune(&*(&ptr as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuningSpace<Impl: IMSVidTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plts: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpace(::core::mem::transmute_copy(&plts)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: IMSVidTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plts: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTuningSpace(&*(&plts as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidTuner>, base.5, Tune::<Impl, OFFSET>, SetTune::<Impl, OFFSET>, TuningSpace::<Impl, OFFSET>, SetTuningSpace::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidTunerEventImpl: Sized + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn TuneChanged();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidTunerEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidTunerEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidTunerEventVtbl {
    pub const fn new<Impl: IMSVidTunerEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidTunerEventVtbl {
        unsafe extern "system" fn TuneChanged<Impl: IMSVidTunerEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuneChanged(&*(&lpd as *const <IMSVidTuner as ::windows::core::Abi>::Abi as *const <IMSVidTuner as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidTunerEvent>, base.5, TuneChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVMR9Impl: Sized + IMSVidVideoRendererImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Allocator_ID();
    fn SetAllocator();
    fn SetSuppressEffects();
    fn SuppressEffects();
    fn Allocator();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVMR9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVMR9";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVMR9Vtbl {
    pub const fn new<Impl: IMSVidVMR9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVMR9Vtbl {
        unsafe extern "system" fn Allocator_ID<Impl: IMSVidVMR9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Allocator_ID(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllocator<Impl: IMSVidVMR9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::core::ffi::c_void, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllocator(&*(&allocpresent as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidVMR9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSuppressEffects(bsuppress) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidVMR9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuppressEffects(::core::mem::transmute_copy(&bsuppress)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allocator<Impl: IMSVidVMR9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Allocator(::core::mem::transmute_copy(&allocpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVMR9>, base.5, Allocator_ID::<Impl, OFFSET>, SetAllocator::<Impl, OFFSET>, SetSuppressEffects::<Impl, OFFSET>, SuppressEffects::<Impl, OFFSET>, Allocator::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVRGraphSegmentImpl: Sized + IMSVidGraphSegmentImpl + IPersistImpl {
    fn Set_VMRendererMode();
    fn SetOwner();
    fn Owner();
    fn UseOverlay();
    fn SetUseOverlay();
    fn Visible();
    fn SetVisible();
    fn ColorKey();
    fn SetColorKey();
    fn Source();
    fn SetSource();
    fn Destination();
    fn SetDestination();
    fn NativeSize();
    fn BorderColor();
    fn SetBorderColor();
    fn MaintainAspectRatio();
    fn SetMaintainAspectRatio();
    fn Refresh();
    fn DisplayChange();
    fn RePaint();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVRGraphSegment {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVRGraphSegment";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVRGraphSegmentVtbl {
    pub const fn new<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVRGraphSegmentVtbl {
        unsafe extern "system" fn Set_VMRendererMode<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_VMRendererMode(dwmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOwner<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, window: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOwner(&*(&window as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Owner<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, window: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Owner(::core::mem::transmute_copy(&window)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseOverlay<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlayval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseOverlay(::core::mem::transmute_copy(&useoverlayval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseOverlay<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlayval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUseOverlay(useoverlayval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Visible<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, visible: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Visible(::core::mem::transmute_copy(&visible)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisible<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, visible: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVisible(visible) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorKey<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, colorkey: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorKey(::core::mem::transmute_copy(&colorkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, colorkey: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(colorkey) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Source<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source(::core::mem::transmute_copy(&r)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r: super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSource(&*(&r as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Destination<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Destination(::core::mem::transmute_copy(&r)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestination<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r: super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestination(&*(&r as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NativeSize<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sizeval: *mut super::super::Foundation::SIZE, aspectratio: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NativeSize(::core::mem::transmute_copy(&sizeval), ::core::mem::transmute_copy(&aspectratio)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderColor<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderColor(::core::mem::transmute_copy(&color)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(color) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaintainAspectRatio<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmaintain: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaintainAspectRatio(::core::mem::transmute_copy(&fmaintain)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaintainAspectRatio<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmaintain: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaintainAspectRatio(fmaintain) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Refresh<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Refresh() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayChange<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RePaint<Impl: IMSVidVRGraphSegmentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RePaint(&*(&hdc as *const <super::super::Graphics::Gdi::HDC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HDC as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidVRGraphSegment>,
            base.5,
            Set_VMRendererMode::<Impl, OFFSET>,
            SetOwner::<Impl, OFFSET>,
            Owner::<Impl, OFFSET>,
            UseOverlay::<Impl, OFFSET>,
            SetUseOverlay::<Impl, OFFSET>,
            Visible::<Impl, OFFSET>,
            SetVisible::<Impl, OFFSET>,
            ColorKey::<Impl, OFFSET>,
            SetColorKey::<Impl, OFFSET>,
            Source::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            Destination::<Impl, OFFSET>,
            SetDestination::<Impl, OFFSET>,
            NativeSize::<Impl, OFFSET>,
            BorderColor::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            MaintainAspectRatio::<Impl, OFFSET>,
            SetMaintainAspectRatio::<Impl, OFFSET>,
            Refresh::<Impl, OFFSET>,
            DisplayChange::<Impl, OFFSET>,
            RePaint::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoInputDeviceImpl: Sized + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoInputDevice {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoInputDevice";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoInputDeviceVtbl {
    pub const fn new<Impl: IMSVidVideoInputDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoInputDeviceVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVideoInputDevice>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoRendererImpl: Sized + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn CustomCompositorClass();
    fn SetCustomCompositorClass();
    fn _CustomCompositorClass();
    fn Set_CustomCompositorClass();
    fn _CustomCompositor();
    fn Set_CustomCompositor();
    fn MixerBitmap();
    fn _MixerBitmap();
    fn SetMixerBitmap();
    fn Set_MixerBitmap();
    fn MixerBitmapPositionRect();
    fn SetMixerBitmapPositionRect();
    fn MixerBitmapOpacity();
    fn SetMixerBitmapOpacity();
    fn SetupMixerBitmap();
    fn SourceSize();
    fn SetSourceSize();
    fn OverScan();
    fn SetOverScan();
    fn AvailableSourceRect();
    fn MaxVidRect();
    fn MinVidRect();
    fn ClippedSourceRect();
    fn SetClippedSourceRect();
    fn UsingOverlay();
    fn SetUsingOverlay();
    fn Capture();
    fn FramesPerSecond();
    fn DecimateInput();
    fn SetDecimateInput();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoRenderer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoRenderer";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererVtbl {
    pub const fn new<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoRendererVtbl {
        unsafe extern "system" fn CustomCompositorClass<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositorclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CustomCompositorClass(::core::mem::transmute_copy(&compositorclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomCompositorClass<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositorclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCustomCompositorClass(&*(&compositorclsid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _CustomCompositorClass<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositorclsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._CustomCompositorClass(::core::mem::transmute_copy(&compositorclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_CustomCompositorClass<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_CustomCompositorClass(&*(&compositorclsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _CustomCompositor<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._CustomCompositor(::core::mem::transmute_copy(&compositor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_CustomCompositor<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, compositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_CustomCompositor(&*(&compositor as *const <IVMRImageCompositor as ::windows::core::Abi>::Abi as *const <IVMRImageCompositor as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MixerBitmap<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MixerBitmap(::core::mem::transmute_copy(&mixerpicturedisp)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _MixerBitmap<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mixerpicture: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._MixerBitmap(::core::mem::transmute_copy(&mixerpicture)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmap<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixerBitmap(&*(&mixerpicturedisp as *const <super::super::System::Ole::IPictureDisp as ::windows::core::Abi>::Abi as *const <super::super::System::Ole::IPictureDisp as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MixerBitmap<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_MixerBitmap(&*(&mixerpicture as *const <VMRALPHABITMAP as ::windows::core::Abi>::Abi as *const <VMRALPHABITMAP as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MixerBitmapPositionRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rdest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MixerBitmapPositionRect(::core::mem::transmute_copy(&rdest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmapPositionRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixerBitmapPositionRect(&*(&rdest as *const <IMSVidRect as ::windows::core::Abi>::Abi as *const <IMSVidRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MixerBitmapOpacity<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, opacity: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MixerBitmapOpacity(::core::mem::transmute_copy(&opacity)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmapOpacity<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, opacity: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixerBitmapOpacity(opacity) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetupMixerBitmap<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: ::windows::core::RawPtr, opacity: i32, rdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetupMixerBitmap(&*(&mixerpicturedisp as *const <super::super::System::Ole::IPictureDisp as ::windows::core::Abi>::Abi as *const <super::super::System::Ole::IPictureDisp as ::windows::core::DefaultType>::DefaultType), opacity, &*(&rdest as *const <IMSVidRect as ::windows::core::Abi>::Abi as *const <IMSVidRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceSize<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentsize: *mut SourceSizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceSize(::core::mem::transmute_copy(&currentsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceSize<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newsize: SourceSizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceSize(newsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverScan<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plpercent: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverScan(::core::mem::transmute_copy(&plpercent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverScan<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpercent: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOverScan(lpercent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AvailableSourceRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvailableSourceRect(::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxVidRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppvidrect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxVidRect(::core::mem::transmute_copy(&ppvidrect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinVidRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppvidrect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinVidRect(::core::mem::transmute_copy(&ppvidrect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClippedSourceRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClippedSourceRect(::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClippedSourceRect<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prect: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetClippedSourceRect(&*(&prect as *const <IMSVidRect as ::windows::core::Abi>::Abi as *const <IMSVidRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UsingOverlay<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlayval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UsingOverlay(::core::mem::transmute_copy(&useoverlayval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUsingOverlay<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, useoverlayval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUsingOverlay(useoverlayval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Capture<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentimage: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Capture(::core::mem::transmute_copy(&currentimage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FramesPerSecond<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FramesPerSecond(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DecimateInput<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeci: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DecimateInput(::core::mem::transmute_copy(&pdeci)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecimateInput<Impl: IMSVidVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeci: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDecimateInput(pdeci) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidVideoRenderer>,
            base.5,
            CustomCompositorClass::<Impl, OFFSET>,
            SetCustomCompositorClass::<Impl, OFFSET>,
            _CustomCompositorClass::<Impl, OFFSET>,
            Set_CustomCompositorClass::<Impl, OFFSET>,
            _CustomCompositor::<Impl, OFFSET>,
            Set_CustomCompositor::<Impl, OFFSET>,
            MixerBitmap::<Impl, OFFSET>,
            _MixerBitmap::<Impl, OFFSET>,
            SetMixerBitmap::<Impl, OFFSET>,
            Set_MixerBitmap::<Impl, OFFSET>,
            MixerBitmapPositionRect::<Impl, OFFSET>,
            SetMixerBitmapPositionRect::<Impl, OFFSET>,
            MixerBitmapOpacity::<Impl, OFFSET>,
            SetMixerBitmapOpacity::<Impl, OFFSET>,
            SetupMixerBitmap::<Impl, OFFSET>,
            SourceSize::<Impl, OFFSET>,
            SetSourceSize::<Impl, OFFSET>,
            OverScan::<Impl, OFFSET>,
            SetOverScan::<Impl, OFFSET>,
            AvailableSourceRect::<Impl, OFFSET>,
            MaxVidRect::<Impl, OFFSET>,
            MinVidRect::<Impl, OFFSET>,
            ClippedSourceRect::<Impl, OFFSET>,
            SetClippedSourceRect::<Impl, OFFSET>,
            UsingOverlay::<Impl, OFFSET>,
            SetUsingOverlay::<Impl, OFFSET>,
            Capture::<Impl, OFFSET>,
            FramesPerSecond::<Impl, OFFSET>,
            DecimateInput::<Impl, OFFSET>,
            SetDecimateInput::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoRenderer2Impl: Sized + IMSVidVideoRendererImpl + IMSVidOutputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Allocator();
    fn _Allocator();
    fn Allocator_ID();
    fn SetAllocator();
    fn _SetAllocator2();
    fn SetSuppressEffects();
    fn SuppressEffects();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoRenderer2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoRenderer2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRenderer2Vtbl {
    pub const fn new<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoRenderer2Vtbl {
        unsafe extern "system" fn Allocator<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Allocator(::core::mem::transmute_copy(&allocpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _Allocator<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._Allocator(::core::mem::transmute_copy(&allocpresent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allocator_ID<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Allocator_ID(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllocator<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::core::ffi::c_void, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllocator(&*(&allocpresent as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _SetAllocator2<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, allocpresent: ::windows::core::RawPtr, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._SetAllocator2(&*(&allocpresent as *const <IVMRSurfaceAllocator as ::windows::core::Abi>::Abi as *const <IVMRSurfaceAllocator as ::windows::core::DefaultType>::DefaultType), id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSuppressEffects(bsuppress) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidVideoRenderer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuppressEffects(::core::mem::transmute_copy(&bsuppress)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVideoRenderer2>, base.5, Allocator::<Impl, OFFSET>, _Allocator::<Impl, OFFSET>, Allocator_ID::<Impl, OFFSET>, SetAllocator::<Impl, OFFSET>, _SetAllocator2::<Impl, OFFSET>, SetSuppressEffects::<Impl, OFFSET>, SuppressEffects::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoRendererDevicesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn Add();
    fn Remove();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoRendererDevices {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoRendererDevices";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererDevicesVtbl {
    pub const fn new<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoRendererDevicesVtbl {
        unsafe extern "system" fn Count<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&lcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&pd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&pdb as *const <IMSVidVideoRenderer as ::windows::core::Abi>::Abi as *const <IMSVidVideoRenderer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMSVidVideoRendererDevicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&v as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVideoRendererDevices>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, Add::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoRendererEventImpl: Sized + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn OverlayUnavailable();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoRendererEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoRendererEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererEventVtbl {
    pub const fn new<Impl: IMSVidVideoRendererEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoRendererEventVtbl {
        unsafe extern "system" fn OverlayUnavailable<Impl: IMSVidVideoRendererEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverlayUnavailable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVideoRendererEvent>, base.5, OverlayUnavailable::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidVideoRendererEvent2Impl: Sized + IMSVidOutputDeviceEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn OverlayUnavailable();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidVideoRendererEvent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidVideoRendererEvent2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererEvent2Vtbl {
    pub const fn new<Impl: IMSVidVideoRendererEvent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidVideoRendererEvent2Vtbl {
        unsafe extern "system" fn OverlayUnavailable<Impl: IMSVidVideoRendererEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverlayUnavailable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidVideoRendererEvent2>, base.5, OverlayUnavailable::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidWebDVDImpl: Sized + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn OnDVDEvent();
    fn PlayTitle();
    fn PlayChapterInTitle();
    fn PlayChapter();
    fn PlayChaptersAutoStop();
    fn PlayAtTime();
    fn PlayAtTimeInTitle();
    fn PlayPeriodInTitleAutoStop();
    fn ReplayChapter();
    fn PlayPrevChapter();
    fn PlayNextChapter();
    fn StillOff();
    fn AudioLanguage();
    fn ShowMenu();
    fn Resume();
    fn ReturnFromSubmenu();
    fn ButtonsAvailable();
    fn CurrentButton();
    fn SelectAndActivateButton();
    fn ActivateButton();
    fn SelectRightButton();
    fn SelectLeftButton();
    fn SelectLowerButton();
    fn SelectUpperButton();
    fn ActivateAtPosition();
    fn SelectAtPosition();
    fn ButtonAtPosition();
    fn NumberOfChapters();
    fn TotalTitleTime();
    fn TitlesAvailable();
    fn VolumesAvailable();
    fn CurrentVolume();
    fn CurrentDiscSide();
    fn CurrentDomain();
    fn CurrentChapter();
    fn CurrentTitle();
    fn CurrentTime();
    fn DVDTimeCode2bstr();
    fn DVDDirectory();
    fn SetDVDDirectory();
    fn IsSubpictureStreamEnabled();
    fn IsAudioStreamEnabled();
    fn CurrentSubpictureStream();
    fn SetCurrentSubpictureStream();
    fn SubpictureLanguage();
    fn CurrentAudioStream();
    fn SetCurrentAudioStream();
    fn AudioStreamsAvailable();
    fn AnglesAvailable();
    fn CurrentAngle();
    fn SetCurrentAngle();
    fn SubpictureStreamsAvailable();
    fn SubpictureOn();
    fn SetSubpictureOn();
    fn DVDUniqueID();
    fn AcceptParentalLevelChange();
    fn NotifyParentalLevelChange();
    fn SelectParentalCountry();
    fn SelectParentalLevel();
    fn TitleParentalLevels();
    fn PlayerParentalCountry();
    fn PlayerParentalLevel();
    fn Eject();
    fn UOPValid();
    fn SPRM();
    fn GPRM();
    fn SetGPRM();
    fn DVDTextStringType();
    fn DVDTextString();
    fn DVDTextNumberOfStrings();
    fn DVDTextNumberOfLanguages();
    fn DVDTextLanguageLCID();
    fn RegionChange();
    fn DVDAdm();
    fn DeleteBookmark();
    fn RestoreBookmark();
    fn SaveBookmark();
    fn SelectDefaultAudioLanguage();
    fn SelectDefaultSubpictureLanguage();
    fn PreferredSubpictureStream();
    fn DefaultMenuLanguage();
    fn SetDefaultMenuLanguage();
    fn DefaultSubpictureLanguage();
    fn DefaultAudioLanguage();
    fn DefaultSubpictureLanguageExt();
    fn DefaultAudioLanguageExt();
    fn LanguageFromLCID();
    fn KaraokeAudioPresentationMode();
    fn SetKaraokeAudioPresentationMode();
    fn KaraokeChannelContent();
    fn KaraokeChannelAssignment();
    fn RestorePreferredSettings();
    fn ButtonRect();
    fn DVDScreenInMouseCoordinates();
    fn SetDVDScreenInMouseCoordinates();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidWebDVD {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidWebDVD";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVDVtbl {
    pub const fn new<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidWebDVDVtbl {
        unsafe extern "system" fn OnDVDEvent<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, levent: i32, lparam1: isize, lparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnDVDEvent(levent, lparam1, lparam2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayTitle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayTitle(ltitle) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, lchapter: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapterInTitle(ltitle, lchapter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapter<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lchapter: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapter(lchapter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChaptersAutoStop<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, lstrchapter: i32, lchaptercount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChaptersAutoStop(ltitle, lstrchapter, lchaptercount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTime<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTime(&*(&strtime as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, strtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTimeInTitle(ltitle, &*(&strtime as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPeriodInTitleAutoStop<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, strstarttime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strendtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayPeriodInTitleAutoStop(ltitle, &*(&strstarttime as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strendtime as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReplayChapter<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReplayChapter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayPrevChapter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayNextChapter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StillOff<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StillOff() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, fformat: i16, straudiolang: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioLanguage(lstream, fformat, ::core::mem::transmute_copy(&straudiolang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowMenu<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, menuid: DVDMenuIDConstants) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowMenu(menuid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Resume<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Resume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReturnFromSubmenu() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonsAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonsAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentButton(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAndActivateButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lbutton: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAndActivateButton(lbutton) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActivateButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectRightButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectRightButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectLeftButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectLeftButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectLowerButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectLowerButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectUpperButton<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectUpperButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActivateAtPosition<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateAtPosition(xpos, ypos) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAtPosition<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectAtPosition(xpos, ypos) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonAtPosition<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32, plbutton: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonAtPosition(xpos, ypos, ::core::mem::transmute_copy(&plbutton)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfChapters<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumberOfChapters(ltitle, ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TotalTitleTime<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TotalTitleTime(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitlesAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitlesAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VolumesAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VolumesAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentVolume<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentVolume(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentDiscSide<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentDiscSide(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentDomain<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentDomain(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentChapter<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentChapter(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentTitle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentTitle(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentTime<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentTime(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTimeCode2bstr<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, timecode: i32, ptimestr: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTimeCode2bstr(timecode, ::core::mem::transmute_copy(&ptimestr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDDirectory<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDDirectory(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDVDDirectory<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDVDDirectory(&*(&newval as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSubpictureStreamEnabled<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, fenabled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSubpictureStreamEnabled(lstream, ::core::mem::transmute_copy(&fenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioStreamEnabled<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, fenabled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAudioStreamEnabled(lstream, ::core::mem::transmute_copy(&fenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSubpictureStream<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentSubpictureStream(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentSubpictureStream<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentSubpictureStream(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SubpictureLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, strlanguage: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SubpictureLanguage(lstream, ::core::mem::transmute_copy(&strlanguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentAudioStream<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentAudioStream(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentAudioStream<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentAudioStream(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamsAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamsAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AnglesAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AnglesAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentAngle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentAngle(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentAngle<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentAngle(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SubpictureStreamsAvailable<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SubpictureStreamsAvailable(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SubpictureOn<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SubpictureOn(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubpictureOn<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSubpictureOn(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDUniqueID<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDUniqueID(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptParentalLevelChange<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, faccept: i16, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptParentalLevelChange(faccept, &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyParentalLevelChange<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyParentalLevelChange(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectParentalCountry<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcountry: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectParentalCountry(lcountry, &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectParentalLevel<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lparentallevel: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectParentalLevel(lparentallevel, &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleParentalLevels<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ltitle: i32, plparentallevels: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleParentalLevels(ltitle, ::core::mem::transmute_copy(&plparentallevels)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayerParentalCountry<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plcountrycode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayerParentalCountry(::core::mem::transmute_copy(&plcountrycode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayerParentalLevel<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plparentallevel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayerParentalLevel(::core::mem::transmute_copy(&plparentallevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Eject<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Eject() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UOPValid<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, luop: i32, pfvalid: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UOPValid(luop, ::core::mem::transmute_copy(&pfvalid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SPRM<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, pssprm: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SPRM(lindex, ::core::mem::transmute_copy(&pssprm)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GPRM<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, pssprm: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GPRM(lindex, ::core::mem::transmute_copy(&pssprm)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGPRM<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lindex: i32, svalue: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGPRM(lindex, svalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextStringType<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llangindex: i32, lstringindex: i32, ptype: *mut DVDTextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTextStringType(llangindex, lstringindex, ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextString<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llangindex: i32, lstringindex: i32, pstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTextString(llangindex, lstringindex, ::core::mem::transmute_copy(&pstrtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextNumberOfStrings<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llangindex: i32, plnumofstrings: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTextNumberOfStrings(llangindex, ::core::mem::transmute_copy(&plnumofstrings)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextNumberOfLanguages<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plnumoflangs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTextNumberOfLanguages(::core::mem::transmute_copy(&plnumoflangs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextLanguageLCID<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llangindex: i32, lcid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDTextLanguageLCID(llangindex, ::core::mem::transmute_copy(&lcid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegionChange<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegionChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDAdm<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDAdm(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteBookmark<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteBookmark() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RestoreBookmark<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RestoreBookmark() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SaveBookmark<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SaveBookmark() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultAudioLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: i32, ext: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectDefaultAudioLanguage(lang, ext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultSubpictureLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: i32, ext: DVDSPExt) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectDefaultSubpictureLanguage(lang, ext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreferredSubpictureStream<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreferredSubpictureStream(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultMenuLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultMenuLanguage(::core::mem::transmute_copy(&lang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMenuLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultMenuLanguage(lang) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSubpictureLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLanguage(::core::mem::transmute_copy(&lang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLanguage<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLanguage(::core::mem::transmute_copy(&lang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSubpictureLanguageExt<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ext: *mut DVDSPExt) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLanguageExt(::core::mem::transmute_copy(&ext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLanguageExt<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ext: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLanguageExt(::core::mem::transmute_copy(&ext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LanguageFromLCID<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcid: i32, lang: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LanguageFromLCID(lcid, ::core::mem::transmute_copy(&lang)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeAudioPresentationMode<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KaraokeAudioPresentationMode(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKaraokeAudioPresentationMode<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetKaraokeAudioPresentationMode(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeChannelContent<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, lchan: i32, lcontent: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KaraokeChannelContent(lstream, lchan, ::core::mem::transmute_copy(&lcontent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeChannelAssignment<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lstream: i32, lchannelassignment: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KaraokeChannelAssignment(lstream, ::core::mem::transmute_copy(&lchannelassignment)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RestorePreferredSettings<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RestorePreferredSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonRect<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lbutton: i32, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonRect(lbutton, ::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDScreenInMouseCoordinates<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDScreenInMouseCoordinates(::core::mem::transmute_copy(&pprect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDVDScreenInMouseCoordinates<Impl: IMSVidWebDVDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prect: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDVDScreenInMouseCoordinates(&*(&prect as *const <IMSVidRect as ::windows::core::Abi>::Abi as *const <IMSVidRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidWebDVD>,
            base.5,
            OnDVDEvent::<Impl, OFFSET>,
            PlayTitle::<Impl, OFFSET>,
            PlayChapterInTitle::<Impl, OFFSET>,
            PlayChapter::<Impl, OFFSET>,
            PlayChaptersAutoStop::<Impl, OFFSET>,
            PlayAtTime::<Impl, OFFSET>,
            PlayAtTimeInTitle::<Impl, OFFSET>,
            PlayPeriodInTitleAutoStop::<Impl, OFFSET>,
            ReplayChapter::<Impl, OFFSET>,
            PlayPrevChapter::<Impl, OFFSET>,
            PlayNextChapter::<Impl, OFFSET>,
            StillOff::<Impl, OFFSET>,
            AudioLanguage::<Impl, OFFSET>,
            ShowMenu::<Impl, OFFSET>,
            Resume::<Impl, OFFSET>,
            ReturnFromSubmenu::<Impl, OFFSET>,
            ButtonsAvailable::<Impl, OFFSET>,
            CurrentButton::<Impl, OFFSET>,
            SelectAndActivateButton::<Impl, OFFSET>,
            ActivateButton::<Impl, OFFSET>,
            SelectRightButton::<Impl, OFFSET>,
            SelectLeftButton::<Impl, OFFSET>,
            SelectLowerButton::<Impl, OFFSET>,
            SelectUpperButton::<Impl, OFFSET>,
            ActivateAtPosition::<Impl, OFFSET>,
            SelectAtPosition::<Impl, OFFSET>,
            ButtonAtPosition::<Impl, OFFSET>,
            NumberOfChapters::<Impl, OFFSET>,
            TotalTitleTime::<Impl, OFFSET>,
            TitlesAvailable::<Impl, OFFSET>,
            VolumesAvailable::<Impl, OFFSET>,
            CurrentVolume::<Impl, OFFSET>,
            CurrentDiscSide::<Impl, OFFSET>,
            CurrentDomain::<Impl, OFFSET>,
            CurrentChapter::<Impl, OFFSET>,
            CurrentTitle::<Impl, OFFSET>,
            CurrentTime::<Impl, OFFSET>,
            DVDTimeCode2bstr::<Impl, OFFSET>,
            DVDDirectory::<Impl, OFFSET>,
            SetDVDDirectory::<Impl, OFFSET>,
            IsSubpictureStreamEnabled::<Impl, OFFSET>,
            IsAudioStreamEnabled::<Impl, OFFSET>,
            CurrentSubpictureStream::<Impl, OFFSET>,
            SetCurrentSubpictureStream::<Impl, OFFSET>,
            SubpictureLanguage::<Impl, OFFSET>,
            CurrentAudioStream::<Impl, OFFSET>,
            SetCurrentAudioStream::<Impl, OFFSET>,
            AudioStreamsAvailable::<Impl, OFFSET>,
            AnglesAvailable::<Impl, OFFSET>,
            CurrentAngle::<Impl, OFFSET>,
            SetCurrentAngle::<Impl, OFFSET>,
            SubpictureStreamsAvailable::<Impl, OFFSET>,
            SubpictureOn::<Impl, OFFSET>,
            SetSubpictureOn::<Impl, OFFSET>,
            DVDUniqueID::<Impl, OFFSET>,
            AcceptParentalLevelChange::<Impl, OFFSET>,
            NotifyParentalLevelChange::<Impl, OFFSET>,
            SelectParentalCountry::<Impl, OFFSET>,
            SelectParentalLevel::<Impl, OFFSET>,
            TitleParentalLevels::<Impl, OFFSET>,
            PlayerParentalCountry::<Impl, OFFSET>,
            PlayerParentalLevel::<Impl, OFFSET>,
            Eject::<Impl, OFFSET>,
            UOPValid::<Impl, OFFSET>,
            SPRM::<Impl, OFFSET>,
            GPRM::<Impl, OFFSET>,
            SetGPRM::<Impl, OFFSET>,
            DVDTextStringType::<Impl, OFFSET>,
            DVDTextString::<Impl, OFFSET>,
            DVDTextNumberOfStrings::<Impl, OFFSET>,
            DVDTextNumberOfLanguages::<Impl, OFFSET>,
            DVDTextLanguageLCID::<Impl, OFFSET>,
            RegionChange::<Impl, OFFSET>,
            DVDAdm::<Impl, OFFSET>,
            DeleteBookmark::<Impl, OFFSET>,
            RestoreBookmark::<Impl, OFFSET>,
            SaveBookmark::<Impl, OFFSET>,
            SelectDefaultAudioLanguage::<Impl, OFFSET>,
            SelectDefaultSubpictureLanguage::<Impl, OFFSET>,
            PreferredSubpictureStream::<Impl, OFFSET>,
            DefaultMenuLanguage::<Impl, OFFSET>,
            SetDefaultMenuLanguage::<Impl, OFFSET>,
            DefaultSubpictureLanguage::<Impl, OFFSET>,
            DefaultAudioLanguage::<Impl, OFFSET>,
            DefaultSubpictureLanguageExt::<Impl, OFFSET>,
            DefaultAudioLanguageExt::<Impl, OFFSET>,
            LanguageFromLCID::<Impl, OFFSET>,
            KaraokeAudioPresentationMode::<Impl, OFFSET>,
            SetKaraokeAudioPresentationMode::<Impl, OFFSET>,
            KaraokeChannelContent::<Impl, OFFSET>,
            KaraokeChannelAssignment::<Impl, OFFSET>,
            RestorePreferredSettings::<Impl, OFFSET>,
            ButtonRect::<Impl, OFFSET>,
            DVDScreenInMouseCoordinates::<Impl, OFFSET>,
            SetDVDScreenInMouseCoordinates::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidWebDVD2Impl: Sized + IMSVidWebDVDImpl + IMSVidPlaybackImpl + IMSVidInputDeviceImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn Bookmark();
    fn SetBookmark();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidWebDVD2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidWebDVD2";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVD2Vtbl {
    pub const fn new<Impl: IMSVidWebDVD2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidWebDVD2Vtbl {
        unsafe extern "system" fn Bookmark<Impl: IMSVidWebDVD2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdata: *mut *mut u8, pdatalength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bookmark(::core::mem::transmute_copy(&ppdata), ::core::mem::transmute_copy(&pdatalength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBookmark<Impl: IMSVidWebDVD2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdata: *const u8, dwdatalength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBookmark(pdata, dwdatalength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidWebDVD2>, base.5, Bookmark::<Impl, OFFSET>, SetBookmark::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidWebDVDAdmImpl: Sized + IDispatchImpl {
    fn ChangePassword();
    fn SaveParentalLevel();
    fn SaveParentalCountry();
    fn ConfirmPassword();
    fn GetParentalLevel();
    fn GetParentalCountry();
    fn DefaultAudioLCID();
    fn SetDefaultAudioLCID();
    fn DefaultSubpictureLCID();
    fn SetDefaultSubpictureLCID();
    fn DefaultMenuLCID();
    fn SetDefaultMenuLCID();
    fn BookmarkOnStop();
    fn SetBookmarkOnStop();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidWebDVDAdm {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidWebDVDAdm";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVDAdmVtbl {
    pub const fn new<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidWebDVDAdmVtbl {
        unsafe extern "system" fn ChangePassword<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strold: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strnew: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangePassword(
                &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&strold as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&strnew as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SaveParentalLevel<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, level: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SaveParentalLevel(level, &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SaveParentalCountry<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, country: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SaveParentalCountry(country, &*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfirmPassword<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfirmPassword(&*(&strusername as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&strpassword as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalLevel<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llevel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParentalLevel(::core::mem::transmute_copy(&llevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalCountry<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcountry: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParentalCountry(::core::mem::transmute_copy(&lcountry)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLCID(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultAudioLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultAudioLCID(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSubpictureLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLCID(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSubpictureLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultSubpictureLCID(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultMenuLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultMenuLCID(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMenuLCID<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultMenuLCID(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BookmarkOnStop<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BookmarkOnStop(::core::mem::transmute_copy(&pval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBookmarkOnStop<Impl: IMSVidWebDVDAdmImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBookmarkOnStop(newval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidWebDVDAdm>,
            base.5,
            ChangePassword::<Impl, OFFSET>,
            SaveParentalLevel::<Impl, OFFSET>,
            SaveParentalCountry::<Impl, OFFSET>,
            ConfirmPassword::<Impl, OFFSET>,
            GetParentalLevel::<Impl, OFFSET>,
            GetParentalCountry::<Impl, OFFSET>,
            DefaultAudioLCID::<Impl, OFFSET>,
            SetDefaultAudioLCID::<Impl, OFFSET>,
            DefaultSubpictureLCID::<Impl, OFFSET>,
            SetDefaultSubpictureLCID::<Impl, OFFSET>,
            DefaultMenuLCID::<Impl, OFFSET>,
            SetDefaultMenuLCID::<Impl, OFFSET>,
            BookmarkOnStop::<Impl, OFFSET>,
            SetBookmarkOnStop::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidWebDVDEventImpl: Sized + IMSVidPlaybackEventImpl + IMSVidInputDeviceEventImpl + IDispatchImpl {
    fn DVDNotify();
    fn PlayForwards();
    fn PlayBackwards();
    fn ShowMenu();
    fn Resume();
    fn SelectOrActivateButton();
    fn StillOff();
    fn PauseOn();
    fn ChangeCurrentAudioStream();
    fn ChangeCurrentSubpictureStream();
    fn ChangeCurrentAngle();
    fn PlayAtTimeInTitle();
    fn PlayAtTime();
    fn PlayChapterInTitle();
    fn PlayChapter();
    fn ReplayChapter();
    fn PlayNextChapter();
    fn Stop();
    fn ReturnFromSubmenu();
    fn PlayTitle();
    fn PlayPrevChapter();
    fn ChangeKaraokePresMode();
    fn ChangeVideoPresMode();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidWebDVDEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidWebDVDEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVDEventVtbl {
    pub const fn new<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidWebDVDEventVtbl {
        unsafe extern "system" fn DVDNotify<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leventcode: i32, lparam1: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, lparam2: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DVDNotify(leventcode, &*(&lparam1 as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), &*(&lparam2 as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayForwards<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayForwards(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayBackwards<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayBackwards(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowMenu<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, menuid: DVDMenuIDConstants, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowMenu(menuid, benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Resume<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Resume(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectOrActivateButton<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectOrActivateButton(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StillOff<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StillOff(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PauseOn<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PauseOn(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeCurrentAudioStream<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeCurrentAudioStream(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeCurrentSubpictureStream<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeCurrentSubpictureStream(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeCurrentAngle<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeCurrentAngle(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTimeInTitle(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTime<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayAtTime(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapterInTitle(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapter<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayChapter(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReplayChapter<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReplayChapter(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayNextChapter(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReturnFromSubmenu(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayTitle<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayTitle(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayPrevChapter(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeKaraokePresMode<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeKaraokePresMode(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeVideoPresMode<Impl: IMSVidWebDVDEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeVideoPresMode(benabled) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMSVidWebDVDEvent>,
            base.5,
            DVDNotify::<Impl, OFFSET>,
            PlayForwards::<Impl, OFFSET>,
            PlayBackwards::<Impl, OFFSET>,
            ShowMenu::<Impl, OFFSET>,
            Resume::<Impl, OFFSET>,
            SelectOrActivateButton::<Impl, OFFSET>,
            StillOff::<Impl, OFFSET>,
            PauseOn::<Impl, OFFSET>,
            ChangeCurrentAudioStream::<Impl, OFFSET>,
            ChangeCurrentSubpictureStream::<Impl, OFFSET>,
            ChangeCurrentAngle::<Impl, OFFSET>,
            PlayAtTimeInTitle::<Impl, OFFSET>,
            PlayAtTime::<Impl, OFFSET>,
            PlayChapterInTitle::<Impl, OFFSET>,
            PlayChapter::<Impl, OFFSET>,
            ReplayChapter::<Impl, OFFSET>,
            PlayNextChapter::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            ReturnFromSubmenu::<Impl, OFFSET>,
            PlayTitle::<Impl, OFFSET>,
            PlayPrevChapter::<Impl, OFFSET>,
            ChangeKaraokePresMode::<Impl, OFFSET>,
            ChangeVideoPresMode::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidXDSImpl: Sized + IMSVidFeatureImpl + IMSVidDeviceImpl + IDispatchImpl {
    fn ChannelChangeInterface();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidXDS {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidXDS";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidXDSVtbl {
    pub const fn new<Impl: IMSVidXDSImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidXDSVtbl {
        unsafe extern "system" fn ChannelChangeInterface<Impl: IMSVidXDSImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkcc: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChannelChangeInterface(::core::mem::transmute_copy(&punkcc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidXDS>, base.5, ChannelChangeInterface::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidXDSEventImpl: Sized + IMSVidFeatureEventImpl + IMSVidDeviceEventImpl + IDispatchImpl {
    fn RatingChange();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMSVidXDSEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMSVidXDSEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidXDSEventVtbl {
    pub const fn new<Impl: IMSVidXDSEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMSVidXDSEventVtbl {
        unsafe extern "system" fn RatingChange<Impl: IMSVidXDSEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prevratingsystem: EnTvRat_System, prevlevel: EnTvRat_GenericLevel, prevattributes: BfEnTvRat_GenericAttributes, newratingsystem: EnTvRat_System, newlevel: EnTvRat_GenericLevel, newattributes: BfEnTvRat_GenericAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RatingChange(prevratingsystem, prevlevel, prevattributes, newratingsystem, newlevel, newattributes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMSVidXDSEvent>, base.5, RatingChange::<Impl, OFFSET>)
    }
}
pub trait IMceBurnerControlImpl: Sized {
    fn GetBurnerNoDecryption();
}
impl ::windows::core::RuntimeName for IMceBurnerControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMceBurnerControl";
}
impl IMceBurnerControlVtbl {
    pub const fn new<Impl: IMceBurnerControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMceBurnerControlVtbl {
        unsafe extern "system" fn GetBurnerNoDecryption<Impl: IMceBurnerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBurnerNoDecryption() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMceBurnerControl>, base.5, GetBurnerNoDecryption::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaControlImpl: Sized + IDispatchImpl {
    fn Run();
    fn Pause();
    fn Stop();
    fn GetState();
    fn RenderFile();
    fn AddSourceFilter();
    fn FilterCollection();
    fn RegFilterCollection();
    fn StopWhenReady();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaControl";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaControlVtbl {
    pub const fn new<Impl: IMediaControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaControlVtbl {
        unsafe extern "system" fn Run<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Run() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mstimeout: i32, pfs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(mstimeout, ::core::mem::transmute_copy(&pfs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderFile<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenderFile(&*(&strfilename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSourceFilter<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddSourceFilter(&*(&strfilename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FilterCollection<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FilterCollection(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegFilterCollection<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegFilterCollection(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopWhenReady<Impl: IMediaControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopWhenReady() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaControl>, base.5, Run::<Impl, OFFSET>, Pause::<Impl, OFFSET>, Stop::<Impl, OFFSET>, GetState::<Impl, OFFSET>, RenderFile::<Impl, OFFSET>, AddSourceFilter::<Impl, OFFSET>, FilterCollection::<Impl, OFFSET>, RegFilterCollection::<Impl, OFFSET>, StopWhenReady::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaEventImpl: Sized + IDispatchImpl {
    fn GetEventHandle();
    fn GetEvent();
    fn WaitForCompletion();
    fn CancelDefaultHandling();
    fn RestoreDefaultHandling();
    fn FreeEventParams();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaEvent";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaEventVtbl {
    pub const fn new<Impl: IMediaEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaEventVtbl {
        unsafe extern "system" fn GetEventHandle<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hevent: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEventHandle(::core::mem::transmute_copy(&hevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEvent<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEvent(::core::mem::transmute_copy(&leventcode), ::core::mem::transmute_copy(&lparam1), ::core::mem::transmute_copy(&lparam2), mstimeout) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WaitForCompletion<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mstimeout: i32, pevcode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitForCompletion(mstimeout, ::core::mem::transmute_copy(&pevcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelDefaultHandling<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, levcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelDefaultHandling(levcode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RestoreDefaultHandling<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, levcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RestoreDefaultHandling(levcode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FreeEventParams<Impl: IMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, levcode: i32, lparam1: isize, lparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FreeEventParams(levcode, lparam1, lparam2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaEvent>, base.5, GetEventHandle::<Impl, OFFSET>, GetEvent::<Impl, OFFSET>, WaitForCompletion::<Impl, OFFSET>, CancelDefaultHandling::<Impl, OFFSET>, RestoreDefaultHandling::<Impl, OFFSET>, FreeEventParams::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaEventExImpl: Sized + IMediaEventImpl + IDispatchImpl {
    fn SetNotifyWindow();
    fn SetNotifyFlags();
    fn GetNotifyFlags();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaEventEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaEventEx";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaEventExVtbl {
    pub const fn new<Impl: IMediaEventExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaEventExVtbl {
        unsafe extern "system" fn SetNotifyWindow<Impl: IMediaEventExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: isize, lmsg: i32, linstancedata: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNotifyWindow(hwnd, lmsg, linstancedata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNotifyFlags<Impl: IMediaEventExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lnonotifyflags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNotifyFlags(lnonotifyflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNotifyFlags<Impl: IMediaEventExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplnonotifyflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNotifyFlags(::core::mem::transmute_copy(&lplnonotifyflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaEventEx>, base.5, SetNotifyWindow::<Impl, OFFSET>, SetNotifyFlags::<Impl, OFFSET>, GetNotifyFlags::<Impl, OFFSET>)
    }
}
pub trait IMediaEventSinkImpl: Sized {
    fn Notify();
}
impl ::windows::core::RuntimeName for IMediaEventSink {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaEventSink";
}
impl IMediaEventSinkVtbl {
    pub const fn new<Impl: IMediaEventSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaEventSinkVtbl {
        unsafe extern "system" fn Notify<Impl: IMediaEventSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eventcode: i32, eventparam1: isize, eventparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Notify(eventcode, eventparam1, eventparam2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaEventSink>, base.5, Notify::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaFilterImpl: Sized + IPersistImpl {
    fn Stop();
    fn Pause();
    fn Run();
    fn GetState();
    fn SetSyncSource();
    fn GetSyncSource();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaFilter";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaFilterVtbl {
    pub const fn new<Impl: IMediaFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaFilterVtbl {
        unsafe extern "system" fn Stop<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Run<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tstart: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Run(tstart) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmillisecstimeout: u32, state: *mut FILTER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(dwmillisecstimeout, ::core::mem::transmute_copy(&state)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncSource<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncSource(&*(&pclock as *const <super::IReferenceClock as ::windows::core::Abi>::Abi as *const <super::IReferenceClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSyncSource<Impl: IMediaFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSyncSource(::core::mem::transmute_copy(&pclock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaFilter>, base.5, Stop::<Impl, OFFSET>, Pause::<Impl, OFFSET>, Run::<Impl, OFFSET>, GetState::<Impl, OFFSET>, SetSyncSource::<Impl, OFFSET>, GetSyncSource::<Impl, OFFSET>)
    }
}
pub trait IMediaParamInfoImpl: Sized {
    fn GetParamCount();
    fn GetParamInfo();
    fn GetParamText();
    fn GetNumTimeFormats();
    fn GetSupportedTimeFormat();
    fn GetCurrentTimeFormat();
}
impl ::windows::core::RuntimeName for IMediaParamInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaParamInfo";
}
impl IMediaParamInfoVtbl {
    pub const fn new<Impl: IMediaParamInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaParamInfoVtbl {
        unsafe extern "system" fn GetParamCount<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwparams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParamCount(::core::mem::transmute_copy(&pdwparams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParamInfo<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, pinfo: *mut MP_PARAMINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParamInfo(dwparamindex, ::core::mem::transmute_copy(&pinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParamText<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, ppwchtext: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParamText(dwparamindex, ::core::mem::transmute_copy(&ppwchtext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumTimeFormats<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumtimeformats: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumTimeFormats(::core::mem::transmute_copy(&pdwnumtimeformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedTimeFormat<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwformatindex: u32, pguidtimeformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSupportedTimeFormat(dwformatindex, ::core::mem::transmute_copy(&pguidtimeformat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentTimeFormat<Impl: IMediaParamInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *mut ::windows::core::GUID, ptimedata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentTimeFormat(::core::mem::transmute_copy(&pguidtimeformat), ::core::mem::transmute_copy(&ptimedata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaParamInfo>, base.5, GetParamCount::<Impl, OFFSET>, GetParamInfo::<Impl, OFFSET>, GetParamText::<Impl, OFFSET>, GetNumTimeFormats::<Impl, OFFSET>, GetSupportedTimeFormat::<Impl, OFFSET>, GetCurrentTimeFormat::<Impl, OFFSET>)
    }
}
pub trait IMediaParamsImpl: Sized {
    fn GetParam();
    fn SetParam();
    fn AddEnvelope();
    fn FlushEnvelope();
    fn SetTimeFormat();
}
impl ::windows::core::RuntimeName for IMediaParams {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaParams";
}
impl IMediaParamsVtbl {
    pub const fn new<Impl: IMediaParamsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaParamsVtbl {
        unsafe extern "system" fn GetParam<Impl: IMediaParamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, pvalue: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParam(dwparamindex, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParam<Impl: IMediaParamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetParam(dwparamindex, value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEnvelope<Impl: IMediaParamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEnvelope(dwparamindex, csegments, &*(&penvelopesegments as *const <MP_ENVELOPE_SEGMENT as ::windows::core::Abi>::Abi as *const <MP_ENVELOPE_SEGMENT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FlushEnvelope<Impl: IMediaParamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FlushEnvelope(dwparamindex, reftimestart, reftimeend) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimeFormat<Impl: IMediaParamsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidtimeformat: ::windows::core::GUID, mptimedata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimeFormat(&*(&guidtimeformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), mptimedata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaParams>, base.5, GetParam::<Impl, OFFSET>, SetParam::<Impl, OFFSET>, AddEnvelope::<Impl, OFFSET>, FlushEnvelope::<Impl, OFFSET>, SetTimeFormat::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaPositionImpl: Sized + IDispatchImpl {
    fn Duration();
    fn SetCurrentPosition();
    fn CurrentPosition();
    fn StopTime();
    fn SetStopTime();
    fn PrerollTime();
    fn SetPrerollTime();
    fn SetRate();
    fn Rate();
    fn CanSeekForward();
    fn CanSeekBackward();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaPosition {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaPosition";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaPositionVtbl {
    pub const fn new<Impl: IMediaPositionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPositionVtbl {
        unsafe extern "system" fn Duration<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plength: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Duration(::core::mem::transmute_copy(&plength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPosition(lltime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentPosition<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentPosition(::core::mem::transmute_copy(&plltime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopTime<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopTime(::core::mem::transmute_copy(&plltime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopTime<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStopTime(lltime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrerollTime<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrerollTime(::core::mem::transmute_copy(&plltime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrerollTime<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPrerollTime(lltime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(drate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Rate<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Rate(::core::mem::transmute_copy(&pdrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekForward<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcanseekforward: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanSeekForward(::core::mem::transmute_copy(&pcanseekforward)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekBackward<Impl: IMediaPositionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcanseekbackward: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanSeekBackward(::core::mem::transmute_copy(&pcanseekbackward)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPosition>, base.5, Duration::<Impl, OFFSET>, SetCurrentPosition::<Impl, OFFSET>, CurrentPosition::<Impl, OFFSET>, StopTime::<Impl, OFFSET>, SetStopTime::<Impl, OFFSET>, PrerollTime::<Impl, OFFSET>, SetPrerollTime::<Impl, OFFSET>, SetRate::<Impl, OFFSET>, Rate::<Impl, OFFSET>, CanSeekForward::<Impl, OFFSET>, CanSeekBackward::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
pub trait IMediaPropertyBagImpl: Sized + IPropertyBagImpl {
    fn EnumProperty();
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::windows::core::RuntimeName for IMediaPropertyBag {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaPropertyBag";
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IMediaPropertyBagVtbl {
    pub const fn new<Impl: IMediaPropertyBagImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPropertyBagVtbl {
        unsafe extern "system" fn EnumProperty<Impl: IMediaPropertyBagImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, iproperty: u32, pvarpropertyname: *mut super::super::System::Com::VARIANT, pvarpropertyvalue: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumProperty(iproperty, &*(&pvarpropertyname as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), &*(&pvarpropertyvalue as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPropertyBag>, base.5, EnumProperty::<Impl, OFFSET>)
    }
}
pub trait IMediaSampleImpl: Sized {
    fn GetPointer();
    fn GetSize();
    fn GetTime();
    fn SetTime();
    fn IsSyncPoint();
    fn SetSyncPoint();
    fn IsPreroll();
    fn SetPreroll();
    fn GetActualDataLength();
    fn SetActualDataLength();
    fn GetMediaType();
    fn SetMediaType();
    fn IsDiscontinuity();
    fn SetDiscontinuity();
    fn GetMediaTime();
    fn SetMediaTime();
}
impl ::windows::core::RuntimeName for IMediaSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaSample";
}
impl IMediaSampleVtbl {
    pub const fn new<Impl: IMediaSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaSampleVtbl {
        unsafe extern "system" fn GetPointer<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPointer(::core::mem::transmute_copy(&ppbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSize<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTime(ptimestart, ptimeend) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSyncPoint<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSyncPoint() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncPoint<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncPoint(&*(&bissyncpoint as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPreroll<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPreroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreroll<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreroll(&*(&bispreroll as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActualDataLength<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActualDataLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActualDataLength<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__imediasample0000: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetActualDataLength(__midl__imediasample0000) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaType(::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(&*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDiscontinuity<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDiscontinuity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiscontinuity<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDiscontinuity(&*(&bdiscontinuity as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTime<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaTime<Impl: IMediaSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaTime(ptimestart, ptimeend) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaSample>,
            base.5,
            GetPointer::<Impl, OFFSET>,
            GetSize::<Impl, OFFSET>,
            GetTime::<Impl, OFFSET>,
            SetTime::<Impl, OFFSET>,
            IsSyncPoint::<Impl, OFFSET>,
            SetSyncPoint::<Impl, OFFSET>,
            IsPreroll::<Impl, OFFSET>,
            SetPreroll::<Impl, OFFSET>,
            GetActualDataLength::<Impl, OFFSET>,
            SetActualDataLength::<Impl, OFFSET>,
            GetMediaType::<Impl, OFFSET>,
            SetMediaType::<Impl, OFFSET>,
            IsDiscontinuity::<Impl, OFFSET>,
            SetDiscontinuity::<Impl, OFFSET>,
            GetMediaTime::<Impl, OFFSET>,
            SetMediaTime::<Impl, OFFSET>,
        )
    }
}
pub trait IMediaSample2Impl: Sized + IMediaSampleImpl {
    fn GetProperties();
    fn SetProperties();
}
impl ::windows::core::RuntimeName for IMediaSample2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaSample2";
}
impl IMediaSample2Vtbl {
    pub const fn new<Impl: IMediaSample2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaSample2Vtbl {
        unsafe extern "system" fn GetProperties<Impl: IMediaSample2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbproperties: u32, pbproperties: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProperties(cbproperties, ::core::mem::transmute_copy(&pbproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProperties<Impl: IMediaSample2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbproperties: u32, pbproperties: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProperties(cbproperties, pbproperties) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaSample2>, base.5, GetProperties::<Impl, OFFSET>, SetProperties::<Impl, OFFSET>)
    }
}
pub trait IMediaSample2ConfigImpl: Sized {
    fn GetSurface();
}
impl ::windows::core::RuntimeName for IMediaSample2Config {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaSample2Config";
}
impl IMediaSample2ConfigVtbl {
    pub const fn new<Impl: IMediaSample2ConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaSample2ConfigVtbl {
        unsafe extern "system" fn GetSurface<Impl: IMediaSample2ConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirect3dsurface9: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurface(::core::mem::transmute_copy(&ppdirect3dsurface9)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaSample2Config>, base.5, GetSurface::<Impl, OFFSET>)
    }
}
pub trait IMediaSeekingImpl: Sized {
    fn GetCapabilities();
    fn CheckCapabilities();
    fn IsFormatSupported();
    fn QueryPreferredFormat();
    fn GetTimeFormat();
    fn IsUsingTimeFormat();
    fn SetTimeFormat();
    fn GetDuration();
    fn GetStopPosition();
    fn GetCurrentPosition();
    fn ConvertTimeFormat();
    fn SetPositions();
    fn GetPositions();
    fn GetAvailable();
    fn SetRate();
    fn GetRate();
    fn GetPreroll();
}
impl ::windows::core::RuntimeName for IMediaSeeking {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaSeeking";
}
impl IMediaSeekingVtbl {
    pub const fn new<Impl: IMediaSeekingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaSeekingVtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapabilities(::core::mem::transmute_copy(&pcapabilities)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CheckCapabilities<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckCapabilities(pcapabilities) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFormatSupported<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFormatSupported(&*(&pformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryPreferredFormat<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryPreferredFormat(::core::mem::transmute_copy(&pformat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeFormat<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeFormat(::core::mem::transmute_copy(&pformat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingTimeFormat<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsUsingTimeFormat(&*(&pformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimeFormat<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimeFormat(&*(&pformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration(::core::mem::transmute_copy(&pduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStopPosition<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstop: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStopPosition(::core::mem::transmute_copy(&pstop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentPosition(::core::mem::transmute_copy(&pcurrent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertTimeFormat<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptarget: *mut i64, ptargetformat: *const ::windows::core::GUID, source: i64, psourceformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertTimeFormat(::core::mem::transmute_copy(&ptarget), &*(&ptargetformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), source, &*(&psourceformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPositions<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64, dwcurrentflags: u32, pstop: *mut i64, dwstopflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPositions(pcurrent, dwcurrentflags, pstop, dwstopflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPositions<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64, pstop: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPositions(::core::mem::transmute_copy(&pcurrent), ::core::mem::transmute_copy(&pstop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailable<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pearliest: *mut i64, platest: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailable(::core::mem::transmute_copy(&pearliest), ::core::mem::transmute_copy(&platest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(drate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRate<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRate(::core::mem::transmute_copy(&pdrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreroll<Impl: IMediaSeekingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pllpreroll: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreroll(::core::mem::transmute_copy(&pllpreroll)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaSeeking>,
            base.5,
            GetCapabilities::<Impl, OFFSET>,
            CheckCapabilities::<Impl, OFFSET>,
            IsFormatSupported::<Impl, OFFSET>,
            QueryPreferredFormat::<Impl, OFFSET>,
            GetTimeFormat::<Impl, OFFSET>,
            IsUsingTimeFormat::<Impl, OFFSET>,
            SetTimeFormat::<Impl, OFFSET>,
            GetDuration::<Impl, OFFSET>,
            GetStopPosition::<Impl, OFFSET>,
            GetCurrentPosition::<Impl, OFFSET>,
            ConvertTimeFormat::<Impl, OFFSET>,
            SetPositions::<Impl, OFFSET>,
            GetPositions::<Impl, OFFSET>,
            GetAvailable::<Impl, OFFSET>,
            SetRate::<Impl, OFFSET>,
            GetRate::<Impl, OFFSET>,
            GetPreroll::<Impl, OFFSET>,
        )
    }
}
pub trait IMediaStreamImpl: Sized {
    fn GetMultiMediaStream();
    fn GetInformation();
    fn SetSameFormat();
    fn AllocateSample();
    fn CreateSharedSample();
    fn SendEndOfStream();
}
impl ::windows::core::RuntimeName for IMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaStream";
}
impl IMediaStreamVtbl {
    pub const fn new<Impl: IMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaStreamVtbl {
        unsafe extern "system" fn GetMultiMediaStream<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmultimediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMultiMediaStream(::core::mem::transmute_copy(&ppmultimediastream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInformation<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInformation(::core::mem::transmute_copy(&ppurposeid), ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSameFormat<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstreamthathasdesiredformat: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSameFormat(&*(&pstreamthathasdesiredformat as *const <IMediaStream as ::windows::core::Abi>::Abi as *const <IMediaStream as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllocateSample<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocateSample(dwflags, ::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSharedSample<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pexistingsample: ::windows::core::RawPtr, dwflags: u32, ppnewsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSharedSample(&*(&pexistingsample as *const <IStreamSample as ::windows::core::Abi>::Abi as *const <IStreamSample as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&ppnewsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendEndOfStream<Impl: IMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SendEndOfStream(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaStream>, base.5, GetMultiMediaStream::<Impl, OFFSET>, GetInformation::<Impl, OFFSET>, SetSameFormat::<Impl, OFFSET>, AllocateSample::<Impl, OFFSET>, CreateSharedSample::<Impl, OFFSET>, SendEndOfStream::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaStreamFilterImpl: Sized + IBaseFilterImpl + IMediaFilterImpl + IPersistImpl {
    fn AddMediaStream();
    fn GetMediaStream();
    fn EnumMediaStreams();
    fn SupportSeeking();
    fn ReferenceTimeToStreamTime();
    fn GetCurrentStreamTime();
    fn WaitUntil();
    fn Flush();
    fn EndOfStream();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaStreamFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaStreamFilter";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaStreamFilterVtbl {
    pub const fn new<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaStreamFilterVtbl {
        unsafe extern "system" fn AddMediaStream<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pammediastream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddMediaStream(&*(&pammediastream as *const <IAMMediaStream as ::windows::core::Abi>::Abi as *const <IAMMediaStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaStream<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idpurpose: *const ::windows::core::GUID, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaStream(&*(&idpurpose as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppmediastream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMediaStreams(index, ::core::mem::transmute_copy(&ppmediastream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportSeeking<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brenderer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportSeeking(&*(&brenderer as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReferenceTimeToStreamTime<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReferenceTimeToStreamTime(::core::mem::transmute_copy(&ptime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentStreamTime<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrentstreamtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentStreamTime(::core::mem::transmute_copy(&pcurrentstreamtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WaitUntil<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, waitstreamtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitUntil(waitstreamtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bcanceleos: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush(&*(&bcanceleos as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndOfStream<Impl: IMediaStreamFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndOfStream() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaStreamFilter>, base.5, AddMediaStream::<Impl, OFFSET>, GetMediaStream::<Impl, OFFSET>, EnumMediaStreams::<Impl, OFFSET>, SupportSeeking::<Impl, OFFSET>, ReferenceTimeToStreamTime::<Impl, OFFSET>, GetCurrentStreamTime::<Impl, OFFSET>, WaitUntil::<Impl, OFFSET>, Flush::<Impl, OFFSET>, EndOfStream::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaTypeInfoImpl: Sized + IDispatchImpl {
    fn Type();
    fn Subtype();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IMediaTypeInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMediaTypeInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaTypeInfoVtbl {
    pub const fn new<Impl: IMediaTypeInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTypeInfoVtbl {
        unsafe extern "system" fn Type<Impl: IMediaTypeInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Type(::core::mem::transmute_copy(&strtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Subtype<Impl: IMediaTypeInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Subtype(::core::mem::transmute_copy(&strtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTypeInfo>, base.5, Type::<Impl, OFFSET>, Subtype::<Impl, OFFSET>)
    }
}
pub trait IMemAllocatorImpl: Sized {
    fn SetProperties();
    fn GetProperties();
    fn Commit();
    fn Decommit();
    fn GetBuffer();
    fn ReleaseBuffer();
}
impl ::windows::core::RuntimeName for IMemAllocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMemAllocator";
}
impl IMemAllocatorVtbl {
    pub const fn new<Impl: IMemAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMemAllocatorVtbl {
        unsafe extern "system" fn SetProperties<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prequest: *const ALLOCATOR_PROPERTIES, pactual: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProperties(&*(&prequest as *const <ALLOCATOR_PROPERTIES as ::windows::core::Abi>::Abi as *const <ALLOCATOR_PROPERTIES as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pactual)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperties<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProperties(::core::mem::transmute_copy(&pprops)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Commit<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Commit() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Decommit<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Decommit() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBuffer<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut ::windows::core::RawPtr, pstarttime: *const i64, pendtime: *const i64, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBuffer(::core::mem::transmute_copy(&ppbuffer), pstarttime, pendtime, dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IMemAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseBuffer(&*(&pbuffer as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMemAllocator>, base.5, SetProperties::<Impl, OFFSET>, GetProperties::<Impl, OFFSET>, Commit::<Impl, OFFSET>, Decommit::<Impl, OFFSET>, GetBuffer::<Impl, OFFSET>, ReleaseBuffer::<Impl, OFFSET>)
    }
}
pub trait IMemAllocatorCallbackTempImpl: Sized + IMemAllocatorImpl {
    fn SetNotify();
    fn GetFreeCount();
}
impl ::windows::core::RuntimeName for IMemAllocatorCallbackTemp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMemAllocatorCallbackTemp";
}
impl IMemAllocatorCallbackTempVtbl {
    pub const fn new<Impl: IMemAllocatorCallbackTempImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMemAllocatorCallbackTempVtbl {
        unsafe extern "system" fn SetNotify<Impl: IMemAllocatorCallbackTempImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNotify(&*(&pnotify as *const <IMemAllocatorNotifyCallbackTemp as ::windows::core::Abi>::Abi as *const <IMemAllocatorNotifyCallbackTemp as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFreeCount<Impl: IMemAllocatorCallbackTempImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plbuffersfree: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFreeCount(::core::mem::transmute_copy(&plbuffersfree)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMemAllocatorCallbackTemp>, base.5, SetNotify::<Impl, OFFSET>, GetFreeCount::<Impl, OFFSET>)
    }
}
pub trait IMemAllocatorNotifyCallbackTempImpl: Sized {
    fn NotifyRelease();
}
impl ::windows::core::RuntimeName for IMemAllocatorNotifyCallbackTemp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMemAllocatorNotifyCallbackTemp";
}
impl IMemAllocatorNotifyCallbackTempVtbl {
    pub const fn new<Impl: IMemAllocatorNotifyCallbackTempImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMemAllocatorNotifyCallbackTempVtbl {
        unsafe extern "system" fn NotifyRelease<Impl: IMemAllocatorNotifyCallbackTempImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyRelease() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMemAllocatorNotifyCallbackTemp>, base.5, NotifyRelease::<Impl, OFFSET>)
    }
}
pub trait IMemInputPinImpl: Sized {
    fn GetAllocator();
    fn NotifyAllocator();
    fn GetAllocatorRequirements();
    fn Receive();
    fn ReceiveMultiple();
    fn ReceiveCanBlock();
}
impl ::windows::core::RuntimeName for IMemInputPin {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMemInputPin";
}
impl IMemInputPinVtbl {
    pub const fn new<Impl: IMemInputPinImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMemInputPinVtbl {
        unsafe extern "system" fn GetAllocator<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppallocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocator(::core::mem::transmute_copy(&ppallocator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyAllocator<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr, breadonly: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyAllocator(&*(&pallocator as *const <IMemAllocator as ::windows::core::Abi>::Abi as *const <IMemAllocator as ::windows::core::DefaultType>::DefaultType), &*(&breadonly as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllocatorRequirements<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocatorRequirements(::core::mem::transmute_copy(&pprops)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Receive<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Receive(&*(&psample as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReceiveMultiple<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psamples: *const ::windows::core::RawPtr, nsamples: i32, nsamplesprocessed: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReceiveMultiple(&*(&psamples as *const <IMediaSample as ::windows::core::Abi>::Abi as *const <IMediaSample as ::windows::core::DefaultType>::DefaultType), nsamples, ::core::mem::transmute_copy(&nsamplesprocessed)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReceiveCanBlock<Impl: IMemInputPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReceiveCanBlock() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMemInputPin>, base.5, GetAllocator::<Impl, OFFSET>, NotifyAllocator::<Impl, OFFSET>, GetAllocatorRequirements::<Impl, OFFSET>, Receive::<Impl, OFFSET>, ReceiveMultiple::<Impl, OFFSET>, ReceiveCanBlock::<Impl, OFFSET>)
    }
}
pub trait IMemoryDataImpl: Sized {
    fn SetBuffer();
    fn GetInfo();
    fn SetActual();
}
impl ::windows::core::RuntimeName for IMemoryData {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMemoryData";
}
impl IMemoryDataVtbl {
    pub const fn new<Impl: IMemoryDataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMemoryDataVtbl {
        unsafe extern "system" fn SetBuffer<Impl: IMemoryDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbsize: u32, pbdata: *const u8, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBuffer(cbsize, pbdata, dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInfo<Impl: IMemoryDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInfo(::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbactualdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActual<Impl: IMemoryDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbdatavalid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetActual(cbdatavalid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMemoryData>, base.5, SetBuffer::<Impl, OFFSET>, GetInfo::<Impl, OFFSET>, SetActual::<Impl, OFFSET>)
    }
}
pub trait IMixerOCXImpl: Sized {
    fn OnDisplayChange();
    fn GetAspectRatio();
    fn GetVideoSize();
    fn GetStatus();
    fn OnDraw();
    fn SetDrawRegion();
    fn Advise();
    fn UnAdvise();
}
impl ::windows::core::RuntimeName for IMixerOCX {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMixerOCX";
}
impl IMixerOCXVtbl {
    pub const fn new<Impl: IMixerOCXImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMixerOCXVtbl {
        unsafe extern "system" fn OnDisplayChange<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnDisplayChange(ulbitsperpixel, ulscreenwidth, ulscreenheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatio<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatio(::core::mem::transmute_copy(&pdwpictaspectratiox), ::core::mem::transmute_copy(&pdwpictaspectratioy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoSize<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoSize(::core::mem::transmute_copy(&pdwvideowidth), ::core::mem::transmute_copy(&pdwvideoheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstatus: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&pdwstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnDraw<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnDraw(&*(&hdcdraw as *const <super::super::Graphics::Gdi::HDC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HDC as ::windows::core::DefaultType>::DefaultType), &*(&prcdraw as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDrawRegion<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDrawRegion(
                &*(&lppttopleftsc as *const <super::super::Foundation::POINT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::POINT as ::windows::core::DefaultType>::DefaultType),
                &*(&prcdrawcc as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&lprcclip as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Advise<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmdns: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Advise(&*(&pmdns as *const <IMixerOCXNotify as ::windows::core::Abi>::Abi as *const <IMixerOCXNotify as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnAdvise<Impl: IMixerOCXImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnAdvise() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMixerOCX>, base.5, OnDisplayChange::<Impl, OFFSET>, GetAspectRatio::<Impl, OFFSET>, GetVideoSize::<Impl, OFFSET>, GetStatus::<Impl, OFFSET>, OnDraw::<Impl, OFFSET>, SetDrawRegion::<Impl, OFFSET>, Advise::<Impl, OFFSET>, UnAdvise::<Impl, OFFSET>)
    }
}
pub trait IMixerOCXNotifyImpl: Sized {
    fn OnInvalidateRect();
    fn OnStatusChange();
    fn OnDataChange();
}
impl ::windows::core::RuntimeName for IMixerOCXNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMixerOCXNotify";
}
impl IMixerOCXNotifyVtbl {
    pub const fn new<Impl: IMixerOCXNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMixerOCXNotifyVtbl {
        unsafe extern "system" fn OnInvalidateRect<Impl: IMixerOCXNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpcrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnInvalidateRect(&*(&lpcrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnStatusChange<Impl: IMixerOCXNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulstatusflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnStatusChange(ulstatusflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnDataChange<Impl: IMixerOCXNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uldataflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnDataChange(uldataflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMixerOCXNotify>, base.5, OnInvalidateRect::<Impl, OFFSET>, OnStatusChange::<Impl, OFFSET>, OnDataChange::<Impl, OFFSET>)
    }
}
pub trait IMixerPinConfigImpl: Sized {
    fn SetRelativePosition();
    fn GetRelativePosition();
    fn SetZOrder();
    fn GetZOrder();
    fn SetColorKey();
    fn GetColorKey();
    fn SetBlendingParameter();
    fn GetBlendingParameter();
    fn SetAspectRatioMode();
    fn GetAspectRatioMode();
    fn SetStreamTransparent();
    fn GetStreamTransparent();
}
impl ::windows::core::RuntimeName for IMixerPinConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMixerPinConfig";
}
impl IMixerPinConfigVtbl {
    pub const fn new<Impl: IMixerPinConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMixerPinConfigVtbl {
        unsafe extern "system" fn SetRelativePosition<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRelativePosition(dwleft, dwtop, dwright, dwbottom) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRelativePosition<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRelativePosition(pdwleft, pdwtop, pdwright, pdwbottom) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZOrder<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwzorder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetZOrder(dwzorder) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZOrder<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwzorder: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZOrder(pdwzorder) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(&*(&pcolorkey as *const <COLORKEY as ::windows::core::Abi>::Abi as *const <COLORKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColorKey<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColorKey(&*(&pcolorkey as *const <COLORKEY as ::windows::core::Abi>::Abi as *const <COLORKEY as ::windows::core::DefaultType>::DefaultType), pcolor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlendingParameter<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwblendingparameter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlendingParameter(dwblendingparameter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBlendingParameter<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwblendingparameter: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBlendingParameter(pdwblendingparameter) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(amaspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(pamaspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamTransparent<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstreamtransparent: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamTransparent(&*(&bstreamtransparent as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamTransparent<Impl: IMixerPinConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbstreamtransparent: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamTransparent(&*(&pbstreamtransparent as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMixerPinConfig>,
            base.5,
            SetRelativePosition::<Impl, OFFSET>,
            GetRelativePosition::<Impl, OFFSET>,
            SetZOrder::<Impl, OFFSET>,
            GetZOrder::<Impl, OFFSET>,
            SetColorKey::<Impl, OFFSET>,
            GetColorKey::<Impl, OFFSET>,
            SetBlendingParameter::<Impl, OFFSET>,
            GetBlendingParameter::<Impl, OFFSET>,
            SetAspectRatioMode::<Impl, OFFSET>,
            GetAspectRatioMode::<Impl, OFFSET>,
            SetStreamTransparent::<Impl, OFFSET>,
            GetStreamTransparent::<Impl, OFFSET>,
        )
    }
}
pub trait IMixerPinConfig2Impl: Sized + IMixerPinConfigImpl {
    fn SetOverlaySurfaceColorControls();
    fn GetOverlaySurfaceColorControls();
}
impl ::windows::core::RuntimeName for IMixerPinConfig2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMixerPinConfig2";
}
impl IMixerPinConfig2Vtbl {
    pub const fn new<Impl: IMixerPinConfig2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMixerPinConfig2Vtbl {
        unsafe extern "system" fn SetOverlaySurfaceColorControls<Impl: IMixerPinConfig2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOverlaySurfaceColorControls(&*(&pcolorcontrol as *const <super::super::Graphics::DirectDraw::DDCOLORCONTROL as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDCOLORCONTROL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOverlaySurfaceColorControls<Impl: IMixerPinConfig2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOverlaySurfaceColorControls(&*(&pcolorcontrol as *const <super::super::Graphics::DirectDraw::DDCOLORCONTROL as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDCOLORCONTROL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMixerPinConfig2>, base.5, SetOverlaySurfaceColorControls::<Impl, OFFSET>, GetOverlaySurfaceColorControls::<Impl, OFFSET>)
    }
}
pub trait IMpeg2DataImpl: Sized {
    fn GetSection();
    fn GetTable();
    fn GetStreamOfSections();
}
impl ::windows::core::RuntimeName for IMpeg2Data {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMpeg2Data";
}
impl IMpeg2DataVtbl {
    pub const fn new<Impl: IMpeg2DataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMpeg2DataVtbl {
        unsafe extern "system" fn GetSection<Impl: IMpeg2DataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32, ppsectionlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSection(pid, tid, &*(&pfilter as *const <MPEG2_FILTER as ::windows::core::Abi>::Abi as *const <MPEG2_FILTER as ::windows::core::DefaultType>::DefaultType), dwtimeout, ::core::mem::transmute_copy(&ppsectionlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTable<Impl: IMpeg2DataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32, ppsectionlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTable(pid, tid, &*(&pfilter as *const <MPEG2_FILTER as ::windows::core::Abi>::Abi as *const <MPEG2_FILTER as ::windows::core::DefaultType>::DefaultType), dwtimeout, ::core::mem::transmute_copy(&ppsectionlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamOfSections<Impl: IMpeg2DataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE, ppmpegstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamOfSections(pid, tid, &*(&pfilter as *const <MPEG2_FILTER as ::windows::core::Abi>::Abi as *const <MPEG2_FILTER as ::windows::core::DefaultType>::DefaultType), &*(&hdatareadyevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppmpegstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMpeg2Data>, base.5, GetSection::<Impl, OFFSET>, GetTable::<Impl, OFFSET>, GetStreamOfSections::<Impl, OFFSET>)
    }
}
pub trait IMpeg2DemultiplexerImpl: Sized {
    fn CreateOutputPin();
    fn SetOutputPinMediaType();
    fn DeleteOutputPin();
}
impl ::windows::core::RuntimeName for IMpeg2Demultiplexer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMpeg2Demultiplexer";
}
impl IMpeg2DemultiplexerVtbl {
    pub const fn new<Impl: IMpeg2DemultiplexerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMpeg2DemultiplexerVtbl {
        unsafe extern "system" fn CreateOutputPin<Impl: IMpeg2DemultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *mut AM_MEDIA_TYPE, pszpinname: super::super::Foundation::PWSTR, ppipin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateOutputPin(&*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), &*(&pszpinname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppipin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputPinMediaType<Impl: IMpeg2DemultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszpinname: super::super::Foundation::PWSTR, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputPinMediaType(&*(&pszpinname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteOutputPin<Impl: IMpeg2DemultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszpinname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteOutputPin(&*(&pszpinname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMpeg2Demultiplexer>, base.5, CreateOutputPin::<Impl, OFFSET>, SetOutputPinMediaType::<Impl, OFFSET>, DeleteOutputPin::<Impl, OFFSET>)
    }
}
pub trait IMpeg2StreamImpl: Sized {
    fn Initialize();
    fn SupplyDataBuffer();
}
impl ::windows::core::RuntimeName for IMpeg2Stream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMpeg2Stream";
}
impl IMpeg2StreamVtbl {
    pub const fn new<Impl: IMpeg2StreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMpeg2StreamVtbl {
        unsafe extern "system" fn Initialize<Impl: IMpeg2StreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: ::windows::core::RawPtr, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(
                requesttype,
                &*(&pmpeg2data as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType),
                &*(&pcontext as *const <MPEG_CONTEXT as ::windows::core::Abi>::Abi as *const <MPEG_CONTEXT as ::windows::core::DefaultType>::DefaultType),
                pid,
                tid,
                &*(&pfilter as *const <MPEG2_FILTER as ::windows::core::Abi>::Abi as *const <MPEG2_FILTER as ::windows::core::DefaultType>::DefaultType),
                &*(&hdatareadyevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupplyDataBuffer<Impl: IMpeg2StreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstreambuffer: *const MPEG_STREAM_BUFFER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupplyDataBuffer(&*(&pstreambuffer as *const <MPEG_STREAM_BUFFER as ::windows::core::Abi>::Abi as *const <MPEG_STREAM_BUFFER as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMpeg2Stream>, base.5, Initialize::<Impl, OFFSET>, SupplyDataBuffer::<Impl, OFFSET>)
    }
}
pub trait IMpeg2TableFilterImpl: Sized {
    fn AddPID();
    fn AddTable();
    fn AddExtension();
    fn RemovePID();
    fn RemoveTable();
    fn RemoveExtension();
}
impl ::windows::core::RuntimeName for IMpeg2TableFilter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMpeg2TableFilter";
}
impl IMpeg2TableFilterVtbl {
    pub const fn new<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMpeg2TableFilterVtbl {
        unsafe extern "system" fn AddPID<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddPID(p) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTable<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16, t: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddTable(p, t) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddExtension<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16, t: u8, e: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddExtension(p, t, e) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePID<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovePID(p) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTable<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16, t: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveTable(p, t) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveExtension<Impl: IMpeg2TableFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, p: u16, t: u8, e: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveExtension(p, t, e) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMpeg2TableFilter>, base.5, AddPID::<Impl, OFFSET>, AddTable::<Impl, OFFSET>, AddExtension::<Impl, OFFSET>, RemovePID::<Impl, OFFSET>, RemoveTable::<Impl, OFFSET>, RemoveExtension::<Impl, OFFSET>)
    }
}
pub trait IMpegAudioDecoderImpl: Sized {
    fn FrequencyDivider();
    fn SetFrequencyDivider();
    fn DecoderAccuracy();
    fn SetDecoderAccuracy();
    fn Stereo();
    fn SetStereo();
    fn DecoderWordSize();
    fn SetDecoderWordSize();
    fn IntegerDecode();
    fn SetIntegerDecode();
    fn DualMode();
    fn SetDualMode();
    fn AudioFormat();
}
impl ::windows::core::RuntimeName for IMpegAudioDecoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMpegAudioDecoder";
}
impl IMpegAudioDecoderVtbl {
    pub const fn new<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMpegAudioDecoderVtbl {
        unsafe extern "system" fn FrequencyDivider<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdivider: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrequencyDivider(::core::mem::transmute_copy(&pdivider)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyDivider<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, divider: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrequencyDivider(divider) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DecoderAccuracy<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, paccuracy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DecoderAccuracy(::core::mem::transmute_copy(&paccuracy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecoderAccuracy<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, accuracy: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDecoderAccuracy(accuracy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstereo: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stereo(::core::mem::transmute_copy(&pstereo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stereo: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStereo(stereo) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DecoderWordSize<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwordsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DecoderWordSize(::core::mem::transmute_copy(&pwordsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecoderWordSize<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wordsize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDecoderWordSize(wordsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IntegerDecode<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pintdecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IntegerDecode(::core::mem::transmute_copy(&pintdecode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIntegerDecode<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, intdecode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIntegerDecode(intdecode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DualMode<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pintdecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DualMode(pintdecode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDualMode<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, intdecode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDualMode(intdecode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioFormat<Impl: IMpegAudioDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpfmt: *mut MPEG1WAVEFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioFormat(::core::mem::transmute_copy(&lpfmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMpegAudioDecoder>,
            base.5,
            FrequencyDivider::<Impl, OFFSET>,
            SetFrequencyDivider::<Impl, OFFSET>,
            DecoderAccuracy::<Impl, OFFSET>,
            SetDecoderAccuracy::<Impl, OFFSET>,
            Stereo::<Impl, OFFSET>,
            SetStereo::<Impl, OFFSET>,
            DecoderWordSize::<Impl, OFFSET>,
            SetDecoderWordSize::<Impl, OFFSET>,
            IntegerDecode::<Impl, OFFSET>,
            SetIntegerDecode::<Impl, OFFSET>,
            DualMode::<Impl, OFFSET>,
            SetDualMode::<Impl, OFFSET>,
            AudioFormat::<Impl, OFFSET>,
        )
    }
}
pub trait IMultiMediaStreamImpl: Sized {
    fn GetInformation();
    fn GetMediaStream();
    fn EnumMediaStreams();
    fn GetState();
    fn SetState();
    fn GetTime();
    fn GetDuration();
    fn Seek();
    fn GetEndOfStreamEventHandle();
}
impl ::windows::core::RuntimeName for IMultiMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IMultiMediaStream";
}
impl IMultiMediaStreamVtbl {
    pub const fn new<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMultiMediaStreamVtbl {
        unsafe extern "system" fn GetInformation<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInformation(::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&pstreamtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaStream<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idpurpose: *const ::windows::core::GUID, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaStream(&*(&idpurpose as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppmediastream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMediaStreams(index, ::core::mem::transmute_copy(&ppmediastream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrentstate: *mut STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&pcurrentstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetState<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newstate: STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetState(newstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrenttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTime(::core::mem::transmute_copy(&pcurrenttime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration(::core::mem::transmute_copy(&pduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, seektime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Seek(seektime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEndOfStreamEventHandle<Impl: IMultiMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pheos: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEndOfStreamEventHandle(::core::mem::transmute_copy(&pheos)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMultiMediaStream>, base.5, GetInformation::<Impl, OFFSET>, GetMediaStream::<Impl, OFFSET>, EnumMediaStreams::<Impl, OFFSET>, GetState::<Impl, OFFSET>, SetState::<Impl, OFFSET>, GetTime::<Impl, OFFSET>, GetDuration::<Impl, OFFSET>, Seek::<Impl, OFFSET>, GetEndOfStreamEventHandle::<Impl, OFFSET>)
    }
}
pub trait IOverlayImpl: Sized {
    fn GetPalette();
    fn SetPalette();
    fn GetDefaultColorKey();
    fn GetColorKey();
    fn SetColorKey();
    fn GetWindowHandle();
    fn GetClipList();
    fn GetVideoPosition();
    fn Advise();
    fn Unadvise();
}
impl ::windows::core::RuntimeName for IOverlay {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IOverlay";
}
impl IOverlayVtbl {
    pub const fn new<Impl: IOverlayImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IOverlayVtbl {
        unsafe extern "system" fn GetPalette<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPalette(pdwcolors, ::core::mem::transmute_copy(&pppalette)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPalette<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPalette(dwcolors, &*(&ppalette as *const <super::super::Graphics::Gdi::PALETTEENTRY as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::PALETTEENTRY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultColorKey<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultColorKey(::core::mem::transmute_copy(&pcolorkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColorKey<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColorKey(::core::mem::transmute_copy(&pcolorkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(&*(&pcolorkey as *const <COLORKEY as ::windows::core::Abi>::Abi as *const <COLORKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWindowHandle<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWindowHandle(::core::mem::transmute_copy(&phwnd)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClipList<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClipList(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect), ::core::mem::transmute_copy(&pprgndata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPosition(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Advise<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poverlaynotify: ::windows::core::RawPtr, dwinterests: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Advise(&*(&poverlaynotify as *const <IOverlayNotify as ::windows::core::Abi>::Abi as *const <IOverlayNotify as ::windows::core::DefaultType>::DefaultType), dwinterests) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unadvise<Impl: IOverlayImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unadvise() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IOverlay>, base.5, GetPalette::<Impl, OFFSET>, SetPalette::<Impl, OFFSET>, GetDefaultColorKey::<Impl, OFFSET>, GetColorKey::<Impl, OFFSET>, SetColorKey::<Impl, OFFSET>, GetWindowHandle::<Impl, OFFSET>, GetClipList::<Impl, OFFSET>, GetVideoPosition::<Impl, OFFSET>, Advise::<Impl, OFFSET>, Unadvise::<Impl, OFFSET>)
    }
}
pub trait IOverlayNotifyImpl: Sized {
    fn OnPaletteChange();
    fn OnClipChange();
    fn OnColorKeyChange();
    fn OnPositionChange();
}
impl ::windows::core::RuntimeName for IOverlayNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IOverlayNotify";
}
impl IOverlayNotifyVtbl {
    pub const fn new<Impl: IOverlayNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IOverlayNotifyVtbl {
        unsafe extern "system" fn OnPaletteChange<Impl: IOverlayNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnPaletteChange(dwcolors, &*(&ppalette as *const <super::super::Graphics::Gdi::PALETTEENTRY as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::PALETTEENTRY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnClipChange<Impl: IOverlayNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClipChange(
                &*(&psourcerect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&pdestinationrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&prgndata as *const <super::super::Graphics::Gdi::RGNDATA as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::RGNDATA as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnColorKeyChange<Impl: IOverlayNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcolorkey: *const COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnColorKeyChange(&*(&pcolorkey as *const <COLORKEY as ::windows::core::Abi>::Abi as *const <COLORKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnPositionChange<Impl: IOverlayNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnPositionChange(&*(&psourcerect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&pdestinationrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IOverlayNotify>, base.5, OnPaletteChange::<Impl, OFFSET>, OnClipChange::<Impl, OFFSET>, OnColorKeyChange::<Impl, OFFSET>, OnPositionChange::<Impl, OFFSET>)
    }
}
pub trait IOverlayNotify2Impl: Sized + IOverlayNotifyImpl {
    fn OnDisplayChange();
}
impl ::windows::core::RuntimeName for IOverlayNotify2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IOverlayNotify2";
}
impl IOverlayNotify2Vtbl {
    pub const fn new<Impl: IOverlayNotify2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IOverlayNotify2Vtbl {
        unsafe extern "system" fn OnDisplayChange<Impl: IOverlayNotify2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnDisplayChange(&*(&hmonitor as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IOverlayNotify2>, base.5, OnDisplayChange::<Impl, OFFSET>)
    }
}
pub trait IPATImpl: Sized {
    fn Initialize();
    fn GetTransportStreamId();
    fn GetVersionNumber();
    fn GetCountOfRecords();
    fn GetRecordProgramNumber();
    fn GetRecordProgramMapPid();
    fn FindRecordProgramMapPid();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for IPAT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPAT";
}
impl IPATVtbl {
    pub const fn new<Impl: IPATImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPATVtbl {
        unsafe extern "system" fn Initialize<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramNumber<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramNumber(dwindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramMapPid<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramMapPid(dwindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindRecordProgramMapPid<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wprogramnumber: u16, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindRecordProgramMapPid(wprogramnumber, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&pppat)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IPATImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPAT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetTransportStreamId::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordProgramNumber::<Impl, OFFSET>,
            GetRecordProgramMapPid::<Impl, OFFSET>,
            FindRecordProgramMapPid::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
        )
    }
}
pub trait IPBDAAttributesDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetAttributePayload();
}
impl ::windows::core::RuntimeName for IPBDAAttributesDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPBDAAttributesDescriptor";
}
impl IPBDAAttributesDescriptorVtbl {
    pub const fn new<Impl: IPBDAAttributesDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPBDAAttributesDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IPBDAAttributesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IPBDAAttributesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributePayload<Impl: IPBDAAttributesDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbattributebuffer: *mut *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributePayload(::core::mem::transmute_copy(&ppbattributebuffer), ::core::mem::transmute_copy(&pdwattributelength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPBDAAttributesDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetAttributePayload::<Impl, OFFSET>)
    }
}
pub trait IPBDAEntitlementDescriptorImpl: Sized {
    fn GetTag();
    fn GetLength();
    fn GetToken();
}
impl ::windows::core::RuntimeName for IPBDAEntitlementDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPBDAEntitlementDescriptor";
}
impl IPBDAEntitlementDescriptorVtbl {
    pub const fn new<Impl: IPBDAEntitlementDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPBDAEntitlementDescriptorVtbl {
        unsafe extern "system" fn GetTag<Impl: IPBDAEntitlementDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTag(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IPBDAEntitlementDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToken<Impl: IPBDAEntitlementDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbtokenbuffer: *mut *mut u8, pdwtokenlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetToken(::core::mem::transmute_copy(&ppbtokenbuffer), ::core::mem::transmute_copy(&pdwtokenlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPBDAEntitlementDescriptor>, base.5, GetTag::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, GetToken::<Impl, OFFSET>)
    }
}
pub trait IPBDASiParserImpl: Sized {
    fn Initialize();
    fn GetEIT();
    fn GetServices();
}
impl ::windows::core::RuntimeName for IPBDASiParser {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPBDASiParser";
}
impl IPBDASiParserVtbl {
    pub const fn new<Impl: IPBDASiParserImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPBDASiParserVtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDASiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&punk as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEIT<Impl: IPBDASiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsize: u32, pbuffer: *const u8, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEIT(dwsize, pbuffer, ::core::mem::transmute_copy(&ppeit)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServices<Impl: IPBDASiParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsize: u32, pbuffer: *const u8, ppservices: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServices(dwsize, pbuffer, ::core::mem::transmute_copy(&ppservices)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPBDASiParser>, base.5, Initialize::<Impl, OFFSET>, GetEIT::<Impl, OFFSET>, GetServices::<Impl, OFFSET>)
    }
}
pub trait IPBDA_EITImpl: Sized {
    fn Initialize();
    fn GetTableId();
    fn GetVersionNumber();
    fn GetServiceIdx();
    fn GetCountOfRecords();
    fn GetRecordEventId();
    fn GetRecordStartTime();
    fn GetRecordDuration();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
}
impl ::windows::core::RuntimeName for IPBDA_EIT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPBDA_EIT";
}
impl IPBDA_EITVtbl {
    pub const fn new<Impl: IPBDA_EITImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPBDA_EITVtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, size: u32, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(size, pbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableId<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableId(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceIdx<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plwval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceIdx(::core::mem::transmute_copy(&plwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, plwval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(dwrecordindex, ::core::mem::transmute_copy(&plwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(dwrecordindex, ::core::mem::transmute_copy(&pmdtval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(dwrecordindex, ::core::mem::transmute_copy(&pmdval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IPBDA_EITImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPBDA_EIT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetTableId::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetServiceIdx::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordEventId::<Impl, OFFSET>,
            GetRecordStartTime::<Impl, OFFSET>,
            GetRecordDuration::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
        )
    }
}
pub trait IPBDA_ServicesImpl: Sized {
    fn Initialize();
    fn GetCountOfRecords();
    fn GetRecordByIndex();
}
impl ::windows::core::RuntimeName for IPBDA_Services {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPBDA_Services";
}
impl IPBDA_ServicesVtbl {
    pub const fn new<Impl: IPBDA_ServicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPBDA_ServicesVtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDA_ServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, size: u32, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(size, pbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPBDA_ServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordByIndex<Impl: IPBDA_ServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pul64serviceidx: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordByIndex(dwrecordindex, ::core::mem::transmute_copy(&pul64serviceidx)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPBDA_Services>, base.5, Initialize::<Impl, OFFSET>, GetCountOfRecords::<Impl, OFFSET>, GetRecordByIndex::<Impl, OFFSET>)
    }
}
pub trait IPMTImpl: Sized {
    fn Initialize();
    fn GetProgramNumber();
    fn GetVersionNumber();
    fn GetPcrPid();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn GetCountOfRecords();
    fn GetRecordStreamType();
    fn GetRecordElementaryPid();
    fn GetRecordCountOfDescriptors();
    fn GetRecordDescriptorByIndex();
    fn GetRecordDescriptorByTag();
    fn QueryServiceGatewayInfo();
    fn QueryMPEInfo();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for IPMT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPMT";
}
impl IPMTVtbl {
    pub const fn new<Impl: IPMTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPMTVtbl {
        unsafe extern "system" fn Initialize<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramNumber<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProgramNumber(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPcrPid<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPcrPid(::core::mem::transmute_copy(&ppidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStreamType<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordStreamType(dwrecordindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordElementaryPid<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordElementaryPid(dwrecordindex, ::core::mem::transmute_copy(&ppidval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(dwrecordindex, ::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwdescindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(dwrecordindex, dwdescindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByTag(dwrecordindex, btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryServiceGatewayInfo<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdsmcclist: *mut *mut DSMCC_ELEMENT, puicount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryServiceGatewayInfo(::core::mem::transmute_copy(&ppdsmcclist), ::core::mem::transmute_copy(&puicount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryMPEInfo<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmpelist: *mut *mut MPE_ELEMENT, puicount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryMPEInfo(::core::mem::transmute_copy(&ppmpelist), ::core::mem::transmute_copy(&puicount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&pppmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IPMTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPMT>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetProgramNumber::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetPcrPid::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
            GetCountOfRecords::<Impl, OFFSET>,
            GetRecordStreamType::<Impl, OFFSET>,
            GetRecordElementaryPid::<Impl, OFFSET>,
            GetRecordCountOfDescriptors::<Impl, OFFSET>,
            GetRecordDescriptorByIndex::<Impl, OFFSET>,
            GetRecordDescriptorByTag::<Impl, OFFSET>,
            QueryServiceGatewayInfo::<Impl, OFFSET>,
            QueryMPEInfo::<Impl, OFFSET>,
            RegisterForNextTable::<Impl, OFFSET>,
            GetNextTable::<Impl, OFFSET>,
            RegisterForWhenCurrent::<Impl, OFFSET>,
            ConvertNextToCurrent::<Impl, OFFSET>,
        )
    }
}
pub trait IPSITablesImpl: Sized {
    fn GetTable();
}
impl ::windows::core::RuntimeName for IPSITables {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPSITables";
}
impl IPSITablesVtbl {
    pub const fn new<Impl: IPSITablesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPSITablesVtbl {
        unsafe extern "system" fn GetTable<Impl: IPSITablesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtsid: u32, dwtid_pid: u32, dwhashedver: u32, dwpara4: u32, ppiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTable(dwtsid, dwtid_pid, dwhashedver, dwpara4, ::core::mem::transmute_copy(&ppiunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPSITables>, base.5, GetTable::<Impl, OFFSET>)
    }
}
pub trait IPTFilterLicenseRenewalImpl: Sized {
    fn RenewLicenses();
    fn CancelLicenseRenewal();
}
impl ::windows::core::RuntimeName for IPTFilterLicenseRenewal {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPTFilterLicenseRenewal";
}
impl IPTFilterLicenseRenewalVtbl {
    pub const fn new<Impl: IPTFilterLicenseRenewalImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPTFilterLicenseRenewalVtbl {
        unsafe extern "system" fn RenewLicenses<Impl: IPTFilterLicenseRenewalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wszfilename: super::super::Foundation::PWSTR, wszexpiredkid: super::super::Foundation::PWSTR, dwcallersid: u32, bhighpriority: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenewLicenses(
                &*(&wszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&wszexpiredkid as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwcallersid,
                &*(&bhighpriority as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelLicenseRenewal<Impl: IPTFilterLicenseRenewalImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelLicenseRenewal() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPTFilterLicenseRenewal>, base.5, RenewLicenses::<Impl, OFFSET>, CancelLicenseRenewal::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IPersistMediaPropertyBagImpl: Sized + IPersistImpl {
    fn InitNew();
    fn Load();
    fn Save();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IPersistMediaPropertyBag {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPersistMediaPropertyBag";
}
#[cfg(feature = "Win32_System_Com")]
impl IPersistMediaPropertyBagVtbl {
    pub const fn new<Impl: IPersistMediaPropertyBagImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersistMediaPropertyBagVtbl {
        unsafe extern "system" fn InitNew<Impl: IPersistMediaPropertyBagImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitNew() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IPersistMediaPropertyBagImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppropbag: ::windows::core::RawPtr, perrorlog: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&ppropbag as *const <IMediaPropertyBag as ::windows::core::Abi>::Abi as *const <IMediaPropertyBag as ::windows::core::DefaultType>::DefaultType), &*(&perrorlog as *const <super::super::System::Com::IErrorLog as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IErrorLog as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Save<Impl: IPersistMediaPropertyBagImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppropbag: ::windows::core::RawPtr, fcleardirty: super::super::Foundation::BOOL, fsaveallproperties: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Save(
                &*(&ppropbag as *const <IMediaPropertyBag as ::windows::core::Abi>::Abi as *const <IMediaPropertyBag as ::windows::core::DefaultType>::DefaultType),
                &*(&fcleardirty as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&fsaveallproperties as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersistMediaPropertyBag>, base.5, InitNew::<Impl, OFFSET>, Load::<Impl, OFFSET>, Save::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IPersistTuneXmlImpl: Sized + IPersistImpl {
    fn InitNew();
    fn Load();
    fn Save();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IPersistTuneXml {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPersistTuneXml";
}
#[cfg(feature = "Win32_System_Com")]
impl IPersistTuneXmlVtbl {
    pub const fn new<Impl: IPersistTuneXmlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersistTuneXmlVtbl {
        unsafe extern "system" fn InitNew<Impl: IPersistTuneXmlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitNew() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IPersistTuneXmlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varvalue: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&varvalue as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Save<Impl: IPersistTuneXmlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvarfragment: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Save(::core::mem::transmute_copy(&pvarfragment)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersistTuneXml>, base.5, InitNew::<Impl, OFFSET>, Load::<Impl, OFFSET>, Save::<Impl, OFFSET>)
    }
}
pub trait IPersistTuneXmlUtilityImpl: Sized {
    fn Deserialize();
}
impl ::windows::core::RuntimeName for IPersistTuneXmlUtility {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPersistTuneXmlUtility";
}
impl IPersistTuneXmlUtilityVtbl {
    pub const fn new<Impl: IPersistTuneXmlUtilityImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersistTuneXmlUtilityVtbl {
        unsafe extern "system" fn Deserialize<Impl: IPersistTuneXmlUtilityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varvalue: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Deserialize(&*(&varvalue as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersistTuneXmlUtility>, base.5, Deserialize::<Impl, OFFSET>)
    }
}
pub trait IPersistTuneXmlUtility2Impl: Sized + IPersistTuneXmlUtilityImpl {
    fn Serialize();
}
impl ::windows::core::RuntimeName for IPersistTuneXmlUtility2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPersistTuneXmlUtility2";
}
impl IPersistTuneXmlUtility2Vtbl {
    pub const fn new<Impl: IPersistTuneXmlUtility2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersistTuneXmlUtility2Vtbl {
        unsafe extern "system" fn Serialize<Impl: IPersistTuneXmlUtility2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pitunerequest: ::windows::core::RawPtr, pstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Serialize(&*(&pitunerequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pstring)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersistTuneXmlUtility2>, base.5, Serialize::<Impl, OFFSET>)
    }
}
pub trait IPinImpl: Sized {
    fn Connect();
    fn ReceiveConnection();
    fn Disconnect();
    fn ConnectedTo();
    fn ConnectionMediaType();
    fn QueryPinInfo();
    fn QueryDirection();
    fn QueryId();
    fn QueryAccept();
    fn EnumMediaTypes();
    fn QueryInternalConnections();
    fn EndOfStream();
    fn BeginFlush();
    fn EndFlush();
    fn NewSegment();
}
impl ::windows::core::RuntimeName for IPin {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPin";
}
impl IPinVtbl {
    pub const fn new<Impl: IPinImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPinVtbl {
        unsafe extern "system" fn Connect<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, preceivepin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Connect(&*(&preceivepin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReceiveConnection<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pconnector: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReceiveConnection(&*(&pconnector as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Disconnect<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Disconnect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectedTo<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectedTo(::core::mem::transmute_copy(&ppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectionMediaType(::core::mem::transmute_copy(&pmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryPinInfo<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinfo: *mut PIN_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryPinInfo(::core::mem::transmute_copy(&pinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryDirection<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppindir: *mut PIN_DIRECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryDirection(::core::mem::transmute_copy(&ppindir)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryId<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryId(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryAccept<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryAccept(&*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMediaTypes<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMediaTypes(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryInternalConnections<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, appin: *mut ::windows::core::RawPtr, npin: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryInternalConnections(::core::mem::transmute_copy(&appin), npin) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndOfStream<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndOfStream() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginFlush<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginFlush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndFlush<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndFlush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewSegment<Impl: IPinImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tstart: i64, tstop: i64, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewSegment(tstart, tstop, drate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPin>,
            base.5,
            Connect::<Impl, OFFSET>,
            ReceiveConnection::<Impl, OFFSET>,
            Disconnect::<Impl, OFFSET>,
            ConnectedTo::<Impl, OFFSET>,
            ConnectionMediaType::<Impl, OFFSET>,
            QueryPinInfo::<Impl, OFFSET>,
            QueryDirection::<Impl, OFFSET>,
            QueryId::<Impl, OFFSET>,
            QueryAccept::<Impl, OFFSET>,
            EnumMediaTypes::<Impl, OFFSET>,
            QueryInternalConnections::<Impl, OFFSET>,
            EndOfStream::<Impl, OFFSET>,
            BeginFlush::<Impl, OFFSET>,
            EndFlush::<Impl, OFFSET>,
            NewSegment::<Impl, OFFSET>,
        )
    }
}
pub trait IPinConnectionImpl: Sized {
    fn DynamicQueryAccept();
    fn NotifyEndOfStream();
    fn IsEndPin();
    fn DynamicDisconnect();
}
impl ::windows::core::RuntimeName for IPinConnection {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPinConnection";
}
impl IPinConnectionVtbl {
    pub const fn new<Impl: IPinConnectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPinConnectionVtbl {
        unsafe extern "system" fn DynamicQueryAccept<Impl: IPinConnectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicQueryAccept(&*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyEndOfStream<Impl: IPinConnectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnotifyevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyEndOfStream(&*(&hnotifyevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEndPin<Impl: IPinConnectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEndPin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicDisconnect<Impl: IPinConnectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicDisconnect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPinConnection>, base.5, DynamicQueryAccept::<Impl, OFFSET>, NotifyEndOfStream::<Impl, OFFSET>, IsEndPin::<Impl, OFFSET>, DynamicDisconnect::<Impl, OFFSET>)
    }
}
pub trait IPinFlowControlImpl: Sized {
    fn Block();
}
impl ::windows::core::RuntimeName for IPinFlowControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPinFlowControl";
}
impl IPinFlowControlVtbl {
    pub const fn new<Impl: IPinFlowControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPinFlowControlVtbl {
        unsafe extern "system" fn Block<Impl: IPinFlowControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Block(dwblockflags, &*(&hevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPinFlowControl>, base.5, Block::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IPinInfoImpl: Sized + IDispatchImpl {
    fn Pin();
    fn ConnectedTo();
    fn ConnectionMediaType();
    fn FilterInfo();
    fn Name();
    fn Direction();
    fn PinID();
    fn MediaTypes();
    fn Connect();
    fn ConnectDirect();
    fn ConnectWithType();
    fn Disconnect();
    fn Render();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IPinInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IPinInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IPinInfoVtbl {
    pub const fn new<Impl: IPinInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPinInfoVtbl {
        unsafe extern "system" fn Pin<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pin(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectedTo<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectedTo(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectionMediaType(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FilterInfo<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FilterInfo(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Name<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Name(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Direction<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppdirection: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Direction(::core::mem::transmute_copy(&ppdirection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PinID<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strpinid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PinID(::core::mem::transmute_copy(&strpinid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaTypes<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaTypes(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Connect<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Connect(&*(&ppin as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectDirect<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectDirect(&*(&ppin as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectWithType<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectWithType(&*(&ppin as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&pmediatype as *const <super::super::System::Com::IDispatch as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IDispatch as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Disconnect<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Disconnect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Render<Impl: IPinInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Render() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPinInfo>, base.5, Pin::<Impl, OFFSET>, ConnectedTo::<Impl, OFFSET>, ConnectionMediaType::<Impl, OFFSET>, FilterInfo::<Impl, OFFSET>, Name::<Impl, OFFSET>, Direction::<Impl, OFFSET>, PinID::<Impl, OFFSET>, MediaTypes::<Impl, OFFSET>, Connect::<Impl, OFFSET>, ConnectDirect::<Impl, OFFSET>, ConnectWithType::<Impl, OFFSET>, Disconnect::<Impl, OFFSET>, Render::<Impl, OFFSET>)
    }
}
pub trait IQualPropImpl: Sized {
    fn FramesDroppedInRenderer();
    fn FramesDrawn();
    fn AvgFrameRate();
    fn Jitter();
    fn AvgSyncOffset();
    fn DevSyncOffset();
}
impl ::windows::core::RuntimeName for IQualProp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IQualProp";
}
impl IQualPropVtbl {
    pub const fn new<Impl: IQualPropImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IQualPropVtbl {
        unsafe extern "system" fn FramesDroppedInRenderer<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcframes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FramesDroppedInRenderer(::core::mem::transmute_copy(&pcframes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FramesDrawn<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcframesdrawn: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FramesDrawn(::core::mem::transmute_copy(&pcframesdrawn)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AvgFrameRate<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piavgframerate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvgFrameRate(::core::mem::transmute_copy(&piavgframerate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Jitter<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ijitter: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Jitter(::core::mem::transmute_copy(&ijitter)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AvgSyncOffset<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piavg: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AvgSyncOffset(::core::mem::transmute_copy(&piavg)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DevSyncOffset<Impl: IQualPropImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pidev: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DevSyncOffset(::core::mem::transmute_copy(&pidev)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IQualProp>, base.5, FramesDroppedInRenderer::<Impl, OFFSET>, FramesDrawn::<Impl, OFFSET>, AvgFrameRate::<Impl, OFFSET>, Jitter::<Impl, OFFSET>, AvgSyncOffset::<Impl, OFFSET>, DevSyncOffset::<Impl, OFFSET>)
    }
}
pub trait IQualityControlImpl: Sized {
    fn Notify();
    fn SetSink();
}
impl ::windows::core::RuntimeName for IQualityControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IQualityControl";
}
impl IQualityControlVtbl {
    pub const fn new<Impl: IQualityControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IQualityControlVtbl {
        unsafe extern "system" fn Notify<Impl: IQualityControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pself: ::windows::core::RawPtr, q: Quality) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Notify(&*(&pself as *const <IBaseFilter as ::windows::core::Abi>::Abi as *const <IBaseFilter as ::windows::core::DefaultType>::DefaultType), &*(&q as *const <Quality as ::windows::core::Abi>::Abi as *const <Quality as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSink<Impl: IQualityControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piqc: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSink(&*(&piqc as *const <IQualityControl as ::windows::core::Abi>::Abi as *const <IQualityControl as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IQualityControl>, base.5, Notify::<Impl, OFFSET>, SetSink::<Impl, OFFSET>)
    }
}
pub trait IQueueCommandImpl: Sized {
    fn InvokeAtStreamTime();
    fn InvokeAtPresentationTime();
}
impl ::windows::core::RuntimeName for IQueueCommand {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IQueueCommand";
}
impl IQueueCommandVtbl {
    pub const fn new<Impl: IQueueCommandImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IQueueCommandVtbl {
        unsafe extern "system" fn InvokeAtStreamTime<Impl: IQueueCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcmd: *mut ::windows::core::RawPtr, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokeAtStreamTime(
                ::core::mem::transmute_copy(&pcmd),
                time,
                &*(&iid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                dispidmethod,
                wflags,
                cargs,
                &*(&pdispparams as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pvarresult as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&puargerr),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InvokeAtPresentationTime<Impl: IQueueCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcmd: *mut ::windows::core::RawPtr, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokeAtPresentationTime(
                ::core::mem::transmute_copy(&pcmd),
                time,
                &*(&iid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                dispidmethod,
                wflags,
                cargs,
                &*(&pdispparams as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pvarresult as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&puargerr),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IQueueCommand>, base.5, InvokeAtStreamTime::<Impl, OFFSET>, InvokeAtPresentationTime::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IRegFilterInfoImpl: Sized + IDispatchImpl {
    fn Name();
    fn Filter();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IRegFilterInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IRegFilterInfo";
}
#[cfg(feature = "Win32_System_Com")]
impl IRegFilterInfoVtbl {
    pub const fn new<Impl: IRegFilterInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRegFilterInfoVtbl {
        unsafe extern "system" fn Name<Impl: IRegFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Name(::core::mem::transmute_copy(&strname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filter<Impl: IRegFilterInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Filter(::core::mem::transmute_copy(&ppunk)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRegFilterInfo>, base.5, Name::<Impl, OFFSET>, Filter::<Impl, OFFSET>)
    }
}
pub trait IRegisterServiceProviderImpl: Sized {
    fn RegisterService();
}
impl ::windows::core::RuntimeName for IRegisterServiceProvider {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IRegisterServiceProvider";
}
impl IRegisterServiceProviderVtbl {
    pub const fn new<Impl: IRegisterServiceProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRegisterServiceProviderVtbl {
        unsafe extern "system" fn RegisterService<Impl: IRegisterServiceProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidservice: *const ::windows::core::GUID, punkobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterService(&*(&guidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&punkobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRegisterServiceProvider>, base.5, RegisterService::<Impl, OFFSET>)
    }
}
pub trait IRegisterTunerImpl: Sized {
    fn Register();
    fn Unregister();
}
impl ::windows::core::RuntimeName for IRegisterTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IRegisterTuner";
}
impl IRegisterTunerVtbl {
    pub const fn new<Impl: IRegisterTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRegisterTunerVtbl {
        unsafe extern "system" fn Register<Impl: IRegisterTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptuner: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Register(&*(&ptuner as *const <ITuner as ::windows::core::Abi>::Abi as *const <ITuner as ::windows::core::DefaultType>::DefaultType), &*(&pgraph as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unregister<Impl: IRegisterTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unregister() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRegisterTuner>, base.5, Register::<Impl, OFFSET>, Unregister::<Impl, OFFSET>)
    }
}
pub trait IResourceConsumerImpl: Sized {
    fn AcquireResource();
    fn ReleaseResource();
}
impl ::windows::core::RuntimeName for IResourceConsumer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IResourceConsumer";
}
impl IResourceConsumerVtbl {
    pub const fn new<Impl: IResourceConsumerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IResourceConsumerVtbl {
        unsafe extern "system" fn AcquireResource<Impl: IResourceConsumerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcquireResource(idresource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseResource<Impl: IResourceConsumerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseResource(idresource) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IResourceConsumer>, base.5, AcquireResource::<Impl, OFFSET>, ReleaseResource::<Impl, OFFSET>)
    }
}
pub trait IResourceManagerImpl: Sized {
    fn Register();
    fn RegisterGroup();
    fn RequestResource();
    fn NotifyAcquire();
    fn NotifyRelease();
    fn CancelRequest();
    fn SetFocus();
    fn ReleaseFocus();
}
impl ::windows::core::RuntimeName for IResourceManager {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IResourceManager";
}
impl IResourceManagerVtbl {
    pub const fn new<Impl: IResourceManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IResourceManagerVtbl {
        unsafe extern "system" fn Register<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, cresource: i32, pltoken: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Register(&*(&pname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), cresource, ::core::mem::transmute_copy(&pltoken)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterGroup<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, cresource: i32, paltokens: *const i32, pltoken: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterGroup(&*(&pname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), cresource, paltokens, ::core::mem::transmute_copy(&pltoken)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestResource<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32, pfocusobject: *mut ::core::ffi::c_void, pconsumer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestResource(idresource, &*(&pfocusobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&pconsumer as *const <IResourceConsumer as ::windows::core::Abi>::Abi as *const <IResourceConsumer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyAcquire<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr, hr: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyAcquire(idresource, &*(&pconsumer as *const <IResourceConsumer as ::windows::core::Abi>::Abi as *const <IResourceConsumer as ::windows::core::DefaultType>::DefaultType), hr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyRelease<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr, bstillwant: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyRelease(idresource, &*(&pconsumer as *const <IResourceConsumer as ::windows::core::Abi>::Abi as *const <IResourceConsumer as ::windows::core::DefaultType>::DefaultType), &*(&bstillwant as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelRequest<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelRequest(idresource, &*(&pconsumer as *const <IResourceConsumer as ::windows::core::Abi>::Abi as *const <IResourceConsumer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocus<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfocusobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFocus(&*(&pfocusobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseFocus<Impl: IResourceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfocusobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseFocus(&*(&pfocusobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IResourceManager>, base.5, Register::<Impl, OFFSET>, RegisterGroup::<Impl, OFFSET>, RequestResource::<Impl, OFFSET>, NotifyAcquire::<Impl, OFFSET>, NotifyRelease::<Impl, OFFSET>, CancelRequest::<Impl, OFFSET>, SetFocus::<Impl, OFFSET>, ReleaseFocus::<Impl, OFFSET>)
    }
}
pub trait ISBE2CrossbarImpl: Sized {
    fn EnableDefaultMode();
    fn GetInitialProfile();
    fn SetOutputProfile();
    fn EnumStreams();
}
impl ::windows::core::RuntimeName for ISBE2Crossbar {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2Crossbar";
}
impl ISBE2CrossbarVtbl {
    pub const fn new<Impl: ISBE2CrossbarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2CrossbarVtbl {
        unsafe extern "system" fn EnableDefaultMode<Impl: ISBE2CrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, defaultflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableDefaultMode(defaultflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInitialProfile<Impl: ISBE2CrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInitialProfile(::core::mem::transmute_copy(&ppprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputProfile<Impl: ISBE2CrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr, pcoutputpins: *mut u32, ppoutputpins: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputProfile(&*(&pprofile as *const <ISBE2MediaTypeProfile as ::windows::core::Abi>::Abi as *const <ISBE2MediaTypeProfile as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcoutputpins), ::core::mem::transmute_copy(&ppoutputpins)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumStreams<Impl: ISBE2CrossbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppstreams: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumStreams(::core::mem::transmute_copy(&ppstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2Crossbar>, base.5, EnableDefaultMode::<Impl, OFFSET>, GetInitialProfile::<Impl, OFFSET>, SetOutputProfile::<Impl, OFFSET>, EnumStreams::<Impl, OFFSET>)
    }
}
pub trait ISBE2EnumStreamImpl: Sized {
    fn Next();
    fn Skip();
    fn Reset();
    fn Clone();
}
impl ::windows::core::RuntimeName for ISBE2EnumStream {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2EnumStream";
}
impl ISBE2EnumStreamVtbl {
    pub const fn new<Impl: ISBE2EnumStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2EnumStreamVtbl {
        unsafe extern "system" fn Next<Impl: ISBE2EnumStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreamdesc: *mut SBE2_STREAM_DESC, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Next(crequest, &*(&pstreamdesc as *const <SBE2_STREAM_DESC as ::windows::core::Abi>::Abi as *const <SBE2_STREAM_DESC as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcreceived)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Skip<Impl: ISBE2EnumStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Skip(crecords) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: ISBE2EnumStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: ISBE2EnumStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppienumstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2EnumStream>, base.5, Next::<Impl, OFFSET>, Skip::<Impl, OFFSET>, Reset::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait ISBE2FileScanImpl: Sized {
    fn RepairFile();
}
impl ::windows::core::RuntimeName for ISBE2FileScan {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2FileScan";
}
impl ISBE2FileScanVtbl {
    pub const fn new<Impl: ISBE2FileScanImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2FileScanVtbl {
        unsafe extern "system" fn RepairFile<Impl: ISBE2FileScanImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RepairFile(&*(&filename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2FileScan>, base.5, RepairFile::<Impl, OFFSET>)
    }
}
pub trait ISBE2GlobalEventImpl: Sized {
    fn GetEvent();
}
impl ::windows::core::RuntimeName for ISBE2GlobalEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2GlobalEvent";
}
impl ISBE2GlobalEventVtbl {
    pub const fn new<Impl: ISBE2GlobalEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2GlobalEventVtbl {
        unsafe extern "system" fn GetEvent<Impl: ISBE2GlobalEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEvent(&*(&idevt as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), param1, param2, param3, param4, ::core::mem::transmute_copy(&pspanning), pcb, ::core::mem::transmute_copy(&pb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2GlobalEvent>, base.5, GetEvent::<Impl, OFFSET>)
    }
}
pub trait ISBE2GlobalEvent2Impl: Sized + ISBE2GlobalEventImpl {
    fn GetEventEx();
}
impl ::windows::core::RuntimeName for ISBE2GlobalEvent2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2GlobalEvent2";
}
impl ISBE2GlobalEvent2Vtbl {
    pub const fn new<Impl: ISBE2GlobalEvent2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2GlobalEvent2Vtbl {
        unsafe extern "system" fn GetEventEx<Impl: ISBE2GlobalEvent2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8, pstreamtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEventEx(&*(&idevt as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), param1, param2, param3, param4, ::core::mem::transmute_copy(&pspanning), pcb, ::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&pstreamtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2GlobalEvent2>, base.5, GetEventEx::<Impl, OFFSET>)
    }
}
pub trait ISBE2MediaTypeProfileImpl: Sized {
    fn GetStreamCount();
    fn GetStream();
    fn AddStream();
    fn DeleteStream();
}
impl ::windows::core::RuntimeName for ISBE2MediaTypeProfile {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2MediaTypeProfile";
}
impl ISBE2MediaTypeProfileVtbl {
    pub const fn new<Impl: ISBE2MediaTypeProfileImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2MediaTypeProfileVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: ISBE2MediaTypeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: ISBE2MediaTypeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStream(index, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStream<Impl: ISBE2MediaTypeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStream(&*(&pmediatype as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteStream<Impl: ISBE2MediaTypeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteStream(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2MediaTypeProfile>, base.5, GetStreamCount::<Impl, OFFSET>, GetStream::<Impl, OFFSET>, AddStream::<Impl, OFFSET>, DeleteStream::<Impl, OFFSET>)
    }
}
pub trait ISBE2SpanningEventImpl: Sized {
    fn GetEvent();
}
impl ::windows::core::RuntimeName for ISBE2SpanningEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2SpanningEvent";
}
impl ISBE2SpanningEventVtbl {
    pub const fn new<Impl: ISBE2SpanningEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2SpanningEventVtbl {
        unsafe extern "system" fn GetEvent<Impl: ISBE2SpanningEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, streamid: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEvent(&*(&idevt as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), streamid, pcb, ::core::mem::transmute_copy(&pb)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2SpanningEvent>, base.5, GetEvent::<Impl, OFFSET>)
    }
}
pub trait ISBE2StreamMapImpl: Sized {
    fn MapStream();
    fn UnmapStream();
    fn EnumMappedStreams();
}
impl ::windows::core::RuntimeName for ISBE2StreamMap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISBE2StreamMap";
}
impl ISBE2StreamMapVtbl {
    pub const fn new<Impl: ISBE2StreamMapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISBE2StreamMapVtbl {
        unsafe extern "system" fn MapStream<Impl: ISBE2StreamMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stream: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MapStream(stream) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnmapStream<Impl: ISBE2StreamMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stream: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnmapStream(stream) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMappedStreams<Impl: ISBE2StreamMapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppstreams: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumMappedStreams(::core::mem::transmute_copy(&ppstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISBE2StreamMap>, base.5, MapStream::<Impl, OFFSET>, UnmapStream::<Impl, OFFSET>, EnumMappedStreams::<Impl, OFFSET>)
    }
}
pub trait ISCTE_EASImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetSequencyNumber();
    fn GetProtocolVersion();
    fn GetEASEventID();
    fn GetOriginatorCode();
    fn GetEASEventCodeLen();
    fn GetEASEventCode();
    fn GetRawNatureOfActivationTextLen();
    fn GetRawNatureOfActivationText();
    fn GetNatureOfActivationText();
    fn GetTimeRemaining();
    fn GetStartTime();
    fn GetDuration();
    fn GetAlertPriority();
    fn GetDetailsOOBSourceID();
    fn GetDetailsMajor();
    fn GetDetailsMinor();
    fn GetDetailsAudioOOBSourceID();
    fn GetAlertText();
    fn GetRawAlertTextLen();
    fn GetRawAlertText();
    fn GetLocationCount();
    fn GetLocationCodes();
    fn GetExceptionCount();
    fn GetExceptionService();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
}
impl ::windows::core::RuntimeName for ISCTE_EAS {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISCTE_EAS";
}
impl ISCTE_EASVtbl {
    pub const fn new<Impl: ISCTE_EASImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISCTE_EASVtbl {
        unsafe extern "system" fn Initialize<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSequencyNumber<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSequencyNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventID<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEASEventID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorCode<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginatorCode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventCodeLen<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEASEventCodeLen(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventCode<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEASEventCode(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawNatureOfActivationTextLen<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRawNatureOfActivationTextLen(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawNatureOfActivationText<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRawNatureOfActivationText(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNatureOfActivationText<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstris0639code: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNatureOfActivationText(&*(&bstris0639code as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbstrstring)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeRemaining<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeRemaining(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartTime<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartTime(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlertPriority<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlertPriority(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsOOBSourceID<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDetailsOOBSourceID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsMajor<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDetailsMajor(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsMinor<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDetailsMinor(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsAudioOOBSourceID<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDetailsAudioOOBSourceID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlertText<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstris0639code: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlertText(&*(&bstris0639code as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbstrstring)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawAlertTextLen<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRawAlertTextLen(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawAlertText<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRawAlertText(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLocationCount<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLocationCount(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLocationCodes<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbstate: *mut u8, pbcountysubdivision: *mut u8, pwcounty: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLocationCodes(bindex, ::core::mem::transmute_copy(&pbstate), ::core::mem::transmute_copy(&pbcountysubdivision), ::core::mem::transmute_copy(&pwcounty)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExceptionCount<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExceptionCount(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExceptionService<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbibref: *mut u8, pwfirst: *mut u16, pwsecond: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExceptionService(bindex, ::core::mem::transmute_copy(&pbibref), ::core::mem::transmute_copy(&pwfirst), ::core::mem::transmute_copy(&pwsecond)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ISCTE_EASImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISCTE_EAS>,
            base.5,
            Initialize::<Impl, OFFSET>,
            GetVersionNumber::<Impl, OFFSET>,
            GetSequencyNumber::<Impl, OFFSET>,
            GetProtocolVersion::<Impl, OFFSET>,
            GetEASEventID::<Impl, OFFSET>,
            GetOriginatorCode::<Impl, OFFSET>,
            GetEASEventCodeLen::<Impl, OFFSET>,
            GetEASEventCode::<Impl, OFFSET>,
            GetRawNatureOfActivationTextLen::<Impl, OFFSET>,
            GetRawNatureOfActivationText::<Impl, OFFSET>,
            GetNatureOfActivationText::<Impl, OFFSET>,
            GetTimeRemaining::<Impl, OFFSET>,
            GetStartTime::<Impl, OFFSET>,
            GetDuration::<Impl, OFFSET>,
            GetAlertPriority::<Impl, OFFSET>,
            GetDetailsOOBSourceID::<Impl, OFFSET>,
            GetDetailsMajor::<Impl, OFFSET>,
            GetDetailsMinor::<Impl, OFFSET>,
            GetDetailsAudioOOBSourceID::<Impl, OFFSET>,
            GetAlertText::<Impl, OFFSET>,
            GetRawAlertTextLen::<Impl, OFFSET>,
            GetRawAlertText::<Impl, OFFSET>,
            GetLocationCount::<Impl, OFFSET>,
            GetLocationCodes::<Impl, OFFSET>,
            GetExceptionCount::<Impl, OFFSET>,
            GetExceptionService::<Impl, OFFSET>,
            GetCountOfTableDescriptors::<Impl, OFFSET>,
            GetTableDescriptorByIndex::<Impl, OFFSET>,
            GetTableDescriptorByTag::<Impl, OFFSET>,
        )
    }
}
pub trait ISIInbandEPGImpl: Sized {
    fn StartSIEPGScan();
    fn StopSIEPGScan();
    fn IsSIEPGScanRunning();
}
impl ::windows::core::RuntimeName for ISIInbandEPG {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISIInbandEPG";
}
impl ISIInbandEPGVtbl {
    pub const fn new<Impl: ISIInbandEPGImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISIInbandEPGVtbl {
        unsafe extern "system" fn StartSIEPGScan<Impl: ISIInbandEPGImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartSIEPGScan() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopSIEPGScan<Impl: ISIInbandEPGImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopSIEPGScan() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSIEPGScanRunning<Impl: ISIInbandEPGImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brunning: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSIEPGScanRunning(::core::mem::transmute_copy(&brunning)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISIInbandEPG>, base.5, StartSIEPGScan::<Impl, OFFSET>, StopSIEPGScan::<Impl, OFFSET>, IsSIEPGScanRunning::<Impl, OFFSET>)
    }
}
pub trait ISIInbandEPGEventImpl: Sized {
    fn SIObjectEvent();
}
impl ::windows::core::RuntimeName for ISIInbandEPGEvent {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISIInbandEPGEvent";
}
impl ISIInbandEPGEventVtbl {
    pub const fn new<Impl: ISIInbandEPGEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISIInbandEPGEventVtbl {
        unsafe extern "system" fn SIObjectEvent<Impl: ISIInbandEPGEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pidvb_eit: ::windows::core::RawPtr, dwtable_id: u32, dwservice_id: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SIObjectEvent(&*(&pidvb_eit as *const <IDVB_EIT2 as ::windows::core::Abi>::Abi as *const <IDVB_EIT2 as ::windows::core::DefaultType>::DefaultType), dwtable_id, dwservice_id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISIInbandEPGEvent>, base.5, SIObjectEvent::<Impl, OFFSET>)
    }
}
pub trait IScanningTunerImpl: Sized + ITunerImpl {
    fn SeekUp();
    fn SeekDown();
    fn ScanUp();
    fn ScanDown();
    fn AutoProgram();
}
impl ::windows::core::RuntimeName for IScanningTuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IScanningTuner";
}
impl IScanningTunerVtbl {
    pub const fn new<Impl: IScanningTunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScanningTunerVtbl {
        unsafe extern "system" fn SeekUp<Impl: IScanningTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SeekUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SeekDown<Impl: IScanningTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SeekDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScanUp<Impl: IScanningTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, millisecondspause: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScanUp(millisecondspause) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScanDown<Impl: IScanningTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, millisecondspause: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScanDown(millisecondspause) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoProgram<Impl: IScanningTunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoProgram() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScanningTuner>, base.5, SeekUp::<Impl, OFFSET>, SeekDown::<Impl, OFFSET>, ScanUp::<Impl, OFFSET>, ScanDown::<Impl, OFFSET>, AutoProgram::<Impl, OFFSET>)
    }
}
pub trait IScanningTunerExImpl: Sized + IScanningTunerImpl + ITunerImpl {
    fn GetCurrentLocator();
    fn PerformExhaustiveScan();
    fn TerminateCurrentScan();
    fn ResumeCurrentScan();
    fn GetTunerScanningCapability();
    fn GetTunerStatus();
    fn GetCurrentTunerStandardCapability();
    fn SetScanSignalTypeFilter();
}
impl ::windows::core::RuntimeName for IScanningTunerEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IScanningTunerEx";
}
impl IScanningTunerExVtbl {
    pub const fn new<Impl: IScanningTunerExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScanningTunerExVtbl {
        unsafe extern "system" fn GetCurrentLocator<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pilocator: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentLocator(&*(&pilocator as *const <ILocator as ::windows::core::Abi>::Abi as *const <ILocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PerformExhaustiveScan<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwlowerfreq: i32, dwhigherfreq: i32, bfinetune: i16, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PerformExhaustiveScan(dwlowerfreq, dwhigherfreq, bfinetune, hevent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TerminateCurrentScan<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcurrentfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TerminateCurrentScan(::core::mem::transmute_copy(&pcurrentfreq)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResumeCurrentScan<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResumeCurrentScan(hevent) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTunerScanningCapability<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hardwareassistedscanning: *mut i32, numstandardssupported: *mut i32, broadcaststandards: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTunerScanningCapability(::core::mem::transmute_copy(&hardwareassistedscanning), ::core::mem::transmute_copy(&numstandardssupported), ::core::mem::transmute_copy(&broadcaststandards)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTunerStatus<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, secondsleft: *mut i32, currentlocktype: *mut i32, autodetect: *mut i32, currentfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTunerStatus(::core::mem::transmute_copy(&secondsleft), ::core::mem::transmute_copy(&currentlocktype), ::core::mem::transmute_copy(&autodetect), ::core::mem::transmute_copy(&currentfreq)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentTunerStandardCapability<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentbroadcaststandard: ::windows::core::GUID, settlingtime: *mut i32, tvstandardssupported: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentTunerStandardCapability(&*(&currentbroadcaststandard as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&settlingtime), ::core::mem::transmute_copy(&tvstandardssupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScanSignalTypeFilter<Impl: IScanningTunerExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, scanmodulationtypes: i32, analogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetScanSignalTypeFilter(scanmodulationtypes, analogvideostandard) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScanningTunerEx>, base.5, GetCurrentLocator::<Impl, OFFSET>, PerformExhaustiveScan::<Impl, OFFSET>, TerminateCurrentScan::<Impl, OFFSET>, ResumeCurrentScan::<Impl, OFFSET>, GetTunerScanningCapability::<Impl, OFFSET>, GetTunerStatus::<Impl, OFFSET>, GetCurrentTunerStandardCapability::<Impl, OFFSET>, SetScanSignalTypeFilter::<Impl, OFFSET>)
    }
}
pub trait ISectionListImpl: Sized {
    fn Initialize();
    fn InitializeWithRawSections();
    fn CancelPendingRequest();
    fn GetNumberOfSections();
    fn GetSectionData();
    fn GetProgramIdentifier();
    fn GetTableIdentifier();
}
impl ::windows::core::RuntimeName for ISectionList {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISectionList";
}
impl ISectionListVtbl {
    pub const fn new<Impl: ISectionListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISectionListVtbl {
        unsafe extern "system" fn Initialize<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: ::windows::core::RawPtr, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, timeout: u32, hdoneevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(
                requesttype,
                &*(&pmpeg2data as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType),
                &*(&pcontext as *const <MPEG_CONTEXT as ::windows::core::Abi>::Abi as *const <MPEG_CONTEXT as ::windows::core::DefaultType>::DefaultType),
                pid,
                tid,
                &*(&pfilter as *const <MPEG2_FILTER as ::windows::core::Abi>::Abi as *const <MPEG2_FILTER as ::windows::core::DefaultType>::DefaultType),
                timeout,
                &*(&hdoneevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitializeWithRawSections<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmplsections: *const MPEG_PACKET_LIST) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeWithRawSections(&*(&pmplsections as *const <MPEG_PACKET_LIST as ::windows::core::Abi>::Abi as *const <MPEG_PACKET_LIST as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelPendingRequest<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelPendingRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfSections<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcount: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfSections(::core::mem::transmute_copy(&pcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSectionData<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sectionnumber: u16, pdwrawpacketlength: *mut u32, ppsection: *mut *mut SECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSectionData(sectionnumber, ::core::mem::transmute_copy(&pdwrawpacketlength), ::core::mem::transmute_copy(&ppsection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramIdentifier<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppid: *const u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProgramIdentifier(ppid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableIdentifier<Impl: ISectionListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptableid: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableIdentifier(ptableid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISectionList>, base.5, Initialize::<Impl, OFFSET>, InitializeWithRawSections::<Impl, OFFSET>, CancelPendingRequest::<Impl, OFFSET>, GetNumberOfSections::<Impl, OFFSET>, GetSectionData::<Impl, OFFSET>, GetProgramIdentifier::<Impl, OFFSET>, GetTableIdentifier::<Impl, OFFSET>)
    }
}
pub trait ISeekingPassThruImpl: Sized {
    fn Init();
}
impl ::windows::core::RuntimeName for ISeekingPassThru {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISeekingPassThru";
}
impl ISeekingPassThruVtbl {
    pub const fn new<Impl: ISeekingPassThruImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISeekingPassThruVtbl {
        unsafe extern "system" fn Init<Impl: ISeekingPassThruImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bsupportrendering: super::super::Foundation::BOOL, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init(&*(&bsupportrendering as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), &*(&ppin as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISeekingPassThru>, base.5, Init::<Impl, OFFSET>)
    }
}
pub trait ISelectorImpl: Sized {
    fn NumSources();
    fn SourceNodeId();
    fn SetSourceNodeId();
}
impl ::windows::core::RuntimeName for ISelector {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISelector";
}
impl ISelectorVtbl {
    pub const fn new<Impl: ISelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISelectorVtbl {
        unsafe extern "system" fn NumSources<Impl: ISelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumsources: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumSources(::core::mem::transmute_copy(&pdwnumsources)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceNodeId<Impl: ISelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceNodeId(::core::mem::transmute_copy(&pdwpinid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceNodeId<Impl: ISelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceNodeId(dwpinid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISelector>, base.5, NumSources::<Impl, OFFSET>, SourceNodeId::<Impl, OFFSET>, SetSourceNodeId::<Impl, OFFSET>)
    }
}
pub trait IServiceLocationDescriptorImpl: Sized {
    fn GetPCR_PID();
    fn GetNumberOfElements();
    fn GetElementStreamType();
    fn GetElementPID();
    fn GetElementLanguageCode();
}
impl ::windows::core::RuntimeName for IServiceLocationDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IServiceLocationDescriptor";
}
impl IServiceLocationDescriptorVtbl {
    pub const fn new<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IServiceLocationDescriptorVtbl {
        unsafe extern "system" fn GetPCR_PID<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPCR_PID(::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfElements<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfElements(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementStreamType<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetElementStreamType(bindex, ::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementPID<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetElementPID(bindex, ::core::mem::transmute_copy(&pwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementLanguageCode<Impl: IServiceLocationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bindex: u8, langcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetElementLanguageCode(bindex, ::core::mem::transmute_copy(&langcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IServiceLocationDescriptor>, base.5, GetPCR_PID::<Impl, OFFSET>, GetNumberOfElements::<Impl, OFFSET>, GetElementStreamType::<Impl, OFFSET>, GetElementPID::<Impl, OFFSET>, GetElementLanguageCode::<Impl, OFFSET>)
    }
}
pub trait ISpecifyParticularPagesImpl: Sized {
    fn GetPages();
}
impl ::windows::core::RuntimeName for ISpecifyParticularPages {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ISpecifyParticularPages";
}
impl ISpecifyParticularPagesVtbl {
    pub const fn new<Impl: ISpecifyParticularPagesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISpecifyParticularPagesVtbl {
        unsafe extern "system" fn GetPages<Impl: ISpecifyParticularPagesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidwhatpages: *const ::windows::core::GUID, ppages: *mut super::super::System::Ole::CAUUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPages(&*(&guidwhatpages as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppages)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISpecifyParticularPages>, base.5, GetPages::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferConfigureImpl: Sized {
    fn SetDirectory();
    fn GetDirectory();
    fn SetBackingFileCount();
    fn GetBackingFileCount();
    fn SetBackingFileDuration();
    fn GetBackingFileDuration();
}
impl ::windows::core::RuntimeName for IStreamBufferConfigure {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferConfigure";
}
impl IStreamBufferConfigureVtbl {
    pub const fn new<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferConfigureVtbl {
        unsafe extern "system" fn SetDirectory<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszdirectoryname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectory(&*(&pszdirectoryname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDirectory<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszdirectoryname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectory(::core::mem::transmute_copy(&ppszdirectoryname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackingFileCount<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmin: u32, dwmax: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackingFileCount(dwmin, dwmax) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackingFileCount<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmin: *mut u32, pdwmax: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackingFileCount(::core::mem::transmute_copy(&pdwmin), ::core::mem::transmute_copy(&pdwmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackingFileDuration<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackingFileDuration(dwseconds) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackingFileDuration<Impl: IStreamBufferConfigureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackingFileDuration(::core::mem::transmute_copy(&pdwseconds)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferConfigure>, base.5, SetDirectory::<Impl, OFFSET>, GetDirectory::<Impl, OFFSET>, SetBackingFileCount::<Impl, OFFSET>, GetBackingFileCount::<Impl, OFFSET>, SetBackingFileDuration::<Impl, OFFSET>, GetBackingFileDuration::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferConfigure2Impl: Sized + IStreamBufferConfigureImpl {
    fn SetMultiplexedPacketSize();
    fn GetMultiplexedPacketSize();
    fn SetFFTransitionRates();
    fn GetFFTransitionRates();
}
impl ::windows::core::RuntimeName for IStreamBufferConfigure2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferConfigure2";
}
impl IStreamBufferConfigure2Vtbl {
    pub const fn new<Impl: IStreamBufferConfigure2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferConfigure2Vtbl {
        unsafe extern "system" fn SetMultiplexedPacketSize<Impl: IStreamBufferConfigure2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbbytesperpacket: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMultiplexedPacketSize(cbbytesperpacket) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMultiplexedPacketSize<Impl: IStreamBufferConfigure2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbbytesperpacket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMultiplexedPacketSize(::core::mem::transmute_copy(&pcbbytesperpacket)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFFTransitionRates<Impl: IStreamBufferConfigure2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxfullframerate: u32, dwmaxnonskippingrate: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFFTransitionRates(dwmaxfullframerate, dwmaxnonskippingrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFFTransitionRates<Impl: IStreamBufferConfigure2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmaxfullframerate: *mut u32, pdwmaxnonskippingrate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFFTransitionRates(::core::mem::transmute_copy(&pdwmaxfullframerate), ::core::mem::transmute_copy(&pdwmaxnonskippingrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferConfigure2>, base.5, SetMultiplexedPacketSize::<Impl, OFFSET>, GetMultiplexedPacketSize::<Impl, OFFSET>, SetFFTransitionRates::<Impl, OFFSET>, GetFFTransitionRates::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferConfigure3Impl: Sized + IStreamBufferConfigure2Impl + IStreamBufferConfigureImpl {
    fn SetStartRecConfig();
    fn GetStartRecConfig();
    fn SetNamespace();
    fn GetNamespace();
}
impl ::windows::core::RuntimeName for IStreamBufferConfigure3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferConfigure3";
}
impl IStreamBufferConfigure3Vtbl {
    pub const fn new<Impl: IStreamBufferConfigure3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferConfigure3Vtbl {
        unsafe extern "system" fn SetStartRecConfig<Impl: IStreamBufferConfigure3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fstartstopscur: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStartRecConfig(&*(&fstartstopscur as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartRecConfig<Impl: IStreamBufferConfigure3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfstartstopscur: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartRecConfig(::core::mem::transmute_copy(&pfstartstopscur)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNamespace<Impl: IStreamBufferConfigure3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psznamespace: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNamespace(&*(&psznamespace as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNamespace<Impl: IStreamBufferConfigure3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsznamespace: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNamespace(::core::mem::transmute_copy(&ppsznamespace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferConfigure3>, base.5, SetStartRecConfig::<Impl, OFFSET>, GetStartRecConfig::<Impl, OFFSET>, SetNamespace::<Impl, OFFSET>, GetNamespace::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferDataCountersImpl: Sized {
    fn GetData();
    fn ResetData();
}
impl ::windows::core::RuntimeName for IStreamBufferDataCounters {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferDataCounters";
}
impl IStreamBufferDataCountersVtbl {
    pub const fn new<Impl: IStreamBufferDataCountersImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferDataCountersVtbl {
        unsafe extern "system" fn GetData<Impl: IStreamBufferDataCountersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppindata: *mut SBE_PIN_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&ppindata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetData<Impl: IStreamBufferDataCountersImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetData() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferDataCounters>, base.5, GetData::<Impl, OFFSET>, ResetData::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferInitializeImpl: Sized {
    fn SetHKEY();
    fn SetSIDs();
}
impl ::windows::core::RuntimeName for IStreamBufferInitialize {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferInitialize";
}
impl IStreamBufferInitializeVtbl {
    pub const fn new<Impl: IStreamBufferInitializeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferInitializeVtbl {
        unsafe extern "system" fn SetHKEY<Impl: IStreamBufferInitializeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hkeyroot: super::super::System::Registry::HKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHKEY(&*(&hkeyroot as *const <super::super::System::Registry::HKEY as ::windows::core::Abi>::Abi as *const <super::super::System::Registry::HKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSIDs<Impl: IStreamBufferInitializeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, csids: u32, ppsid: *mut super::super::Foundation::PSID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSIDs(csids, &*(&ppsid as *const <super::super::Foundation::PSID as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PSID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferInitialize>, base.5, SetHKEY::<Impl, OFFSET>, SetSIDs::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferMediaSeekingImpl: Sized + IMediaSeekingImpl {}
impl ::windows::core::RuntimeName for IStreamBufferMediaSeeking {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferMediaSeeking";
}
impl IStreamBufferMediaSeekingVtbl {
    pub const fn new<Impl: IStreamBufferMediaSeekingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferMediaSeekingVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferMediaSeeking>, base.5)
    }
}
pub trait IStreamBufferMediaSeeking2Impl: Sized + IStreamBufferMediaSeekingImpl + IMediaSeekingImpl {
    fn SetRateEx();
}
impl ::windows::core::RuntimeName for IStreamBufferMediaSeeking2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferMediaSeeking2";
}
impl IStreamBufferMediaSeeking2Vtbl {
    pub const fn new<Impl: IStreamBufferMediaSeeking2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferMediaSeeking2Vtbl {
        unsafe extern "system" fn SetRateEx<Impl: IStreamBufferMediaSeeking2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, drate: f64, dwframespersec: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRateEx(drate, dwframespersec) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferMediaSeeking2>, base.5, SetRateEx::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferRecCompImpl: Sized {
    fn Initialize();
    fn Append();
    fn AppendEx();
    fn GetCurrentLength();
    fn Close();
    fn Cancel();
}
impl ::windows::core::RuntimeName for IStreamBufferRecComp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferRecComp";
}
impl IStreamBufferRecCompVtbl {
    pub const fn new<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferRecCompVtbl {
        unsafe extern "system" fn Initialize<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psztargetfilename: super::super::Foundation::PWSTR, pszsbrecprofileref: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psztargetfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&pszsbrecprofileref as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Append<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszsbrecording: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Append(&*(&pszsbrecording as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AppendEx<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszsbrecording: super::super::Foundation::PWSTR, rtstart: i64, rtstop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AppendEx(&*(&pszsbrecording as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), rtstart, rtstop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentLength<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentLength(::core::mem::transmute_copy(&pcseconds)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IStreamBufferRecCompImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferRecComp>, base.5, Initialize::<Impl, OFFSET>, Append::<Impl, OFFSET>, AppendEx::<Impl, OFFSET>, GetCurrentLength::<Impl, OFFSET>, Close::<Impl, OFFSET>, Cancel::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferRecordControlImpl: Sized {
    fn Start();
    fn Stop();
    fn GetRecordingStatus();
}
impl ::windows::core::RuntimeName for IStreamBufferRecordControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferRecordControl";
}
impl IStreamBufferRecordControlVtbl {
    pub const fn new<Impl: IStreamBufferRecordControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferRecordControlVtbl {
        unsafe extern "system" fn Start<Impl: IStreamBufferRecordControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(prtstart) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IStreamBufferRecordControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rtstop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop(rtstop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordingStatus<Impl: IStreamBufferRecordControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phresult: *mut ::windows::core::HRESULT, pbstarted: *mut super::super::Foundation::BOOL, pbstopped: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordingStatus(::core::mem::transmute_copy(&phresult), ::core::mem::transmute_copy(&pbstarted), ::core::mem::transmute_copy(&pbstopped)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferRecordControl>, base.5, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>, GetRecordingStatus::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferRecordingAttributeImpl: Sized {
    fn SetAttribute();
    fn GetAttributeCount();
    fn GetAttributeByName();
    fn GetAttributeByIndex();
    fn EnumAttributes();
}
impl ::windows::core::RuntimeName for IStreamBufferRecordingAttribute {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferRecordingAttribute";
}
impl IStreamBufferRecordingAttributeVtbl {
    pub const fn new<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferRecordingAttributeVtbl {
        unsafe extern "system" fn SetAttribute<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulreserved: u32, pszattributename: super::super::Foundation::PWSTR, streambufferattributetype: STREAMBUFFER_ATTR_DATATYPE, pbattribute: *const u8, cbattributelength: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAttribute(ulreserved, &*(&pszattributename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), streambufferattributetype, pbattribute, cbattributelength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributeCount<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulreserved: u32, pcattributes: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributeCount(ulreserved, ::core::mem::transmute_copy(&pcattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributeByName<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszattributename: super::super::Foundation::PWSTR, pulreserved: *const u32, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributeByName(&*(&pszattributename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), pulreserved, ::core::mem::transmute_copy(&pstreambufferattributetype), ::core::mem::transmute_copy(&pbattribute), pcblength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributeByIndex<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windex: u16, pulreserved: *const u32, pszattributename: super::super::Foundation::PWSTR, pcchnamelength: *mut u16, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributeByIndex(windex, pulreserved, ::core::mem::transmute_copy(&pszattributename), pcchnamelength, ::core::mem::transmute_copy(&pstreambufferattributetype), ::core::mem::transmute_copy(&pbattribute), pcblength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumAttributes<Impl: IStreamBufferRecordingAttributeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppienumstreambufferattrib: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumAttributes(::core::mem::transmute_copy(&ppienumstreambufferattrib)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferRecordingAttribute>, base.5, SetAttribute::<Impl, OFFSET>, GetAttributeCount::<Impl, OFFSET>, GetAttributeByName::<Impl, OFFSET>, GetAttributeByIndex::<Impl, OFFSET>, EnumAttributes::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferSinkImpl: Sized {
    fn LockProfile();
    fn CreateRecorder();
    fn IsProfileLocked();
}
impl ::windows::core::RuntimeName for IStreamBufferSink {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferSink";
}
impl IStreamBufferSinkVtbl {
    pub const fn new<Impl: IStreamBufferSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferSinkVtbl {
        unsafe extern "system" fn LockProfile<Impl: IStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszstreambufferfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockProfile(&*(&pszstreambufferfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateRecorder<Impl: IStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, dwrecordtype: u32, precordingiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateRecorder(&*(&pszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwrecordtype, ::core::mem::transmute_copy(&precordingiunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProfileLocked<Impl: IStreamBufferSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsProfileLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferSink>, base.5, LockProfile::<Impl, OFFSET>, CreateRecorder::<Impl, OFFSET>, IsProfileLocked::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferSink2Impl: Sized + IStreamBufferSinkImpl {
    fn UnlockProfile();
}
impl ::windows::core::RuntimeName for IStreamBufferSink2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferSink2";
}
impl IStreamBufferSink2Vtbl {
    pub const fn new<Impl: IStreamBufferSink2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferSink2Vtbl {
        unsafe extern "system" fn UnlockProfile<Impl: IStreamBufferSink2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockProfile() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferSink2>, base.5, UnlockProfile::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferSink3Impl: Sized + IStreamBufferSink2Impl + IStreamBufferSinkImpl {
    fn SetAvailableFilter();
}
impl ::windows::core::RuntimeName for IStreamBufferSink3 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferSink3";
}
impl IStreamBufferSink3Vtbl {
    pub const fn new<Impl: IStreamBufferSink3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferSink3Vtbl {
        unsafe extern "system" fn SetAvailableFilter<Impl: IStreamBufferSink3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prtmin: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAvailableFilter(prtmin) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferSink3>, base.5, SetAvailableFilter::<Impl, OFFSET>)
    }
}
pub trait IStreamBufferSourceImpl: Sized {
    fn SetStreamSink();
}
impl ::windows::core::RuntimeName for IStreamBufferSource {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBufferSource";
}
impl IStreamBufferSourceVtbl {
    pub const fn new<Impl: IStreamBufferSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBufferSourceVtbl {
        unsafe extern "system" fn SetStreamSink<Impl: IStreamBufferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pistreambuffersink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSink(&*(&pistreambuffersink as *const <IStreamBufferSink as ::windows::core::Abi>::Abi as *const <IStreamBufferSink as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBufferSource>, base.5, SetStreamSink::<Impl, OFFSET>)
    }
}
pub trait IStreamBuilderImpl: Sized {
    fn Render();
    fn Backout();
}
impl ::windows::core::RuntimeName for IStreamBuilder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamBuilder";
}
impl IStreamBuilderVtbl {
    pub const fn new<Impl: IStreamBuilderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamBuilderVtbl {
        unsafe extern "system" fn Render<Impl: IStreamBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Render(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pgraph as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Backout<Impl: IStreamBuilderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Backout(&*(&ppinout as *const <IPin as ::windows::core::Abi>::Abi as *const <IPin as ::windows::core::DefaultType>::DefaultType), &*(&pgraph as *const <IGraphBuilder as ::windows::core::Abi>::Abi as *const <IGraphBuilder as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamBuilder>, base.5, Render::<Impl, OFFSET>, Backout::<Impl, OFFSET>)
    }
}
pub trait IStreamSampleImpl: Sized {
    fn GetMediaStream();
    fn GetSampleTimes();
    fn SetSampleTimes();
    fn Update();
    fn CompletionStatus();
}
impl ::windows::core::RuntimeName for IStreamSample {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IStreamSample";
}
impl IStreamSampleVtbl {
    pub const fn new<Impl: IStreamSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStreamSampleVtbl {
        unsafe extern "system" fn GetMediaStream<Impl: IStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediastream: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaStream(&*(&ppmediastream as *const <IMediaStream as ::windows::core::Abi>::Abi as *const <IMediaStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSampleTimes<Impl: IStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSampleTimes(::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&pendtime), ::core::mem::transmute_copy(&pcurrenttime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleTimes<Impl: IStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleTimes(pstarttime, pendtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Update<Impl: IStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: ::windows::core::RawPtr, dwapcdata: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Update(dwflags, &*(&hevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), &*(&pfnapc as *const <super::super::Foundation::PAPCFUNC as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PAPCFUNC as ::windows::core::DefaultType>::DefaultType), dwapcdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompletionStatus<Impl: IStreamSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompletionStatus(dwflags, dwmilliseconds) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStreamSample>, base.5, GetMediaStream::<Impl, OFFSET>, GetSampleTimes::<Impl, OFFSET>, SetSampleTimes::<Impl, OFFSET>, Update::<Impl, OFFSET>, CompletionStatus::<Impl, OFFSET>)
    }
}
pub trait ITSDTImpl: Sized {
    fn Initialize();
    fn GetVersionNumber();
    fn GetCountOfTableDescriptors();
    fn GetTableDescriptorByIndex();
    fn GetTableDescriptorByTag();
    fn RegisterForNextTable();
    fn GetNextTable();
    fn RegisterForWhenCurrent();
    fn ConvertNextToCurrent();
}
impl ::windows::core::RuntimeName for ITSDT {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITSDT";
}
impl ITSDTVtbl {
    pub const fn new<Impl: ITSDTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITSDTVtbl {
        unsafe extern "system" fn Initialize<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&psectionlist as *const <ISectionList as ::windows::core::Abi>::Abi as *const <ISectionList as ::windows::core::DefaultType>::DefaultType), &*(&pmpegdata as *const <IMpeg2Data as ::windows::core::Abi>::Abi as *const <IMpeg2Data as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber(::core::mem::transmute_copy(&pbval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByTag(btag, pdwcookie, ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForNextTable(&*(&hnexttableavailable as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextTable<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&pptsdt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForWhenCurrent(&*(&hnexttableiscurrent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: ITSDTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertNextToCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITSDT>, base.5, Initialize::<Impl, OFFSET>, GetVersionNumber::<Impl, OFFSET>, GetCountOfTableDescriptors::<Impl, OFFSET>, GetTableDescriptorByIndex::<Impl, OFFSET>, GetTableDescriptorByTag::<Impl, OFFSET>, RegisterForNextTable::<Impl, OFFSET>, GetNextTable::<Impl, OFFSET>, RegisterForWhenCurrent::<Impl, OFFSET>, ConvertNextToCurrent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuneRequestImpl: Sized + IDispatchImpl {
    fn TuningSpace();
    fn Components();
    fn Clone();
    fn Locator();
    fn SetLocator();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ITuneRequest {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuneRequest";
}
#[cfg(feature = "Win32_System_Com")]
impl ITuneRequestVtbl {
    pub const fn new<Impl: ITuneRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuneRequestVtbl {
        unsafe extern "system" fn TuningSpace<Impl: ITuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpace(::core::mem::transmute_copy(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Components<Impl: ITuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, components: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Components(::core::mem::transmute_copy(&components)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: ITuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newtunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newtunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Locator<Impl: ITuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Locator(::core::mem::transmute_copy(&locator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocator<Impl: ITuneRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLocator(&*(&locator as *const <ILocator as ::windows::core::Abi>::Abi as *const <ILocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuneRequest>, base.5, TuningSpace::<Impl, OFFSET>, Components::<Impl, OFFSET>, Clone::<Impl, OFFSET>, Locator::<Impl, OFFSET>, SetLocator::<Impl, OFFSET>)
    }
}
pub trait ITuneRequestInfoImpl: Sized {
    fn GetLocatorData();
    fn GetComponentData();
    fn CreateComponentList();
    fn GetNextProgram();
    fn GetPreviousProgram();
    fn GetNextLocator();
    fn GetPreviousLocator();
}
impl ::windows::core::RuntimeName for ITuneRequestInfo {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuneRequestInfo";
}
impl ITuneRequestInfoVtbl {
    pub const fn new<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuneRequestInfoVtbl {
        unsafe extern "system" fn GetLocatorData<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, request: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLocatorData(&*(&request as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentData<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetComponentData(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateComponentList<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateComponentList(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextProgram<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextProgram(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreviousProgram<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreviousProgram(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextLocator<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextLocator(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreviousLocator<Impl: ITuneRequestInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreviousLocator(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuneRequestInfo>, base.5, GetLocatorData::<Impl, OFFSET>, GetComponentData::<Impl, OFFSET>, CreateComponentList::<Impl, OFFSET>, GetNextProgram::<Impl, OFFSET>, GetPreviousProgram::<Impl, OFFSET>, GetNextLocator::<Impl, OFFSET>, GetPreviousLocator::<Impl, OFFSET>)
    }
}
pub trait ITuneRequestInfoExImpl: Sized + ITuneRequestInfoImpl {
    fn CreateComponentListEx();
}
impl ::windows::core::RuntimeName for ITuneRequestInfoEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuneRequestInfoEx";
}
impl ITuneRequestInfoExVtbl {
    pub const fn new<Impl: ITuneRequestInfoExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuneRequestInfoExVtbl {
        unsafe extern "system" fn CreateComponentListEx<Impl: ITuneRequestInfoExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, ppcurpmt: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateComponentListEx(&*(&currentrequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppcurpmt)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuneRequestInfoEx>, base.5, CreateComponentListEx::<Impl, OFFSET>)
    }
}
pub trait ITunerImpl: Sized {
    fn TuningSpace();
    fn SetTuningSpace();
    fn EnumTuningSpaces();
    fn TuneRequest();
    fn SetTuneRequest();
    fn Validate();
    fn PreferredComponentTypes();
    fn SetPreferredComponentTypes();
    fn SignalStrength();
    fn TriggerSignalEvents();
}
impl ::windows::core::RuntimeName for ITuner {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuner";
}
impl ITunerVtbl {
    pub const fn new<Impl: ITunerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITunerVtbl {
        unsafe extern "system" fn TuningSpace<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpace(::core::mem::transmute_copy(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTuningSpace(&*(&tuningspace as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuneRequest<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuneRequest(::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuneRequest<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tunerequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTuneRequest(&*(&tunerequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Validate<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tunerequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Validate(&*(&tunerequest as *const <ITuneRequest as ::windows::core::Abi>::Abi as *const <ITuneRequest as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreferredComponentTypes<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, componenttypes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreferredComponentTypes(::core::mem::transmute_copy(&componenttypes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferredComponentTypes<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, componenttypes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreferredComponentTypes(&*(&componenttypes as *const <IComponentTypes as ::windows::core::Abi>::Abi as *const <IComponentTypes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalStrength<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalStrength(::core::mem::transmute_copy(&strength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TriggerSignalEvents<Impl: ITunerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, interval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TriggerSignalEvents(interval) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuner>, base.5, TuningSpace::<Impl, OFFSET>, SetTuningSpace::<Impl, OFFSET>, EnumTuningSpaces::<Impl, OFFSET>, TuneRequest::<Impl, OFFSET>, SetTuneRequest::<Impl, OFFSET>, Validate::<Impl, OFFSET>, PreferredComponentTypes::<Impl, OFFSET>, SetPreferredComponentTypes::<Impl, OFFSET>, SignalStrength::<Impl, OFFSET>, TriggerSignalEvents::<Impl, OFFSET>)
    }
}
pub trait ITunerCapImpl: Sized {
    fn SupportedNetworkTypes();
    fn SupportedVideoFormats();
    fn AuxInputCount();
}
impl ::windows::core::RuntimeName for ITunerCap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITunerCap";
}
impl ITunerCapVtbl {
    pub const fn new<Impl: ITunerCapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITunerCapVtbl {
        unsafe extern "system" fn SupportedNetworkTypes<Impl: ITunerCapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulcnetworktypesmax: u32, pulcnetworktypes: *mut u32, pguidnetworktypes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportedNetworkTypes(ulcnetworktypesmax, ::core::mem::transmute_copy(&pulcnetworktypes), &*(&pguidnetworktypes as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportedVideoFormats<Impl: ITunerCapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportedVideoFormats(::core::mem::transmute_copy(&pulamtunermodetype), ::core::mem::transmute_copy(&pulanalogvideostandard)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AuxInputCount<Impl: ITunerCapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AuxInputCount(pulcompositecount, pulsvideocount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITunerCap>, base.5, SupportedNetworkTypes::<Impl, OFFSET>, SupportedVideoFormats::<Impl, OFFSET>, AuxInputCount::<Impl, OFFSET>)
    }
}
pub trait ITunerCapExImpl: Sized {
    fn Has608_708Caption();
}
impl ::windows::core::RuntimeName for ITunerCapEx {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITunerCapEx";
}
impl ITunerCapExVtbl {
    pub const fn new<Impl: ITunerCapExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITunerCapExVtbl {
        unsafe extern "system" fn Has608_708Caption<Impl: ITunerCapExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbhascaption: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Has608_708Caption(::core::mem::transmute_copy(&pbhascaption)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITunerCapEx>, base.5, Has608_708Caption::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuningSpaceImpl: Sized + IDispatchImpl {
    fn UniqueName();
    fn SetUniqueName();
    fn FriendlyName();
    fn SetFriendlyName();
    fn CLSID();
    fn NetworkType();
    fn SetNetworkType();
    fn _NetworkType();
    fn Set_NetworkType();
    fn CreateTuneRequest();
    fn EnumCategoryGUIDs();
    fn EnumDeviceMonikers();
    fn DefaultPreferredComponentTypes();
    fn SetDefaultPreferredComponentTypes();
    fn FrequencyMapping();
    fn SetFrequencyMapping();
    fn DefaultLocator();
    fn SetDefaultLocator();
    fn Clone();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ITuningSpace {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuningSpace";
}
#[cfg(feature = "Win32_System_Com")]
impl ITuningSpaceVtbl {
    pub const fn new<Impl: ITuningSpaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuningSpaceVtbl {
        unsafe extern "system" fn UniqueName<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UniqueName(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUniqueName<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUniqueName(&*(&name as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FriendlyName<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FriendlyName(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFriendlyName<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFriendlyName(&*(&name as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CLSID<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, spaceclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CLSID(::core::mem::transmute_copy(&spaceclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NetworkType<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networktypeguid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NetworkType(::core::mem::transmute_copy(&networktypeguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNetworkType<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networktypeguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNetworkType(&*(&networktypeguid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NetworkType<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networktypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NetworkType(::core::mem::transmute_copy(&networktypeguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_NetworkType<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set_NetworkType(&*(&networktypeguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTuneRequest<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequest(::core::mem::transmute_copy(&tunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumCategoryGUIDs<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumCategoryGUIDs(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumDeviceMonikers<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumDeviceMonikers(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPreferredComponentTypes<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, componenttypes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultPreferredComponentTypes(::core::mem::transmute_copy(&componenttypes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPreferredComponentTypes<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newcomponenttypes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultPreferredComponentTypes(&*(&newcomponenttypes as *const <IComponentTypes as ::windows::core::Abi>::Abi as *const <IComponentTypes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FrequencyMapping<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmapping: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrequencyMapping(::core::mem::transmute_copy(&pmapping)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyMapping<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mapping: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrequencyMapping(&*(&mapping as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultLocator<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locatorval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultLocator(::core::mem::transmute_copy(&locatorval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultLocator<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, locatorval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultLocator(&*(&locatorval as *const <ILocator as ::windows::core::Abi>::Abi as *const <ILocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: ITuningSpaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newts: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&newts)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITuningSpace>,
            base.5,
            UniqueName::<Impl, OFFSET>,
            SetUniqueName::<Impl, OFFSET>,
            FriendlyName::<Impl, OFFSET>,
            SetFriendlyName::<Impl, OFFSET>,
            CLSID::<Impl, OFFSET>,
            NetworkType::<Impl, OFFSET>,
            SetNetworkType::<Impl, OFFSET>,
            _NetworkType::<Impl, OFFSET>,
            Set_NetworkType::<Impl, OFFSET>,
            CreateTuneRequest::<Impl, OFFSET>,
            EnumCategoryGUIDs::<Impl, OFFSET>,
            EnumDeviceMonikers::<Impl, OFFSET>,
            DefaultPreferredComponentTypes::<Impl, OFFSET>,
            SetDefaultPreferredComponentTypes::<Impl, OFFSET>,
            FrequencyMapping::<Impl, OFFSET>,
            SetFrequencyMapping::<Impl, OFFSET>,
            DefaultLocator::<Impl, OFFSET>,
            SetDefaultLocator::<Impl, OFFSET>,
            Clone::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuningSpaceContainerImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn SetItem();
    fn TuningSpacesForCLSID();
    fn _TuningSpacesForCLSID2();
    fn TuningSpacesForName();
    fn FindID();
    fn Add();
    fn EnumTuningSpaces();
    fn Remove();
    fn MaxCount();
    fn SetMaxCount();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ITuningSpaceContainer {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuningSpaceContainer";
}
#[cfg(feature = "Win32_System_Com")]
impl ITuningSpaceContainerVtbl {
    pub const fn new<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuningSpaceContainerVtbl {
        unsafe extern "system" fn Count<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&newenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&varindex as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetItem(&*(&varindex as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), &*(&tuningspace as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuningSpacesForCLSID<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, spaceclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpacesForCLSID(&*(&spaceclsid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newcoll)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _TuningSpacesForCLSID2<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, spaceclsid: *const ::windows::core::GUID, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._TuningSpacesForCLSID2(&*(&spaceclsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newcoll)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuningSpacesForName<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TuningSpacesForName(&*(&name as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newcoll)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindID<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindID(&*(&tuningspace as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Add(&*(&tuningspace as *const <ITuningSpace as ::windows::core::Abi>::Abi as *const <ITuningSpace as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&newindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces(::core::mem::transmute_copy(&ppenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(&*(&index as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxCount<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxCount(::core::mem::transmute_copy(&maxcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxCount<Impl: ITuningSpaceContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, maxcount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMaxCount(maxcount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuningSpaceContainer>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, SetItem::<Impl, OFFSET>, TuningSpacesForCLSID::<Impl, OFFSET>, _TuningSpacesForCLSID2::<Impl, OFFSET>, TuningSpacesForName::<Impl, OFFSET>, FindID::<Impl, OFFSET>, Add::<Impl, OFFSET>, EnumTuningSpaces::<Impl, OFFSET>, Remove::<Impl, OFFSET>, MaxCount::<Impl, OFFSET>, SetMaxCount::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuningSpacesImpl: Sized + IDispatchImpl {
    fn Count();
    fn _NewEnum();
    fn Item();
    fn EnumTuningSpaces();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for ITuningSpaces {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.ITuningSpaces";
}
#[cfg(feature = "Win32_System_Com")]
impl ITuningSpacesVtbl {
    pub const fn new<Impl: ITuningSpacesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITuningSpacesVtbl {
        unsafe extern "system" fn Count<Impl: ITuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Count(::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: ITuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this)._NewEnum(::core::mem::transmute_copy(&newenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ITuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item(&*(&varindex as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITuningSpacesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces(::core::mem::transmute_copy(&newenum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITuningSpaces>, base.5, Count::<Impl, OFFSET>, _NewEnum::<Impl, OFFSET>, Item::<Impl, OFFSET>, EnumTuningSpaces::<Impl, OFFSET>)
    }
}
pub trait IVMRAspectRatioControlImpl: Sized {
    fn GetAspectRatioMode();
    fn SetAspectRatioMode();
}
impl ::windows::core::RuntimeName for IVMRAspectRatioControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRAspectRatioControl";
}
impl IVMRAspectRatioControlVtbl {
    pub const fn new<Impl: IVMRAspectRatioControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRAspectRatioControlVtbl {
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRAspectRatioControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwarmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(lpdwarmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRAspectRatioControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwarmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(dwarmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRAspectRatioControl>, base.5, GetAspectRatioMode::<Impl, OFFSET>, SetAspectRatioMode::<Impl, OFFSET>)
    }
}
pub trait IVMRAspectRatioControl9Impl: Sized {
    fn GetAspectRatioMode();
    fn SetAspectRatioMode();
}
impl ::windows::core::RuntimeName for IVMRAspectRatioControl9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRAspectRatioControl9";
}
impl IVMRAspectRatioControl9Vtbl {
    pub const fn new<Impl: IVMRAspectRatioControl9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRAspectRatioControl9Vtbl {
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRAspectRatioControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwarmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(::core::mem::transmute_copy(&lpdwarmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRAspectRatioControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwarmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(dwarmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRAspectRatioControl9>, base.5, GetAspectRatioMode::<Impl, OFFSET>, SetAspectRatioMode::<Impl, OFFSET>)
    }
}
pub trait IVMRDeinterlaceControlImpl: Sized {
    fn GetNumberOfDeinterlaceModes();
    fn GetDeinterlaceModeCaps();
    fn GetDeinterlaceMode();
    fn SetDeinterlaceMode();
    fn GetDeinterlacePrefs();
    fn SetDeinterlacePrefs();
    fn GetActualDeinterlaceMode();
}
impl ::windows::core::RuntimeName for IVMRDeinterlaceControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRDeinterlaceControl";
}
impl IVMRDeinterlaceControlVtbl {
    pub const fn new<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRDeinterlaceControlVtbl {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpvideodescription: *mut VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfDeinterlaceModes(&*(&lpvideodescription as *const <VMRVideoDesc as ::windows::core::Abi>::Abi as *const <VMRVideoDesc as ::windows::core::DefaultType>::DefaultType), lpdwnumdeinterlacemodes, &*(&lpdeinterlacemodes as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdeinterlacemode: *mut ::windows::core::GUID, lpvideodescription: *mut VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceModeCaps(&*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&lpvideodescription as *const <VMRVideoDesc as ::windows::core::Abi>::Abi as *const <VMRVideoDesc as ::windows::core::DefaultType>::DefaultType), &*(&lpdeinterlacecaps as *const <VMRDeinterlaceCaps as ::windows::core::Abi>::Abi as *const <VMRDeinterlaceCaps as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceMode(dwstreamid, &*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDeinterlaceMode(dwstreamid, &*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlacePrefs(lpdwdeinterlaceprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdeinterlaceprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDeinterlacePrefs(dwdeinterlaceprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Impl: IVMRDeinterlaceControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActualDeinterlaceMode(dwstreamid, &*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRDeinterlaceControl>, base.5, GetNumberOfDeinterlaceModes::<Impl, OFFSET>, GetDeinterlaceModeCaps::<Impl, OFFSET>, GetDeinterlaceMode::<Impl, OFFSET>, SetDeinterlaceMode::<Impl, OFFSET>, GetDeinterlacePrefs::<Impl, OFFSET>, SetDeinterlacePrefs::<Impl, OFFSET>, GetActualDeinterlaceMode::<Impl, OFFSET>)
    }
}
pub trait IVMRDeinterlaceControl9Impl: Sized {
    fn GetNumberOfDeinterlaceModes();
    fn GetDeinterlaceModeCaps();
    fn GetDeinterlaceMode();
    fn SetDeinterlaceMode();
    fn GetDeinterlacePrefs();
    fn SetDeinterlacePrefs();
    fn GetActualDeinterlaceMode();
}
impl ::windows::core::RuntimeName for IVMRDeinterlaceControl9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRDeinterlaceControl9";
}
impl IVMRDeinterlaceControl9Vtbl {
    pub const fn new<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRDeinterlaceControl9Vtbl {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfDeinterlaceModes(&*(&lpvideodescription as *const <VMR9VideoDesc as ::windows::core::Abi>::Abi as *const <VMR9VideoDesc as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&lpdwnumdeinterlacemodes), ::core::mem::transmute_copy(&lpdeinterlacemodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdeinterlacemode: *const ::windows::core::GUID, lpvideodescription: *const VMR9VideoDesc, lpdeinterlacecaps: *mut VMR9DeinterlaceCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceModeCaps(&*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&lpvideodescription as *const <VMR9VideoDesc as ::windows::core::Abi>::Abi as *const <VMR9VideoDesc as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&lpdeinterlacecaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceMode(dwstreamid, ::core::mem::transmute_copy(&lpdeinterlacemode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDeinterlaceMode(dwstreamid, &*(&lpdeinterlacemode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlacePrefs(::core::mem::transmute_copy(&lpdwdeinterlaceprefs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdeinterlaceprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDeinterlacePrefs(dwdeinterlaceprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Impl: IVMRDeinterlaceControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActualDeinterlaceMode(dwstreamid, ::core::mem::transmute_copy(&lpdeinterlacemode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRDeinterlaceControl9>, base.5, GetNumberOfDeinterlaceModes::<Impl, OFFSET>, GetDeinterlaceModeCaps::<Impl, OFFSET>, GetDeinterlaceMode::<Impl, OFFSET>, SetDeinterlaceMode::<Impl, OFFSET>, GetDeinterlacePrefs::<Impl, OFFSET>, SetDeinterlacePrefs::<Impl, OFFSET>, GetActualDeinterlaceMode::<Impl, OFFSET>)
    }
}
pub trait IVMRFilterConfigImpl: Sized {
    fn SetImageCompositor();
    fn SetNumberOfStreams();
    fn GetNumberOfStreams();
    fn SetRenderingPrefs();
    fn GetRenderingPrefs();
    fn SetRenderingMode();
    fn GetRenderingMode();
}
impl ::windows::core::RuntimeName for IVMRFilterConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRFilterConfig";
}
impl IVMRFilterConfigVtbl {
    pub const fn new<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRFilterConfigVtbl {
        unsafe extern "system" fn SetImageCompositor<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpvmrimgcompositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetImageCompositor(&*(&lpvmrimgcompositor as *const <IVMRImageCompositor as ::windows::core::Abi>::Abi as *const <IVMRImageCompositor as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNumberOfStreams<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNumberOfStreams(dwmaxstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams(pdwmaxstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs(pdwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingMode<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingMode<Impl: IVMRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingMode(pmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRFilterConfig>, base.5, SetImageCompositor::<Impl, OFFSET>, SetNumberOfStreams::<Impl, OFFSET>, GetNumberOfStreams::<Impl, OFFSET>, SetRenderingPrefs::<Impl, OFFSET>, GetRenderingPrefs::<Impl, OFFSET>, SetRenderingMode::<Impl, OFFSET>, GetRenderingMode::<Impl, OFFSET>)
    }
}
pub trait IVMRFilterConfig9Impl: Sized {
    fn SetImageCompositor();
    fn SetNumberOfStreams();
    fn GetNumberOfStreams();
    fn SetRenderingPrefs();
    fn GetRenderingPrefs();
    fn SetRenderingMode();
    fn GetRenderingMode();
}
impl ::windows::core::RuntimeName for IVMRFilterConfig9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRFilterConfig9";
}
impl IVMRFilterConfig9Vtbl {
    pub const fn new<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRFilterConfig9Vtbl {
        unsafe extern "system" fn SetImageCompositor<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpvmrimgcompositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetImageCompositor(&*(&lpvmrimgcompositor as *const <IVMRImageCompositor9 as ::windows::core::Abi>::Abi as *const <IVMRImageCompositor9 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNumberOfStreams<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNumberOfStreams(dwmaxstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams(::core::mem::transmute_copy(&pdwmaxstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs(::core::mem::transmute_copy(&pdwrenderflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingMode<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingMode<Impl: IVMRFilterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingMode(::core::mem::transmute_copy(&pmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRFilterConfig9>, base.5, SetImageCompositor::<Impl, OFFSET>, SetNumberOfStreams::<Impl, OFFSET>, GetNumberOfStreams::<Impl, OFFSET>, SetRenderingPrefs::<Impl, OFFSET>, GetRenderingPrefs::<Impl, OFFSET>, SetRenderingMode::<Impl, OFFSET>, GetRenderingMode::<Impl, OFFSET>)
    }
}
pub trait IVMRImageCompositorImpl: Sized {
    fn InitCompositionTarget();
    fn TermCompositionTarget();
    fn SetStreamMediaType();
    fn CompositeImage();
}
impl ::windows::core::RuntimeName for IVMRImageCompositor {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImageCompositor";
}
impl IVMRImageCompositorVtbl {
    pub const fn new<Impl: IVMRImageCompositorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImageCompositorVtbl {
        unsafe extern "system" fn InitCompositionTarget<Impl: IVMRImageCompositorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitCompositionTarget(&*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&pddsrendertarget as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TermCompositionTarget<Impl: IVMRImageCompositorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TermCompositionTarget(&*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&pddsrendertarget as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamMediaType<Impl: IVMRImageCompositorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstrmid: u32, pmt: *mut AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamMediaType(dwstrmid, &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), &*(&ftexture as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositeImage<Impl: IVMRImageCompositorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr, pmtrendertarget: *mut AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *mut VMRVIDEOSTREAMINFO, cstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositeImage(
                &*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pddsrendertarget as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::DefaultType>::DefaultType),
                &*(&pmtrendertarget as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType),
                rtstart,
                rtend,
                dwclrbkgnd,
                &*(&pvideostreaminfo as *const <VMRVIDEOSTREAMINFO as ::windows::core::Abi>::Abi as *const <VMRVIDEOSTREAMINFO as ::windows::core::DefaultType>::DefaultType),
                cstreams,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImageCompositor>, base.5, InitCompositionTarget::<Impl, OFFSET>, TermCompositionTarget::<Impl, OFFSET>, SetStreamMediaType::<Impl, OFFSET>, CompositeImage::<Impl, OFFSET>)
    }
}
pub trait IVMRImageCompositor9Impl: Sized {
    fn InitCompositionDevice();
    fn TermCompositionDevice();
    fn SetStreamMediaType();
    fn CompositeImage();
}
impl ::windows::core::RuntimeName for IVMRImageCompositor9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImageCompositor9";
}
impl IVMRImageCompositor9Vtbl {
    pub const fn new<Impl: IVMRImageCompositor9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImageCompositor9Vtbl {
        unsafe extern "system" fn InitCompositionDevice<Impl: IVMRImageCompositor9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitCompositionDevice(&*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TermCompositionDevice<Impl: IVMRImageCompositor9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TermCompositionDevice(&*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamMediaType<Impl: IVMRImageCompositor9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstrmid: u32, pmt: *const AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamMediaType(dwstrmid, &*(&pmt as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), &*(&ftexture as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositeImage<Impl: IVMRImageCompositor9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr, pmtrendertarget: *const AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositeImage(
                &*(&pd3ddevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pddsrendertarget as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                &*(&pmtrendertarget as *const <AM_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <AM_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType),
                rtstart,
                rtend,
                dwclrbkgnd,
                &*(&pvideostreaminfo as *const <VMR9VideoStreamInfo as ::windows::core::Abi>::Abi as *const <VMR9VideoStreamInfo as ::windows::core::DefaultType>::DefaultType),
                cstreams,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImageCompositor9>, base.5, InitCompositionDevice::<Impl, OFFSET>, TermCompositionDevice::<Impl, OFFSET>, SetStreamMediaType::<Impl, OFFSET>, CompositeImage::<Impl, OFFSET>)
    }
}
pub trait IVMRImagePresenterImpl: Sized {
    fn StartPresenting();
    fn StopPresenting();
    fn PresentImage();
}
impl ::windows::core::RuntimeName for IVMRImagePresenter {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImagePresenter";
}
impl IVMRImagePresenterVtbl {
    pub const fn new<Impl: IVMRImagePresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImagePresenterVtbl {
        unsafe extern "system" fn StartPresenting<Impl: IVMRImagePresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartPresenting(dwuserid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPresenting<Impl: IVMRImagePresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopPresenting(dwuserid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PresentImage<Impl: IVMRImagePresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lppresinfo: *mut VMRPRESENTATIONINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PresentImage(dwuserid, &*(&lppresinfo as *const <VMRPRESENTATIONINFO as ::windows::core::Abi>::Abi as *const <VMRPRESENTATIONINFO as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImagePresenter>, base.5, StartPresenting::<Impl, OFFSET>, StopPresenting::<Impl, OFFSET>, PresentImage::<Impl, OFFSET>)
    }
}
pub trait IVMRImagePresenter9Impl: Sized {
    fn StartPresenting();
    fn StopPresenting();
    fn PresentImage();
}
impl ::windows::core::RuntimeName for IVMRImagePresenter9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImagePresenter9";
}
impl IVMRImagePresenter9Vtbl {
    pub const fn new<Impl: IVMRImagePresenter9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImagePresenter9Vtbl {
        unsafe extern "system" fn StartPresenting<Impl: IVMRImagePresenter9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartPresenting(dwuserid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPresenting<Impl: IVMRImagePresenter9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopPresenting(dwuserid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PresentImage<Impl: IVMRImagePresenter9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PresentImage(dwuserid, &*(&lppresinfo as *const <VMR9PresentationInfo as ::windows::core::Abi>::Abi as *const <VMR9PresentationInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImagePresenter9>, base.5, StartPresenting::<Impl, OFFSET>, StopPresenting::<Impl, OFFSET>, PresentImage::<Impl, OFFSET>)
    }
}
pub trait IVMRImagePresenterConfigImpl: Sized {
    fn SetRenderingPrefs();
    fn GetRenderingPrefs();
}
impl ::windows::core::RuntimeName for IVMRImagePresenterConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImagePresenterConfig";
}
impl IVMRImagePresenterConfigVtbl {
    pub const fn new<Impl: IVMRImagePresenterConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImagePresenterConfigVtbl {
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRImagePresenterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRImagePresenterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImagePresenterConfig>, base.5, SetRenderingPrefs::<Impl, OFFSET>, GetRenderingPrefs::<Impl, OFFSET>)
    }
}
pub trait IVMRImagePresenterConfig9Impl: Sized {
    fn SetRenderingPrefs();
    fn GetRenderingPrefs();
}
impl ::windows::core::RuntimeName for IVMRImagePresenterConfig9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImagePresenterConfig9";
}
impl IVMRImagePresenterConfig9Vtbl {
    pub const fn new<Impl: IVMRImagePresenterConfig9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImagePresenterConfig9Vtbl {
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRImagePresenterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRImagePresenterConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImagePresenterConfig9>, base.5, SetRenderingPrefs::<Impl, OFFSET>, GetRenderingPrefs::<Impl, OFFSET>)
    }
}
pub trait IVMRImagePresenterExclModeConfigImpl: Sized + IVMRImagePresenterConfigImpl {
    fn SetXlcModeDDObjAndPrimarySurface();
    fn GetXlcModeDDObjAndPrimarySurface();
}
impl ::windows::core::RuntimeName for IVMRImagePresenterExclModeConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRImagePresenterExclModeConfig";
}
impl IVMRImagePresenterExclModeConfigVtbl {
    pub const fn new<Impl: IVMRImagePresenterExclModeConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRImagePresenterExclModeConfigVtbl {
        unsafe extern "system" fn SetXlcModeDDObjAndPrimarySurface<Impl: IVMRImagePresenterExclModeConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpddobj: ::windows::core::RawPtr, lpprimarysurf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetXlcModeDDObjAndPrimarySurface(&*(&lpddobj as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::DefaultType>::DefaultType), &*(&lpprimarysurf as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetXlcModeDDObjAndPrimarySurface<Impl: IVMRImagePresenterExclModeConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpddobj: *mut ::windows::core::RawPtr, lpprimarysurf: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetXlcModeDDObjAndPrimarySurface(::core::mem::transmute_copy(&lpddobj), ::core::mem::transmute_copy(&lpprimarysurf)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRImagePresenterExclModeConfig>, base.5, SetXlcModeDDObjAndPrimarySurface::<Impl, OFFSET>, GetXlcModeDDObjAndPrimarySurface::<Impl, OFFSET>)
    }
}
pub trait IVMRMixerBitmapImpl: Sized {
    fn SetAlphaBitmap();
    fn UpdateAlphaBitmapParameters();
    fn GetAlphaBitmapParameters();
}
impl ::windows::core::RuntimeName for IVMRMixerBitmap {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMixerBitmap";
}
impl IVMRMixerBitmapVtbl {
    pub const fn new<Impl: IVMRMixerBitmapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMixerBitmapVtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IVMRMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAlphaBitmap(&*(&pbmpparms as *const <VMRALPHABITMAP as ::windows::core::Abi>::Abi as *const <VMRALPHABITMAP as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IVMRMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateAlphaBitmapParameters(&*(&pbmpparms as *const <VMRALPHABITMAP as ::windows::core::Abi>::Abi as *const <VMRALPHABITMAP as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IVMRMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlphaBitmapParameters(&*(&pbmpparms as *const <VMRALPHABITMAP as ::windows::core::Abi>::Abi as *const <VMRALPHABITMAP as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRMixerBitmap>, base.5, SetAlphaBitmap::<Impl, OFFSET>, UpdateAlphaBitmapParameters::<Impl, OFFSET>, GetAlphaBitmapParameters::<Impl, OFFSET>)
    }
}
pub trait IVMRMixerBitmap9Impl: Sized {
    fn SetAlphaBitmap();
    fn UpdateAlphaBitmapParameters();
    fn GetAlphaBitmapParameters();
}
impl ::windows::core::RuntimeName for IVMRMixerBitmap9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMixerBitmap9";
}
impl IVMRMixerBitmap9Vtbl {
    pub const fn new<Impl: IVMRMixerBitmap9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMixerBitmap9Vtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IVMRMixerBitmap9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAlphaBitmap(&*(&pbmpparms as *const <VMR9AlphaBitmap as ::windows::core::Abi>::Abi as *const <VMR9AlphaBitmap as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IVMRMixerBitmap9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateAlphaBitmapParameters(&*(&pbmpparms as *const <VMR9AlphaBitmap as ::windows::core::Abi>::Abi as *const <VMR9AlphaBitmap as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IVMRMixerBitmap9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRMixerBitmap9>, base.5, SetAlphaBitmap::<Impl, OFFSET>, UpdateAlphaBitmapParameters::<Impl, OFFSET>, GetAlphaBitmapParameters::<Impl, OFFSET>)
    }
}
pub trait IVMRMixerControlImpl: Sized {
    fn SetAlpha();
    fn GetAlpha();
    fn SetZOrder();
    fn GetZOrder();
    fn SetOutputRect();
    fn GetOutputRect();
    fn SetBackgroundClr();
    fn GetBackgroundClr();
    fn SetMixingPrefs();
    fn GetMixingPrefs();
}
impl ::windows::core::RuntimeName for IVMRMixerControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMixerControl";
}
impl IVMRMixerControlVtbl {
    pub const fn new<Impl: IVMRMixerControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMixerControlVtbl {
        unsafe extern "system" fn SetAlpha<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, alpha: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAlpha(dwstreamid, alpha) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlpha<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlpha(dwstreamid, palpha) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZOrder<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetZOrder(dwstreamid, dwz) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZOrder<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZOrder(dwstreamid, pz) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputRect<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputRect(dwstreamid, &*(&prect as *const <NORMALIZEDRECT as ::windows::core::Abi>::Abi as *const <NORMALIZEDRECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputRect<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *mut NORMALIZEDRECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputRect(dwstreamid, &*(&prect as *const <NORMALIZEDRECT as ::windows::core::Abi>::Abi as *const <NORMALIZEDRECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundClr<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundClr(clrbkg) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundClr<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclrbkg: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundClr(lpclrbkg) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixingPrefs<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmixerprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixingPrefs(dwmixerprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IVMRMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmixerprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMixingPrefs(pdwmixerprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRMixerControl>, base.5, SetAlpha::<Impl, OFFSET>, GetAlpha::<Impl, OFFSET>, SetZOrder::<Impl, OFFSET>, GetZOrder::<Impl, OFFSET>, SetOutputRect::<Impl, OFFSET>, GetOutputRect::<Impl, OFFSET>, SetBackgroundClr::<Impl, OFFSET>, GetBackgroundClr::<Impl, OFFSET>, SetMixingPrefs::<Impl, OFFSET>, GetMixingPrefs::<Impl, OFFSET>)
    }
}
pub trait IVMRMixerControl9Impl: Sized {
    fn SetAlpha();
    fn GetAlpha();
    fn SetZOrder();
    fn GetZOrder();
    fn SetOutputRect();
    fn GetOutputRect();
    fn SetBackgroundClr();
    fn GetBackgroundClr();
    fn SetMixingPrefs();
    fn GetMixingPrefs();
    fn SetProcAmpControl();
    fn GetProcAmpControl();
    fn GetProcAmpControlRange();
}
impl ::windows::core::RuntimeName for IVMRMixerControl9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMixerControl9";
}
impl IVMRMixerControl9Vtbl {
    pub const fn new<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMixerControl9Vtbl {
        unsafe extern "system" fn SetAlpha<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, alpha: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAlpha(dwstreamid, alpha) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlpha<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlpha(dwstreamid, ::core::mem::transmute_copy(&palpha)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZOrder<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetZOrder(dwstreamid, dwz) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZOrder<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZOrder(dwstreamid, ::core::mem::transmute_copy(&pz)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputRect<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputRect(dwstreamid, &*(&prect as *const <VMR9NormalizedRect as ::windows::core::Abi>::Abi as *const <VMR9NormalizedRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputRect<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *mut VMR9NormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputRect(dwstreamid, ::core::mem::transmute_copy(&prect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundClr<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundClr(clrbkg) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundClr<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclrbkg: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundClr(lpclrbkg) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixingPrefs<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmixerprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixingPrefs(dwmixerprefs) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmixerprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMixingPrefs(::core::mem::transmute_copy(&pdwmixerprefs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProcAmpControl<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProcAmpControl(dwstreamid, &*(&lpclrcontrol as *const <VMR9ProcAmpControl as ::windows::core::Abi>::Abi as *const <VMR9ProcAmpControl as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpControl<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpControl(dwstreamid, &*(&lpclrcontrol as *const <VMR9ProcAmpControl as ::windows::core::Abi>::Abi as *const <VMR9ProcAmpControl as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpControlRange<Impl: IVMRMixerControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpControlRange(dwstreamid, &*(&lpclrcontrol as *const <VMR9ProcAmpControlRange as ::windows::core::Abi>::Abi as *const <VMR9ProcAmpControlRange as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVMRMixerControl9>,
            base.5,
            SetAlpha::<Impl, OFFSET>,
            GetAlpha::<Impl, OFFSET>,
            SetZOrder::<Impl, OFFSET>,
            GetZOrder::<Impl, OFFSET>,
            SetOutputRect::<Impl, OFFSET>,
            GetOutputRect::<Impl, OFFSET>,
            SetBackgroundClr::<Impl, OFFSET>,
            GetBackgroundClr::<Impl, OFFSET>,
            SetMixingPrefs::<Impl, OFFSET>,
            GetMixingPrefs::<Impl, OFFSET>,
            SetProcAmpControl::<Impl, OFFSET>,
            GetProcAmpControl::<Impl, OFFSET>,
            GetProcAmpControlRange::<Impl, OFFSET>,
        )
    }
}
pub trait IVMRMonitorConfigImpl: Sized {
    fn SetMonitor();
    fn GetMonitor();
    fn SetDefaultMonitor();
    fn GetDefaultMonitor();
    fn GetAvailableMonitors();
}
impl ::windows::core::RuntimeName for IVMRMonitorConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMonitorConfig";
}
impl IVMRMonitorConfigVtbl {
    pub const fn new<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMonitorConfigVtbl {
        unsafe extern "system" fn SetMonitor<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMonitor(&*(&pguid as *const <VMRGUID as ::windows::core::Abi>::Abi as *const <VMRGUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMonitor<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMonitor(&*(&pguid as *const <VMRGUID as ::windows::core::Abi>::Abi as *const <VMRGUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMonitor<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *const VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultMonitor(&*(&pguid as *const <VMRGUID as ::windows::core::Abi>::Abi as *const <VMRGUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultMonitor<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguid: *mut VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultMonitor(&*(&pguid as *const <VMRGUID as ::windows::core::Abi>::Abi as *const <VMRGUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableMonitors<Impl: IVMRMonitorConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinfo: *mut VMRMONITORINFO, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableMonitors(&*(&pinfo as *const <VMRMONITORINFO as ::windows::core::Abi>::Abi as *const <VMRMONITORINFO as ::windows::core::DefaultType>::DefaultType), dwmaxinfoarraysize, pdwnumdevices) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRMonitorConfig>, base.5, SetMonitor::<Impl, OFFSET>, GetMonitor::<Impl, OFFSET>, SetDefaultMonitor::<Impl, OFFSET>, GetDefaultMonitor::<Impl, OFFSET>, GetAvailableMonitors::<Impl, OFFSET>)
    }
}
pub trait IVMRMonitorConfig9Impl: Sized {
    fn SetMonitor();
    fn GetMonitor();
    fn SetDefaultMonitor();
    fn GetDefaultMonitor();
    fn GetAvailableMonitors();
}
impl ::windows::core::RuntimeName for IVMRMonitorConfig9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRMonitorConfig9";
}
impl IVMRMonitorConfig9Vtbl {
    pub const fn new<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRMonitorConfig9Vtbl {
        unsafe extern "system" fn SetMonitor<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, udev: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMonitor(udev) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMonitor<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pudev: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMonitor(::core::mem::transmute_copy(&pudev)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMonitor<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, udev: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultMonitor(udev) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultMonitor<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pudev: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultMonitor(::core::mem::transmute_copy(&pudev)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableMonitors<Impl: IVMRMonitorConfig9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinfo: *mut VMR9MonitorInfo, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableMonitors(::core::mem::transmute_copy(&pinfo), dwmaxinfoarraysize, ::core::mem::transmute_copy(&pdwnumdevices)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRMonitorConfig9>, base.5, SetMonitor::<Impl, OFFSET>, GetMonitor::<Impl, OFFSET>, SetDefaultMonitor::<Impl, OFFSET>, GetDefaultMonitor::<Impl, OFFSET>, GetAvailableMonitors::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceImpl: Sized {
    fn IsSurfaceLocked();
    fn LockSurface();
    fn UnlockSurface();
    fn GetSurface();
}
impl ::windows::core::RuntimeName for IVMRSurface {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurface";
}
impl IVMRSurfaceVtbl {
    pub const fn new<Impl: IVMRSurfaceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceVtbl {
        unsafe extern "system" fn IsSurfaceLocked<Impl: IVMRSurfaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSurfaceLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockSurface<Impl: IVMRSurfaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsurface: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockSurface(lpsurface) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockSurface<Impl: IVMRSurfaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurfaceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurface(::core::mem::transmute_copy(&lplpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurface>, base.5, IsSurfaceLocked::<Impl, OFFSET>, LockSurface::<Impl, OFFSET>, UnlockSurface::<Impl, OFFSET>, GetSurface::<Impl, OFFSET>)
    }
}
pub trait IVMRSurface9Impl: Sized {
    fn IsSurfaceLocked();
    fn LockSurface();
    fn UnlockSurface();
    fn GetSurface();
}
impl ::windows::core::RuntimeName for IVMRSurface9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurface9";
}
impl IVMRSurface9Vtbl {
    pub const fn new<Impl: IVMRSurface9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurface9Vtbl {
        unsafe extern "system" fn IsSurfaceLocked<Impl: IVMRSurface9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSurfaceLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockSurface<Impl: IVMRSurface9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsurface: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockSurface(::core::mem::transmute_copy(&lpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockSurface<Impl: IVMRSurface9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurface9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurface(::core::mem::transmute_copy(&lplpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurface9>, base.5, IsSurfaceLocked::<Impl, OFFSET>, LockSurface::<Impl, OFFSET>, UnlockSurface::<Impl, OFFSET>, GetSurface::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceAllocatorImpl: Sized {
    fn AllocateSurface();
    fn FreeSurface();
    fn PrepareSurface();
    fn AdviseNotify();
}
impl ::windows::core::RuntimeName for IVMRSurfaceAllocator {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurfaceAllocator";
}
impl IVMRSurfaceAllocatorVtbl {
    pub const fn new<Impl: IVMRSurfaceAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceAllocatorVtbl {
        unsafe extern "system" fn AllocateSurface<Impl: IVMRSurfaceAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpallocinfo: *mut VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocateSurface(dwuserid, &*(&lpallocinfo as *const <VMRALLOCATIONINFO as ::windows::core::Abi>::Abi as *const <VMRALLOCATIONINFO as ::windows::core::DefaultType>::DefaultType), lpdwactualbuffers, ::core::mem::transmute_copy(&lplpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FreeSurface<Impl: IVMRSurfaceAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FreeSurface(dwid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareSurface<Impl: IVMRSurfaceAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpsurface: ::windows::core::RawPtr, dwsurfaceflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrepareSurface(dwuserid, &*(&lpsurface as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDrawSurface7 as ::windows::core::DefaultType>::DefaultType), dwsurfaceflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdviseNotify<Impl: IVMRSurfaceAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpivmrsurfallocnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdviseNotify(&*(&lpivmrsurfallocnotify as *const <IVMRSurfaceAllocatorNotify as ::windows::core::Abi>::Abi as *const <IVMRSurfaceAllocatorNotify as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurfaceAllocator>, base.5, AllocateSurface::<Impl, OFFSET>, FreeSurface::<Impl, OFFSET>, PrepareSurface::<Impl, OFFSET>, AdviseNotify::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceAllocator9Impl: Sized {
    fn InitializeDevice();
    fn TerminateDevice();
    fn GetSurface();
    fn AdviseNotify();
}
impl ::windows::core::RuntimeName for IVMRSurfaceAllocator9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurfaceAllocator9";
}
impl IVMRSurfaceAllocator9Vtbl {
    pub const fn new<Impl: IVMRSurfaceAllocator9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceAllocator9Vtbl {
        unsafe extern "system" fn InitializeDevice<Impl: IVMRSurfaceAllocator9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeDevice(dwuserid, &*(&lpallocinfo as *const <VMR9AllocationInfo as ::windows::core::Abi>::Abi as *const <VMR9AllocationInfo as ::windows::core::DefaultType>::DefaultType), lpnumbuffers) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TerminateDevice<Impl: IVMRSurfaceAllocator9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TerminateDevice(dwid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurfaceAllocator9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurface(dwuserid, surfaceindex, surfaceflags, ::core::mem::transmute_copy(&lplpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdviseNotify<Impl: IVMRSurfaceAllocator9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpivmrsurfallocnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdviseNotify(&*(&lpivmrsurfallocnotify as *const <IVMRSurfaceAllocatorNotify9 as ::windows::core::Abi>::Abi as *const <IVMRSurfaceAllocatorNotify9 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurfaceAllocator9>, base.5, InitializeDevice::<Impl, OFFSET>, TerminateDevice::<Impl, OFFSET>, GetSurface::<Impl, OFFSET>, AdviseNotify::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceAllocatorEx9Impl: Sized + IVMRSurfaceAllocator9Impl {
    fn GetSurfaceEx();
}
impl ::windows::core::RuntimeName for IVMRSurfaceAllocatorEx9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurfaceAllocatorEx9";
}
impl IVMRSurfaceAllocatorEx9Vtbl {
    pub const fn new<Impl: IVMRSurfaceAllocatorEx9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceAllocatorEx9Vtbl {
        unsafe extern "system" fn GetSurfaceEx<Impl: IVMRSurfaceAllocatorEx9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut ::windows::core::RawPtr, lprcdst: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurfaceEx(dwuserid, surfaceindex, surfaceflags, ::core::mem::transmute_copy(&lplpsurface), ::core::mem::transmute_copy(&lprcdst)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurfaceAllocatorEx9>, base.5, GetSurfaceEx::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceAllocatorNotifyImpl: Sized {
    fn AdviseSurfaceAllocator();
    fn SetDDrawDevice();
    fn ChangeDDrawDevice();
    fn RestoreDDrawSurfaces();
    fn NotifyEvent();
    fn SetBorderColor();
}
impl ::windows::core::RuntimeName for IVMRSurfaceAllocatorNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurfaceAllocatorNotify";
}
impl IVMRSurfaceAllocatorNotifyVtbl {
    pub const fn new<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceAllocatorNotifyVtbl {
        unsafe extern "system" fn AdviseSurfaceAllocator<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdviseSurfaceAllocator(dwuserid, &*(&lpivrmsurfaceallocator as *const <IVMRSurfaceAllocator as ::windows::core::Abi>::Abi as *const <IVMRSurfaceAllocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDDrawDevice<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpddrawdevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDDrawDevice(&*(&lpddrawdevice as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::DefaultType>::DefaultType), &*(&hmonitor as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeDDrawDevice<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpddrawdevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeDDrawDevice(&*(&lpddrawdevice as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::IDirectDraw7 as ::windows::core::DefaultType>::DefaultType), &*(&hmonitor as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RestoreDDrawSurfaces<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RestoreDDrawSurfaces() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyEvent<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyEvent(eventcode, param1, param2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRSurfaceAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clrborder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(clrborder) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurfaceAllocatorNotify>, base.5, AdviseSurfaceAllocator::<Impl, OFFSET>, SetDDrawDevice::<Impl, OFFSET>, ChangeDDrawDevice::<Impl, OFFSET>, RestoreDDrawSurfaces::<Impl, OFFSET>, NotifyEvent::<Impl, OFFSET>, SetBorderColor::<Impl, OFFSET>)
    }
}
pub trait IVMRSurfaceAllocatorNotify9Impl: Sized {
    fn AdviseSurfaceAllocator();
    fn SetD3DDevice();
    fn ChangeD3DDevice();
    fn AllocateSurfaceHelper();
    fn NotifyEvent();
}
impl ::windows::core::RuntimeName for IVMRSurfaceAllocatorNotify9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRSurfaceAllocatorNotify9";
}
impl IVMRSurfaceAllocatorNotify9Vtbl {
    pub const fn new<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRSurfaceAllocatorNotify9Vtbl {
        unsafe extern "system" fn AdviseSurfaceAllocator<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AdviseSurfaceAllocator(dwuserid, &*(&lpivrmsurfaceallocator as *const <IVMRSurfaceAllocator9 as ::windows::core::Abi>::Abi as *const <IVMRSurfaceAllocator9 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetD3DDevice<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpd3ddevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetD3DDevice(&*(&lpd3ddevice as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::DefaultType>::DefaultType), &*(&hmonitor as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeD3DDevice<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpd3ddevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeD3DDevice(&*(&lpd3ddevice as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::DefaultType>::DefaultType), &*(&hmonitor as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HMONITOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllocateSurfaceHelper<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocateSurfaceHelper(&*(&lpallocinfo as *const <VMR9AllocationInfo as ::windows::core::Abi>::Abi as *const <VMR9AllocationInfo as ::windows::core::DefaultType>::DefaultType), lpnumbuffers, ::core::mem::transmute_copy(&lplpsurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyEvent<Impl: IVMRSurfaceAllocatorNotify9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyEvent(eventcode, param1, param2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRSurfaceAllocatorNotify9>, base.5, AdviseSurfaceAllocator::<Impl, OFFSET>, SetD3DDevice::<Impl, OFFSET>, ChangeD3DDevice::<Impl, OFFSET>, AllocateSurfaceHelper::<Impl, OFFSET>, NotifyEvent::<Impl, OFFSET>)
    }
}
pub trait IVMRVideoStreamControlImpl: Sized {
    fn SetColorKey();
    fn GetColorKey();
    fn SetStreamActiveState();
    fn GetStreamActiveState();
}
impl ::windows::core::RuntimeName for IVMRVideoStreamControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRVideoStreamControl";
}
impl IVMRVideoStreamControlVtbl {
    pub const fn new<Impl: IVMRVideoStreamControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRVideoStreamControlVtbl {
        unsafe extern "system" fn SetColorKey<Impl: IVMRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(&*(&lpclrkey as *const <super::super::Graphics::DirectDraw::DDCOLORKEY as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDCOLORKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColorKey<Impl: IVMRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColorKey(&*(&lpclrkey as *const <super::super::Graphics::DirectDraw::DDCOLORKEY as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDCOLORKEY as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamActiveState<Impl: IVMRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamActiveState(&*(&factive as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IVMRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamActiveState(&*(&lpfactive as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRVideoStreamControl>, base.5, SetColorKey::<Impl, OFFSET>, GetColorKey::<Impl, OFFSET>, SetStreamActiveState::<Impl, OFFSET>, GetStreamActiveState::<Impl, OFFSET>)
    }
}
pub trait IVMRVideoStreamControl9Impl: Sized {
    fn SetStreamActiveState();
    fn GetStreamActiveState();
}
impl ::windows::core::RuntimeName for IVMRVideoStreamControl9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRVideoStreamControl9";
}
impl IVMRVideoStreamControl9Vtbl {
    pub const fn new<Impl: IVMRVideoStreamControl9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRVideoStreamControl9Vtbl {
        unsafe extern "system" fn SetStreamActiveState<Impl: IVMRVideoStreamControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamActiveState(&*(&factive as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IVMRVideoStreamControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamActiveState(::core::mem::transmute_copy(&lpfactive)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVMRVideoStreamControl9>, base.5, SetStreamActiveState::<Impl, OFFSET>, GetStreamActiveState::<Impl, OFFSET>)
    }
}
pub trait IVMRWindowlessControlImpl: Sized {
    fn GetNativeVideoSize();
    fn GetMinIdealVideoSize();
    fn GetMaxIdealVideoSize();
    fn SetVideoPosition();
    fn GetVideoPosition();
    fn GetAspectRatioMode();
    fn SetAspectRatioMode();
    fn SetVideoClippingWindow();
    fn RepaintVideo();
    fn DisplayModeChanged();
    fn GetCurrentImage();
    fn SetBorderColor();
    fn GetBorderColor();
    fn SetColorKey();
    fn GetColorKey();
}
impl ::windows::core::RuntimeName for IVMRWindowlessControl {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRWindowlessControl";
}
impl IVMRWindowlessControlVtbl {
    pub const fn new<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRWindowlessControlVtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoSize(lpwidth, lpheight, lparwidth, lparheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMinIdealVideoSize(lpwidth, lpheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxIdealVideoSize(lpwidth, lpheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoPosition(&*(&lpsrcrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&lpdstrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPosition(&*(&lpsrcrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&lpdstrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(lpaspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, aspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(aspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoClippingWindow<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoClippingWindow(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RepaintVideo<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RepaintVideo(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType), &*(&hdc as *const <super::super::Graphics::Gdi::HDC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HDC as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeChanged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdib: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentImage(lpdib) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(clr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBorderColor<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBorderColor(lpclr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorKey(clr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColorKey<Impl: IVMRWindowlessControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColorKey(lpclr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVMRWindowlessControl>,
            base.5,
            GetNativeVideoSize::<Impl, OFFSET>,
            GetMinIdealVideoSize::<Impl, OFFSET>,
            GetMaxIdealVideoSize::<Impl, OFFSET>,
            SetVideoPosition::<Impl, OFFSET>,
            GetVideoPosition::<Impl, OFFSET>,
            GetAspectRatioMode::<Impl, OFFSET>,
            SetAspectRatioMode::<Impl, OFFSET>,
            SetVideoClippingWindow::<Impl, OFFSET>,
            RepaintVideo::<Impl, OFFSET>,
            DisplayModeChanged::<Impl, OFFSET>,
            GetCurrentImage::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            GetBorderColor::<Impl, OFFSET>,
            SetColorKey::<Impl, OFFSET>,
            GetColorKey::<Impl, OFFSET>,
        )
    }
}
pub trait IVMRWindowlessControl9Impl: Sized {
    fn GetNativeVideoSize();
    fn GetMinIdealVideoSize();
    fn GetMaxIdealVideoSize();
    fn SetVideoPosition();
    fn GetVideoPosition();
    fn GetAspectRatioMode();
    fn SetAspectRatioMode();
    fn SetVideoClippingWindow();
    fn RepaintVideo();
    fn DisplayModeChanged();
    fn GetCurrentImage();
    fn SetBorderColor();
    fn GetBorderColor();
}
impl ::windows::core::RuntimeName for IVMRWindowlessControl9 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVMRWindowlessControl9";
}
impl IVMRWindowlessControl9Vtbl {
    pub const fn new<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVMRWindowlessControl9Vtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight), ::core::mem::transmute_copy(&lparwidth), ::core::mem::transmute_copy(&lparheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMinIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoPosition(&*(&lpsrcrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&lpdstrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPosition(::core::mem::transmute_copy(&lpsrcrect), ::core::mem::transmute_copy(&lpdstrect)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(::core::mem::transmute_copy(&lpaspectratiomode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, aspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(aspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoClippingWindow<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoClippingWindow(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RepaintVideo<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RepaintVideo(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType), &*(&hdc as *const <super::super::Graphics::Gdi::HDC as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::HDC as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeChanged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdib: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentImage(::core::mem::transmute_copy(&lpdib)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(clr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBorderColor<Impl: IVMRWindowlessControl9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBorderColor(::core::mem::transmute_copy(&lpclr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVMRWindowlessControl9>,
            base.5,
            GetNativeVideoSize::<Impl, OFFSET>,
            GetMinIdealVideoSize::<Impl, OFFSET>,
            GetMaxIdealVideoSize::<Impl, OFFSET>,
            SetVideoPosition::<Impl, OFFSET>,
            GetVideoPosition::<Impl, OFFSET>,
            GetAspectRatioMode::<Impl, OFFSET>,
            SetAspectRatioMode::<Impl, OFFSET>,
            SetVideoClippingWindow::<Impl, OFFSET>,
            RepaintVideo::<Impl, OFFSET>,
            DisplayModeChanged::<Impl, OFFSET>,
            GetCurrentImage::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            GetBorderColor::<Impl, OFFSET>,
        )
    }
}
pub trait IVPBaseConfigImpl: Sized {
    fn GetConnectInfo();
    fn SetConnectInfo();
    fn GetVPDataInfo();
    fn GetMaxPixelRate();
    fn InformVPInputFormats();
    fn GetVideoFormats();
    fn SetVideoFormat();
    fn SetInvertPolarity();
    fn GetOverlaySurface();
    fn SetDirectDrawKernelHandle();
    fn SetVideoPortID();
    fn SetDDSurfaceKernelHandles();
    fn SetSurfaceParameters();
}
impl ::windows::core::RuntimeName for IVPBaseConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPBaseConfig";
}
impl IVPBaseConfigVtbl {
    pub const fn new<Impl: IVPBaseConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPBaseConfigVtbl {
        unsafe extern "system" fn GetConnectInfo<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConnectInfo(pdwnumconnectinfo, ::core::mem::transmute_copy(&pddvpconnectinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConnectInfo<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwchosenentry: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetConnectInfo(dwchosenentry) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVPDataInfo<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pamvpdatainfo: *mut AMVPDATAINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVPDataInfo(&*(&pamvpdatainfo as *const <AMVPDATAINFO as ::windows::core::Abi>::Abi as *const <AMVPDATAINFO as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxPixelRate<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxPixelRate(&*(&pamvpsize as *const <AMVPSIZE as ::windows::core::Abi>::Abi as *const <AMVPSIZE as ::windows::core::DefaultType>::DefaultType), pdwmaxpixelspersecond) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InformVPInputFormats<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InformVPInputFormats(dwnumformats, &*(&pddpixelformats as *const <super::super::Graphics::DirectDraw::DDPIXELFORMAT as ::windows::core::Abi>::Abi as *const <super::super::Graphics::DirectDraw::DDPIXELFORMAT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoFormats<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumformats: *mut u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoFormats(pdwnumformats, ::core::mem::transmute_copy(&pddpixelformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoFormat<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwchosenentry: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoFormat(dwchosenentry) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInvertPolarity<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInvertPolarity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOverlaySurface<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppddoverlaysurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOverlaySurface(::core::mem::transmute_copy(&ppddoverlaysurface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDirectDrawKernelHandle<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwddkernelhandle: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectDrawKernelHandle(dwddkernelhandle) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoPortID<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwvideoportid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoPortID(dwvideoportid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDDSurfaceKernelHandles<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, chandles: u32, rgddkernelhandles: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDDSurfaceKernelHandles(chandles, rgddkernelhandles) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSurfaceParameters<Impl: IVPBaseConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSurfaceParameters(dwpitch, dwxorigin, dwyorigin) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVPBaseConfig>,
            base.5,
            GetConnectInfo::<Impl, OFFSET>,
            SetConnectInfo::<Impl, OFFSET>,
            GetVPDataInfo::<Impl, OFFSET>,
            GetMaxPixelRate::<Impl, OFFSET>,
            InformVPInputFormats::<Impl, OFFSET>,
            GetVideoFormats::<Impl, OFFSET>,
            SetVideoFormat::<Impl, OFFSET>,
            SetInvertPolarity::<Impl, OFFSET>,
            GetOverlaySurface::<Impl, OFFSET>,
            SetDirectDrawKernelHandle::<Impl, OFFSET>,
            SetVideoPortID::<Impl, OFFSET>,
            SetDDSurfaceKernelHandles::<Impl, OFFSET>,
            SetSurfaceParameters::<Impl, OFFSET>,
        )
    }
}
pub trait IVPBaseNotifyImpl: Sized {
    fn RenegotiateVPParameters();
}
impl ::windows::core::RuntimeName for IVPBaseNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPBaseNotify";
}
impl IVPBaseNotifyVtbl {
    pub const fn new<Impl: IVPBaseNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPBaseNotifyVtbl {
        unsafe extern "system" fn RenegotiateVPParameters<Impl: IVPBaseNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RenegotiateVPParameters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPBaseNotify>, base.5, RenegotiateVPParameters::<Impl, OFFSET>)
    }
}
pub trait IVPConfigImpl: Sized + IVPBaseConfigImpl {
    fn IsVPDecimationAllowed();
    fn SetScalingFactors();
}
impl ::windows::core::RuntimeName for IVPConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPConfig";
}
impl IVPConfigVtbl {
    pub const fn new<Impl: IVPConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPConfigVtbl {
        unsafe extern "system" fn IsVPDecimationAllowed<Impl: IVPConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbisdecimationallowed: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVPDecimationAllowed(pbisdecimationallowed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScalingFactors<Impl: IVPConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pamvpsize: *mut AMVPSIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetScalingFactors(&*(&pamvpsize as *const <AMVPSIZE as ::windows::core::Abi>::Abi as *const <AMVPSIZE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPConfig>, base.5, IsVPDecimationAllowed::<Impl, OFFSET>, SetScalingFactors::<Impl, OFFSET>)
    }
}
pub trait IVPManagerImpl: Sized {
    fn SetVideoPortIndex();
    fn GetVideoPortIndex();
}
impl ::windows::core::RuntimeName for IVPManager {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPManager";
}
impl IVPManagerVtbl {
    pub const fn new<Impl: IVPManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPManagerVtbl {
        unsafe extern "system" fn SetVideoPortIndex<Impl: IVPManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwvideoportindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoPortIndex(dwvideoportindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPortIndex<Impl: IVPManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwvideoportindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPortIndex(pdwvideoportindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPManager>, base.5, SetVideoPortIndex::<Impl, OFFSET>, GetVideoPortIndex::<Impl, OFFSET>)
    }
}
pub trait IVPNotifyImpl: Sized + IVPBaseNotifyImpl {
    fn SetDeinterlaceMode();
    fn GetDeinterlaceMode();
}
impl ::windows::core::RuntimeName for IVPNotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPNotify";
}
impl IVPNotifyVtbl {
    pub const fn new<Impl: IVPNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPNotifyVtbl {
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVPNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: AMVP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDeinterlaceMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVPNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut AMVP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceMode(pmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPNotify>, base.5, SetDeinterlaceMode::<Impl, OFFSET>, GetDeinterlaceMode::<Impl, OFFSET>)
    }
}
pub trait IVPNotify2Impl: Sized + IVPNotifyImpl + IVPBaseNotifyImpl {
    fn SetVPSyncMaster();
    fn GetVPSyncMaster();
}
impl ::windows::core::RuntimeName for IVPNotify2 {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPNotify2";
}
impl IVPNotify2Vtbl {
    pub const fn new<Impl: IVPNotify2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPNotify2Vtbl {
        unsafe extern "system" fn SetVPSyncMaster<Impl: IVPNotify2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bvpsyncmaster: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVPSyncMaster(&*(&bvpsyncmaster as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVPSyncMaster<Impl: IVPNotify2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbvpsyncmaster: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVPSyncMaster(&*(&pbvpsyncmaster as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPNotify2>, base.5, SetVPSyncMaster::<Impl, OFFSET>, GetVPSyncMaster::<Impl, OFFSET>)
    }
}
pub trait IVPVBIConfigImpl: Sized + IVPBaseConfigImpl {}
impl ::windows::core::RuntimeName for IVPVBIConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPVBIConfig";
}
impl IVPVBIConfigVtbl {
    pub const fn new<Impl: IVPVBIConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPVBIConfigVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPVBIConfig>, base.5)
    }
}
pub trait IVPVBINotifyImpl: Sized + IVPBaseNotifyImpl {}
impl ::windows::core::RuntimeName for IVPVBINotify {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVPVBINotify";
}
impl IVPVBINotifyVtbl {
    pub const fn new<Impl: IVPVBINotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVPVBINotifyVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVPVBINotify>, base.5)
    }
}
pub trait IVideoEncoderImpl: Sized + IEncoderAPIImpl {}
impl ::windows::core::RuntimeName for IVideoEncoder {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVideoEncoder";
}
impl IVideoEncoderVtbl {
    pub const fn new<Impl: IVideoEncoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVideoEncoderVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVideoEncoder>, base.5)
    }
}
pub trait IVideoFrameStepImpl: Sized {
    fn Step();
    fn CanStep();
    fn CancelStep();
}
impl ::windows::core::RuntimeName for IVideoFrameStep {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVideoFrameStep";
}
impl IVideoFrameStepVtbl {
    pub const fn new<Impl: IVideoFrameStepImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVideoFrameStepVtbl {
        unsafe extern "system" fn Step<Impl: IVideoFrameStepImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwframes: u32, pstepobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Step(dwframes, &*(&pstepobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanStep<Impl: IVideoFrameStepImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bmultiple: i32, pstepobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanStep(bmultiple, &*(&pstepobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelStep<Impl: IVideoFrameStepImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelStep() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVideoFrameStep>, base.5, Step::<Impl, OFFSET>, CanStep::<Impl, OFFSET>, CancelStep::<Impl, OFFSET>)
    }
}
pub trait IVideoProcAmpImpl: Sized {
    fn BacklightCompensation();
    fn SetBacklightCompensation();
    fn getRange_BacklightCompensation();
    fn Brightness();
    fn SetBrightness();
    fn getRange_Brightness();
    fn ColorEnable();
    fn SetColorEnable();
    fn getRange_ColorEnable();
    fn Contrast();
    fn SetContrast();
    fn getRange_Contrast();
    fn Gamma();
    fn SetGamma();
    fn getRange_Gamma();
    fn Saturation();
    fn SetSaturation();
    fn getRange_Saturation();
    fn Sharpness();
    fn SetSharpness();
    fn getRange_Sharpness();
    fn WhiteBalance();
    fn SetWhiteBalance();
    fn getRange_WhiteBalance();
    fn Gain();
    fn SetGain();
    fn getRange_Gain();
    fn Hue();
    fn SetHue();
    fn getRange_Hue();
    fn DigitalMultiplier();
    fn SetDigitalMultiplier();
    fn getRange_DigitalMultiplier();
    fn PowerlineFrequency();
    fn SetPowerlineFrequency();
    fn getRange_PowerlineFrequency();
    fn WhiteBalanceComponent();
    fn SetWhiteBalanceComponent();
    fn getRange_WhiteBalanceComponent();
}
impl ::windows::core::RuntimeName for IVideoProcAmp {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVideoProcAmp";
}
impl IVideoProcAmpVtbl {
    pub const fn new<Impl: IVideoProcAmpImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVideoProcAmpVtbl {
        unsafe extern "system" fn BacklightCompensation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BacklightCompensation(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBacklightCompensation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBacklightCompensation(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_BacklightCompensation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_BacklightCompensation(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Brightness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Brightness(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBrightness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBrightness(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Brightness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Brightness(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorEnable<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorEnable(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorEnable<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorEnable(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_ColorEnable<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_ColorEnable(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Contrast<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Contrast(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContrast<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContrast(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Contrast<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Contrast(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Gamma<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Gamma(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGamma<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGamma(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Gamma<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Gamma(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Saturation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Saturation(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSaturation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSaturation(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Saturation<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Saturation(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Sharpness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Sharpness(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSharpness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSharpness(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Sharpness<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Sharpness(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WhiteBalance<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WhiteBalance(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWhiteBalance<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWhiteBalance(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_WhiteBalance<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_WhiteBalance(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Gain<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Gain(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGain<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGain(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Gain<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Gain(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Hue<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Hue(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHue<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHue(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_Hue<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_Hue(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DigitalMultiplier<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DigitalMultiplier(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDigitalMultiplier<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDigitalMultiplier(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_DigitalMultiplier<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_DigitalMultiplier(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PowerlineFrequency<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PowerlineFrequency(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPowerlineFrequency<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPowerlineFrequency(value, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_PowerlineFrequency<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_PowerlineFrequency(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WhiteBalanceComponent<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WhiteBalanceComponent(::core::mem::transmute_copy(&pvalue1), ::core::mem::transmute_copy(&pvalue2), pflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWhiteBalanceComponent<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value1: i32, value2: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWhiteBalanceComponent(value1, value2, flags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getRange_WhiteBalanceComponent<Impl: IVideoProcAmpImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).getRange_WhiteBalanceComponent(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), pcapsflag) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVideoProcAmp>,
            base.5,
            BacklightCompensation::<Impl, OFFSET>,
            SetBacklightCompensation::<Impl, OFFSET>,
            getRange_BacklightCompensation::<Impl, OFFSET>,
            Brightness::<Impl, OFFSET>,
            SetBrightness::<Impl, OFFSET>,
            getRange_Brightness::<Impl, OFFSET>,
            ColorEnable::<Impl, OFFSET>,
            SetColorEnable::<Impl, OFFSET>,
            getRange_ColorEnable::<Impl, OFFSET>,
            Contrast::<Impl, OFFSET>,
            SetContrast::<Impl, OFFSET>,
            getRange_Contrast::<Impl, OFFSET>,
            Gamma::<Impl, OFFSET>,
            SetGamma::<Impl, OFFSET>,
            getRange_Gamma::<Impl, OFFSET>,
            Saturation::<Impl, OFFSET>,
            SetSaturation::<Impl, OFFSET>,
            getRange_Saturation::<Impl, OFFSET>,
            Sharpness::<Impl, OFFSET>,
            SetSharpness::<Impl, OFFSET>,
            getRange_Sharpness::<Impl, OFFSET>,
            WhiteBalance::<Impl, OFFSET>,
            SetWhiteBalance::<Impl, OFFSET>,
            getRange_WhiteBalance::<Impl, OFFSET>,
            Gain::<Impl, OFFSET>,
            SetGain::<Impl, OFFSET>,
            getRange_Gain::<Impl, OFFSET>,
            Hue::<Impl, OFFSET>,
            SetHue::<Impl, OFFSET>,
            getRange_Hue::<Impl, OFFSET>,
            DigitalMultiplier::<Impl, OFFSET>,
            SetDigitalMultiplier::<Impl, OFFSET>,
            getRange_DigitalMultiplier::<Impl, OFFSET>,
            PowerlineFrequency::<Impl, OFFSET>,
            SetPowerlineFrequency::<Impl, OFFSET>,
            getRange_PowerlineFrequency::<Impl, OFFSET>,
            WhiteBalanceComponent::<Impl, OFFSET>,
            SetWhiteBalanceComponent::<Impl, OFFSET>,
            getRange_WhiteBalanceComponent::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IVideoWindowImpl: Sized + IDispatchImpl {
    fn SetCaption();
    fn Caption();
    fn SetWindowStyle();
    fn WindowStyle();
    fn SetWindowStyleEx();
    fn WindowStyleEx();
    fn SetAutoShow();
    fn AutoShow();
    fn SetWindowState();
    fn WindowState();
    fn SetBackgroundPalette();
    fn BackgroundPalette();
    fn SetVisible();
    fn Visible();
    fn SetLeft();
    fn Left();
    fn SetWidth();
    fn Width();
    fn SetTop();
    fn Top();
    fn SetHeight();
    fn Height();
    fn SetOwner();
    fn Owner();
    fn SetMessageDrain();
    fn MessageDrain();
    fn BorderColor();
    fn SetBorderColor();
    fn FullScreenMode();
    fn SetFullScreenMode();
    fn SetWindowForeground();
    fn NotifyOwnerMessage();
    fn SetWindowPosition();
    fn GetWindowPosition();
    fn GetMinIdealImageSize();
    fn GetMaxIdealImageSize();
    fn GetRestorePosition();
    fn HideCursor();
    fn IsCursorHidden();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IVideoWindow {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IVideoWindow";
}
#[cfg(feature = "Win32_System_Com")]
impl IVideoWindowVtbl {
    pub const fn new<Impl: IVideoWindowImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVideoWindowVtbl {
        unsafe extern "system" fn SetCaption<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strcaption: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCaption(&*(&strcaption as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Caption<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, strcaption: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Caption(::core::mem::transmute_copy(&strcaption)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowStyle<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstyle: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowStyle(windowstyle) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WindowStyle<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstyle: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WindowStyle(::core::mem::transmute_copy(&windowstyle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowStyleEx<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstyleex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowStyleEx(windowstyleex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WindowStyleEx<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstyleex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WindowStyleEx(::core::mem::transmute_copy(&windowstyleex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoShow<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, autoshow: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAutoShow(autoshow) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoShow<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, autoshow: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoShow(::core::mem::transmute_copy(&autoshow)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowState<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowState(windowstate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WindowState<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windowstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WindowState(::core::mem::transmute_copy(&windowstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundPalette<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, backgroundpalette: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundPalette(backgroundpalette) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundPalette<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbackgroundpalette: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundPalette(::core::mem::transmute_copy(&pbackgroundpalette)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisible<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, visible: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVisible(visible) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Visible<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvisible: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Visible(::core::mem::transmute_copy(&pvisible)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, left: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLeft(left) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Left<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Left(::core::mem::transmute_copy(&pleft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, width: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWidth(width) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Width<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Width(::core::mem::transmute_copy(&pwidth)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, top: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTop(top) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Top<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Top(::core::mem::transmute_copy(&ptop)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHeight(height) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Height<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Height(::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOwner<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, owner: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOwner(owner) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Owner<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, owner: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Owner(::core::mem::transmute_copy(&owner)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMessageDrain<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, drain: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMessageDrain(drain) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MessageDrain<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, drain: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MessageDrain(::core::mem::transmute_copy(&drain)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderColor<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderColor(::core::mem::transmute_copy(&color)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(color) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FullScreenMode<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fullscreenmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FullScreenMode(::core::mem::transmute_copy(&fullscreenmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullScreenMode<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fullscreenmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFullScreenMode(fullscreenmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowForeground<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, focus: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowForeground(focus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyOwnerMessage<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyOwnerMessage(hwnd, umsg, wparam, lparam) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowPosition<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWindowPosition(left, top, width, height) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWindowPosition<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWindowPosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinIdealImageSize<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMinIdealImageSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxIdealImageSize<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxIdealImageSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRestorePosition<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRestorePosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HideCursor<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hidecursor: OA_BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HideCursor(hidecursor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCursorHidden<Impl: IVideoWindowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cursorhidden: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCursorHidden(::core::mem::transmute_copy(&cursorhidden)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVideoWindow>,
            base.5,
            SetCaption::<Impl, OFFSET>,
            Caption::<Impl, OFFSET>,
            SetWindowStyle::<Impl, OFFSET>,
            WindowStyle::<Impl, OFFSET>,
            SetWindowStyleEx::<Impl, OFFSET>,
            WindowStyleEx::<Impl, OFFSET>,
            SetAutoShow::<Impl, OFFSET>,
            AutoShow::<Impl, OFFSET>,
            SetWindowState::<Impl, OFFSET>,
            WindowState::<Impl, OFFSET>,
            SetBackgroundPalette::<Impl, OFFSET>,
            BackgroundPalette::<Impl, OFFSET>,
            SetVisible::<Impl, OFFSET>,
            Visible::<Impl, OFFSET>,
            SetLeft::<Impl, OFFSET>,
            Left::<Impl, OFFSET>,
            SetWidth::<Impl, OFFSET>,
            Width::<Impl, OFFSET>,
            SetTop::<Impl, OFFSET>,
            Top::<Impl, OFFSET>,
            SetHeight::<Impl, OFFSET>,
            Height::<Impl, OFFSET>,
            SetOwner::<Impl, OFFSET>,
            Owner::<Impl, OFFSET>,
            SetMessageDrain::<Impl, OFFSET>,
            MessageDrain::<Impl, OFFSET>,
            BorderColor::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            FullScreenMode::<Impl, OFFSET>,
            SetFullScreenMode::<Impl, OFFSET>,
            SetWindowForeground::<Impl, OFFSET>,
            NotifyOwnerMessage::<Impl, OFFSET>,
            SetWindowPosition::<Impl, OFFSET>,
            GetWindowPosition::<Impl, OFFSET>,
            GetMinIdealImageSize::<Impl, OFFSET>,
            GetMaxIdealImageSize::<Impl, OFFSET>,
            GetRestorePosition::<Impl, OFFSET>,
            HideCursor::<Impl, OFFSET>,
            IsCursorHidden::<Impl, OFFSET>,
        )
    }
}
pub trait IXDSCodecImpl: Sized {
    fn XDSToRatObjOK();
    fn SetCCSubstreamService();
    fn CCSubstreamService();
    fn GetContentAdvisoryRating();
    fn GetXDSPacket();
    fn GetCurrLicenseExpDate();
    fn GetLastErrorCode();
}
impl ::windows::core::RuntimeName for IXDSCodec {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IXDSCodec";
}
impl IXDSCodecVtbl {
    pub const fn new<Impl: IXDSCodecImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IXDSCodecVtbl {
        unsafe extern "system" fn XDSToRatObjOK<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XDSToRatObjOK(::core::mem::transmute_copy(&phrcocreateretval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCCSubstreamService<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, substreammask: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCCSubstreamService(substreammask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCSubstreamService<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psubstreammask: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CCSubstreamService(::core::mem::transmute_copy(&psubstreammask)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContentAdvisoryRating<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prat: *mut i32, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContentAdvisoryRating(::core::mem::transmute_copy(&prat), ::core::mem::transmute_copy(&ppktseqid), ::core::mem::transmute_copy(&pcallseqid), ::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetXDSPacket<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pxdsclasspkt: *mut i32, pxdstypepkt: *mut i32, pbstrxdspkt: *mut super::super::Foundation::BSTR, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetXDSPacket(::core::mem::transmute_copy(&pxdsclasspkt), ::core::mem::transmute_copy(&pxdstypepkt), ::core::mem::transmute_copy(&pbstrxdspkt), ::core::mem::transmute_copy(&ppktseqid), ::core::mem::transmute_copy(&pcallseqid), ::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(prottype, ::core::mem::transmute_copy(&lpdatetime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IXDSCodecImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IXDSCodec>, base.5, XDSToRatObjOK::<Impl, OFFSET>, SetCCSubstreamService::<Impl, OFFSET>, CCSubstreamService::<Impl, OFFSET>, GetContentAdvisoryRating::<Impl, OFFSET>, GetXDSPacket::<Impl, OFFSET>, GetCurrLicenseExpDate::<Impl, OFFSET>, GetLastErrorCode::<Impl, OFFSET>)
    }
}
pub trait IXDSCodecConfigImpl: Sized {
    fn GetSecureChannelObject();
    fn SetPauseBufferTime();
}
impl ::windows::core::RuntimeName for IXDSCodecConfig {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IXDSCodecConfig";
}
impl IXDSCodecConfigVtbl {
    pub const fn new<Impl: IXDSCodecConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IXDSCodecConfigVtbl {
        unsafe extern "system" fn GetSecureChannelObject<Impl: IXDSCodecConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject(::core::mem::transmute_copy(&ppunkdrmsecurechannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPauseBufferTime<Impl: IXDSCodecConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwpausebuffertime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPauseBufferTime(dwpausebuffertime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IXDSCodecConfig>, base.5, GetSecureChannelObject::<Impl, OFFSET>, SetPauseBufferTime::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IXDSCodecEventsImpl: Sized + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IXDSCodecEvents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IXDSCodecEvents";
}
#[cfg(feature = "Win32_System_Com")]
impl IXDSCodecEventsVtbl {
    pub const fn new<Impl: IXDSCodecEventsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IXDSCodecEventsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IXDSCodecEvents>, base.5)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IXDSToRatImpl: Sized + IDispatchImpl {
    fn Init();
    fn ParseXDSBytePair();
}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for IXDSToRat {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow.IXDSToRat";
}
#[cfg(feature = "Win32_System_Com")]
impl IXDSToRatVtbl {
    pub const fn new<Impl: IXDSToRatImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IXDSToRatVtbl {
        unsafe extern "system" fn Init<Impl: IXDSToRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParseXDSBytePair<Impl: IXDSToRatImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, byte1: u8, byte2: u8, pensystem: *mut EnTvRat_System, penlevel: *mut EnTvRat_GenericLevel, plbfenattributes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParseXDSBytePair(byte1, byte2, ::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penlevel), ::core::mem::transmute_copy(&plbfenattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IXDSToRat>, base.5, Init::<Impl, OFFSET>, ParseXDSBytePair::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait _IMSVidCtlEventsImpl: Sized + IDispatchImpl {}
#[cfg(feature = "Win32_System_Com")]
impl ::windows::core::RuntimeName for _IMSVidCtlEvents {
    const NAME: &'static str = "Windows.Win32.Media.DirectShow._IMSVidCtlEvents";
}
#[cfg(feature = "Win32_System_Com")]
impl _IMSVidCtlEventsVtbl {
    pub const fn new<Impl: _IMSVidCtlEventsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> _IMSVidCtlEventsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<_IMSVidCtlEvents>, base.5)
    }
}
