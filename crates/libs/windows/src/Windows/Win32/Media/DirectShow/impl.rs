pub trait IAMAnalogVideoDecoder_Impl: Sized {
    fn AvailableTVFormats(&mut self) -> ::windows::core::Result<i32>;
    fn SetTVFormat(&mut self, lanalogvideostandard: i32) -> ::windows::core::Result<()>;
    fn TVFormat(&mut self) -> ::windows::core::Result<i32>;
    fn HorizontalLocked(&mut self) -> ::windows::core::Result<i32>;
    fn SetVCRHorizontalLocking(&mut self, lvcrhorizontallocking: i32) -> ::windows::core::Result<()>;
    fn VCRHorizontalLocking(&mut self) -> ::windows::core::Result<i32>;
    fn NumberOfLines(&mut self) -> ::windows::core::Result<i32>;
    fn SetOutputEnable(&mut self, loutputenable: i32) -> ::windows::core::Result<()>;
    fn OutputEnable(&mut self) -> ::windows::core::Result<i32>;
}
impl IAMAnalogVideoDecoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMAnalogVideoDecoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMAnalogVideoDecoder_Vtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats() {
                ::core::result::Result::Ok(ok__) => {
                    *lanalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVFormat<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTVFormat(::core::mem::transmute_copy(&lanalogvideostandard)).into()
        }
        unsafe extern "system" fn TVFormat<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TVFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *planalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalLocked<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pllocked: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HorizontalLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *pllocked = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVCRHorizontalLocking<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvcrhorizontallocking: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVCRHorizontalLocking(::core::mem::transmute_copy(&lvcrhorizontallocking)).into()
        }
        unsafe extern "system" fn VCRHorizontalLocking<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plvcrhorizontallocking: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VCRHorizontalLocking() {
                ::core::result::Result::Ok(ok__) => {
                    *plvcrhorizontallocking = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfLines<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plnumberoflines: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfLines() {
                ::core::result::Result::Ok(ok__) => {
                    *plnumberoflines = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputEnable<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, loutputenable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputEnable(::core::mem::transmute_copy(&loutputenable)).into()
        }
        unsafe extern "system" fn OutputEnable<Impl: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ploutputenable: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutputEnable() {
                ::core::result::Result::Ok(ok__) => {
                    *ploutputenable = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Impl, IMPL_OFFSET>,
            SetTVFormat: SetTVFormat::<Impl, IMPL_OFFSET>,
            TVFormat: TVFormat::<Impl, IMPL_OFFSET>,
            HorizontalLocked: HorizontalLocked::<Impl, IMPL_OFFSET>,
            SetVCRHorizontalLocking: SetVCRHorizontalLocking::<Impl, IMPL_OFFSET>,
            VCRHorizontalLocking: VCRHorizontalLocking::<Impl, IMPL_OFFSET>,
            NumberOfLines: NumberOfLines::<Impl, IMPL_OFFSET>,
            SetOutputEnable: SetOutputEnable::<Impl, IMPL_OFFSET>,
            OutputEnable: OutputEnable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMAnalogVideoDecoder as ::windows::core::Interface>::IID
    }
}
pub trait IAMAnalogVideoEncoder_Impl: Sized {
    fn AvailableTVFormats(&mut self) -> ::windows::core::Result<i32>;
    fn SetTVFormat(&mut self, lanalogvideostandard: i32) -> ::windows::core::Result<()>;
    fn TVFormat(&mut self) -> ::windows::core::Result<i32>;
    fn SetCopyProtection(&mut self, lvideocopyprotection: i32) -> ::windows::core::Result<()>;
    fn CopyProtection(&mut self) -> ::windows::core::Result<i32>;
    fn SetCCEnable(&mut self, lccenable: i32) -> ::windows::core::Result<()>;
    fn CCEnable(&mut self) -> ::windows::core::Result<i32>;
}
impl IAMAnalogVideoEncoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMAnalogVideoEncoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMAnalogVideoEncoder_Vtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats() {
                ::core::result::Result::Ok(ok__) => {
                    *lanalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVFormat<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTVFormat(::core::mem::transmute_copy(&lanalogvideostandard)).into()
        }
        unsafe extern "system" fn TVFormat<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TVFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *planalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCopyProtection<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvideocopyprotection: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCopyProtection(::core::mem::transmute_copy(&lvideocopyprotection)).into()
        }
        unsafe extern "system" fn CopyProtection<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvideocopyprotection: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CopyProtection() {
                ::core::result::Result::Ok(ok__) => {
                    *lvideocopyprotection = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCCEnable<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lccenable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCCEnable(::core::mem::transmute_copy(&lccenable)).into()
        }
        unsafe extern "system" fn CCEnable<Impl: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lccenable: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CCEnable() {
                ::core::result::Result::Ok(ok__) => {
                    *lccenable = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Impl, IMPL_OFFSET>,
            SetTVFormat: SetTVFormat::<Impl, IMPL_OFFSET>,
            TVFormat: TVFormat::<Impl, IMPL_OFFSET>,
            SetCopyProtection: SetCopyProtection::<Impl, IMPL_OFFSET>,
            CopyProtection: CopyProtection::<Impl, IMPL_OFFSET>,
            SetCCEnable: SetCCEnable::<Impl, IMPL_OFFSET>,
            CCEnable: CCEnable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMAnalogVideoEncoder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMAsyncReaderTimestampScaling_Impl: Sized {
    fn GetTimestampMode(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetTimestampMode(&mut self, fraw: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMAsyncReaderTimestampScaling_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMAsyncReaderTimestampScaling_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMAsyncReaderTimestampScaling_Vtbl {
        unsafe extern "system" fn GetTimestampMode<Impl: IAMAsyncReaderTimestampScaling_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfraw: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimestampMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pfraw = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimestampMode<Impl: IAMAsyncReaderTimestampScaling_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fraw: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimestampMode(::core::mem::transmute_copy(&fraw)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTimestampMode: GetTimestampMode::<Impl, IMPL_OFFSET>,
            SetTimestampMode: SetTimestampMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMAsyncReaderTimestampScaling as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMAudioInputMixer_Impl: Sized {
    fn SetEnable(&mut self, fenable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Enable(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetMono(&mut self, fmono: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Mono(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetMixLevel(&mut self, level: f64) -> ::windows::core::Result<()>;
    fn MixLevel(&mut self) -> ::windows::core::Result<f64>;
    fn SetPan(&mut self, pan: f64) -> ::windows::core::Result<()>;
    fn Pan(&mut self) -> ::windows::core::Result<f64>;
    fn SetLoudness(&mut self, floudness: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Loudness(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetTreble(&mut self, treble: f64) -> ::windows::core::Result<()>;
    fn Treble(&mut self) -> ::windows::core::Result<f64>;
    fn TrebleRange(&mut self) -> ::windows::core::Result<f64>;
    fn SetBass(&mut self, bass: f64) -> ::windows::core::Result<()>;
    fn Bass(&mut self) -> ::windows::core::Result<f64>;
    fn BassRange(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMAudioInputMixer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMAudioInputMixer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMAudioInputMixer_Vtbl {
        unsafe extern "system" fn SetEnable<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnable(::core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn Enable<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfenable: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Enable() {
                ::core::result::Result::Ok(ok__) => {
                    *pfenable = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMono<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmono: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMono(::core::mem::transmute_copy(&fmono)).into()
        }
        unsafe extern "system" fn Mono<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfmono: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mono() {
                ::core::result::Result::Ok(ok__) => {
                    *pfmono = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixLevel<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, level: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixLevel(::core::mem::transmute_copy(&level)).into()
        }
        unsafe extern "system" fn MixLevel<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plevel: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MixLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *plevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPan<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pan: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPan(::core::mem::transmute_copy(&pan)).into()
        }
        unsafe extern "system" fn Pan<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppan: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pan() {
                ::core::result::Result::Ok(ok__) => {
                    *ppan = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLoudness<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, floudness: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLoudness(::core::mem::transmute_copy(&floudness)).into()
        }
        unsafe extern "system" fn Loudness<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfloudness: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Loudness() {
                ::core::result::Result::Ok(ok__) => {
                    *pfloudness = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTreble<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, treble: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTreble(::core::mem::transmute_copy(&treble)).into()
        }
        unsafe extern "system" fn Treble<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptreble: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Treble() {
                ::core::result::Result::Ok(ok__) => {
                    *ptreble = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TrebleRange<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prange: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TrebleRange() {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBass<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bass: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBass(::core::mem::transmute_copy(&bass)).into()
        }
        unsafe extern "system" fn Bass<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbass: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bass() {
                ::core::result::Result::Ok(ok__) => {
                    *pbass = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BassRange<Impl: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prange: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BassRange() {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetEnable: SetEnable::<Impl, IMPL_OFFSET>,
            Enable: Enable::<Impl, IMPL_OFFSET>,
            SetMono: SetMono::<Impl, IMPL_OFFSET>,
            Mono: Mono::<Impl, IMPL_OFFSET>,
            SetMixLevel: SetMixLevel::<Impl, IMPL_OFFSET>,
            MixLevel: MixLevel::<Impl, IMPL_OFFSET>,
            SetPan: SetPan::<Impl, IMPL_OFFSET>,
            Pan: Pan::<Impl, IMPL_OFFSET>,
            SetLoudness: SetLoudness::<Impl, IMPL_OFFSET>,
            Loudness: Loudness::<Impl, IMPL_OFFSET>,
            SetTreble: SetTreble::<Impl, IMPL_OFFSET>,
            Treble: Treble::<Impl, IMPL_OFFSET>,
            TrebleRange: TrebleRange::<Impl, IMPL_OFFSET>,
            SetBass: SetBass::<Impl, IMPL_OFFSET>,
            Bass: Bass::<Impl, IMPL_OFFSET>,
            BassRange: BassRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMAudioInputMixer as ::windows::core::Interface>::IID
    }
}
pub trait IAMAudioRendererStats_Impl: Sized {
    fn GetStatParam(&mut self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::Result<()>;
}
impl IAMAudioRendererStats_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMAudioRendererStats_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMAudioRendererStats_Vtbl {
        unsafe extern "system" fn GetStatParam<Impl: IAMAudioRendererStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStatParam(::core::mem::transmute_copy(&dwparam), ::core::mem::transmute_copy(&pdwparam1), ::core::mem::transmute_copy(&pdwparam2)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetStatParam: GetStatParam::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMAudioRendererStats as ::windows::core::Interface>::IID
    }
}
pub trait IAMBufferNegotiation_Impl: Sized {
    fn SuggestAllocatorProperties(&mut self, pprop: *const ALLOCATOR_PROPERTIES) -> ::windows::core::Result<()>;
    fn GetAllocatorProperties(&mut self) -> ::windows::core::Result<ALLOCATOR_PROPERTIES>;
}
impl IAMBufferNegotiation_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMBufferNegotiation_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMBufferNegotiation_Vtbl {
        unsafe extern "system" fn SuggestAllocatorProperties<Impl: IAMBufferNegotiation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprop: *const ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SuggestAllocatorProperties(::core::mem::transmute_copy(&pprop)).into()
        }
        unsafe extern "system" fn GetAllocatorProperties<Impl: IAMBufferNegotiation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprop: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllocatorProperties() {
                ::core::result::Result::Ok(ok__) => {
                    *pprop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SuggestAllocatorProperties: SuggestAllocatorProperties::<Impl, IMPL_OFFSET>,
            GetAllocatorProperties: GetAllocatorProperties::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMBufferNegotiation as ::windows::core::Interface>::IID
    }
}
pub trait IAMCameraControl_Impl: Sized {
    fn GetRange(&mut self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::Result<()>;
    fn Set(&mut self, property: i32, lvalue: i32, flags: i32) -> ::windows::core::Result<()>;
    fn Get(&mut self, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::Result<()>;
}
impl IAMCameraControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMCameraControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMCameraControl_Vtbl {
        unsafe extern "system" fn GetRange<Impl: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRange(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflags)).into()
        }
        unsafe extern "system" fn Set<Impl: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn Get<Impl: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Get(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetRange: GetRange::<Impl, IMPL_OFFSET>,
            Set: Set::<Impl, IMPL_OFFSET>,
            Get: Get::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMCameraControl as ::windows::core::Interface>::IID
    }
}
pub trait IAMCertifiedOutputProtection_Impl: Sized {
    fn KeyExchange(&mut self, prandom: *mut ::windows::core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> ::windows::core::Result<()>;
    fn SessionSequenceStart(&mut self, psig: *mut AMCOPPSignature) -> ::windows::core::Result<()>;
    fn ProtectionCommand(&mut self, cmd: *const AMCOPPCommand) -> ::windows::core::Result<()>;
    fn ProtectionStatus(&mut self, pstatusinput: *const AMCOPPStatusInput) -> ::windows::core::Result<AMCOPPStatusOutput>;
}
impl IAMCertifiedOutputProtection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMCertifiedOutputProtection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMCertifiedOutputProtection_Vtbl {
        unsafe extern "system" fn KeyExchange<Impl: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prandom: *mut ::windows::core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyExchange(::core::mem::transmute_copy(&prandom), ::core::mem::transmute_copy(&varlencertgh), ::core::mem::transmute_copy(&pdwlengthcertgh)).into()
        }
        unsafe extern "system" fn SessionSequenceStart<Impl: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psig: *mut AMCOPPSignature) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SessionSequenceStart(::core::mem::transmute_copy(&psig)).into()
        }
        unsafe extern "system" fn ProtectionCommand<Impl: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cmd: *const AMCOPPCommand) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProtectionCommand(::core::mem::transmute_copy(&cmd)).into()
        }
        unsafe extern "system" fn ProtectionStatus<Impl: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatusinput: *const AMCOPPStatusInput, pstatusoutput: *mut AMCOPPStatusOutput) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProtectionStatus(::core::mem::transmute_copy(&pstatusinput)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstatusoutput = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            KeyExchange: KeyExchange::<Impl, IMPL_OFFSET>,
            SessionSequenceStart: SessionSequenceStart::<Impl, IMPL_OFFSET>,
            ProtectionCommand: ProtectionCommand::<Impl, IMPL_OFFSET>,
            ProtectionStatus: ProtectionStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMCertifiedOutputProtection as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMChannelInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn ChannelName(&mut self, pbstrchannelname: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ChannelDescription(&mut self, pbstrchanneldescription: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ChannelURL(&mut self, pbstrchannelurl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ContactAddress(&mut self, pbstrcontactaddress: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ContactPhone(&mut self, pbstrcontactphone: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ContactEmail(&mut self, pbstrcontactemail: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMChannelInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMChannelInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMChannelInfo_Vtbl {
        unsafe extern "system" fn ChannelName<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrchannelname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChannelName(::core::mem::transmute_copy(&pbstrchannelname)).into()
        }
        unsafe extern "system" fn ChannelDescription<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrchanneldescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChannelDescription(::core::mem::transmute_copy(&pbstrchanneldescription)).into()
        }
        unsafe extern "system" fn ChannelURL<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrchannelurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChannelURL(::core::mem::transmute_copy(&pbstrchannelurl)).into()
        }
        unsafe extern "system" fn ContactAddress<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrcontactaddress: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContactAddress(::core::mem::transmute_copy(&pbstrcontactaddress)).into()
        }
        unsafe extern "system" fn ContactPhone<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrcontactphone: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContactPhone(::core::mem::transmute_copy(&pbstrcontactphone)).into()
        }
        unsafe extern "system" fn ContactEmail<Impl: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrcontactemail: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContactEmail(::core::mem::transmute_copy(&pbstrcontactemail)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ChannelName: ChannelName::<Impl, IMPL_OFFSET>,
            ChannelDescription: ChannelDescription::<Impl, IMPL_OFFSET>,
            ChannelURL: ChannelURL::<Impl, IMPL_OFFSET>,
            ContactAddress: ContactAddress::<Impl, IMPL_OFFSET>,
            ContactPhone: ContactPhone::<Impl, IMPL_OFFSET>,
            ContactEmail: ContactEmail::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMChannelInfo as ::windows::core::Interface>::IID
    }
}
pub trait IAMClockAdjust_Impl: Sized {
    fn SetClockDelta(&mut self, rtdelta: i64) -> ::windows::core::Result<()>;
}
impl IAMClockAdjust_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMClockAdjust_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMClockAdjust_Vtbl {
        unsafe extern "system" fn SetClockDelta<Impl: IAMClockAdjust_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtdelta: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockDelta(::core::mem::transmute_copy(&rtdelta)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetClockDelta: SetClockDelta::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMClockAdjust as ::windows::core::Interface>::IID
    }
}
pub trait IAMClockSlave_Impl: Sized {
    fn SetErrorTolerance(&mut self, dwtolerance: u32) -> ::windows::core::Result<()>;
    fn GetErrorTolerance(&mut self) -> ::windows::core::Result<u32>;
}
impl IAMClockSlave_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMClockSlave_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMClockSlave_Vtbl {
        unsafe extern "system" fn SetErrorTolerance<Impl: IAMClockSlave_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtolerance: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetErrorTolerance(::core::mem::transmute_copy(&dwtolerance)).into()
        }
        unsafe extern "system" fn GetErrorTolerance<Impl: IAMClockSlave_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwtolerance: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetErrorTolerance() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtolerance = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetErrorTolerance: SetErrorTolerance::<Impl, IMPL_OFFSET>,
            GetErrorTolerance: GetErrorTolerance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMClockSlave as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMCollection_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn Item(&mut self, litem: i32) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMCollection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMCollection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMCollection_Vtbl {
        unsafe extern "system" fn Count<Impl: IAMCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *plcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IAMCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, litem: i32, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&litem)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IAMCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMCollection as ::windows::core::Interface>::IID
    }
}
pub trait IAMCopyCaptureFileProgress_Impl: Sized {
    fn Progress(&mut self, iprogress: i32) -> ::windows::core::Result<()>;
}
impl IAMCopyCaptureFileProgress_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMCopyCaptureFileProgress_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMCopyCaptureFileProgress_Vtbl {
        unsafe extern "system" fn Progress<Impl: IAMCopyCaptureFileProgress_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, iprogress: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Progress(::core::mem::transmute_copy(&iprogress)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Progress: Progress::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMCopyCaptureFileProgress as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMCrossbar_Impl: Sized {
    fn PinCounts(&mut self, outputpincount: *mut i32, inputpincount: *mut i32) -> ::windows::core::Result<()>;
    fn CanRoute(&mut self, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::Result<()>;
    fn Route(&mut self, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::Result<()>;
    fn IsRoutedTo(&mut self, outputpinindex: i32) -> ::windows::core::Result<i32>;
    fn CrossbarPinInfo(&mut self, isinputpin: super::super::Foundation::BOOL, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMCrossbar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMCrossbar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMCrossbar_Vtbl {
        unsafe extern "system" fn PinCounts<Impl: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputpincount: *mut i32, inputpincount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PinCounts(::core::mem::transmute_copy(&outputpincount), ::core::mem::transmute_copy(&inputpincount)).into()
        }
        unsafe extern "system" fn CanRoute<Impl: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CanRoute(::core::mem::transmute_copy(&outputpinindex), ::core::mem::transmute_copy(&inputpinindex)).into()
        }
        unsafe extern "system" fn Route<Impl: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Route(::core::mem::transmute_copy(&outputpinindex), ::core::mem::transmute_copy(&inputpinindex)).into()
        }
        unsafe extern "system" fn IsRoutedTo<Impl: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputpinindex: i32, inputpinindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRoutedTo(::core::mem::transmute_copy(&outputpinindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *inputpinindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CrossbarPinInfo<Impl: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isinputpin: super::super::Foundation::BOOL, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CrossbarPinInfo(::core::mem::transmute_copy(&isinputpin), ::core::mem::transmute_copy(&pinindex), ::core::mem::transmute_copy(&pinindexrelated), ::core::mem::transmute_copy(&physicaltype)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            PinCounts: PinCounts::<Impl, IMPL_OFFSET>,
            CanRoute: CanRoute::<Impl, IMPL_OFFSET>,
            Route: Route::<Impl, IMPL_OFFSET>,
            IsRoutedTo: IsRoutedTo::<Impl, IMPL_OFFSET>,
            CrossbarPinInfo: CrossbarPinInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMCrossbar as ::windows::core::Interface>::IID
    }
}
pub trait IAMDecoderCaps_Impl: Sized {
    fn GetDecoderCaps(&mut self, dwcapindex: u32) -> ::windows::core::Result<u32>;
}
impl IAMDecoderCaps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDecoderCaps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDecoderCaps_Vtbl {
        unsafe extern "system" fn GetDecoderCaps<Impl: IAMDecoderCaps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcapindex: u32, lpdwcap: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDecoderCaps(::core::mem::transmute_copy(&dwcapindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdwcap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetDecoderCaps: GetDecoderCaps::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDecoderCaps as ::windows::core::Interface>::IID
    }
}
pub trait IAMDevMemoryAllocator_Impl: Sized {
    fn GetInfo(&mut self, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> ::windows::core::Result<()>;
    fn CheckMemory(&mut self, pbuffer: *const u8) -> ::windows::core::Result<()>;
    fn Alloc(&mut self, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> ::windows::core::Result<()>;
    fn Free(&mut self, pbuffer: *mut u8) -> ::windows::core::Result<()>;
    fn GetDevMemoryObject(&mut self, ppunkinnner: *mut ::core::option::Option<::windows::core::IUnknown>, punkouter: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IAMDevMemoryAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDevMemoryAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDevMemoryAllocator_Vtbl {
        unsafe extern "system" fn GetInfo<Impl: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInfo(::core::mem::transmute_copy(&pdwcbtotalfree), ::core::mem::transmute_copy(&pdwcblargestfree), ::core::mem::transmute_copy(&pdwcbtotalmemory), ::core::mem::transmute_copy(&pdwcbminimumchunk)).into()
        }
        unsafe extern "system" fn CheckMemory<Impl: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CheckMemory(::core::mem::transmute_copy(&pbuffer)).into()
        }
        unsafe extern "system" fn Alloc<Impl: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Alloc(::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&pdwcbbuffer)).into()
        }
        unsafe extern "system" fn Free<Impl: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Free(::core::mem::transmute_copy(&pbuffer)).into()
        }
        unsafe extern "system" fn GetDevMemoryObject<Impl: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunkinnner: *mut *mut ::core::ffi::c_void, punkouter: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDevMemoryObject(::core::mem::transmute_copy(&ppunkinnner), ::core::mem::transmute(&punkouter)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetInfo: GetInfo::<Impl, IMPL_OFFSET>,
            CheckMemory: CheckMemory::<Impl, IMPL_OFFSET>,
            Alloc: Alloc::<Impl, IMPL_OFFSET>,
            Free: Free::<Impl, IMPL_OFFSET>,
            GetDevMemoryObject: GetDevMemoryObject::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDevMemoryAllocator as ::windows::core::Interface>::IID
    }
}
pub trait IAMDevMemoryControl_Impl: Sized {
    fn QueryWriteSync(&mut self) -> ::windows::core::Result<()>;
    fn WriteSync(&mut self) -> ::windows::core::Result<()>;
    fn GetDevId(&mut self) -> ::windows::core::Result<u32>;
}
impl IAMDevMemoryControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDevMemoryControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDevMemoryControl_Vtbl {
        unsafe extern "system" fn QueryWriteSync<Impl: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryWriteSync().into()
        }
        unsafe extern "system" fn WriteSync<Impl: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteSync().into()
        }
        unsafe extern "system" fn GetDevId<Impl: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwdevid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDevId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwdevid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryWriteSync: QueryWriteSync::<Impl, IMPL_OFFSET>,
            WriteSync: WriteSync::<Impl, IMPL_OFFSET>,
            GetDevId: GetDevId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDevMemoryControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMDeviceRemoval_Impl: Sized {
    fn DeviceInfo(&mut self, pclsidinterfaceclass: *mut ::windows::core::GUID, pwszsymboliclink: *mut super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn Reassociate(&mut self) -> ::windows::core::Result<()>;
    fn Disassociate(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMDeviceRemoval_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDeviceRemoval_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDeviceRemoval_Vtbl {
        unsafe extern "system" fn DeviceInfo<Impl: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclsidinterfaceclass: *mut ::windows::core::GUID, pwszsymboliclink: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeviceInfo(::core::mem::transmute_copy(&pclsidinterfaceclass), ::core::mem::transmute_copy(&pwszsymboliclink)).into()
        }
        unsafe extern "system" fn Reassociate<Impl: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reassociate().into()
        }
        unsafe extern "system" fn Disassociate<Impl: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Disassociate().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            DeviceInfo: DeviceInfo::<Impl, IMPL_OFFSET>,
            Reassociate: Reassociate::<Impl, IMPL_OFFSET>,
            Disassociate: Disassociate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDeviceRemoval as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_Audio_DirectSound"))]
pub trait IAMDirectSound_Impl: Sized {
    fn GetDirectSoundInterface(&mut self) -> ::windows::core::Result<super::Audio::DirectSound::IDirectSound>;
    fn GetPrimaryBufferInterface(&mut self) -> ::windows::core::Result<super::Audio::DirectSound::IDirectSoundBuffer>;
    fn GetSecondaryBufferInterface(&mut self) -> ::windows::core::Result<super::Audio::DirectSound::IDirectSoundBuffer>;
    fn ReleaseDirectSoundInterface(&mut self, lpds: &::core::option::Option<super::Audio::DirectSound::IDirectSound>) -> ::windows::core::Result<()>;
    fn ReleasePrimaryBufferInterface(&mut self, lpdsb: &::core::option::Option<super::Audio::DirectSound::IDirectSoundBuffer>) -> ::windows::core::Result<()>;
    fn ReleaseSecondaryBufferInterface(&mut self, lpdsb: &::core::option::Option<super::Audio::DirectSound::IDirectSoundBuffer>) -> ::windows::core::Result<()>;
    fn SetFocusWindow(&mut self, param0: super::super::Foundation::HWND, param1: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetFocusWindow(&mut self, param0: *mut super::super::Foundation::HWND, param1: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_Audio_DirectSound"))]
impl IAMDirectSound_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDirectSound_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDirectSound_Vtbl {
        unsafe extern "system" fn GetDirectSoundInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplpds: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectSoundInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *lplpds = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrimaryBufferInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplpdsb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPrimaryBufferInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *lplpdsb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSecondaryBufferInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplpdsb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSecondaryBufferInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *lplpdsb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseDirectSoundInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpds: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseDirectSoundInterface(::core::mem::transmute(&lpds)).into()
        }
        unsafe extern "system" fn ReleasePrimaryBufferInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdsb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleasePrimaryBufferInterface(::core::mem::transmute(&lpdsb)).into()
        }
        unsafe extern "system" fn ReleaseSecondaryBufferInterface<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdsb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseSecondaryBufferInterface(::core::mem::transmute(&lpdsb)).into()
        }
        unsafe extern "system" fn SetFocusWindow<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param0: super::super::Foundation::HWND, param1: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusWindow(::core::mem::transmute_copy(&param0), ::core::mem::transmute_copy(&param1)).into()
        }
        unsafe extern "system" fn GetFocusWindow<Impl: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param0: *mut super::super::Foundation::HWND, param1: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFocusWindow(::core::mem::transmute_copy(&param0), ::core::mem::transmute_copy(&param1)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDirectSoundInterface: GetDirectSoundInterface::<Impl, IMPL_OFFSET>,
            GetPrimaryBufferInterface: GetPrimaryBufferInterface::<Impl, IMPL_OFFSET>,
            GetSecondaryBufferInterface: GetSecondaryBufferInterface::<Impl, IMPL_OFFSET>,
            ReleaseDirectSoundInterface: ReleaseDirectSoundInterface::<Impl, IMPL_OFFSET>,
            ReleasePrimaryBufferInterface: ReleasePrimaryBufferInterface::<Impl, IMPL_OFFSET>,
            ReleaseSecondaryBufferInterface: ReleaseSecondaryBufferInterface::<Impl, IMPL_OFFSET>,
            SetFocusWindow: SetFocusWindow::<Impl, IMPL_OFFSET>,
            GetFocusWindow: GetFocusWindow::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDirectSound as ::windows::core::Interface>::IID
    }
}
pub trait IAMDroppedFrames_Impl: Sized {
    fn GetNumDropped(&mut self) -> ::windows::core::Result<i32>;
    fn GetNumNotDropped(&mut self) -> ::windows::core::Result<i32>;
    fn GetDroppedInfo(&mut self, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> ::windows::core::Result<()>;
    fn GetAverageFrameSize(&mut self) -> ::windows::core::Result<i32>;
}
impl IAMDroppedFrames_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMDroppedFrames_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMDroppedFrames_Vtbl {
        unsafe extern "system" fn GetNumDropped<Impl: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pldropped: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumDropped() {
                ::core::result::Result::Ok(ok__) => {
                    *pldropped = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumNotDropped<Impl: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plnotdropped: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumNotDropped() {
                ::core::result::Result::Ok(ok__) => {
                    *plnotdropped = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDroppedInfo<Impl: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDroppedInfo(::core::mem::transmute_copy(&lsize), ::core::mem::transmute_copy(&plarray), ::core::mem::transmute_copy(&plnumcopied)).into()
        }
        unsafe extern "system" fn GetAverageFrameSize<Impl: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plaveragesize: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAverageFrameSize() {
                ::core::result::Result::Ok(ok__) => {
                    *plaveragesize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNumDropped: GetNumDropped::<Impl, IMPL_OFFSET>,
            GetNumNotDropped: GetNumNotDropped::<Impl, IMPL_OFFSET>,
            GetDroppedInfo: GetDroppedInfo::<Impl, IMPL_OFFSET>,
            GetAverageFrameSize: GetAverageFrameSize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMDroppedFrames as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMExtDevice_Impl: Sized {
    fn GetCapability(&mut self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::Result<()>;
    fn ExternalDeviceID(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn ExternalDeviceVersion(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn SetDevicePower(&mut self, powermode: i32) -> ::windows::core::Result<()>;
    fn DevicePower(&mut self) -> ::windows::core::Result<i32>;
    fn Calibrate(&mut self, hevent: usize, mode: i32) -> ::windows::core::Result<i32>;
    fn SetDevicePort(&mut self, deviceport: i32) -> ::windows::core::Result<()>;
    fn DevicePort(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMExtDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMExtDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMExtDevice_Vtbl {
        unsafe extern "system" fn GetCapability<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCapability(::core::mem::transmute_copy(&capability), ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdblvalue)).into()
        }
        unsafe extern "system" fn ExternalDeviceID<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExternalDeviceID() {
                ::core::result::Result::Ok(ok__) => {
                    *ppszdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExternalDeviceVersion<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ExternalDeviceVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *ppszdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDevicePower<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, powermode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDevicePower(::core::mem::transmute_copy(&powermode)).into()
        }
        unsafe extern "system" fn DevicePower<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppowermode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DevicePower() {
                ::core::result::Result::Ok(ok__) => {
                    *ppowermode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Calibrate<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hevent: usize, mode: i32, pstatus: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Calibrate(::core::mem::transmute_copy(&hevent), ::core::mem::transmute_copy(&mode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDevicePort<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, deviceport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDevicePort(::core::mem::transmute_copy(&deviceport)).into()
        }
        unsafe extern "system" fn DevicePort<Impl: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeviceport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DevicePort() {
                ::core::result::Result::Ok(ok__) => {
                    *pdeviceport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCapability: GetCapability::<Impl, IMPL_OFFSET>,
            ExternalDeviceID: ExternalDeviceID::<Impl, IMPL_OFFSET>,
            ExternalDeviceVersion: ExternalDeviceVersion::<Impl, IMPL_OFFSET>,
            SetDevicePower: SetDevicePower::<Impl, IMPL_OFFSET>,
            DevicePower: DevicePower::<Impl, IMPL_OFFSET>,
            Calibrate: Calibrate::<Impl, IMPL_OFFSET>,
            SetDevicePort: SetDevicePort::<Impl, IMPL_OFFSET>,
            DevicePort: DevicePort::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMExtDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMExtTransport_Impl: Sized {
    fn GetCapability(&mut self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::Result<()>;
    fn SetMediaState(&mut self, state: i32) -> ::windows::core::Result<()>;
    fn MediaState(&mut self) -> ::windows::core::Result<i32>;
    fn SetLocalControl(&mut self, state: i32) -> ::windows::core::Result<()>;
    fn LocalControl(&mut self) -> ::windows::core::Result<i32>;
    fn GetStatus(&mut self, statusitem: i32) -> ::windows::core::Result<i32>;
    fn GetTransportBasicParameters(&mut self, param: i32, pvalue: *mut i32, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetTransportBasicParameters(&mut self, param: i32, value: i32, pszdata: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetTransportVideoParameters(&mut self, param: i32) -> ::windows::core::Result<i32>;
    fn SetTransportVideoParameters(&mut self, param: i32, value: i32) -> ::windows::core::Result<()>;
    fn GetTransportAudioParameters(&mut self, param: i32) -> ::windows::core::Result<i32>;
    fn SetTransportAudioParameters(&mut self, param: i32, value: i32) -> ::windows::core::Result<()>;
    fn SetMode(&mut self, mode: i32) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<i32>;
    fn SetRate(&mut self, dblrate: f64) -> ::windows::core::Result<()>;
    fn Rate(&mut self) -> ::windows::core::Result<f64>;
    fn GetChase(&mut self, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> ::windows::core::Result<()>;
    fn SetChase(&mut self, enable: i32, offset: i32, hevent: usize) -> ::windows::core::Result<()>;
    fn GetBump(&mut self, pspeed: *mut i32, pduration: *mut i32) -> ::windows::core::Result<()>;
    fn SetBump(&mut self, speed: i32, duration: i32) -> ::windows::core::Result<()>;
    fn AntiClogControl(&mut self) -> ::windows::core::Result<i32>;
    fn SetAntiClogControl(&mut self, enable: i32) -> ::windows::core::Result<()>;
    fn GetEditPropertySet(&mut self, editid: i32) -> ::windows::core::Result<i32>;
    fn SetEditPropertySet(&mut self, peditid: *mut i32, state: i32) -> ::windows::core::Result<()>;
    fn GetEditProperty(&mut self, editid: i32, param: i32) -> ::windows::core::Result<i32>;
    fn SetEditProperty(&mut self, editid: i32, param: i32, value: i32) -> ::windows::core::Result<()>;
    fn EditStart(&mut self) -> ::windows::core::Result<i32>;
    fn SetEditStart(&mut self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMExtTransport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMExtTransport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMExtTransport_Vtbl {
        unsafe extern "system" fn GetCapability<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCapability(::core::mem::transmute_copy(&capability), ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdblvalue)).into()
        }
        unsafe extern "system" fn SetMediaState<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaState(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn MediaState<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaState() {
                ::core::result::Result::Ok(ok__) => {
                    *pstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalControl<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalControl(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn LocalControl<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LocalControl() {
                ::core::result::Result::Ok(ok__) => {
                    *pstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, statusitem: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&statusitem)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportBasicParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32, ppszdata: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTransportBasicParameters(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&ppszdata)).into()
        }
        unsafe extern "system" fn SetTransportBasicParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32, pszdata: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportBasicParameters(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&pszdata)).into()
        }
        unsafe extern "system" fn GetTransportVideoParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportVideoParameters(::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportVideoParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportVideoParameters(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn GetTransportAudioParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportAudioParameters(::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportAudioParameters<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransportAudioParameters(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn SetMode<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn Mode<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *pmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dblrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&dblrate)).into()
        }
        unsafe extern "system" fn Rate<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdblrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Rate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdblrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetChase<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetChase(::core::mem::transmute_copy(&penabled), ::core::mem::transmute_copy(&poffset), ::core::mem::transmute_copy(&phevent)).into()
        }
        unsafe extern "system" fn SetChase<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enable: i32, offset: i32, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChase(::core::mem::transmute_copy(&enable), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn GetBump<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pspeed: *mut i32, pduration: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBump(::core::mem::transmute_copy(&pspeed), ::core::mem::transmute_copy(&pduration)).into()
        }
        unsafe extern "system" fn SetBump<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, speed: i32, duration: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBump(::core::mem::transmute_copy(&speed), ::core::mem::transmute_copy(&duration)).into()
        }
        unsafe extern "system" fn AntiClogControl<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penabled: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AntiClogControl() {
                ::core::result::Result::Ok(ok__) => {
                    *penabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAntiClogControl<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enable: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAntiClogControl(::core::mem::transmute_copy(&enable)).into()
        }
        unsafe extern "system" fn GetEditPropertySet<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, editid: i32, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEditPropertySet(::core::mem::transmute_copy(&editid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditPropertySet<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peditid: *mut i32, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEditPropertySet(::core::mem::transmute_copy(&peditid), ::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn GetEditProperty<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, editid: i32, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEditProperty(::core::mem::transmute_copy(&editid), ::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditProperty<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, editid: i32, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEditProperty(::core::mem::transmute_copy(&editid), ::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn EditStart<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EditStart() {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEditStart<Impl: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEditStart(::core::mem::transmute_copy(&value)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCapability: GetCapability::<Impl, IMPL_OFFSET>,
            SetMediaState: SetMediaState::<Impl, IMPL_OFFSET>,
            MediaState: MediaState::<Impl, IMPL_OFFSET>,
            SetLocalControl: SetLocalControl::<Impl, IMPL_OFFSET>,
            LocalControl: LocalControl::<Impl, IMPL_OFFSET>,
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            GetTransportBasicParameters: GetTransportBasicParameters::<Impl, IMPL_OFFSET>,
            SetTransportBasicParameters: SetTransportBasicParameters::<Impl, IMPL_OFFSET>,
            GetTransportVideoParameters: GetTransportVideoParameters::<Impl, IMPL_OFFSET>,
            SetTransportVideoParameters: SetTransportVideoParameters::<Impl, IMPL_OFFSET>,
            GetTransportAudioParameters: GetTransportAudioParameters::<Impl, IMPL_OFFSET>,
            SetTransportAudioParameters: SetTransportAudioParameters::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            Rate: Rate::<Impl, IMPL_OFFSET>,
            GetChase: GetChase::<Impl, IMPL_OFFSET>,
            SetChase: SetChase::<Impl, IMPL_OFFSET>,
            GetBump: GetBump::<Impl, IMPL_OFFSET>,
            SetBump: SetBump::<Impl, IMPL_OFFSET>,
            AntiClogControl: AntiClogControl::<Impl, IMPL_OFFSET>,
            SetAntiClogControl: SetAntiClogControl::<Impl, IMPL_OFFSET>,
            GetEditPropertySet: GetEditPropertySet::<Impl, IMPL_OFFSET>,
            SetEditPropertySet: SetEditPropertySet::<Impl, IMPL_OFFSET>,
            GetEditProperty: GetEditProperty::<Impl, IMPL_OFFSET>,
            SetEditProperty: SetEditProperty::<Impl, IMPL_OFFSET>,
            EditStart: EditStart::<Impl, IMPL_OFFSET>,
            SetEditStart: SetEditStart::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMExtTransport as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMExtendedErrorInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn HasError(&mut self, phaserror: *mut i16) -> ::windows::core::Result<()>;
    fn ErrorDescription(&mut self, pbstrerrordescription: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ErrorCode(&mut self, perrorcode: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMExtendedErrorInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMExtendedErrorInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMExtendedErrorInfo_Vtbl {
        unsafe extern "system" fn HasError<Impl: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phaserror: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasError(::core::mem::transmute_copy(&phaserror)).into()
        }
        unsafe extern "system" fn ErrorDescription<Impl: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrerrordescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ErrorDescription(::core::mem::transmute_copy(&pbstrerrordescription)).into()
        }
        unsafe extern "system" fn ErrorCode<Impl: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, perrorcode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ErrorCode(::core::mem::transmute_copy(&perrorcode)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            HasError: HasError::<Impl, IMPL_OFFSET>,
            ErrorDescription: ErrorDescription::<Impl, IMPL_OFFSET>,
            ErrorCode: ErrorCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMExtendedErrorInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMExtendedSeeking_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn ExSeekCapabilities(&mut self, pexcapabilities: *mut i32) -> ::windows::core::Result<()>;
    fn MarkerCount(&mut self, pmarkercount: *mut i32) -> ::windows::core::Result<()>;
    fn CurrentMarker(&mut self, pcurrentmarker: *mut i32) -> ::windows::core::Result<()>;
    fn GetMarkerTime(&mut self, markernum: i32, pmarkertime: *mut f64) -> ::windows::core::Result<()>;
    fn GetMarkerName(&mut self, markernum: i32, pbstrmarkername: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SetPlaybackSpeed(&mut self, speed: f64) -> ::windows::core::Result<()>;
    fn PlaybackSpeed(&mut self, pspeed: *mut f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMExtendedSeeking_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMExtendedSeeking_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMExtendedSeeking_Vtbl {
        unsafe extern "system" fn ExSeekCapabilities<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pexcapabilities: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExSeekCapabilities(::core::mem::transmute_copy(&pexcapabilities)).into()
        }
        unsafe extern "system" fn MarkerCount<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmarkercount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MarkerCount(::core::mem::transmute_copy(&pmarkercount)).into()
        }
        unsafe extern "system" fn CurrentMarker<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrentmarker: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CurrentMarker(::core::mem::transmute_copy(&pcurrentmarker)).into()
        }
        unsafe extern "system" fn GetMarkerTime<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, markernum: i32, pmarkertime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMarkerTime(::core::mem::transmute_copy(&markernum), ::core::mem::transmute_copy(&pmarkertime)).into()
        }
        unsafe extern "system" fn GetMarkerName<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, markernum: i32, pbstrmarkername: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMarkerName(::core::mem::transmute_copy(&markernum), ::core::mem::transmute_copy(&pbstrmarkername)).into()
        }
        unsafe extern "system" fn SetPlaybackSpeed<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, speed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackSpeed(::core::mem::transmute_copy(&speed)).into()
        }
        unsafe extern "system" fn PlaybackSpeed<Impl: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pspeed: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlaybackSpeed(::core::mem::transmute_copy(&pspeed)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ExSeekCapabilities: ExSeekCapabilities::<Impl, IMPL_OFFSET>,
            MarkerCount: MarkerCount::<Impl, IMPL_OFFSET>,
            CurrentMarker: CurrentMarker::<Impl, IMPL_OFFSET>,
            GetMarkerTime: GetMarkerTime::<Impl, IMPL_OFFSET>,
            GetMarkerName: GetMarkerName::<Impl, IMPL_OFFSET>,
            SetPlaybackSpeed: SetPlaybackSpeed::<Impl, IMPL_OFFSET>,
            PlaybackSpeed: PlaybackSpeed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMExtendedSeeking as ::windows::core::Interface>::IID
    }
}
pub trait IAMFilterGraphCallback_Impl: Sized {
    fn UnableToRender(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
}
impl IAMFilterGraphCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMFilterGraphCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMFilterGraphCallback_Vtbl {
        unsafe extern "system" fn UnableToRender<Impl: IAMFilterGraphCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnableToRender(::core::mem::transmute(&ppin)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), UnableToRender: UnableToRender::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMFilterGraphCallback as ::windows::core::Interface>::IID
    }
}
pub trait IAMFilterMiscFlags_Impl: Sized {
    fn GetMiscFlags(&mut self) -> u32;
}
impl IAMFilterMiscFlags_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMFilterMiscFlags_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMFilterMiscFlags_Vtbl {
        unsafe extern "system" fn GetMiscFlags<Impl: IAMFilterMiscFlags_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMiscFlags()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetMiscFlags: GetMiscFlags::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMFilterMiscFlags as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMGraphBuilderCallback_Impl: Sized {
    fn SelectedFilter(&mut self, pmon: &::core::option::Option<super::super::System::Com::IMoniker>) -> ::windows::core::Result<()>;
    fn CreatedFilter(&mut self, pfil: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IAMGraphBuilderCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMGraphBuilderCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMGraphBuilderCallback_Vtbl {
        unsafe extern "system" fn SelectedFilter<Impl: IAMGraphBuilderCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmon: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectedFilter(::core::mem::transmute(&pmon)).into()
        }
        unsafe extern "system" fn CreatedFilter<Impl: IAMGraphBuilderCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfil: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreatedFilter(::core::mem::transmute(&pfil)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SelectedFilter: SelectedFilter::<Impl, IMPL_OFFSET>,
            CreatedFilter: CreatedFilter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMGraphBuilderCallback as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMGraphStreams_Impl: Sized {
    fn FindUpstreamInterface(&mut self, ppin: &::core::option::Option<IPin>, riid: *const ::windows::core::GUID, ppvinterface: *mut *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::Result<()>;
    fn SyncUsingStreamOffset(&mut self, busestreamoffset: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetMaxGraphLatency(&mut self, rtmaxgraphlatency: i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMGraphStreams_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMGraphStreams_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMGraphStreams_Vtbl {
        unsafe extern "system" fn FindUpstreamInterface<Impl: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvinterface: *mut *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FindUpstreamInterface(::core::mem::transmute(&ppin), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvinterface), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn SyncUsingStreamOffset<Impl: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, busestreamoffset: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SyncUsingStreamOffset(::core::mem::transmute_copy(&busestreamoffset)).into()
        }
        unsafe extern "system" fn SetMaxGraphLatency<Impl: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtmaxgraphlatency: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxGraphLatency(::core::mem::transmute_copy(&rtmaxgraphlatency)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            FindUpstreamInterface: FindUpstreamInterface::<Impl, IMPL_OFFSET>,
            SyncUsingStreamOffset: SyncUsingStreamOffset::<Impl, IMPL_OFFSET>,
            SetMaxGraphLatency: SetMaxGraphLatency::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMGraphStreams as ::windows::core::Interface>::IID
    }
}
pub trait IAMLatency_Impl: Sized {
    fn GetLatency(&mut self) -> ::windows::core::Result<i64>;
}
impl IAMLatency_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMLatency_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMLatency_Vtbl {
        unsafe extern "system" fn GetLatency<Impl: IAMLatency_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtlatency: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLatency() {
                ::core::result::Result::Ok(ok__) => {
                    *prtlatency = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetLatency: GetLatency::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMLatency as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IAMLine21Decoder_Impl: Sized {
    fn GetDecoderLevel(&mut self, lplevel: *mut AM_LINE21_CCLEVEL) -> ::windows::core::Result<()>;
    fn GetCurrentService(&mut self, lpservice: *mut AM_LINE21_CCSERVICE) -> ::windows::core::Result<()>;
    fn SetCurrentService(&mut self, service: AM_LINE21_CCSERVICE) -> ::windows::core::Result<()>;
    fn GetServiceState(&mut self, lpstate: *mut AM_LINE21_CCSTATE) -> ::windows::core::Result<()>;
    fn SetServiceState(&mut self, state: AM_LINE21_CCSTATE) -> ::windows::core::Result<()>;
    fn GetOutputFormat(&mut self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::Result<()>;
    fn SetOutputFormat(&mut self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::Result<()>;
    fn GetBackgroundColor(&mut self, pdwphyscolor: *mut u32) -> ::windows::core::Result<()>;
    fn SetBackgroundColor(&mut self, dwphyscolor: u32) -> ::windows::core::Result<()>;
    fn GetRedrawAlways(&mut self, lpboption: *mut i32) -> ::windows::core::Result<()>;
    fn SetRedrawAlways(&mut self, boption: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetDrawBackgroundMode(&mut self, lpmode: *mut AM_LINE21_DRAWBGMODE) -> ::windows::core::Result<()>;
    fn SetDrawBackgroundMode(&mut self, mode: AM_LINE21_DRAWBGMODE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IAMLine21Decoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMLine21Decoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMLine21Decoder_Vtbl {
        unsafe extern "system" fn GetDecoderLevel<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplevel: *mut AM_LINE21_CCLEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecoderLevel(::core::mem::transmute_copy(&lplevel)).into()
        }
        unsafe extern "system" fn GetCurrentService<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpservice: *mut AM_LINE21_CCSERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentService(::core::mem::transmute_copy(&lpservice)).into()
        }
        unsafe extern "system" fn SetCurrentService<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, service: AM_LINE21_CCSERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentService(::core::mem::transmute_copy(&service)).into()
        }
        unsafe extern "system" fn GetServiceState<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpstate: *mut AM_LINE21_CCSTATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServiceState(::core::mem::transmute_copy(&lpstate)).into()
        }
        unsafe extern "system" fn SetServiceState<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: AM_LINE21_CCSTATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetServiceState(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn GetOutputFormat<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOutputFormat(::core::mem::transmute_copy(&lpbmih)).into()
        }
        unsafe extern "system" fn SetOutputFormat<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFormat(::core::mem::transmute_copy(&lpbmi)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwphyscolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBackgroundColor(::core::mem::transmute_copy(&pdwphyscolor)).into()
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwphyscolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundColor(::core::mem::transmute_copy(&dwphyscolor)).into()
        }
        unsafe extern "system" fn GetRedrawAlways<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpboption: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRedrawAlways(::core::mem::transmute_copy(&lpboption)).into()
        }
        unsafe extern "system" fn SetRedrawAlways<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, boption: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRedrawAlways(::core::mem::transmute_copy(&boption)).into()
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpmode: *mut AM_LINE21_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDrawBackgroundMode(::core::mem::transmute_copy(&lpmode)).into()
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Impl: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: AM_LINE21_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDrawBackgroundMode(::core::mem::transmute_copy(&mode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDecoderLevel: GetDecoderLevel::<Impl, IMPL_OFFSET>,
            GetCurrentService: GetCurrentService::<Impl, IMPL_OFFSET>,
            SetCurrentService: SetCurrentService::<Impl, IMPL_OFFSET>,
            GetServiceState: GetServiceState::<Impl, IMPL_OFFSET>,
            SetServiceState: SetServiceState::<Impl, IMPL_OFFSET>,
            GetOutputFormat: GetOutputFormat::<Impl, IMPL_OFFSET>,
            SetOutputFormat: SetOutputFormat::<Impl, IMPL_OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Impl, IMPL_OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Impl, IMPL_OFFSET>,
            GetRedrawAlways: GetRedrawAlways::<Impl, IMPL_OFFSET>,
            SetRedrawAlways: SetRedrawAlways::<Impl, IMPL_OFFSET>,
            GetDrawBackgroundMode: GetDrawBackgroundMode::<Impl, IMPL_OFFSET>,
            SetDrawBackgroundMode: SetDrawBackgroundMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMLine21Decoder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMMediaContent_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn AuthorName(&mut self, pbstrauthorname: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Title(&mut self, pbstrtitle: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Rating(&mut self, pbstrrating: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Description(&mut self, pbstrdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Copyright(&mut self, pbstrcopyright: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn BaseURL(&mut self, pbstrbaseurl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn LogoURL(&mut self, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn LogoIconURL(&mut self, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn WatermarkURL(&mut self, pbstrwatermarkurl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn MoreInfoURL(&mut self, pbstrmoreinfourl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn MoreInfoBannerImage(&mut self, pbstrmoreinfobannerimage: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn MoreInfoBannerURL(&mut self, pbstrmoreinfobannerurl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn MoreInfoText(&mut self, pbstrmoreinfotext: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMMediaContent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMediaContent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMediaContent_Vtbl {
        unsafe extern "system" fn AuthorName<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrauthorname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AuthorName(::core::mem::transmute_copy(&pbstrauthorname)).into()
        }
        unsafe extern "system" fn Title<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrtitle: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Title(::core::mem::transmute_copy(&pbstrtitle)).into()
        }
        unsafe extern "system" fn Rating<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrrating: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Rating(::core::mem::transmute_copy(&pbstrrating)).into()
        }
        unsafe extern "system" fn Description<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Description(::core::mem::transmute_copy(&pbstrdescription)).into()
        }
        unsafe extern "system" fn Copyright<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrcopyright: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Copyright(::core::mem::transmute_copy(&pbstrcopyright)).into()
        }
        unsafe extern "system" fn BaseURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrbaseurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BaseURL(::core::mem::transmute_copy(&pbstrbaseurl)).into()
        }
        unsafe extern "system" fn LogoURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LogoURL(::core::mem::transmute_copy(&pbstrlogourl)).into()
        }
        unsafe extern "system" fn LogoIconURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrlogourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LogoIconURL(::core::mem::transmute_copy(&pbstrlogourl)).into()
        }
        unsafe extern "system" fn WatermarkURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrwatermarkurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WatermarkURL(::core::mem::transmute_copy(&pbstrwatermarkurl)).into()
        }
        unsafe extern "system" fn MoreInfoURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrmoreinfourl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MoreInfoURL(::core::mem::transmute_copy(&pbstrmoreinfourl)).into()
        }
        unsafe extern "system" fn MoreInfoBannerImage<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrmoreinfobannerimage: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MoreInfoBannerImage(::core::mem::transmute_copy(&pbstrmoreinfobannerimage)).into()
        }
        unsafe extern "system" fn MoreInfoBannerURL<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrmoreinfobannerurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MoreInfoBannerURL(::core::mem::transmute_copy(&pbstrmoreinfobannerurl)).into()
        }
        unsafe extern "system" fn MoreInfoText<Impl: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrmoreinfotext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MoreInfoText(::core::mem::transmute_copy(&pbstrmoreinfotext)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AuthorName: AuthorName::<Impl, IMPL_OFFSET>,
            Title: Title::<Impl, IMPL_OFFSET>,
            Rating: Rating::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            Copyright: Copyright::<Impl, IMPL_OFFSET>,
            BaseURL: BaseURL::<Impl, IMPL_OFFSET>,
            LogoURL: LogoURL::<Impl, IMPL_OFFSET>,
            LogoIconURL: LogoIconURL::<Impl, IMPL_OFFSET>,
            WatermarkURL: WatermarkURL::<Impl, IMPL_OFFSET>,
            MoreInfoURL: MoreInfoURL::<Impl, IMPL_OFFSET>,
            MoreInfoBannerImage: MoreInfoBannerImage::<Impl, IMPL_OFFSET>,
            MoreInfoBannerURL: MoreInfoBannerURL::<Impl, IMPL_OFFSET>,
            MoreInfoText: MoreInfoText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMediaContent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMMediaContent2_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn MediaParameter(&mut self, entrynum: i32, bstrname: &super::super::Foundation::BSTR, pbstrvalue: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn MediaParameterName(&mut self, entrynum: i32, index: i32, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn PlaylistCount(&mut self, pnumberentries: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMMediaContent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMediaContent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMediaContent2_Vtbl {
        unsafe extern "system" fn MediaParameter<Impl: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, entrynum: i32, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrvalue: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MediaParameter(::core::mem::transmute_copy(&entrynum), ::core::mem::transmute_copy(&bstrname), ::core::mem::transmute_copy(&pbstrvalue)).into()
        }
        unsafe extern "system" fn MediaParameterName<Impl: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, entrynum: i32, index: i32, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MediaParameterName(::core::mem::transmute_copy(&entrynum), ::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&pbstrname)).into()
        }
        unsafe extern "system" fn PlaylistCount<Impl: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnumberentries: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlaylistCount(::core::mem::transmute_copy(&pnumberentries)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MediaParameter: MediaParameter::<Impl, IMPL_OFFSET>,
            MediaParameterName: MediaParameterName::<Impl, IMPL_OFFSET>,
            PlaylistCount: PlaylistCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMediaContent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMMediaStream_Impl: Sized + IMediaStream_Impl {
    fn Initialize(&mut self, psourceobject: &::core::option::Option<::windows::core::IUnknown>, dwflags: u32, purposeid: *const ::windows::core::GUID, streamtype: STREAM_TYPE) -> ::windows::core::Result<()>;
    fn SetState(&mut self, state: FILTER_STATE) -> ::windows::core::Result<()>;
    fn JoinAMMultiMediaStream(&mut self, pammultimediastream: &::core::option::Option<IAMMultiMediaStream>) -> ::windows::core::Result<()>;
    fn JoinFilter(&mut self, pmediastreamfilter: &::core::option::Option<IMediaStreamFilter>) -> ::windows::core::Result<()>;
    fn JoinFilterGraph(&mut self, pfiltergraph: &::core::option::Option<IFilterGraph>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMediaStream_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourceobject: *mut ::core::ffi::c_void, dwflags: u32, purposeid: *const ::windows::core::GUID, streamtype: STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psourceobject), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&purposeid), ::core::mem::transmute_copy(&streamtype)).into()
        }
        unsafe extern "system" fn SetState<Impl: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: FILTER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetState(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn JoinAMMultiMediaStream<Impl: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pammultimediastream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).JoinAMMultiMediaStream(::core::mem::transmute(&pammultimediastream)).into()
        }
        unsafe extern "system" fn JoinFilter<Impl: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediastreamfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).JoinFilter(::core::mem::transmute(&pmediastreamfilter)).into()
        }
        unsafe extern "system" fn JoinFilterGraph<Impl: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfiltergraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).JoinFilterGraph(::core::mem::transmute(&pfiltergraph)).into()
        }
        Self {
            base: IMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            SetState: SetState::<Impl, IMPL_OFFSET>,
            JoinAMMultiMediaStream: JoinAMMultiMediaStream::<Impl, IMPL_OFFSET>,
            JoinFilter: JoinFilter::<Impl, IMPL_OFFSET>,
            JoinFilterGraph: JoinFilterGraph::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMMediaTypeSample_Impl: Sized + IStreamSample_Impl {
    fn SetPointer(&mut self, pbuffer: *const u8, lsize: i32) -> ::windows::core::Result<()>;
    fn GetPointer(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetSize(&mut self) -> i32;
    fn GetTime(&mut self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn SetTime(&mut self, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::Result<()>;
    fn IsSyncPoint(&mut self) -> ::windows::core::Result<()>;
    fn SetSyncPoint(&mut self, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn IsPreroll(&mut self) -> ::windows::core::Result<()>;
    fn SetPreroll(&mut self, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetActualDataLength(&mut self) -> i32;
    fn SetActualDataLength(&mut self, __midl__iammediatypesample0000: i32) -> ::windows::core::Result<()>;
    fn GetMediaType(&mut self) -> ::windows::core::Result<*mut AM_MEDIA_TYPE>;
    fn SetMediaType(&mut self, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn IsDiscontinuity(&mut self) -> ::windows::core::Result<()>;
    fn SetDiscontinuity(&mut self, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetMediaTime(&mut self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn SetMediaTime(&mut self, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMMediaTypeSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMediaTypeSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMediaTypeSample_Vtbl {
        unsafe extern "system" fn SetPointer<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: *const u8, lsize: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPointer(::core::mem::transmute_copy(&pbuffer), ::core::mem::transmute_copy(&lsize)).into()
        }
        unsafe extern "system" fn GetPointer<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSize<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSize()
        }
        unsafe extern "system" fn GetTime<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn SetTime<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn IsSyncPoint<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSyncPoint().into()
        }
        unsafe extern "system" fn SetSyncPoint<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncPoint(::core::mem::transmute_copy(&bissyncpoint)).into()
        }
        unsafe extern "system" fn IsPreroll<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsPreroll().into()
        }
        unsafe extern "system" fn SetPreroll<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreroll(::core::mem::transmute_copy(&bispreroll)).into()
        }
        unsafe extern "system" fn GetActualDataLength<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetActualDataLength()
        }
        unsafe extern "system" fn SetActualDataLength<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__iammediatypesample0000: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetActualDataLength(::core::mem::transmute_copy(&__midl__iammediatypesample0000)).into()
        }
        unsafe extern "system" fn GetMediaType<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute_copy(&pmediatype)).into()
        }
        unsafe extern "system" fn IsDiscontinuity<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsDiscontinuity().into()
        }
        unsafe extern "system" fn SetDiscontinuity<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiscontinuity(::core::mem::transmute_copy(&bdiscontinuity)).into()
        }
        unsafe extern "system" fn GetMediaTime<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn SetMediaTime<Impl: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        Self {
            base: IStreamSample_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetPointer: SetPointer::<Impl, IMPL_OFFSET>,
            GetPointer: GetPointer::<Impl, IMPL_OFFSET>,
            GetSize: GetSize::<Impl, IMPL_OFFSET>,
            GetTime: GetTime::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            IsSyncPoint: IsSyncPoint::<Impl, IMPL_OFFSET>,
            SetSyncPoint: SetSyncPoint::<Impl, IMPL_OFFSET>,
            IsPreroll: IsPreroll::<Impl, IMPL_OFFSET>,
            SetPreroll: SetPreroll::<Impl, IMPL_OFFSET>,
            GetActualDataLength: GetActualDataLength::<Impl, IMPL_OFFSET>,
            SetActualDataLength: SetActualDataLength::<Impl, IMPL_OFFSET>,
            GetMediaType: GetMediaType::<Impl, IMPL_OFFSET>,
            SetMediaType: SetMediaType::<Impl, IMPL_OFFSET>,
            IsDiscontinuity: IsDiscontinuity::<Impl, IMPL_OFFSET>,
            SetDiscontinuity: SetDiscontinuity::<Impl, IMPL_OFFSET>,
            GetMediaTime: GetMediaTime::<Impl, IMPL_OFFSET>,
            SetMediaTime: SetMediaTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMediaTypeSample as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMMediaTypeStream_Impl: Sized + IMediaStream_Impl {
    fn GetFormat(&mut self, pmediatype: *mut AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::Result<()>;
    fn SetFormat(&mut self, pmediatype: *const AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::Result<()>;
    fn CreateSample(&mut self, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<IAMMediaTypeSample>;
    fn GetStreamAllocatorRequirements(&mut self) -> ::windows::core::Result<ALLOCATOR_PROPERTIES>;
    fn SetStreamAllocatorRequirements(&mut self, pprops: *const ALLOCATOR_PROPERTIES) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMMediaTypeStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMediaTypeStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMediaTypeStream_Vtbl {
        unsafe extern "system" fn GetFormat<Impl: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *mut AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFormat(::core::mem::transmute_copy(&pmediatype), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn SetFormat<Impl: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFormat(::core::mem::transmute_copy(&pmediatype), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn CreateSample<Impl: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: *mut ::core::ffi::c_void, ppammediatypesample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSample(::core::mem::transmute_copy(&lsamplesize), ::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&punkouter)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppammediatypesample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAllocatorRequirements<Impl: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAllocatorRequirements() {
                ::core::result::Result::Ok(ok__) => {
                    *pprops = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamAllocatorRequirements<Impl: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprops: *const ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamAllocatorRequirements(::core::mem::transmute_copy(&pprops)).into()
        }
        Self {
            base: IMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetFormat: GetFormat::<Impl, IMPL_OFFSET>,
            SetFormat: SetFormat::<Impl, IMPL_OFFSET>,
            CreateSample: CreateSample::<Impl, IMPL_OFFSET>,
            GetStreamAllocatorRequirements: GetStreamAllocatorRequirements::<Impl, IMPL_OFFSET>,
            SetStreamAllocatorRequirements: SetStreamAllocatorRequirements::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMediaTypeStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IAMMultiMediaStream_Impl: Sized + IMultiMediaStream_Impl {
    fn Initialize(&mut self, streamtype: STREAM_TYPE, dwflags: AMMSF_MMS_INIT_FLAGS, pfiltergraph: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
    fn GetFilterGraph(&mut self) -> ::windows::core::Result<IGraphBuilder>;
    fn GetFilter(&mut self) -> ::windows::core::Result<IMediaStreamFilter>;
    fn AddMediaStream(&mut self, pstreamobject: &::core::option::Option<::windows::core::IUnknown>, purposeid: *const ::windows::core::GUID, dwflags: AMMSF_MS_FLAGS) -> ::windows::core::Result<IMediaStream>;
    fn OpenFile(&mut self, pszfilename: super::super::Foundation::PWSTR, dwflags: u32) -> ::windows::core::Result<()>;
    fn OpenMoniker(&mut self, pctx: &::core::option::Option<super::super::System::Com::IBindCtx>, pmoniker: &::core::option::Option<super::super::System::Com::IMoniker>, dwflags: u32) -> ::windows::core::Result<()>;
    fn Render(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IAMMultiMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMMultiMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMMultiMediaStream_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamtype: STREAM_TYPE, dwflags: AMMSF_MMS_INIT_FLAGS, pfiltergraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&streamtype), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pfiltergraph)).into()
        }
        unsafe extern "system" fn GetFilterGraph<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppgraphbuilder: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilterGraph() {
                ::core::result::Result::Ok(ok__) => {
                    *ppgraphbuilder = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilter<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppfilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddMediaStream<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstreamobject: *mut ::core::ffi::c_void, purposeid: *const ::windows::core::GUID, dwflags: AMMSF_MS_FLAGS, ppnewstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddMediaStream(::core::mem::transmute(&pstreamobject), ::core::mem::transmute_copy(&purposeid), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenFile<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OpenFile(::core::mem::transmute_copy(&pszfilename), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn OpenMoniker<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pctx: ::windows::core::RawPtr, pmoniker: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OpenMoniker(::core::mem::transmute(&pctx), ::core::mem::transmute(&pmoniker), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn Render<Impl: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Render(::core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base: IMultiMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetFilterGraph: GetFilterGraph::<Impl, IMPL_OFFSET>,
            GetFilter: GetFilter::<Impl, IMPL_OFFSET>,
            AddMediaStream: AddMediaStream::<Impl, IMPL_OFFSET>,
            OpenFile: OpenFile::<Impl, IMPL_OFFSET>,
            OpenMoniker: OpenMoniker::<Impl, IMPL_OFFSET>,
            Render: Render::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMMultiMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMNetShowConfig_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn BufferingTime(&mut self, pbufferingtime: *mut f64) -> ::windows::core::Result<()>;
    fn SetBufferingTime(&mut self, bufferingtime: f64) -> ::windows::core::Result<()>;
    fn UseFixedUDPPort(&mut self, pusefixedudpport: *mut i16) -> ::windows::core::Result<()>;
    fn SetUseFixedUDPPort(&mut self, usefixedudpport: i16) -> ::windows::core::Result<()>;
    fn FixedUDPPort(&mut self, pfixedudpport: *mut i32) -> ::windows::core::Result<()>;
    fn SetFixedUDPPort(&mut self, fixedudpport: i32) -> ::windows::core::Result<()>;
    fn UseHTTPProxy(&mut self, pusehttpproxy: *mut i16) -> ::windows::core::Result<()>;
    fn SetUseHTTPProxy(&mut self, usehttpproxy: i16) -> ::windows::core::Result<()>;
    fn EnableAutoProxy(&mut self, penableautoproxy: *mut i16) -> ::windows::core::Result<()>;
    fn SetEnableAutoProxy(&mut self, enableautoproxy: i16) -> ::windows::core::Result<()>;
    fn HTTPProxyHost(&mut self, pbstrhttpproxyhost: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SetHTTPProxyHost(&mut self, bstrhttpproxyhost: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn HTTPProxyPort(&mut self, phttpproxyport: *mut i32) -> ::windows::core::Result<()>;
    fn SetHTTPProxyPort(&mut self, httpproxyport: i32) -> ::windows::core::Result<()>;
    fn EnableMulticast(&mut self, penablemulticast: *mut i16) -> ::windows::core::Result<()>;
    fn SetEnableMulticast(&mut self, enablemulticast: i16) -> ::windows::core::Result<()>;
    fn EnableUDP(&mut self, penableudp: *mut i16) -> ::windows::core::Result<()>;
    fn SetEnableUDP(&mut self, enableudp: i16) -> ::windows::core::Result<()>;
    fn EnableTCP(&mut self, penabletcp: *mut i16) -> ::windows::core::Result<()>;
    fn SetEnableTCP(&mut self, enabletcp: i16) -> ::windows::core::Result<()>;
    fn EnableHTTP(&mut self, penablehttp: *mut i16) -> ::windows::core::Result<()>;
    fn SetEnableHTTP(&mut self, enablehttp: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMNetShowConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMNetShowConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMNetShowConfig_Vtbl {
        unsafe extern "system" fn BufferingTime<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbufferingtime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BufferingTime(::core::mem::transmute_copy(&pbufferingtime)).into()
        }
        unsafe extern "system" fn SetBufferingTime<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bufferingtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBufferingTime(::core::mem::transmute_copy(&bufferingtime)).into()
        }
        unsafe extern "system" fn UseFixedUDPPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pusefixedudpport: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UseFixedUDPPort(::core::mem::transmute_copy(&pusefixedudpport)).into()
        }
        unsafe extern "system" fn SetUseFixedUDPPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usefixedudpport: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseFixedUDPPort(::core::mem::transmute_copy(&usefixedudpport)).into()
        }
        unsafe extern "system" fn FixedUDPPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfixedudpport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FixedUDPPort(::core::mem::transmute_copy(&pfixedudpport)).into()
        }
        unsafe extern "system" fn SetFixedUDPPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fixedudpport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFixedUDPPort(::core::mem::transmute_copy(&fixedudpport)).into()
        }
        unsafe extern "system" fn UseHTTPProxy<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pusehttpproxy: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UseHTTPProxy(::core::mem::transmute_copy(&pusehttpproxy)).into()
        }
        unsafe extern "system" fn SetUseHTTPProxy<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usehttpproxy: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseHTTPProxy(::core::mem::transmute_copy(&usehttpproxy)).into()
        }
        unsafe extern "system" fn EnableAutoProxy<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penableautoproxy: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableAutoProxy(::core::mem::transmute_copy(&penableautoproxy)).into()
        }
        unsafe extern "system" fn SetEnableAutoProxy<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enableautoproxy: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableAutoProxy(::core::mem::transmute_copy(&enableautoproxy)).into()
        }
        unsafe extern "system" fn HTTPProxyHost<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrhttpproxyhost: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HTTPProxyHost(::core::mem::transmute_copy(&pbstrhttpproxyhost)).into()
        }
        unsafe extern "system" fn SetHTTPProxyHost<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrhttpproxyhost: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHTTPProxyHost(::core::mem::transmute_copy(&bstrhttpproxyhost)).into()
        }
        unsafe extern "system" fn HTTPProxyPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phttpproxyport: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HTTPProxyPort(::core::mem::transmute_copy(&phttpproxyport)).into()
        }
        unsafe extern "system" fn SetHTTPProxyPort<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, httpproxyport: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHTTPProxyPort(::core::mem::transmute_copy(&httpproxyport)).into()
        }
        unsafe extern "system" fn EnableMulticast<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penablemulticast: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableMulticast(::core::mem::transmute_copy(&penablemulticast)).into()
        }
        unsafe extern "system" fn SetEnableMulticast<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enablemulticast: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableMulticast(::core::mem::transmute_copy(&enablemulticast)).into()
        }
        unsafe extern "system" fn EnableUDP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penableudp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableUDP(::core::mem::transmute_copy(&penableudp)).into()
        }
        unsafe extern "system" fn SetEnableUDP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enableudp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableUDP(::core::mem::transmute_copy(&enableudp)).into()
        }
        unsafe extern "system" fn EnableTCP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penabletcp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableTCP(::core::mem::transmute_copy(&penabletcp)).into()
        }
        unsafe extern "system" fn SetEnableTCP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enabletcp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableTCP(::core::mem::transmute_copy(&enabletcp)).into()
        }
        unsafe extern "system" fn EnableHTTP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penablehttp: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableHTTP(::core::mem::transmute_copy(&penablehttp)).into()
        }
        unsafe extern "system" fn SetEnableHTTP<Impl: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enablehttp: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableHTTP(::core::mem::transmute_copy(&enablehttp)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            BufferingTime: BufferingTime::<Impl, IMPL_OFFSET>,
            SetBufferingTime: SetBufferingTime::<Impl, IMPL_OFFSET>,
            UseFixedUDPPort: UseFixedUDPPort::<Impl, IMPL_OFFSET>,
            SetUseFixedUDPPort: SetUseFixedUDPPort::<Impl, IMPL_OFFSET>,
            FixedUDPPort: FixedUDPPort::<Impl, IMPL_OFFSET>,
            SetFixedUDPPort: SetFixedUDPPort::<Impl, IMPL_OFFSET>,
            UseHTTPProxy: UseHTTPProxy::<Impl, IMPL_OFFSET>,
            SetUseHTTPProxy: SetUseHTTPProxy::<Impl, IMPL_OFFSET>,
            EnableAutoProxy: EnableAutoProxy::<Impl, IMPL_OFFSET>,
            SetEnableAutoProxy: SetEnableAutoProxy::<Impl, IMPL_OFFSET>,
            HTTPProxyHost: HTTPProxyHost::<Impl, IMPL_OFFSET>,
            SetHTTPProxyHost: SetHTTPProxyHost::<Impl, IMPL_OFFSET>,
            HTTPProxyPort: HTTPProxyPort::<Impl, IMPL_OFFSET>,
            SetHTTPProxyPort: SetHTTPProxyPort::<Impl, IMPL_OFFSET>,
            EnableMulticast: EnableMulticast::<Impl, IMPL_OFFSET>,
            SetEnableMulticast: SetEnableMulticast::<Impl, IMPL_OFFSET>,
            EnableUDP: EnableUDP::<Impl, IMPL_OFFSET>,
            SetEnableUDP: SetEnableUDP::<Impl, IMPL_OFFSET>,
            EnableTCP: EnableTCP::<Impl, IMPL_OFFSET>,
            SetEnableTCP: SetEnableTCP::<Impl, IMPL_OFFSET>,
            EnableHTTP: EnableHTTP::<Impl, IMPL_OFFSET>,
            SetEnableHTTP: SetEnableHTTP::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMNetShowConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMNetShowExProps_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn SourceProtocol(&mut self, psourceprotocol: *mut i32) -> ::windows::core::Result<()>;
    fn Bandwidth(&mut self, pbandwidth: *mut i32) -> ::windows::core::Result<()>;
    fn ErrorCorrection(&mut self, pbstrerrorcorrection: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn CodecCount(&mut self, pcodeccount: *mut i32) -> ::windows::core::Result<()>;
    fn GetCodecInstalled(&mut self, codecnum: i32, pcodecinstalled: *mut i16) -> ::windows::core::Result<()>;
    fn GetCodecDescription(&mut self, codecnum: i32, pbstrcodecdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetCodecURL(&mut self, codecnum: i32, pbstrcodecurl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn CreationDate(&mut self, pcreationdate: *mut f64) -> ::windows::core::Result<()>;
    fn SourceLink(&mut self, pbstrsourcelink: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMNetShowExProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMNetShowExProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMNetShowExProps_Vtbl {
        unsafe extern "system" fn SourceProtocol<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourceprotocol: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SourceProtocol(::core::mem::transmute_copy(&psourceprotocol)).into()
        }
        unsafe extern "system" fn Bandwidth<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbandwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Bandwidth(::core::mem::transmute_copy(&pbandwidth)).into()
        }
        unsafe extern "system" fn ErrorCorrection<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrerrorcorrection: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ErrorCorrection(::core::mem::transmute_copy(&pbstrerrorcorrection)).into()
        }
        unsafe extern "system" fn CodecCount<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcodeccount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CodecCount(::core::mem::transmute_copy(&pcodeccount)).into()
        }
        unsafe extern "system" fn GetCodecInstalled<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, codecnum: i32, pcodecinstalled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecInstalled(::core::mem::transmute_copy(&codecnum), ::core::mem::transmute_copy(&pcodecinstalled)).into()
        }
        unsafe extern "system" fn GetCodecDescription<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, codecnum: i32, pbstrcodecdescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecDescription(::core::mem::transmute_copy(&codecnum), ::core::mem::transmute_copy(&pbstrcodecdescription)).into()
        }
        unsafe extern "system" fn GetCodecURL<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, codecnum: i32, pbstrcodecurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecURL(::core::mem::transmute_copy(&codecnum), ::core::mem::transmute_copy(&pbstrcodecurl)).into()
        }
        unsafe extern "system" fn CreationDate<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcreationdate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreationDate(::core::mem::transmute_copy(&pcreationdate)).into()
        }
        unsafe extern "system" fn SourceLink<Impl: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrsourcelink: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SourceLink(::core::mem::transmute_copy(&pbstrsourcelink)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SourceProtocol: SourceProtocol::<Impl, IMPL_OFFSET>,
            Bandwidth: Bandwidth::<Impl, IMPL_OFFSET>,
            ErrorCorrection: ErrorCorrection::<Impl, IMPL_OFFSET>,
            CodecCount: CodecCount::<Impl, IMPL_OFFSET>,
            GetCodecInstalled: GetCodecInstalled::<Impl, IMPL_OFFSET>,
            GetCodecDescription: GetCodecDescription::<Impl, IMPL_OFFSET>,
            GetCodecURL: GetCodecURL::<Impl, IMPL_OFFSET>,
            CreationDate: CreationDate::<Impl, IMPL_OFFSET>,
            SourceLink: SourceLink::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMNetShowExProps as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMNetShowPreroll_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn SetPreroll(&mut self, fpreroll: i16) -> ::windows::core::Result<()>;
    fn Preroll(&mut self, pfpreroll: *mut i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMNetShowPreroll_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMNetShowPreroll_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMNetShowPreroll_Vtbl {
        unsafe extern "system" fn SetPreroll<Impl: IAMNetShowPreroll_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpreroll: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreroll(::core::mem::transmute_copy(&fpreroll)).into()
        }
        unsafe extern "system" fn Preroll<Impl: IAMNetShowPreroll_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfpreroll: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Preroll(::core::mem::transmute_copy(&pfpreroll)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetPreroll: SetPreroll::<Impl, IMPL_OFFSET>,
            Preroll: Preroll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMNetShowPreroll as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMNetworkStatus_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn ReceivedPackets(&mut self, preceivedpackets: *mut i32) -> ::windows::core::Result<()>;
    fn RecoveredPackets(&mut self, precoveredpackets: *mut i32) -> ::windows::core::Result<()>;
    fn LostPackets(&mut self, plostpackets: *mut i32) -> ::windows::core::Result<()>;
    fn ReceptionQuality(&mut self, preceptionquality: *mut i32) -> ::windows::core::Result<()>;
    fn BufferingCount(&mut self, pbufferingcount: *mut i32) -> ::windows::core::Result<()>;
    fn IsBroadcast(&mut self, pisbroadcast: *mut i16) -> ::windows::core::Result<()>;
    fn BufferingProgress(&mut self, pbufferingprogress: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMNetworkStatus_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMNetworkStatus_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMNetworkStatus_Vtbl {
        unsafe extern "system" fn ReceivedPackets<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, preceivedpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReceivedPackets(::core::mem::transmute_copy(&preceivedpackets)).into()
        }
        unsafe extern "system" fn RecoveredPackets<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, precoveredpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RecoveredPackets(::core::mem::transmute_copy(&precoveredpackets)).into()
        }
        unsafe extern "system" fn LostPackets<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plostpackets: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LostPackets(::core::mem::transmute_copy(&plostpackets)).into()
        }
        unsafe extern "system" fn ReceptionQuality<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, preceptionquality: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReceptionQuality(::core::mem::transmute_copy(&preceptionquality)).into()
        }
        unsafe extern "system" fn BufferingCount<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbufferingcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BufferingCount(::core::mem::transmute_copy(&pbufferingcount)).into()
        }
        unsafe extern "system" fn IsBroadcast<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pisbroadcast: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsBroadcast(::core::mem::transmute_copy(&pisbroadcast)).into()
        }
        unsafe extern "system" fn BufferingProgress<Impl: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbufferingprogress: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BufferingProgress(::core::mem::transmute_copy(&pbufferingprogress)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ReceivedPackets: ReceivedPackets::<Impl, IMPL_OFFSET>,
            RecoveredPackets: RecoveredPackets::<Impl, IMPL_OFFSET>,
            LostPackets: LostPackets::<Impl, IMPL_OFFSET>,
            ReceptionQuality: ReceptionQuality::<Impl, IMPL_OFFSET>,
            BufferingCount: BufferingCount::<Impl, IMPL_OFFSET>,
            IsBroadcast: IsBroadcast::<Impl, IMPL_OFFSET>,
            BufferingProgress: BufferingProgress::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMNetworkStatus as ::windows::core::Interface>::IID
    }
}
pub trait IAMOpenProgress_Impl: Sized {
    fn QueryProgress(&mut self, plltotal: *mut i64, pllcurrent: *mut i64) -> ::windows::core::Result<()>;
    fn AbortOperation(&mut self) -> ::windows::core::Result<()>;
}
impl IAMOpenProgress_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMOpenProgress_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMOpenProgress_Vtbl {
        unsafe extern "system" fn QueryProgress<Impl: IAMOpenProgress_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plltotal: *mut i64, pllcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryProgress(::core::mem::transmute_copy(&plltotal), ::core::mem::transmute_copy(&pllcurrent)).into()
        }
        unsafe extern "system" fn AbortOperation<Impl: IAMOpenProgress_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AbortOperation().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryProgress: QueryProgress::<Impl, IMPL_OFFSET>,
            AbortOperation: AbortOperation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMOpenProgress as ::windows::core::Interface>::IID
    }
}
pub trait IAMOverlayFX_Impl: Sized {
    fn QueryOverlayFXCaps(&mut self) -> ::windows::core::Result<u32>;
    fn SetOverlayFX(&mut self, dwoverlayfx: u32) -> ::windows::core::Result<()>;
    fn GetOverlayFX(&mut self) -> ::windows::core::Result<u32>;
}
impl IAMOverlayFX_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMOverlayFX_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMOverlayFX_Vtbl {
        unsafe extern "system" fn QueryOverlayFXCaps<Impl: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwoverlayfxcaps: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryOverlayFXCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *lpdwoverlayfxcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverlayFX<Impl: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoverlayfx: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverlayFX(::core::mem::transmute_copy(&dwoverlayfx)).into()
        }
        unsafe extern "system" fn GetOverlayFX<Impl: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwoverlayfx: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOverlayFX() {
                ::core::result::Result::Ok(ok__) => {
                    *lpdwoverlayfx = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryOverlayFXCaps: QueryOverlayFXCaps::<Impl, IMPL_OFFSET>,
            SetOverlayFX: SetOverlayFX::<Impl, IMPL_OFFSET>,
            GetOverlayFX: GetOverlayFX::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMOverlayFX as ::windows::core::Interface>::IID
    }
}
pub trait IAMParse_Impl: Sized {
    fn GetParseTime(&mut self) -> ::windows::core::Result<i64>;
    fn SetParseTime(&mut self, rtcurrent: i64) -> ::windows::core::Result<()>;
    fn Flush(&mut self) -> ::windows::core::Result<()>;
}
impl IAMParse_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMParse_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMParse_Vtbl {
        unsafe extern "system" fn GetParseTime<Impl: IAMParse_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParseTime() {
                ::core::result::Result::Ok(ok__) => {
                    *prtcurrent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParseTime<Impl: IAMParse_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtcurrent: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetParseTime(::core::mem::transmute_copy(&rtcurrent)).into()
        }
        unsafe extern "system" fn Flush<Impl: IAMParse_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetParseTime: GetParseTime::<Impl, IMPL_OFFSET>,
            SetParseTime: SetParseTime::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMParse as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMPhysicalPinInfo_Impl: Sized {
    fn GetPhysicalType(&mut self, ptype: *mut i32, ppsztype: *mut super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMPhysicalPinInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMPhysicalPinInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMPhysicalPinInfo_Vtbl {
        unsafe extern "system" fn GetPhysicalType<Impl: IAMPhysicalPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut i32, ppsztype: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPhysicalType(::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&ppsztype)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetPhysicalType: GetPhysicalType::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMPhysicalPinInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMPlayList_Impl: Sized {
    fn GetFlags(&mut self) -> ::windows::core::Result<u32>;
    fn GetItemCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetItem(&mut self, dwitemindex: u32) -> ::windows::core::Result<IAMPlayListItem>;
    fn GetNamedEvent(&mut self, pwszeventname: super::super::Foundation::PWSTR, dwitemindex: u32, ppitem: *mut ::core::option::Option<IAMPlayListItem>, pdwflags: *mut u32) -> ::windows::core::Result<()>;
    fn GetRepeatInfo(&mut self, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMPlayList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMPlayList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMPlayList_Vtbl {
        unsafe extern "system" fn GetFlags<Impl: IAMPlayList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemCount<Impl: IAMPlayList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwitems: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwitems = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItem<Impl: IAMPlayList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwitemindex: u32, ppitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItem(::core::mem::transmute_copy(&dwitemindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppitem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNamedEvent<Impl: IAMPlayList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszeventname: super::super::Foundation::PWSTR, dwitemindex: u32, ppitem: *mut ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNamedEvent(::core::mem::transmute_copy(&pwszeventname), ::core::mem::transmute_copy(&dwitemindex), ::core::mem::transmute_copy(&ppitem), ::core::mem::transmute_copy(&pdwflags)).into()
        }
        unsafe extern "system" fn GetRepeatInfo<Impl: IAMPlayList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRepeatInfo(::core::mem::transmute_copy(&pdwrepeatcount), ::core::mem::transmute_copy(&pdwrepeatstart), ::core::mem::transmute_copy(&pdwrepeatend)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            GetItemCount: GetItemCount::<Impl, IMPL_OFFSET>,
            GetItem: GetItem::<Impl, IMPL_OFFSET>,
            GetNamedEvent: GetNamedEvent::<Impl, IMPL_OFFSET>,
            GetRepeatInfo: GetRepeatInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMPlayList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMPlayListItem_Impl: Sized {
    fn GetFlags(&mut self) -> ::windows::core::Result<u32>;
    fn GetSourceCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetSourceURL(&mut self, dwsourceindex: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetSourceStart(&mut self, dwsourceindex: u32) -> ::windows::core::Result<i64>;
    fn GetSourceDuration(&mut self, dwsourceindex: u32) -> ::windows::core::Result<i64>;
    fn GetSourceStartMarker(&mut self, dwsourceindex: u32) -> ::windows::core::Result<u32>;
    fn GetSourceEndMarker(&mut self, dwsourceindex: u32) -> ::windows::core::Result<u32>;
    fn GetSourceStartMarkerName(&mut self, dwsourceindex: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetSourceEndMarkerName(&mut self, dwsourceindex: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetLinkURL(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetScanDuration(&mut self, dwsourceindex: u32) -> ::windows::core::Result<i64>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMPlayListItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMPlayListItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMPlayListItem_Vtbl {
        unsafe extern "system" fn GetFlags<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceCount<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwsources: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwsources = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceURL<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceURL(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStart<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceStart(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *prtstart = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceDuration<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceDuration(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *prtduration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStartMarker<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceStartMarker(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmarker = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceEndMarker<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceEndMarker(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmarker = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceStartMarkerName<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrstartmarker: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceStartMarkerName(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrstartmarker = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceEndMarkerName<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, pbstrendmarker: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceEndMarkerName(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrendmarker = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLinkURL<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinkURL() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScanDuration<Impl: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourceindex: u32, prtscanduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetScanDuration(::core::mem::transmute_copy(&dwsourceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *prtscanduration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            GetSourceCount: GetSourceCount::<Impl, IMPL_OFFSET>,
            GetSourceURL: GetSourceURL::<Impl, IMPL_OFFSET>,
            GetSourceStart: GetSourceStart::<Impl, IMPL_OFFSET>,
            GetSourceDuration: GetSourceDuration::<Impl, IMPL_OFFSET>,
            GetSourceStartMarker: GetSourceStartMarker::<Impl, IMPL_OFFSET>,
            GetSourceEndMarker: GetSourceEndMarker::<Impl, IMPL_OFFSET>,
            GetSourceStartMarkerName: GetSourceStartMarkerName::<Impl, IMPL_OFFSET>,
            GetSourceEndMarkerName: GetSourceEndMarkerName::<Impl, IMPL_OFFSET>,
            GetLinkURL: GetLinkURL::<Impl, IMPL_OFFSET>,
            GetScanDuration: GetScanDuration::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMPlayListItem as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMPluginControl_Impl: Sized {
    fn GetPreferredClsid(&mut self, subtype: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetPreferredClsidByIndex(&mut self, index: u32, subtype: *mut ::windows::core::GUID, clsid: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetPreferredClsid(&mut self, subtype: *const ::windows::core::GUID, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn IsDisabled(&mut self, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDisabledByIndex(&mut self, index: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetDisabled(&mut self, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn IsLegacyDisabled(&mut self, dllname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMPluginControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMPluginControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMPluginControl_Vtbl {
        unsafe extern "system" fn GetPreferredClsid<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, subtype: *const ::windows::core::GUID, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsid(::core::mem::transmute_copy(&subtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, subtype: *mut ::windows::core::GUID, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPreferredClsidByIndex(::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&subtype), ::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn SetPreferredClsid<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, subtype: *const ::windows::core::GUID, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreferredClsid(::core::mem::transmute_copy(&subtype), ::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn IsDisabled<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsDisabled(::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn GetDisabledByIndex<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDisabledByIndex(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabled<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabled(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&disabled)).into()
        }
        unsafe extern "system" fn IsLegacyDisabled<Impl: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dllname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsLegacyDisabled(::core::mem::transmute_copy(&dllname)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPreferredClsid: GetPreferredClsid::<Impl, IMPL_OFFSET>,
            GetPreferredClsidByIndex: GetPreferredClsidByIndex::<Impl, IMPL_OFFSET>,
            SetPreferredClsid: SetPreferredClsid::<Impl, IMPL_OFFSET>,
            IsDisabled: IsDisabled::<Impl, IMPL_OFFSET>,
            GetDisabledByIndex: GetDisabledByIndex::<Impl, IMPL_OFFSET>,
            SetDisabled: SetDisabled::<Impl, IMPL_OFFSET>,
            IsLegacyDisabled: IsLegacyDisabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMPluginControl as ::windows::core::Interface>::IID
    }
}
pub trait IAMPushSource_Impl: Sized + IAMLatency_Impl {
    fn GetPushSourceFlags(&mut self) -> ::windows::core::Result<u32>;
    fn SetPushSourceFlags(&mut self, flags: u32) -> ::windows::core::Result<()>;
    fn SetStreamOffset(&mut self, rtoffset: i64) -> ::windows::core::Result<()>;
    fn GetStreamOffset(&mut self) -> ::windows::core::Result<i64>;
    fn GetMaxStreamOffset(&mut self) -> ::windows::core::Result<i64>;
    fn SetMaxStreamOffset(&mut self, rtmaxoffset: i64) -> ::windows::core::Result<()>;
}
impl IAMPushSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMPushSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMPushSource_Vtbl {
        unsafe extern "system" fn GetPushSourceFlags<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPushSourceFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPushSourceFlags<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPushSourceFlags(::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn SetStreamOffset<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamOffset(::core::mem::transmute_copy(&rtoffset)).into()
        }
        unsafe extern "system" fn GetStreamOffset<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtoffset: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *prtoffset = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxStreamOffset<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtmaxoffset: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaxStreamOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *prtmaxoffset = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxStreamOffset<Impl: IAMPushSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtmaxoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxStreamOffset(::core::mem::transmute_copy(&rtmaxoffset)).into()
        }
        Self {
            base: IAMLatency_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetPushSourceFlags: GetPushSourceFlags::<Impl, IMPL_OFFSET>,
            SetPushSourceFlags: SetPushSourceFlags::<Impl, IMPL_OFFSET>,
            SetStreamOffset: SetStreamOffset::<Impl, IMPL_OFFSET>,
            GetStreamOffset: GetStreamOffset::<Impl, IMPL_OFFSET>,
            GetMaxStreamOffset: GetMaxStreamOffset::<Impl, IMPL_OFFSET>,
            SetMaxStreamOffset: SetMaxStreamOffset::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMPushSource as ::windows::core::Interface>::IID
    }
}
pub trait IAMRebuild_Impl: Sized {
    fn RebuildNow(&mut self) -> ::windows::core::Result<()>;
}
impl IAMRebuild_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMRebuild_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMRebuild_Vtbl {
        unsafe extern "system" fn RebuildNow<Impl: IAMRebuild_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RebuildNow().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), RebuildNow: RebuildNow::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMRebuild as ::windows::core::Interface>::IID
    }
}
pub trait IAMResourceControl_Impl: Sized {
    fn Reserve(&mut self, dwflags: u32, pvreserved: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IAMResourceControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMResourceControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMResourceControl_Vtbl {
        unsafe extern "system" fn Reserve<Impl: IAMResourceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pvreserved: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reserve(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&pvreserved)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Reserve: Reserve::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMResourceControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAMStats_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn GetValueByIndex(&mut self, lindex: i32, szname: *mut super::super::Foundation::BSTR, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::Result<()>;
    fn GetValueByName(&mut self, szname: &super::super::Foundation::BSTR, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::Result<()>;
    fn GetIndex(&mut self, szname: &super::super::Foundation::BSTR, lcreate: i32) -> ::windows::core::Result<i32>;
    fn AddValue(&mut self, lindex: i32, dvalue: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAMStats_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMStats_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMStats_Vtbl {
        unsafe extern "system" fn Reset<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Count<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *plcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValueByIndex<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, szname: *mut super::super::Foundation::BSTR, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetValueByIndex(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&szname), ::core::mem::transmute_copy(&lcount), ::core::mem::transmute_copy(&dlast), ::core::mem::transmute_copy(&daverage), ::core::mem::transmute_copy(&dstddev), ::core::mem::transmute_copy(&dmin), ::core::mem::transmute_copy(&dmax)).into()
        }
        unsafe extern "system" fn GetValueByName<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetValueByName(::core::mem::transmute_copy(&szname), ::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&lcount), ::core::mem::transmute_copy(&dlast), ::core::mem::transmute_copy(&daverage), ::core::mem::transmute_copy(&dstddev), ::core::mem::transmute_copy(&dmin), ::core::mem::transmute_copy(&dmax)).into()
        }
        unsafe extern "system" fn GetIndex<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, lcreate: i32, plindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIndex(::core::mem::transmute_copy(&szname), ::core::mem::transmute_copy(&lcreate)) {
                ::core::result::Result::Ok(ok__) => {
                    *plindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddValue<Impl: IAMStats_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, dvalue: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddValue(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&dvalue)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Count: Count::<Impl, IMPL_OFFSET>,
            GetValueByIndex: GetValueByIndex::<Impl, IMPL_OFFSET>,
            GetValueByName: GetValueByName::<Impl, IMPL_OFFSET>,
            GetIndex: GetIndex::<Impl, IMPL_OFFSET>,
            AddValue: AddValue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMStats as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMStreamConfig_Impl: Sized {
    fn SetFormat(&mut self, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn GetFormat(&mut self) -> ::windows::core::Result<*mut AM_MEDIA_TYPE>;
    fn GetNumberOfCapabilities(&mut self, picount: *mut i32, pisize: *mut i32) -> ::windows::core::Result<()>;
    fn GetStreamCaps(&mut self, iindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pscc: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMStreamConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMStreamConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMStreamConfig_Vtbl {
        unsafe extern "system" fn SetFormat<Impl: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFormat(::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn GetFormat<Impl: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmt: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfCapabilities<Impl: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picount: *mut i32, pisize: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNumberOfCapabilities(::core::mem::transmute_copy(&picount), ::core::mem::transmute_copy(&pisize)).into()
        }
        unsafe extern "system" fn GetStreamCaps<Impl: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, iindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pscc: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamCaps(::core::mem::transmute_copy(&iindex), ::core::mem::transmute_copy(&ppmt), ::core::mem::transmute_copy(&pscc)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFormat: SetFormat::<Impl, IMPL_OFFSET>,
            GetFormat: GetFormat::<Impl, IMPL_OFFSET>,
            GetNumberOfCapabilities: GetNumberOfCapabilities::<Impl, IMPL_OFFSET>,
            GetStreamCaps: GetStreamCaps::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMStreamConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMStreamControl_Impl: Sized {
    fn StartAt(&mut self, ptstart: *const i64, dwcookie: u32) -> ::windows::core::Result<()>;
    fn StopAt(&mut self, ptstop: *const i64, bsendextra: super::super::Foundation::BOOL, dwcookie: u32) -> ::windows::core::Result<()>;
    fn GetInfo(&mut self) -> ::windows::core::Result<AM_STREAM_INFO>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMStreamControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMStreamControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMStreamControl_Vtbl {
        unsafe extern "system" fn StartAt<Impl: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptstart: *const i64, dwcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartAt(::core::mem::transmute_copy(&ptstart), ::core::mem::transmute_copy(&dwcookie)).into()
        }
        unsafe extern "system" fn StopAt<Impl: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptstop: *const i64, bsendextra: super::super::Foundation::BOOL, dwcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopAt(::core::mem::transmute_copy(&ptstop), ::core::mem::transmute_copy(&bsendextra), ::core::mem::transmute_copy(&dwcookie)).into()
        }
        unsafe extern "system" fn GetInfo<Impl: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinfo: *mut AM_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *pinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartAt: StartAt::<Impl, IMPL_OFFSET>,
            StopAt: StopAt::<Impl, IMPL_OFFSET>,
            GetInfo: GetInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMStreamControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMStreamSelect_Impl: Sized {
    fn Count(&mut self) -> ::windows::core::Result<u32>;
    fn Info(&mut self, lindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pdwflags: *mut u32, plcid: *mut u32, pdwgroup: *mut u32, ppszname: *mut super::super::Foundation::PWSTR, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>, ppunk: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn Enable(&mut self, lindex: i32, dwflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMStreamSelect_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMStreamSelect_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMStreamSelect_Vtbl {
        unsafe extern "system" fn Count<Impl: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *pcstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Info<Impl: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, ppmt: *mut *mut AM_MEDIA_TYPE, pdwflags: *mut u32, plcid: *mut u32, pdwgroup: *mut u32, ppszname: *mut super::super::Foundation::PWSTR, ppobject: *mut *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Info(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&ppmt), ::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&plcid), ::core::mem::transmute_copy(&pdwgroup), ::core::mem::transmute_copy(&ppszname), ::core::mem::transmute_copy(&ppobject), ::core::mem::transmute_copy(&ppunk)).into()
        }
        unsafe extern "system" fn Enable<Impl: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Enable(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            Info: Info::<Impl, IMPL_OFFSET>,
            Enable: Enable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMStreamSelect as ::windows::core::Interface>::IID
    }
}
pub trait IAMTVAudio_Impl: Sized {
    fn GetHardwareSupportedTVAudioModes(&mut self) -> ::windows::core::Result<i32>;
    fn GetAvailableTVAudioModes(&mut self) -> ::windows::core::Result<i32>;
    fn TVAudioMode(&mut self) -> ::windows::core::Result<i32>;
    fn SetTVAudioMode(&mut self, lmode: i32) -> ::windows::core::Result<()>;
    fn RegisterNotificationCallBack(&mut self, pnotify: &::core::option::Option<IAMTunerNotification>, levents: i32) -> ::windows::core::Result<()>;
    fn UnRegisterNotificationCallBack(&mut self, pnotify: &::core::option::Option<IAMTunerNotification>) -> ::windows::core::Result<()>;
}
impl IAMTVAudio_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTVAudio_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTVAudio_Vtbl {
        unsafe extern "system" fn GetHardwareSupportedTVAudioModes<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHardwareSupportedTVAudioModes() {
                ::core::result::Result::Ok(ok__) => {
                    *plmodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableTVAudioModes<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAvailableTVAudioModes() {
                ::core::result::Result::Ok(ok__) => {
                    *plmodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVAudioMode<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TVAudioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *plmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTVAudioMode<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTVAudioMode(::core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr, levents: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterNotificationCallBack(::core::mem::transmute(&pnotify), ::core::mem::transmute_copy(&levents)).into()
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Impl: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnRegisterNotificationCallBack(::core::mem::transmute(&pnotify)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetHardwareSupportedTVAudioModes: GetHardwareSupportedTVAudioModes::<Impl, IMPL_OFFSET>,
            GetAvailableTVAudioModes: GetAvailableTVAudioModes::<Impl, IMPL_OFFSET>,
            TVAudioMode: TVAudioMode::<Impl, IMPL_OFFSET>,
            SetTVAudioMode: SetTVAudioMode::<Impl, IMPL_OFFSET>,
            RegisterNotificationCallBack: RegisterNotificationCallBack::<Impl, IMPL_OFFSET>,
            UnRegisterNotificationCallBack: UnRegisterNotificationCallBack::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTVAudio as ::windows::core::Interface>::IID
    }
}
pub trait IAMTVAudioNotification_Impl: Sized {
    fn OnEvent(&mut self, event: AMTVAudioEventType) -> ::windows::core::Result<()>;
}
impl IAMTVAudioNotification_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTVAudioNotification_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTVAudioNotification_Vtbl {
        unsafe extern "system" fn OnEvent<Impl: IAMTVAudioNotification_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, event: AMTVAudioEventType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnEvent(::core::mem::transmute_copy(&event)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnEvent: OnEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTVAudioNotification as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMTVTuner_Impl: Sized + IAMTuner_Impl {
    fn AvailableTVFormats(&mut self) -> ::windows::core::Result<i32>;
    fn TVFormat(&mut self) -> ::windows::core::Result<i32>;
    fn AutoTune(&mut self, lchannel: i32) -> ::windows::core::Result<i32>;
    fn StoreAutoTune(&mut self) -> ::windows::core::Result<()>;
    fn NumInputConnections(&mut self) -> ::windows::core::Result<i32>;
    fn SetInputType(&mut self, lindex: i32, inputtype: TunerInputType) -> ::windows::core::Result<()>;
    fn InputType(&mut self, lindex: i32) -> ::windows::core::Result<TunerInputType>;
    fn SetConnectInput(&mut self, lindex: i32) -> ::windows::core::Result<()>;
    fn ConnectInput(&mut self) -> ::windows::core::Result<i32>;
    fn VideoFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn AudioFrequency(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMTVTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTVTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTVTuner_Vtbl {
        unsafe extern "system" fn AvailableTVFormats<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lanalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvailableTVFormats() {
                ::core::result::Result::Ok(ok__) => {
                    *lanalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TVFormat<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planalogvideostandard: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TVFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *planalogvideostandard = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoTune<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lchannel: i32, plfoundsignal: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoTune(::core::mem::transmute_copy(&lchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *plfoundsignal = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StoreAutoTune<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StoreAutoTune().into()
        }
        unsafe extern "system" fn NumInputConnections<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plnuminputconnections: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumInputConnections() {
                ::core::result::Result::Ok(ok__) => {
                    *plnuminputconnections = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, inputtype: TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputType(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&inputtype)).into()
        }
        unsafe extern "system" fn InputType<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, pinputtype: *mut TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputType(::core::mem::transmute_copy(&lindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pinputtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConnectInput<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConnectInput(::core::mem::transmute_copy(&lindex)).into()
        }
        unsafe extern "system" fn ConnectInput<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectInput() {
                ::core::result::Result::Ok(ok__) => {
                    *plindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoFrequency<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *lfreq = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioFrequency<Impl: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *lfreq = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IAMTuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Impl, IMPL_OFFSET>,
            TVFormat: TVFormat::<Impl, IMPL_OFFSET>,
            AutoTune: AutoTune::<Impl, IMPL_OFFSET>,
            StoreAutoTune: StoreAutoTune::<Impl, IMPL_OFFSET>,
            NumInputConnections: NumInputConnections::<Impl, IMPL_OFFSET>,
            SetInputType: SetInputType::<Impl, IMPL_OFFSET>,
            InputType: InputType::<Impl, IMPL_OFFSET>,
            SetConnectInput: SetConnectInput::<Impl, IMPL_OFFSET>,
            ConnectInput: ConnectInput::<Impl, IMPL_OFFSET>,
            VideoFrequency: VideoFrequency::<Impl, IMPL_OFFSET>,
            AudioFrequency: AudioFrequency::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTVTuner as ::windows::core::Interface>::IID
    }
}
pub trait IAMTimecodeDisplay_Impl: Sized {
    fn GetTCDisplayEnable(&mut self) -> ::windows::core::Result<i32>;
    fn SetTCDisplayEnable(&mut self, state: i32) -> ::windows::core::Result<()>;
    fn GetTCDisplay(&mut self, param: i32) -> ::windows::core::Result<i32>;
    fn SetTCDisplay(&mut self, param: i32, value: i32) -> ::windows::core::Result<()>;
}
impl IAMTimecodeDisplay_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTimecodeDisplay_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTimecodeDisplay_Vtbl {
        unsafe extern "system" fn GetTCDisplayEnable<Impl: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTCDisplayEnable() {
                ::core::result::Result::Ok(ok__) => {
                    *pstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCDisplayEnable<Impl: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTCDisplayEnable(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn GetTCDisplay<Impl: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTCDisplay(::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCDisplay<Impl: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTCDisplay(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTCDisplayEnable: GetTCDisplayEnable::<Impl, IMPL_OFFSET>,
            SetTCDisplayEnable: SetTCDisplayEnable::<Impl, IMPL_OFFSET>,
            GetTCDisplay: GetTCDisplay::<Impl, IMPL_OFFSET>,
            SetTCDisplay: SetTCDisplay::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTimecodeDisplay as ::windows::core::Interface>::IID
    }
}
pub trait IAMTimecodeGenerator_Impl: Sized {
    fn GetTCGMode(&mut self, param: i32) -> ::windows::core::Result<i32>;
    fn SetTCGMode(&mut self, param: i32, value: i32) -> ::windows::core::Result<()>;
    fn SetVITCLine(&mut self, line: i32) -> ::windows::core::Result<()>;
    fn VITCLine(&mut self) -> ::windows::core::Result<i32>;
    fn SetTimecode(&mut self, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::Result<()>;
    fn GetTimecode(&mut self) -> ::windows::core::Result<super::TIMECODE_SAMPLE>;
}
impl IAMTimecodeGenerator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTimecodeGenerator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTimecodeGenerator_Vtbl {
        unsafe extern "system" fn GetTCGMode<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTCGMode(::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCGMode<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTCGMode(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn SetVITCLine<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, line: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVITCLine(::core::mem::transmute_copy(&line)).into()
        }
        unsafe extern "system" fn VITCLine<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VITCLine() {
                ::core::result::Result::Ok(ok__) => {
                    *pline = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimecode<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimecode(::core::mem::transmute_copy(&ptimecodesample)).into()
        }
        unsafe extern "system" fn GetTimecode<Impl: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimecode() {
                ::core::result::Result::Ok(ok__) => {
                    *ptimecodesample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTCGMode: GetTCGMode::<Impl, IMPL_OFFSET>,
            SetTCGMode: SetTCGMode::<Impl, IMPL_OFFSET>,
            SetVITCLine: SetVITCLine::<Impl, IMPL_OFFSET>,
            VITCLine: VITCLine::<Impl, IMPL_OFFSET>,
            SetTimecode: SetTimecode::<Impl, IMPL_OFFSET>,
            GetTimecode: GetTimecode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTimecodeGenerator as ::windows::core::Interface>::IID
    }
}
pub trait IAMTimecodeReader_Impl: Sized {
    fn GetTCRMode(&mut self, param: i32) -> ::windows::core::Result<i32>;
    fn SetTCRMode(&mut self, param: i32, value: i32) -> ::windows::core::Result<()>;
    fn SetVITCLine(&mut self, line: i32) -> ::windows::core::Result<()>;
    fn VITCLine(&mut self) -> ::windows::core::Result<i32>;
    fn GetTimecode(&mut self) -> ::windows::core::Result<super::TIMECODE_SAMPLE>;
}
impl IAMTimecodeReader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTimecodeReader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTimecodeReader_Vtbl {
        unsafe extern "system" fn GetTCRMode<Impl: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTCRMode(::core::mem::transmute_copy(&param)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTCRMode<Impl: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, param: i32, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTCRMode(::core::mem::transmute_copy(&param), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn SetVITCLine<Impl: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, line: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVITCLine(::core::mem::transmute_copy(&line)).into()
        }
        unsafe extern "system" fn VITCLine<Impl: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VITCLine() {
                ::core::result::Result::Ok(ok__) => {
                    *pline = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimecode<Impl: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimecode() {
                ::core::result::Result::Ok(ok__) => {
                    *ptimecodesample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTCRMode: GetTCRMode::<Impl, IMPL_OFFSET>,
            SetTCRMode: SetTCRMode::<Impl, IMPL_OFFSET>,
            SetVITCLine: SetVITCLine::<Impl, IMPL_OFFSET>,
            VITCLine: VITCLine::<Impl, IMPL_OFFSET>,
            GetTimecode: GetTimecode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTimecodeReader as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMTuner_Impl: Sized {
    fn SetChannel(&mut self, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> ::windows::core::Result<()>;
    fn Channel(&mut self, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> ::windows::core::Result<()>;
    fn ChannelMinMax(&mut self, lchannelmin: *mut i32, lchannelmax: *mut i32) -> ::windows::core::Result<()>;
    fn SetCountryCode(&mut self, lcountrycode: i32) -> ::windows::core::Result<()>;
    fn CountryCode(&mut self) -> ::windows::core::Result<i32>;
    fn SetTuningSpace(&mut self, ltuningspace: i32) -> ::windows::core::Result<()>;
    fn TuningSpace(&mut self) -> ::windows::core::Result<i32>;
    fn Logon(&mut self, hcurrentuser: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn Logout(&mut self) -> ::windows::core::Result<()>;
    fn SignalPresent(&mut self) -> ::windows::core::Result<i32>;
    fn SetMode(&mut self, lmode: AMTunerModeType) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<AMTunerModeType>;
    fn GetAvailableModes(&mut self) -> ::windows::core::Result<i32>;
    fn RegisterNotificationCallBack(&mut self, pnotify: &::core::option::Option<IAMTunerNotification>, levents: i32) -> ::windows::core::Result<()>;
    fn UnRegisterNotificationCallBack(&mut self, pnotify: &::core::option::Option<IAMTunerNotification>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTuner_Vtbl {
        unsafe extern "system" fn SetChannel<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChannel(::core::mem::transmute_copy(&lchannel), ::core::mem::transmute_copy(&lvideosubchannel), ::core::mem::transmute_copy(&laudiosubchannel)).into()
        }
        unsafe extern "system" fn Channel<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Channel(::core::mem::transmute_copy(&plchannel), ::core::mem::transmute_copy(&plvideosubchannel), ::core::mem::transmute_copy(&plaudiosubchannel)).into()
        }
        unsafe extern "system" fn ChannelMinMax<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lchannelmin: *mut i32, lchannelmax: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChannelMinMax(::core::mem::transmute_copy(&lchannelmin), ::core::mem::transmute_copy(&lchannelmax)).into()
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcountrycode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&lcountrycode)).into()
        }
        unsafe extern "system" fn CountryCode<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plcountrycode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *plcountrycode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltuningspace: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTuningSpace(::core::mem::transmute_copy(&ltuningspace)).into()
        }
        unsafe extern "system" fn TuningSpace<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pltuningspace: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpace() {
                ::core::result::Result::Ok(ok__) => {
                    *pltuningspace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Logon<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hcurrentuser: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Logon(::core::mem::transmute_copy(&hcurrentuser)).into()
        }
        unsafe extern "system" fn Logout<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Logout().into()
        }
        unsafe extern "system" fn SignalPresent<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plsignalstrength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SignalPresent() {
                ::core::result::Result::Ok(ok__) => {
                    *plsignalstrength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lmode: AMTunerModeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn Mode<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmode: *mut AMTunerModeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *plmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableModes<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAvailableModes() {
                ::core::result::Result::Ok(ok__) => {
                    *plmodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr, levents: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterNotificationCallBack(::core::mem::transmute(&pnotify), ::core::mem::transmute_copy(&levents)).into()
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Impl: IAMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnRegisterNotificationCallBack(::core::mem::transmute(&pnotify)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetChannel: SetChannel::<Impl, IMPL_OFFSET>,
            Channel: Channel::<Impl, IMPL_OFFSET>,
            ChannelMinMax: ChannelMinMax::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetTuningSpace: SetTuningSpace::<Impl, IMPL_OFFSET>,
            TuningSpace: TuningSpace::<Impl, IMPL_OFFSET>,
            Logon: Logon::<Impl, IMPL_OFFSET>,
            Logout: Logout::<Impl, IMPL_OFFSET>,
            SignalPresent: SignalPresent::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            GetAvailableModes: GetAvailableModes::<Impl, IMPL_OFFSET>,
            RegisterNotificationCallBack: RegisterNotificationCallBack::<Impl, IMPL_OFFSET>,
            UnRegisterNotificationCallBack: UnRegisterNotificationCallBack::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTuner as ::windows::core::Interface>::IID
    }
}
pub trait IAMTunerNotification_Impl: Sized {
    fn OnEvent(&mut self, event: AMTunerEventType) -> ::windows::core::Result<()>;
}
impl IAMTunerNotification_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMTunerNotification_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMTunerNotification_Vtbl {
        unsafe extern "system" fn OnEvent<Impl: IAMTunerNotification_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, event: AMTunerEventType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnEvent(::core::mem::transmute_copy(&event)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnEvent: OnEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMTunerNotification as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMVfwCaptureDialogs_Impl: Sized {
    fn HasDialog(&mut self, idialog: i32) -> ::windows::core::Result<()>;
    fn ShowDialog(&mut self, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn SendDriverMessage(&mut self, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMVfwCaptureDialogs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVfwCaptureDialogs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVfwCaptureDialogs_Vtbl {
        unsafe extern "system" fn HasDialog<Impl: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idialog: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasDialog(::core::mem::transmute_copy(&idialog)).into()
        }
        unsafe extern "system" fn ShowDialog<Impl: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowDialog(::core::mem::transmute_copy(&idialog), ::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn SendDriverMessage<Impl: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SendDriverMessage(::core::mem::transmute_copy(&idialog), ::core::mem::transmute_copy(&umsg), ::core::mem::transmute_copy(&dw1), ::core::mem::transmute_copy(&dw2)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            HasDialog: HasDialog::<Impl, IMPL_OFFSET>,
            ShowDialog: ShowDialog::<Impl, IMPL_OFFSET>,
            SendDriverMessage: SendDriverMessage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVfwCaptureDialogs as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMVfwCompressDialogs_Impl: Sized {
    fn ShowDialog(&mut self, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn GetState(&mut self, pstate: *mut ::core::ffi::c_void, pcbstate: *mut i32) -> ::windows::core::Result<()>;
    fn SetState(&mut self, pstate: *const ::core::ffi::c_void, cbstate: i32) -> ::windows::core::Result<()>;
    fn SendDriverMessage(&mut self, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMVfwCompressDialogs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVfwCompressDialogs_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVfwCompressDialogs_Vtbl {
        unsafe extern "system" fn ShowDialog<Impl: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowDialog(::core::mem::transmute_copy(&idialog), ::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn GetState<Impl: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void, pcbstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetState(::core::mem::transmute_copy(&pstate), ::core::mem::transmute_copy(&pcbstate)).into()
        }
        unsafe extern "system" fn SetState<Impl: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *const ::core::ffi::c_void, cbstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetState(::core::mem::transmute_copy(&pstate), ::core::mem::transmute_copy(&cbstate)).into()
        }
        unsafe extern "system" fn SendDriverMessage<Impl: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, umsg: i32, dw1: i32, dw2: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SendDriverMessage(::core::mem::transmute_copy(&umsg), ::core::mem::transmute_copy(&dw1), ::core::mem::transmute_copy(&dw2)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ShowDialog: ShowDialog::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            SetState: SetState::<Impl, IMPL_OFFSET>,
            SendDriverMessage: SendDriverMessage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVfwCompressDialogs as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IAMVideoAccelerator_Impl: Sized {
    fn GetVideoAcceleratorGUIDs(&mut self, pdwnumguidssupported: *mut u32, pguidssupported: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetUncompFormatsSupported(&mut self, pguid: *const ::windows::core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::Result<()>;
    fn GetInternalMemInfo(&mut self, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> ::windows::core::Result<()>;
    fn GetCompBufferInfo(&mut self, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::Result<()>;
    fn GetInternalCompBufferInfo(&mut self, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::Result<()>;
    fn BeginFrame(&mut self, amvabeginframeinfo: *const AMVABeginFrameInfo) -> ::windows::core::Result<()>;
    fn EndFrame(&mut self, pendframeinfo: *const AMVAEndFrameInfo) -> ::windows::core::Result<()>;
    fn GetBuffer(&mut self, dwtypeindex: u32, dwbufferindex: u32, breadonly: super::super::Foundation::BOOL, ppbuffer: *mut *mut ::core::ffi::c_void, lpstride: *mut i32) -> ::windows::core::Result<()>;
    fn ReleaseBuffer(&mut self, dwtypeindex: u32, dwbufferindex: u32) -> ::windows::core::Result<()>;
    fn Execute(&mut self, dwfunction: u32, lpprivateinputdata: *const ::core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const ::core::ffi::c_void, cbprivateoutputdata: u32, dwnumbuffers: u32, pamvabufferinfo: *const AMVABUFFERINFO) -> ::windows::core::Result<()>;
    fn QueryRenderStatus(&mut self, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> ::windows::core::Result<()>;
    fn DisplayFrame(&mut self, dwfliptoindex: u32, pmediasample: &::core::option::Option<IMediaSample>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IAMVideoAccelerator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoAccelerator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoAccelerator_Vtbl {
        unsafe extern "system" fn GetVideoAcceleratorGUIDs<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumguidssupported: *mut u32, pguidssupported: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoAcceleratorGUIDs(::core::mem::transmute_copy(&pdwnumguidssupported), ::core::mem::transmute_copy(&pguidssupported)).into()
        }
        unsafe extern "system" fn GetUncompFormatsSupported<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUncompFormatsSupported(::core::mem::transmute_copy(&pguid), ::core::mem::transmute_copy(&pdwnumformatssupported), ::core::mem::transmute_copy(&pformatssupported)).into()
        }
        unsafe extern "system" fn GetInternalMemInfo<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInternalMemInfo(::core::mem::transmute_copy(&pguid), ::core::mem::transmute_copy(&pamvauncompdatainfo), ::core::mem::transmute_copy(&pamvainternalmeminfo)).into()
        }
        unsafe extern "system" fn GetCompBufferInfo<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCompBufferInfo(::core::mem::transmute_copy(&pguid), ::core::mem::transmute_copy(&pamvauncompdatainfo), ::core::mem::transmute_copy(&pdwnumtypescompbuffers), ::core::mem::transmute_copy(&pamvacompbufferinfo)).into()
        }
        unsafe extern "system" fn GetInternalCompBufferInfo<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInternalCompBufferInfo(::core::mem::transmute_copy(&pdwnumtypescompbuffers), ::core::mem::transmute_copy(&pamvacompbufferinfo)).into()
        }
        unsafe extern "system" fn BeginFrame<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, amvabeginframeinfo: *const AMVABeginFrameInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginFrame(::core::mem::transmute_copy(&amvabeginframeinfo)).into()
        }
        unsafe extern "system" fn EndFrame<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pendframeinfo: *const AMVAEndFrameInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndFrame(::core::mem::transmute_copy(&pendframeinfo)).into()
        }
        unsafe extern "system" fn GetBuffer<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, breadonly: super::super::Foundation::BOOL, ppbuffer: *mut *mut ::core::ffi::c_void, lpstride: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBuffer(::core::mem::transmute_copy(&dwtypeindex), ::core::mem::transmute_copy(&dwbufferindex), ::core::mem::transmute_copy(&breadonly), ::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&lpstride)).into()
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseBuffer(::core::mem::transmute_copy(&dwtypeindex), ::core::mem::transmute_copy(&dwbufferindex)).into()
        }
        unsafe extern "system" fn Execute<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwfunction: u32, lpprivateinputdata: *const ::core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const ::core::ffi::c_void, cbprivateoutputdata: u32, dwnumbuffers: u32, pamvabufferinfo: *const AMVABUFFERINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Execute(::core::mem::transmute_copy(&dwfunction), ::core::mem::transmute_copy(&lpprivateinputdata), ::core::mem::transmute_copy(&cbprivateinputdata), ::core::mem::transmute_copy(&lpprivateoutputdat), ::core::mem::transmute_copy(&cbprivateoutputdata), ::core::mem::transmute_copy(&dwnumbuffers), ::core::mem::transmute_copy(&pamvabufferinfo)).into()
        }
        unsafe extern "system" fn QueryRenderStatus<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryRenderStatus(::core::mem::transmute_copy(&dwtypeindex), ::core::mem::transmute_copy(&dwbufferindex), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn DisplayFrame<Impl: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwfliptoindex: u32, pmediasample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisplayFrame(::core::mem::transmute_copy(&dwfliptoindex), ::core::mem::transmute(&pmediasample)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetVideoAcceleratorGUIDs: GetVideoAcceleratorGUIDs::<Impl, IMPL_OFFSET>,
            GetUncompFormatsSupported: GetUncompFormatsSupported::<Impl, IMPL_OFFSET>,
            GetInternalMemInfo: GetInternalMemInfo::<Impl, IMPL_OFFSET>,
            GetCompBufferInfo: GetCompBufferInfo::<Impl, IMPL_OFFSET>,
            GetInternalCompBufferInfo: GetInternalCompBufferInfo::<Impl, IMPL_OFFSET>,
            BeginFrame: BeginFrame::<Impl, IMPL_OFFSET>,
            EndFrame: EndFrame::<Impl, IMPL_OFFSET>,
            GetBuffer: GetBuffer::<Impl, IMPL_OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Impl, IMPL_OFFSET>,
            Execute: Execute::<Impl, IMPL_OFFSET>,
            QueryRenderStatus: QueryRenderStatus::<Impl, IMPL_OFFSET>,
            DisplayFrame: DisplayFrame::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoAccelerator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IAMVideoAcceleratorNotify_Impl: Sized {
    fn GetUncompSurfacesInfo(&mut self, pguid: *const ::windows::core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> ::windows::core::Result<()>;
    fn SetUncompSurfacesInfo(&mut self, dwactualuncompsurfacesallocated: u32) -> ::windows::core::Result<()>;
    fn GetCreateVideoAcceleratorData(&mut self, pguid: *const ::windows::core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IAMVideoAcceleratorNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoAcceleratorNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoAcceleratorNotify_Vtbl {
        unsafe extern "system" fn GetUncompSurfacesInfo<Impl: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUncompSurfacesInfo(::core::mem::transmute_copy(&pguid), ::core::mem::transmute_copy(&puncompbufferinfo)).into()
        }
        unsafe extern "system" fn SetUncompSurfacesInfo<Impl: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwactualuncompsurfacesallocated: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUncompSurfacesInfo(::core::mem::transmute_copy(&dwactualuncompsurfacesallocated)).into()
        }
        unsafe extern "system" fn GetCreateVideoAcceleratorData<Impl: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const ::windows::core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCreateVideoAcceleratorData(::core::mem::transmute_copy(&pguid), ::core::mem::transmute_copy(&pdwsizemiscdata), ::core::mem::transmute_copy(&ppmiscdata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetUncompSurfacesInfo: GetUncompSurfacesInfo::<Impl, IMPL_OFFSET>,
            SetUncompSurfacesInfo: SetUncompSurfacesInfo::<Impl, IMPL_OFFSET>,
            GetCreateVideoAcceleratorData: GetCreateVideoAcceleratorData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoAcceleratorNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMVideoCompression_Impl: Sized {
    fn SetKeyFrameRate(&mut self, keyframerate: i32) -> ::windows::core::Result<()>;
    fn KeyFrameRate(&mut self) -> ::windows::core::Result<i32>;
    fn SetPFramesPerKeyFrame(&mut self, pframesperkeyframe: i32) -> ::windows::core::Result<()>;
    fn PFramesPerKeyFrame(&mut self) -> ::windows::core::Result<i32>;
    fn SetQuality(&mut self, quality: f64) -> ::windows::core::Result<()>;
    fn Quality(&mut self) -> ::windows::core::Result<f64>;
    fn SetWindowSize(&mut self, windowsize: u64) -> ::windows::core::Result<()>;
    fn WindowSize(&mut self) -> ::windows::core::Result<u64>;
    fn GetInfo(&mut self, pszversion: super::super::Foundation::PWSTR, pcbversion: *mut i32, pszdescription: super::super::Foundation::PWSTR, pcbdescription: *mut i32, pdefaultkeyframerate: *mut i32, pdefaultpframesperkey: *mut i32, pdefaultquality: *mut f64, pcapabilities: *mut i32) -> ::windows::core::Result<()>;
    fn OverrideKeyFrame(&mut self, framenumber: i32) -> ::windows::core::Result<()>;
    fn OverrideFrameSize(&mut self, framenumber: i32, size: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMVideoCompression_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoCompression_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoCompression_Vtbl {
        unsafe extern "system" fn SetKeyFrameRate<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keyframerate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyFrameRate(::core::mem::transmute_copy(&keyframerate)).into()
        }
        unsafe extern "system" fn KeyFrameRate<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkeyframerate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeyFrameRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pkeyframerate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPFramesPerKeyFrame<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pframesperkeyframe: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPFramesPerKeyFrame(::core::mem::transmute_copy(&pframesperkeyframe)).into()
        }
        unsafe extern "system" fn PFramesPerKeyFrame<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppframesperkeyframe: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PFramesPerKeyFrame() {
                ::core::result::Result::Ok(ok__) => {
                    *ppframesperkeyframe = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQuality<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, quality: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQuality(::core::mem::transmute_copy(&quality)).into()
        }
        unsafe extern "system" fn Quality<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pquality: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Quality() {
                ::core::result::Result::Ok(ok__) => {
                    *pquality = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowSize<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowSize(::core::mem::transmute_copy(&windowsize)).into()
        }
        unsafe extern "system" fn WindowSize<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwindowsize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WindowSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pwindowsize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInfo<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszversion: super::super::Foundation::PWSTR, pcbversion: *mut i32, pszdescription: super::super::Foundation::PWSTR, pcbdescription: *mut i32, pdefaultkeyframerate: *mut i32, pdefaultpframesperkey: *mut i32, pdefaultquality: *mut f64, pcapabilities: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInfo(::core::mem::transmute_copy(&pszversion), ::core::mem::transmute_copy(&pcbversion), ::core::mem::transmute_copy(&pszdescription), ::core::mem::transmute_copy(&pcbdescription), ::core::mem::transmute_copy(&pdefaultkeyframerate), ::core::mem::transmute_copy(&pdefaultpframesperkey), ::core::mem::transmute_copy(&pdefaultquality), ::core::mem::transmute_copy(&pcapabilities)).into()
        }
        unsafe extern "system" fn OverrideKeyFrame<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, framenumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OverrideKeyFrame(::core::mem::transmute_copy(&framenumber)).into()
        }
        unsafe extern "system" fn OverrideFrameSize<Impl: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, framenumber: i32, size: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OverrideFrameSize(::core::mem::transmute_copy(&framenumber), ::core::mem::transmute_copy(&size)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetKeyFrameRate: SetKeyFrameRate::<Impl, IMPL_OFFSET>,
            KeyFrameRate: KeyFrameRate::<Impl, IMPL_OFFSET>,
            SetPFramesPerKeyFrame: SetPFramesPerKeyFrame::<Impl, IMPL_OFFSET>,
            PFramesPerKeyFrame: PFramesPerKeyFrame::<Impl, IMPL_OFFSET>,
            SetQuality: SetQuality::<Impl, IMPL_OFFSET>,
            Quality: Quality::<Impl, IMPL_OFFSET>,
            SetWindowSize: SetWindowSize::<Impl, IMPL_OFFSET>,
            WindowSize: WindowSize::<Impl, IMPL_OFFSET>,
            GetInfo: GetInfo::<Impl, IMPL_OFFSET>,
            OverrideKeyFrame: OverrideKeyFrame::<Impl, IMPL_OFFSET>,
            OverrideFrameSize: OverrideFrameSize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoCompression as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAMVideoControl_Impl: Sized {
    fn GetCaps(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<i32>;
    fn SetMode(&mut self, ppin: &::core::option::Option<IPin>, mode: i32) -> ::windows::core::Result<()>;
    fn GetMode(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<i32>;
    fn GetCurrentActualFrameRate(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<i64>;
    fn GetMaxAvailableFrameRate(&mut self, ppin: &::core::option::Option<IPin>, iindex: i32, dimensions: &super::super::Foundation::SIZE) -> ::windows::core::Result<i64>;
    fn GetFrameRateList(&mut self, ppin: &::core::option::Option<IPin>, iindex: i32, dimensions: &super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAMVideoControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoControl_Vtbl {
        unsafe extern "system" fn GetCaps<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaps(::core::mem::transmute(&ppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcapsflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute(&ppin), ::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn GetMode<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, mode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMode(::core::mem::transmute(&ppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *mode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentActualFrameRate<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, actualframerate: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentActualFrameRate(::core::mem::transmute(&ppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *actualframerate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxAvailableFrameRate<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, iindex: i32, dimensions: super::super::Foundation::SIZE, maxavailableframerate: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaxAvailableFrameRate(::core::mem::transmute(&ppin), ::core::mem::transmute_copy(&iindex), ::core::mem::transmute_copy(&dimensions)) {
                ::core::result::Result::Ok(ok__) => {
                    *maxavailableframerate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrameRateList<Impl: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, iindex: i32, dimensions: super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFrameRateList(::core::mem::transmute(&ppin), ::core::mem::transmute_copy(&iindex), ::core::mem::transmute_copy(&dimensions), ::core::mem::transmute_copy(&listsize), ::core::mem::transmute_copy(&framerates)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCaps: GetCaps::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            GetMode: GetMode::<Impl, IMPL_OFFSET>,
            GetCurrentActualFrameRate: GetCurrentActualFrameRate::<Impl, IMPL_OFFSET>,
            GetMaxAvailableFrameRate: GetMaxAvailableFrameRate::<Impl, IMPL_OFFSET>,
            GetFrameRateList: GetFrameRateList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoControl as ::windows::core::Interface>::IID
    }
}
pub trait IAMVideoDecimationProperties_Impl: Sized {
    fn QueryDecimationUsage(&mut self) -> ::windows::core::Result<DECIMATION_USAGE>;
    fn SetDecimationUsage(&mut self, usage: DECIMATION_USAGE) -> ::windows::core::Result<()>;
}
impl IAMVideoDecimationProperties_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoDecimationProperties_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoDecimationProperties_Vtbl {
        unsafe extern "system" fn QueryDecimationUsage<Impl: IAMVideoDecimationProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpusage: *mut DECIMATION_USAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryDecimationUsage() {
                ::core::result::Result::Ok(ok__) => {
                    *lpusage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecimationUsage<Impl: IAMVideoDecimationProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usage: DECIMATION_USAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDecimationUsage(::core::mem::transmute_copy(&usage)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryDecimationUsage: QueryDecimationUsage::<Impl, IMPL_OFFSET>,
            SetDecimationUsage: SetDecimationUsage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoDecimationProperties as ::windows::core::Interface>::IID
    }
}
pub trait IAMVideoProcAmp_Impl: Sized {
    fn GetRange(&mut self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::Result<()>;
    fn Set(&mut self, property: i32, lvalue: i32, flags: i32) -> ::windows::core::Result<()>;
    fn Get(&mut self, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::Result<()>;
}
impl IAMVideoProcAmp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMVideoProcAmp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMVideoProcAmp_Vtbl {
        unsafe extern "system" fn GetRange<Impl: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRange(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflags)).into()
        }
        unsafe extern "system" fn Set<Impl: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn Get<Impl: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Get(::core::mem::transmute_copy(&property), ::core::mem::transmute_copy(&lvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetRange: GetRange::<Impl, IMPL_OFFSET>,
            Set: Set::<Impl, IMPL_OFFSET>,
            Get: Get::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMVideoProcAmp as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IAMWstDecoder_Impl: Sized {
    fn GetDecoderLevel(&mut self, lplevel: *mut AM_WST_LEVEL) -> ::windows::core::Result<()>;
    fn GetCurrentService(&mut self, lpservice: *mut AM_WST_SERVICE) -> ::windows::core::Result<()>;
    fn GetServiceState(&mut self, lpstate: *mut AM_WST_STATE) -> ::windows::core::Result<()>;
    fn SetServiceState(&mut self, state: AM_WST_STATE) -> ::windows::core::Result<()>;
    fn GetOutputFormat(&mut self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::Result<()>;
    fn SetOutputFormat(&mut self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::Result<()>;
    fn GetBackgroundColor(&mut self, pdwphyscolor: *mut u32) -> ::windows::core::Result<()>;
    fn SetBackgroundColor(&mut self, dwphyscolor: u32) -> ::windows::core::Result<()>;
    fn GetRedrawAlways(&mut self, lpboption: *mut i32) -> ::windows::core::Result<()>;
    fn SetRedrawAlways(&mut self, boption: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetDrawBackgroundMode(&mut self, lpmode: *mut AM_WST_DRAWBGMODE) -> ::windows::core::Result<()>;
    fn SetDrawBackgroundMode(&mut self, mode: AM_WST_DRAWBGMODE) -> ::windows::core::Result<()>;
    fn SetAnswerMode(&mut self, banswer: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetAnswerMode(&mut self, pbanswer: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetHoldPage(&mut self, bholdpage: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetHoldPage(&mut self, pbholdpage: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetCurrentPage(&mut self, pwstpage: *mut AM_WST_PAGE) -> ::windows::core::Result<()>;
    fn SetCurrentPage(&mut self, wstpage: &AM_WST_PAGE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IAMWstDecoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMWstDecoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMWstDecoder_Vtbl {
        unsafe extern "system" fn GetDecoderLevel<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplevel: *mut AM_WST_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecoderLevel(::core::mem::transmute_copy(&lplevel)).into()
        }
        unsafe extern "system" fn GetCurrentService<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpservice: *mut AM_WST_SERVICE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentService(::core::mem::transmute_copy(&lpservice)).into()
        }
        unsafe extern "system" fn GetServiceState<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpstate: *mut AM_WST_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServiceState(::core::mem::transmute_copy(&lpstate)).into()
        }
        unsafe extern "system" fn SetServiceState<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: AM_WST_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetServiceState(::core::mem::transmute_copy(&state)).into()
        }
        unsafe extern "system" fn GetOutputFormat<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOutputFormat(::core::mem::transmute_copy(&lpbmih)).into()
        }
        unsafe extern "system" fn SetOutputFormat<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFormat(::core::mem::transmute_copy(&lpbmi)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwphyscolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBackgroundColor(::core::mem::transmute_copy(&pdwphyscolor)).into()
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwphyscolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundColor(::core::mem::transmute_copy(&dwphyscolor)).into()
        }
        unsafe extern "system" fn GetRedrawAlways<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpboption: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRedrawAlways(::core::mem::transmute_copy(&lpboption)).into()
        }
        unsafe extern "system" fn SetRedrawAlways<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, boption: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRedrawAlways(::core::mem::transmute_copy(&boption)).into()
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpmode: *mut AM_WST_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDrawBackgroundMode(::core::mem::transmute_copy(&lpmode)).into()
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: AM_WST_DRAWBGMODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDrawBackgroundMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn SetAnswerMode<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, banswer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAnswerMode(::core::mem::transmute_copy(&banswer)).into()
        }
        unsafe extern "system" fn GetAnswerMode<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbanswer: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAnswerMode(::core::mem::transmute_copy(&pbanswer)).into()
        }
        unsafe extern "system" fn SetHoldPage<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bholdpage: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHoldPage(::core::mem::transmute_copy(&bholdpage)).into()
        }
        unsafe extern "system" fn GetHoldPage<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbholdpage: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetHoldPage(::core::mem::transmute_copy(&pbholdpage)).into()
        }
        unsafe extern "system" fn GetCurrentPage<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwstpage: *mut AM_WST_PAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentPage(::core::mem::transmute_copy(&pwstpage)).into()
        }
        unsafe extern "system" fn SetCurrentPage<Impl: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstpage: AM_WST_PAGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPage(::core::mem::transmute_copy(&wstpage)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDecoderLevel: GetDecoderLevel::<Impl, IMPL_OFFSET>,
            GetCurrentService: GetCurrentService::<Impl, IMPL_OFFSET>,
            GetServiceState: GetServiceState::<Impl, IMPL_OFFSET>,
            SetServiceState: SetServiceState::<Impl, IMPL_OFFSET>,
            GetOutputFormat: GetOutputFormat::<Impl, IMPL_OFFSET>,
            SetOutputFormat: SetOutputFormat::<Impl, IMPL_OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Impl, IMPL_OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Impl, IMPL_OFFSET>,
            GetRedrawAlways: GetRedrawAlways::<Impl, IMPL_OFFSET>,
            SetRedrawAlways: SetRedrawAlways::<Impl, IMPL_OFFSET>,
            GetDrawBackgroundMode: GetDrawBackgroundMode::<Impl, IMPL_OFFSET>,
            SetDrawBackgroundMode: SetDrawBackgroundMode::<Impl, IMPL_OFFSET>,
            SetAnswerMode: SetAnswerMode::<Impl, IMPL_OFFSET>,
            GetAnswerMode: GetAnswerMode::<Impl, IMPL_OFFSET>,
            SetHoldPage: SetHoldPage::<Impl, IMPL_OFFSET>,
            GetHoldPage: GetHoldPage::<Impl, IMPL_OFFSET>,
            GetCurrentPage: GetCurrentPage::<Impl, IMPL_OFFSET>,
            SetCurrentPage: SetCurrentPage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMWstDecoder as ::windows::core::Interface>::IID
    }
}
pub trait IAMovieSetup_Impl: Sized {
    fn Register(&mut self) -> ::windows::core::Result<()>;
    fn Unregister(&mut self) -> ::windows::core::Result<()>;
}
impl IAMovieSetup_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAMovieSetup_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAMovieSetup_Vtbl {
        unsafe extern "system" fn Register<Impl: IAMovieSetup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Register().into()
        }
        unsafe extern "system" fn Unregister<Impl: IAMovieSetup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unregister().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Register: Register::<Impl, IMPL_OFFSET>,
            Unregister: Unregister::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAMovieSetup as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IATSCChannelTuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl + IChannelTuneRequest_Impl {
    fn MinorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinorChannel(&mut self, minorchannel: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IATSCChannelTuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSCChannelTuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSCChannelTuneRequest_Vtbl {
        unsafe extern "system" fn MinorChannel<Impl: IATSCChannelTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minorchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *minorchannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinorChannel<Impl: IATSCChannelTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minorchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinorChannel(::core::mem::transmute_copy(&minorchannel)).into()
        }
        Self {
            base: IChannelTuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MinorChannel: MinorChannel::<Impl, IMPL_OFFSET>,
            SetMinorChannel: SetMinorChannel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSCChannelTuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IATSCComponentType_Impl: Sized + super::super::System::Com::IDispatch_Impl + IComponentType_Impl + ILanguageComponentType_Impl + IMPEG2ComponentType_Impl {
    fn Flags(&mut self) -> ::windows::core::Result<i32>;
    fn SetFlags(&mut self, flags: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IATSCComponentType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSCComponentType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSCComponentType_Vtbl {
        unsafe extern "system" fn Flags<Impl: IATSCComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Flags() {
                ::core::result::Result::Ok(ok__) => {
                    *flags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlags<Impl: IATSCComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlags(::core::mem::transmute_copy(&flags)).into()
        }
        Self {
            base: IMPEG2ComponentType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Flags: Flags::<Impl, IMPL_OFFSET>,
            SetFlags: SetFlags::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSCComponentType as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IATSCLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl {
    fn PhysicalChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetPhysicalChannel(&mut self, physicalchannel: i32) -> ::windows::core::Result<()>;
    fn TSID(&mut self) -> ::windows::core::Result<i32>;
    fn SetTSID(&mut self, tsid: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IATSCLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSCLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSCLocator_Vtbl {
        unsafe extern "system" fn PhysicalChannel<Impl: IATSCLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, physicalchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PhysicalChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *physicalchannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPhysicalChannel<Impl: IATSCLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, physicalchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPhysicalChannel(::core::mem::transmute_copy(&physicalchannel)).into()
        }
        unsafe extern "system" fn TSID<Impl: IATSCLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TSID() {
                ::core::result::Result::Ok(ok__) => {
                    *tsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IATSCLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTSID(::core::mem::transmute_copy(&tsid)).into()
        }
        Self {
            base: IDigitalLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            PhysicalChannel: PhysicalChannel::<Impl, IMPL_OFFSET>,
            SetPhysicalChannel: SetPhysicalChannel::<Impl, IMPL_OFFSET>,
            TSID: TSID::<Impl, IMPL_OFFSET>,
            SetTSID: SetTSID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSCLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IATSCLocator2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl + IATSCLocator_Impl {
    fn ProgramNumber(&mut self) -> ::windows::core::Result<i32>;
    fn SetProgramNumber(&mut self, programnumber: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IATSCLocator2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSCLocator2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSCLocator2_Vtbl {
        unsafe extern "system" fn ProgramNumber<Impl: IATSCLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, programnumber: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProgramNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *programnumber = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgramNumber<Impl: IATSCLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, programnumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProgramNumber(::core::mem::transmute_copy(&programnumber)).into()
        }
        Self {
            base: IATSCLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ProgramNumber: ProgramNumber::<Impl, IMPL_OFFSET>,
            SetProgramNumber: SetProgramNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSCLocator2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IATSCTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IAnalogTVTuningSpace_Impl {
    fn MinMinorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinMinorChannel(&mut self, newminminorchannelval: i32) -> ::windows::core::Result<()>;
    fn MaxMinorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxMinorChannel(&mut self, newmaxminorchannelval: i32) -> ::windows::core::Result<()>;
    fn MinPhysicalChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinPhysicalChannel(&mut self, newminphysicalchannelval: i32) -> ::windows::core::Result<()>;
    fn MaxPhysicalChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxPhysicalChannel(&mut self, newmaxphysicalchannelval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IATSCTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSCTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSCTuningSpace_Vtbl {
        unsafe extern "system" fn MinMinorChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minminorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinMinorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *minminorchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinMinorChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminminorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinMinorChannel(::core::mem::transmute_copy(&newminminorchannelval)).into()
        }
        unsafe extern "system" fn MaxMinorChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxminorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxMinorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *maxminorchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxMinorChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxminorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxMinorChannel(::core::mem::transmute_copy(&newmaxminorchannelval)).into()
        }
        unsafe extern "system" fn MinPhysicalChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minphysicalchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinPhysicalChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *minphysicalchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinPhysicalChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminphysicalchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinPhysicalChannel(::core::mem::transmute_copy(&newminphysicalchannelval)).into()
        }
        unsafe extern "system" fn MaxPhysicalChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxphysicalchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxPhysicalChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *maxphysicalchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxPhysicalChannel<Impl: IATSCTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxphysicalchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxPhysicalChannel(::core::mem::transmute_copy(&newmaxphysicalchannelval)).into()
        }
        Self {
            base: IAnalogTVTuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MinMinorChannel: MinMinorChannel::<Impl, IMPL_OFFSET>,
            SetMinMinorChannel: SetMinMinorChannel::<Impl, IMPL_OFFSET>,
            MaxMinorChannel: MaxMinorChannel::<Impl, IMPL_OFFSET>,
            SetMaxMinorChannel: SetMaxMinorChannel::<Impl, IMPL_OFFSET>,
            MinPhysicalChannel: MinPhysicalChannel::<Impl, IMPL_OFFSET>,
            SetMinPhysicalChannel: SetMinPhysicalChannel::<Impl, IMPL_OFFSET>,
            MaxPhysicalChannel: MaxPhysicalChannel::<Impl, IMPL_OFFSET>,
            SetMaxPhysicalChannel: SetMaxPhysicalChannel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSCTuningSpace as ::windows::core::Interface>::IID
    }
}
pub trait IATSC_EIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetSourceId(&mut self) -> ::windows::core::Result<u16>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordEventId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordStartTime(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetRecordEtmLocation(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordDuration(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_TIME>;
    fn GetRecordTitleText(&mut self, dwrecordindex: u32, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::Result<()>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
impl IATSC_EIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSC_EIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSC_EIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceId<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEtmLocation<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEtmLocation(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTitleText<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordTitleText(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&pptext)).into()
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetSourceId: GetSourceId::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordEventId: GetRecordEventId::<Impl, IMPL_OFFSET>,
            GetRecordStartTime: GetRecordStartTime::<Impl, IMPL_OFFSET>,
            GetRecordEtmLocation: GetRecordEtmLocation::<Impl, IMPL_OFFSET>,
            GetRecordDuration: GetRecordDuration::<Impl, IMPL_OFFSET>,
            GetRecordTitleText: GetRecordTitleText::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSC_EIT as ::windows::core::Interface>::IID
    }
}
pub trait IATSC_ETT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetEtmId(&mut self) -> ::windows::core::Result<u32>;
    fn GetExtendedMessageText(&mut self, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IATSC_ETT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSC_ETT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSC_ETT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_ETT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_ETT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_ETT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEtmId<Impl: IATSC_ETT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEtmId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedMessageText<Impl: IATSC_ETT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExtendedMessageText(::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&pptext)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetEtmId: GetEtmId::<Impl, IMPL_OFFSET>,
            GetExtendedMessageText: GetExtendedMessageText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSC_ETT as ::windows::core::Interface>::IID
    }
}
pub trait IATSC_MGT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordType(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordTypePid(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordVersionNumber(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfTableDescriptors(&mut self, pdwval: *const u32) -> ::windows::core::Result<()>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
impl IATSC_MGT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSC_MGT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSC_MGT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordType<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordType(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTypePid<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTypePid(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVersionNumber<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordVersionNumber(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)).into()
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_MGT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordType: GetRecordType::<Impl, IMPL_OFFSET>,
            GetRecordTypePid: GetRecordTypePid::<Impl, IMPL_OFFSET>,
            GetRecordVersionNumber: GetRecordVersionNumber::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSC_MGT as ::windows::core::Interface>::IID
    }
}
pub trait IATSC_STT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetSystemTime(&mut self) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetGpsUtcOffset(&mut self) -> ::windows::core::Result<u8>;
    fn GetDaylightSavings(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
impl IATSC_STT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSC_STT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSC_STT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSystemTime<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmdtsystemtime: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSystemTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtsystemtime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGpsUtcOffset<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGpsUtcOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDaylightSavings<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDaylightSavings() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_STT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetSystemTime: GetSystemTime::<Impl, IMPL_OFFSET>,
            GetGpsUtcOffset: GetGpsUtcOffset::<Impl, IMPL_OFFSET>,
            GetDaylightSavings: GetDaylightSavings::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSC_STT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IATSC_VCT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordName(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetRecordMajorChannelNumber(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordMinorChannelNumber(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordModulationMode(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordCarrierFrequency(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordTransportStreamId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordProgramNumber(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordEtmLocation(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordIsAccessControlledBitSet(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordIsHiddenBitSet(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordIsPathSelectBitSet(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordIsOutOfBandBitSet(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordIsHideGuideBitSet(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordServiceType(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordSourceId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfTableDescriptors(&mut self, pdwval: *const u32) -> ::windows::core::Result<()>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IATSC_VCT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IATSC_VCT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IATSC_VCT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordName<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwsname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordName(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwsname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMajorChannelNumber<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordMajorChannelNumber(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMinorChannelNumber<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordMinorChannelNumber(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModulationMode<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordModulationMode(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCarrierFrequency<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCarrierFrequency(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramNumber<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramNumber(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEtmLocation<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEtmLocation(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsAccessControlledBitSet<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordIsAccessControlledBitSet(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsHiddenBitSet<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordIsHiddenBitSet(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsPathSelectBitSet<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordIsPathSelectBitSet(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsOutOfBandBitSet<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordIsOutOfBandBitSet(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordIsHideGuideBitSet<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordIsHideGuideBitSet(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceType<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceType(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordSourceId<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordSourceId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCountOfTableDescriptors(::core::mem::transmute_copy(&pdwval)).into()
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IATSC_VCT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordName: GetRecordName::<Impl, IMPL_OFFSET>,
            GetRecordMajorChannelNumber: GetRecordMajorChannelNumber::<Impl, IMPL_OFFSET>,
            GetRecordMinorChannelNumber: GetRecordMinorChannelNumber::<Impl, IMPL_OFFSET>,
            GetRecordModulationMode: GetRecordModulationMode::<Impl, IMPL_OFFSET>,
            GetRecordCarrierFrequency: GetRecordCarrierFrequency::<Impl, IMPL_OFFSET>,
            GetRecordTransportStreamId: GetRecordTransportStreamId::<Impl, IMPL_OFFSET>,
            GetRecordProgramNumber: GetRecordProgramNumber::<Impl, IMPL_OFFSET>,
            GetRecordEtmLocation: GetRecordEtmLocation::<Impl, IMPL_OFFSET>,
            GetRecordIsAccessControlledBitSet: GetRecordIsAccessControlledBitSet::<Impl, IMPL_OFFSET>,
            GetRecordIsHiddenBitSet: GetRecordIsHiddenBitSet::<Impl, IMPL_OFFSET>,
            GetRecordIsPathSelectBitSet: GetRecordIsPathSelectBitSet::<Impl, IMPL_OFFSET>,
            GetRecordIsOutOfBandBitSet: GetRecordIsOutOfBandBitSet::<Impl, IMPL_OFFSET>,
            GetRecordIsHideGuideBitSet: GetRecordIsHideGuideBitSet::<Impl, IMPL_OFFSET>,
            GetRecordServiceType: GetRecordServiceType::<Impl, IMPL_OFFSET>,
            GetRecordSourceId: GetRecordSourceId::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IATSC_VCT as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAnalogAudioComponentType_Impl: Sized + super::super::System::Com::IDispatch_Impl + IComponentType_Impl {
    fn AnalogAudioMode(&mut self) -> ::windows::core::Result<TVAudioMode>;
    fn SetAnalogAudioMode(&mut self, mode: TVAudioMode) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAnalogAudioComponentType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnalogAudioComponentType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnalogAudioComponentType_Vtbl {
        unsafe extern "system" fn AnalogAudioMode<Impl: IAnalogAudioComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: *mut TVAudioMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnalogAudioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *mode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnalogAudioMode<Impl: IAnalogAudioComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: TVAudioMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAnalogAudioMode(::core::mem::transmute_copy(&mode)).into()
        }
        Self {
            base: IComponentType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AnalogAudioMode: AnalogAudioMode::<Impl, IMPL_OFFSET>,
            SetAnalogAudioMode: SetAnalogAudioMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnalogAudioComponentType as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAnalogLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl {
    fn VideoStandard(&mut self) -> ::windows::core::Result<AnalogVideoStandard>;
    fn SetVideoStandard(&mut self, avs: AnalogVideoStandard) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAnalogLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnalogLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnalogLocator_Vtbl {
        unsafe extern "system" fn VideoStandard<Impl: IAnalogLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, avs: *mut AnalogVideoStandard) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoStandard() {
                ::core::result::Result::Ok(ok__) => {
                    *avs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoStandard<Impl: IAnalogLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, avs: AnalogVideoStandard) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoStandard(::core::mem::transmute_copy(&avs)).into()
        }
        Self {
            base: ILocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            VideoStandard: VideoStandard::<Impl, IMPL_OFFSET>,
            SetVideoStandard: SetVideoStandard::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnalogLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAnalogRadioTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl {
    fn MinFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinFrequency(&mut self, newminfrequencyval: i32) -> ::windows::core::Result<()>;
    fn MaxFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxFrequency(&mut self, newmaxfrequencyval: i32) -> ::windows::core::Result<()>;
    fn Step(&mut self) -> ::windows::core::Result<i32>;
    fn SetStep(&mut self, newstepval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAnalogRadioTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnalogRadioTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnalogRadioTuningSpace_Vtbl {
        unsafe extern "system" fn MinFrequency<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minfrequencyval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *minfrequencyval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinFrequency<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminfrequencyval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinFrequency(::core::mem::transmute_copy(&newminfrequencyval)).into()
        }
        unsafe extern "system" fn MaxFrequency<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxfrequencyval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *maxfrequencyval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxFrequency<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxfrequencyval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxFrequency(::core::mem::transmute_copy(&newmaxfrequencyval)).into()
        }
        unsafe extern "system" fn Step<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stepval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Step() {
                ::core::result::Result::Ok(ok__) => {
                    *stepval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStep<Impl: IAnalogRadioTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newstepval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStep(::core::mem::transmute_copy(&newstepval)).into()
        }
        Self {
            base: ITuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MinFrequency: MinFrequency::<Impl, IMPL_OFFSET>,
            SetMinFrequency: SetMinFrequency::<Impl, IMPL_OFFSET>,
            MaxFrequency: MaxFrequency::<Impl, IMPL_OFFSET>,
            SetMaxFrequency: SetMaxFrequency::<Impl, IMPL_OFFSET>,
            Step: Step::<Impl, IMPL_OFFSET>,
            SetStep: SetStep::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnalogRadioTuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAnalogRadioTuningSpace2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IAnalogRadioTuningSpace_Impl {
    fn CountryCode(&mut self) -> ::windows::core::Result<i32>;
    fn SetCountryCode(&mut self, newcountrycodeval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAnalogRadioTuningSpace2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnalogRadioTuningSpace2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnalogRadioTuningSpace2_Vtbl {
        unsafe extern "system" fn CountryCode<Impl: IAnalogRadioTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *countrycodeval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAnalogRadioTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&newcountrycodeval)).into()
        }
        Self {
            base: IAnalogRadioTuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnalogRadioTuningSpace2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAnalogTVTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl {
    fn MinChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinChannel(&mut self, newminchannelval: i32) -> ::windows::core::Result<()>;
    fn MaxChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxChannel(&mut self, newmaxchannelval: i32) -> ::windows::core::Result<()>;
    fn InputType(&mut self) -> ::windows::core::Result<TunerInputType>;
    fn SetInputType(&mut self, newinputtypeval: TunerInputType) -> ::windows::core::Result<()>;
    fn CountryCode(&mut self) -> ::windows::core::Result<i32>;
    fn SetCountryCode(&mut self, newcountrycodeval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAnalogTVTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAnalogTVTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAnalogTVTuningSpace_Vtbl {
        unsafe extern "system" fn MinChannel<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *minchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinChannel<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinChannel(::core::mem::transmute_copy(&newminchannelval)).into()
        }
        unsafe extern "system" fn MaxChannel<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *maxchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxChannel<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxChannel(::core::mem::transmute_copy(&newmaxchannelval)).into()
        }
        unsafe extern "system" fn InputType<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputtypeval: *mut TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputType() {
                ::core::result::Result::Ok(ok__) => {
                    *inputtypeval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newinputtypeval: TunerInputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputType(::core::mem::transmute_copy(&newinputtypeval)).into()
        }
        unsafe extern "system" fn CountryCode<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *countrycodeval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAnalogTVTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&newcountrycodeval)).into()
        }
        Self {
            base: ITuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MinChannel: MinChannel::<Impl, IMPL_OFFSET>,
            SetMinChannel: SetMinChannel::<Impl, IMPL_OFFSET>,
            MaxChannel: MaxChannel::<Impl, IMPL_OFFSET>,
            SetMaxChannel: SetMaxChannel::<Impl, IMPL_OFFSET>,
            InputType: InputType::<Impl, IMPL_OFFSET>,
            SetInputType: SetInputType::<Impl, IMPL_OFFSET>,
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAnalogTVTuningSpace as ::windows::core::Interface>::IID
    }
}
pub trait IAsyncReader_Impl: Sized {
    fn RequestAllocator(&mut self, ppreferred: &::core::option::Option<IMemAllocator>, pprops: *const ALLOCATOR_PROPERTIES) -> ::windows::core::Result<IMemAllocator>;
    fn Request(&mut self, psample: &::core::option::Option<IMediaSample>, dwuser: usize) -> ::windows::core::Result<()>;
    fn WaitForNext(&mut self, dwtimeout: u32, ppsample: *mut ::core::option::Option<IMediaSample>, pdwuser: *mut usize) -> ::windows::core::Result<()>;
    fn SyncReadAligned(&mut self, psample: &::core::option::Option<IMediaSample>) -> ::windows::core::Result<()>;
    fn SyncRead(&mut self, llposition: i64, llength: i32) -> ::windows::core::Result<u8>;
    fn Length(&mut self, ptotal: *mut i64, pavailable: *mut i64) -> ::windows::core::Result<()>;
    fn BeginFlush(&mut self) -> ::windows::core::Result<()>;
    fn EndFlush(&mut self) -> ::windows::core::Result<()>;
}
impl IAsyncReader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAsyncReader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAsyncReader_Vtbl {
        unsafe extern "system" fn RequestAllocator<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppreferred: ::windows::core::RawPtr, pprops: *const ALLOCATOR_PROPERTIES, ppactual: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequestAllocator(::core::mem::transmute(&ppreferred), ::core::mem::transmute_copy(&pprops)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppactual = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Request<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr, dwuser: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Request(::core::mem::transmute(&psample), ::core::mem::transmute_copy(&dwuser)).into()
        }
        unsafe extern "system" fn WaitForNext<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsample: *mut ::windows::core::RawPtr, pdwuser: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitForNext(::core::mem::transmute_copy(&dwtimeout), ::core::mem::transmute_copy(&ppsample), ::core::mem::transmute_copy(&pdwuser)).into()
        }
        unsafe extern "system" fn SyncReadAligned<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SyncReadAligned(::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn SyncRead<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llposition: i64, llength: i32, pbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SyncRead(::core::mem::transmute_copy(&llposition), ::core::mem::transmute_copy(&llength)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptotal: *mut i64, pavailable: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Length(::core::mem::transmute_copy(&ptotal), ::core::mem::transmute_copy(&pavailable)).into()
        }
        unsafe extern "system" fn BeginFlush<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginFlush().into()
        }
        unsafe extern "system" fn EndFlush<Impl: IAsyncReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndFlush().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RequestAllocator: RequestAllocator::<Impl, IMPL_OFFSET>,
            Request: Request::<Impl, IMPL_OFFSET>,
            WaitForNext: WaitForNext::<Impl, IMPL_OFFSET>,
            SyncReadAligned: SyncReadAligned::<Impl, IMPL_OFFSET>,
            SyncRead: SyncRead::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
            BeginFlush: BeginFlush::<Impl, IMPL_OFFSET>,
            EndFlush: EndFlush::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAsyncReader as ::windows::core::Interface>::IID
    }
}
pub trait IAtscContentAdvisoryDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetRatingRegionCount(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordRatingRegion(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordRatedDimensions(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordRatingDimension(&mut self, bindexouter: u8, bindexinner: u8) -> ::windows::core::Result<u8>;
    fn GetRecordRatingValue(&mut self, bindexouter: u8, bindexinner: u8) -> ::windows::core::Result<u8>;
    fn GetRecordRatingDescriptionText(&mut self, bindex: u8, pblength: *mut u8, pptext: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IAtscContentAdvisoryDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAtscContentAdvisoryDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAtscContentAdvisoryDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRatingRegionCount<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRatingRegionCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingRegion<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingRegion(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatedDimensions<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRatedDimensions(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingDimension<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindexouter: u8, bindexinner: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingDimension(::core::mem::transmute_copy(&bindexouter), ::core::mem::transmute_copy(&bindexinner)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingValue<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindexouter: u8, bindexinner: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRatingValue(::core::mem::transmute_copy(&bindexouter), ::core::mem::transmute_copy(&bindexinner)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRatingDescriptionText<Impl: IAtscContentAdvisoryDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pblength: *mut u8, pptext: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordRatingDescriptionText(::core::mem::transmute_copy(&bindex), ::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&pptext)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetRatingRegionCount: GetRatingRegionCount::<Impl, IMPL_OFFSET>,
            GetRecordRatingRegion: GetRecordRatingRegion::<Impl, IMPL_OFFSET>,
            GetRecordRatedDimensions: GetRecordRatedDimensions::<Impl, IMPL_OFFSET>,
            GetRecordRatingDimension: GetRecordRatingDimension::<Impl, IMPL_OFFSET>,
            GetRecordRatingValue: GetRecordRatingValue::<Impl, IMPL_OFFSET>,
            GetRecordRatingDescriptionText: GetRecordRatingDescriptionText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAtscContentAdvisoryDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAtscPsipParser_Impl: Sized {
    fn Initialize(&mut self, punkmpeg2data: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetPAT(&mut self) -> ::windows::core::Result<IPAT>;
    fn GetCAT(&mut self, dwtimeout: u32) -> ::windows::core::Result<ICAT>;
    fn GetPMT(&mut self, pid: u16, pwprogramnumber: *const u16) -> ::windows::core::Result<IPMT>;
    fn GetTSDT(&mut self) -> ::windows::core::Result<ITSDT>;
    fn GetMGT(&mut self) -> ::windows::core::Result<IATSC_MGT>;
    fn GetVCT(&mut self, tableid: u8, fgetnexttable: super::super::Foundation::BOOL) -> ::windows::core::Result<IATSC_VCT>;
    fn GetEIT(&mut self, pid: u16, pwsourceid: *const u16, dwtimeout: u32) -> ::windows::core::Result<IATSC_EIT>;
    fn GetETT(&mut self, pid: u16, wsourceid: *const u16, pweventid: *const u16) -> ::windows::core::Result<IATSC_ETT>;
    fn GetSTT(&mut self) -> ::windows::core::Result<IATSC_STT>;
    fn GetEAS(&mut self, pid: u16) -> ::windows::core::Result<ISCTE_EAS>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAtscPsipParser_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAtscPsipParser_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAtscPsipParser_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkmpeg2data: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&punkmpeg2data)).into()
        }
        unsafe extern "system" fn GetPAT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPAT() {
                ::core::result::Result::Ok(ok__) => {
                    *pppat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCAT(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPMT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, pwprogramnumber: *const u16, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPMT(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&pwprogramnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *pppmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSDT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTSDT() {
                ::core::result::Result::Ok(ok__) => {
                    *pptsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMGT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmgt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMGT() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmgt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVCT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, fgetnexttable: super::super::Foundation::BOOL, ppvct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVCT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&fgetnexttable)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppvct = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEIT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, pwsourceid: *const u16, dwtimeout: u32, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEIT(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&pwsourceid), ::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppeit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetETT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, wsourceid: *const u16, pweventid: *const u16, ppett: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetETT(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&wsourceid), ::core::mem::transmute_copy(&pweventid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppett = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSTT<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppstt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSTT() {
                ::core::result::Result::Ok(ok__) => {
                    *ppstt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEAS<Impl: IAtscPsipParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, ppeas: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEAS(::core::mem::transmute_copy(&pid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppeas = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetPAT: GetPAT::<Impl, IMPL_OFFSET>,
            GetCAT: GetCAT::<Impl, IMPL_OFFSET>,
            GetPMT: GetPMT::<Impl, IMPL_OFFSET>,
            GetTSDT: GetTSDT::<Impl, IMPL_OFFSET>,
            GetMGT: GetMGT::<Impl, IMPL_OFFSET>,
            GetVCT: GetVCT::<Impl, IMPL_OFFSET>,
            GetEIT: GetEIT::<Impl, IMPL_OFFSET>,
            GetETT: GetETT::<Impl, IMPL_OFFSET>,
            GetSTT: GetSTT::<Impl, IMPL_OFFSET>,
            GetEAS: GetEAS::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAtscPsipParser as ::windows::core::Interface>::IID
    }
}
pub trait IAttributeGet_Impl: Sized {
    fn GetCount(&mut self) -> ::windows::core::Result<i32>;
    fn GetAttribIndexed(&mut self, lindex: i32, pguidattribute: *mut ::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::Result<()>;
    fn GetAttrib(&mut self, guidattribute: &::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::Result<()>;
}
impl IAttributeGet_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAttributeGet_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAttributeGet_Vtbl {
        unsafe extern "system" fn GetCount<Impl: IAttributeGet_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCount() {
                ::core::result::Result::Ok(ok__) => {
                    *plcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttribIndexed<Impl: IAttributeGet_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, pguidattribute: *mut ::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAttribIndexed(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&pguidattribute), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&pdwattributelength)).into()
        }
        unsafe extern "system" fn GetAttrib<Impl: IAttributeGet_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidattribute: ::windows::core::GUID, pbattribute: *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAttrib(::core::mem::transmute_copy(&guidattribute), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&pdwattributelength)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCount: GetCount::<Impl, IMPL_OFFSET>,
            GetAttribIndexed: GetAttribIndexed::<Impl, IMPL_OFFSET>,
            GetAttrib: GetAttrib::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAttributeGet as ::windows::core::Interface>::IID
    }
}
pub trait IAttributeSet_Impl: Sized {
    fn SetAttrib(&mut self, guidattribute: &::windows::core::GUID, pbattribute: *const u8, dwattributelength: u32) -> ::windows::core::Result<()>;
}
impl IAttributeSet_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAttributeSet_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAttributeSet_Vtbl {
        unsafe extern "system" fn SetAttrib<Impl: IAttributeSet_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidattribute: ::windows::core::GUID, pbattribute: *const u8, dwattributelength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAttrib(::core::mem::transmute_copy(&guidattribute), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&dwattributelength)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetAttrib: SetAttrib::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAttributeSet as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IAudioData_Impl: Sized + IMemoryData_Impl {
    fn GetFormat(&mut self) -> ::windows::core::Result<super::Audio::WAVEFORMATEX>;
    fn SetFormat(&mut self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IAudioData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAudioData_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAudioData_Vtbl {
        unsafe extern "system" fn GetFormat<Impl: IAudioData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pwaveformatcurrent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IAudioData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFormat(::core::mem::transmute_copy(&lpwaveformat)).into()
        }
        Self {
            base: IMemoryData_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetFormat: GetFormat::<Impl, IMPL_OFFSET>,
            SetFormat: SetFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAudioData as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IAudioMediaStream_Impl: Sized + IMediaStream_Impl {
    fn GetFormat(&mut self) -> ::windows::core::Result<super::Audio::WAVEFORMATEX>;
    fn SetFormat(&mut self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::Result<()>;
    fn CreateSample(&mut self, paudiodata: &::core::option::Option<IAudioData>, dwflags: u32) -> ::windows::core::Result<IAudioStreamSample>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IAudioMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAudioMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAudioMediaStream_Vtbl {
        unsafe extern "system" fn GetFormat<Impl: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pwaveformatcurrent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFormat<Impl: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFormat(::core::mem::transmute_copy(&lpwaveformat)).into()
        }
        unsafe extern "system" fn CreateSample<Impl: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, paudiodata: ::windows::core::RawPtr, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSample(::core::mem::transmute(&paudiodata), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetFormat: GetFormat::<Impl, IMPL_OFFSET>,
            SetFormat: SetFormat::<Impl, IMPL_OFFSET>,
            CreateSample: CreateSample::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAudioMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IAudioStreamSample_Impl: Sized + IStreamSample_Impl {
    fn GetAudioData(&mut self) -> ::windows::core::Result<IAudioData>;
}
#[cfg(feature = "Win32_Foundation")]
impl IAudioStreamSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAudioStreamSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAudioStreamSample_Vtbl {
        unsafe extern "system" fn GetAudioData<Impl: IAudioStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppaudio: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioData() {
                ::core::result::Result::Ok(ok__) => {
                    *ppaudio = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IStreamSample_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetAudioData: GetAudioData::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAudioStreamSample as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAuxInTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAuxInTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAuxInTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAuxInTuningSpace_Vtbl {
        Self { base: ITuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAuxInTuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IAuxInTuningSpace2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IAuxInTuningSpace_Impl {
    fn CountryCode(&mut self) -> ::windows::core::Result<i32>;
    fn SetCountryCode(&mut self, newcountrycodeval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IAuxInTuningSpace2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAuxInTuningSpace2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAuxInTuningSpace2_Vtbl {
        unsafe extern "system" fn CountryCode<Impl: IAuxInTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, countrycodeval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *countrycodeval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IAuxInTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newcountrycodeval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&newcountrycodeval)).into()
        }
        Self {
            base: IAuxInTuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAuxInTuningSpace2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBDAComparable_Impl: Sized {
    fn CompareExact(&mut self, compareto: &::core::option::Option<super::super::System::Com::IDispatch>) -> ::windows::core::Result<i32>;
    fn CompareEquivalent(&mut self, compareto: &::core::option::Option<super::super::System::Com::IDispatch>, dwflags: u32) -> ::windows::core::Result<i32>;
    fn HashExact(&mut self) -> ::windows::core::Result<i64>;
    fn HashExactIncremental(&mut self, partialresult: i64) -> ::windows::core::Result<i64>;
    fn HashEquivalent(&mut self, dwflags: u32) -> ::windows::core::Result<i64>;
    fn HashEquivalentIncremental(&mut self, partialresult: i64, dwflags: u32) -> ::windows::core::Result<i64>;
}
#[cfg(feature = "Win32_System_Com")]
impl IBDAComparable_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDAComparable_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDAComparable_Vtbl {
        unsafe extern "system" fn CompareExact<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compareto: ::windows::core::RawPtr, result: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompareExact(::core::mem::transmute(&compareto)) {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompareEquivalent<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compareto: ::windows::core::RawPtr, dwflags: u32, result: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompareEquivalent(::core::mem::transmute(&compareto), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashExact<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HashExact() {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashExactIncremental<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, partialresult: i64, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HashExactIncremental(::core::mem::transmute_copy(&partialresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashEquivalent<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HashEquivalent(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HashEquivalentIncremental<Impl: IBDAComparable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, partialresult: i64, dwflags: u32, result: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HashEquivalentIncremental(::core::mem::transmute_copy(&partialresult), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CompareExact: CompareExact::<Impl, IMPL_OFFSET>,
            CompareEquivalent: CompareEquivalent::<Impl, IMPL_OFFSET>,
            HashExact: HashExact::<Impl, IMPL_OFFSET>,
            HashExactIncremental: HashExactIncremental::<Impl, IMPL_OFFSET>,
            HashEquivalent: HashEquivalent::<Impl, IMPL_OFFSET>,
            HashEquivalentIncremental: HashEquivalentIncremental::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDAComparable as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBDACreateTuneRequestEx_Impl: Sized {
    fn CreateTuneRequestEx(&mut self, tunerequestiid: *const ::windows::core::GUID) -> ::windows::core::Result<ITuneRequest>;
}
#[cfg(feature = "Win32_System_Com")]
impl IBDACreateTuneRequestEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDACreateTuneRequestEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDACreateTuneRequestEx_Vtbl {
        unsafe extern "system" fn CreateTuneRequestEx<Impl: IBDACreateTuneRequestEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tunerequestiid: *const ::windows::core::GUID, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequestEx(::core::mem::transmute_copy(&tunerequestiid)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateTuneRequestEx: CreateTuneRequestEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDACreateTuneRequestEx as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_AUX_Impl: Sized {
    fn QueryCapabilities(&mut self) -> ::windows::core::Result<u32>;
    fn EnumCapability(&mut self, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut ::windows::core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> ::windows::core::Result<()>;
}
impl IBDA_AUX_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_AUX_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_AUX_Vtbl {
        unsafe extern "system" fn QueryCapabilities<Impl: IBDA_AUX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumauxinputsbstr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumauxinputsbstr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumCapability<Impl: IBDA_AUX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut ::windows::core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnumCapability(::core::mem::transmute_copy(&dwindex), ::core::mem::transmute_copy(&dwinputid), ::core::mem::transmute_copy(&pconnectortype), ::core::mem::transmute_copy(&conntypenum), ::core::mem::transmute_copy(&numvideostds), ::core::mem::transmute_copy(&analogstds)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryCapabilities: QueryCapabilities::<Impl, IMPL_OFFSET>,
            EnumCapability: EnumCapability::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_AUX as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_AutoDemodulate_Impl: Sized {
    fn SetAutoDemodulate(&mut self) -> ::windows::core::Result<()>;
}
impl IBDA_AutoDemodulate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_AutoDemodulate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_AutoDemodulate_Vtbl {
        unsafe extern "system" fn SetAutoDemodulate<Impl: IBDA_AutoDemodulate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoDemodulate().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetAutoDemodulate: SetAutoDemodulate::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_AutoDemodulate as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_AutoDemodulateEx_Impl: Sized + IBDA_AutoDemodulate_Impl {
    fn SupportedDeviceNodeTypes(&mut self, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SupportedVideoFormats(&mut self, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::Result<()>;
    fn AuxInputCount(&mut self, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_AutoDemodulateEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_AutoDemodulateEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_AutoDemodulateEx_Vtbl {
        unsafe extern "system" fn SupportedDeviceNodeTypes<Impl: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupportedDeviceNodeTypes(::core::mem::transmute_copy(&ulcdevicenodetypesmax), ::core::mem::transmute_copy(&pulcdevicenodetypes), ::core::mem::transmute_copy(&pguiddevicenodetypes)).into()
        }
        unsafe extern "system" fn SupportedVideoFormats<Impl: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupportedVideoFormats(::core::mem::transmute_copy(&pulamtunermodetype), ::core::mem::transmute_copy(&pulanalogvideostandard)).into()
        }
        unsafe extern "system" fn AuxInputCount<Impl: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AuxInputCount(::core::mem::transmute_copy(&pulcompositecount), ::core::mem::transmute_copy(&pulsvideocount)).into()
        }
        Self {
            base: IBDA_AutoDemodulate_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SupportedDeviceNodeTypes: SupportedDeviceNodeTypes::<Impl, IMPL_OFFSET>,
            SupportedVideoFormats: SupportedVideoFormats::<Impl, IMPL_OFFSET>,
            AuxInputCount: AuxInputCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_AutoDemodulateEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_ConditionalAccess_Impl: Sized {
    fn SmartCardStatus(&mut self, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut super::super::Foundation::BSTR, pfooblocked: *mut i16) -> ::windows::core::Result<()>;
    fn SmartCardInfo(&mut self, pbstrcardname: *mut super::super::Foundation::BSTR, pbstrcardmanufacturer: *mut super::super::Foundation::BSTR, pfdaylightsavings: *mut i16, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut super::super::Foundation::BSTR, pealocationcode: *mut EALocationCodeType) -> ::windows::core::Result<()>;
    fn SmartCardApplications(&mut self, pulcapplications: *mut u32, ulcapplicationsmax: u32, rgapplications: *mut SmartCardApplication) -> ::windows::core::Result<()>;
    fn Entitlement(&mut self, usvirtualchannel: u16) -> ::windows::core::Result<EntitlementType>;
    fn TuneByChannel(&mut self, usvirtualchannel: u16) -> ::windows::core::Result<()>;
    fn SetProgram(&mut self, usprogramnumber: u16) -> ::windows::core::Result<()>;
    fn AddProgram(&mut self, usprogramnumber: u16) -> ::windows::core::Result<()>;
    fn RemoveProgram(&mut self, usprogramnumber: u16) -> ::windows::core::Result<()>;
    fn GetModuleUI(&mut self, bydialognumber: u8) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn InformUIClosed(&mut self, bydialognumber: u8, closereason: UICloseReasonType) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_ConditionalAccess_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_ConditionalAccess_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_ConditionalAccess_Vtbl {
        unsafe extern "system" fn SmartCardStatus<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut super::super::Foundation::BSTR, pfooblocked: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SmartCardStatus(::core::mem::transmute_copy(&pcardstatus), ::core::mem::transmute_copy(&pcardassociation), ::core::mem::transmute_copy(&pbstrcarderror), ::core::mem::transmute_copy(&pfooblocked)).into()
        }
        unsafe extern "system" fn SmartCardInfo<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrcardname: *mut super::super::Foundation::BSTR, pbstrcardmanufacturer: *mut super::super::Foundation::BSTR, pfdaylightsavings: *mut i16, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut super::super::Foundation::BSTR, pealocationcode: *mut EALocationCodeType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SmartCardInfo(::core::mem::transmute_copy(&pbstrcardname), ::core::mem::transmute_copy(&pbstrcardmanufacturer), ::core::mem::transmute_copy(&pfdaylightsavings), ::core::mem::transmute_copy(&pbyratingregion), ::core::mem::transmute_copy(&pltimezoneoffsetminutes), ::core::mem::transmute_copy(&pbstrlanguage), ::core::mem::transmute_copy(&pealocationcode)).into()
        }
        unsafe extern "system" fn SmartCardApplications<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcapplications: *mut u32, ulcapplicationsmax: u32, rgapplications: *mut SmartCardApplication) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SmartCardApplications(::core::mem::transmute_copy(&pulcapplications), ::core::mem::transmute_copy(&ulcapplicationsmax), ::core::mem::transmute_copy(&rgapplications)).into()
        }
        unsafe extern "system" fn Entitlement<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usvirtualchannel: u16, pentitlement: *mut EntitlementType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Entitlement(::core::mem::transmute_copy(&usvirtualchannel)) {
                ::core::result::Result::Ok(ok__) => {
                    *pentitlement = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuneByChannel<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usvirtualchannel: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TuneByChannel(::core::mem::transmute_copy(&usvirtualchannel)).into()
        }
        unsafe extern "system" fn SetProgram<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProgram(::core::mem::transmute_copy(&usprogramnumber)).into()
        }
        unsafe extern "system" fn AddProgram<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddProgram(::core::mem::transmute_copy(&usprogramnumber)).into()
        }
        unsafe extern "system" fn RemoveProgram<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usprogramnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveProgram(::core::mem::transmute_copy(&usprogramnumber)).into()
        }
        unsafe extern "system" fn GetModuleUI<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bydialognumber: u8, pbstrurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetModuleUI(::core::mem::transmute_copy(&bydialognumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InformUIClosed<Impl: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bydialognumber: u8, closereason: UICloseReasonType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InformUIClosed(::core::mem::transmute_copy(&bydialognumber), ::core::mem::transmute_copy(&closereason)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SmartCardStatus: SmartCardStatus::<Impl, IMPL_OFFSET>,
            SmartCardInfo: SmartCardInfo::<Impl, IMPL_OFFSET>,
            SmartCardApplications: SmartCardApplications::<Impl, IMPL_OFFSET>,
            Entitlement: Entitlement::<Impl, IMPL_OFFSET>,
            TuneByChannel: TuneByChannel::<Impl, IMPL_OFFSET>,
            SetProgram: SetProgram::<Impl, IMPL_OFFSET>,
            AddProgram: AddProgram::<Impl, IMPL_OFFSET>,
            RemoveProgram: RemoveProgram::<Impl, IMPL_OFFSET>,
            GetModuleUI: GetModuleUI::<Impl, IMPL_OFFSET>,
            InformUIClosed: InformUIClosed::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_ConditionalAccess as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_ConditionalAccessEx_Impl: Sized {
    fn CheckEntitlementToken(&mut self, uldialogrequest: u32, bstrlanguage: &super::super::Foundation::BSTR, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbentitlementtokenlen: u32, pbentitlementtoken: *const u8) -> ::windows::core::Result<u32>;
    fn SetCaptureToken(&mut self, ulcbcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::Result<()>;
    fn OpenBroadcastMmi(&mut self, uldialogrequest: u32, bstrlanguage: &super::super::Foundation::BSTR, eventid: u32) -> ::windows::core::Result<()>;
    fn CloseMmiDialog(&mut self, uldialogrequest: u32, bstrlanguage: &super::super::Foundation::BSTR, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON) -> ::windows::core::Result<u32>;
    fn CreateDialogRequestNumber(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_ConditionalAccessEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_ConditionalAccessEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_ConditionalAccessEx_Vtbl {
        unsafe extern "system" fn CheckEntitlementToken<Impl: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CheckEntitlementToken(::core::mem::transmute_copy(&uldialogrequest), ::core::mem::transmute_copy(&bstrlanguage), ::core::mem::transmute_copy(&requesttype), ::core::mem::transmute_copy(&ulcbentitlementtokenlen), ::core::mem::transmute_copy(&pbentitlementtoken)) {
                ::core::result::Result::Ok(ok__) => {
                    *puldescramblestatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaptureToken<Impl: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcbcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCaptureToken(::core::mem::transmute_copy(&ulcbcapturetokenlen), ::core::mem::transmute_copy(&pbcapturetoken)).into()
        }
        unsafe extern "system" fn OpenBroadcastMmi<Impl: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, eventid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OpenBroadcastMmi(::core::mem::transmute_copy(&uldialogrequest), ::core::mem::transmute_copy(&bstrlanguage), ::core::mem::transmute_copy(&eventid)).into()
        }
        unsafe extern "system" fn CloseMmiDialog<Impl: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON, pulsessionresult: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloseMmiDialog(::core::mem::transmute_copy(&uldialogrequest), ::core::mem::transmute_copy(&bstrlanguage), ::core::mem::transmute_copy(&uldialognumber), ::core::mem::transmute_copy(&reasoncode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulsessionresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateDialogRequestNumber<Impl: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puldialogrequestnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateDialogRequestNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *puldialogrequestnumber = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CheckEntitlementToken: CheckEntitlementToken::<Impl, IMPL_OFFSET>,
            SetCaptureToken: SetCaptureToken::<Impl, IMPL_OFFSET>,
            OpenBroadcastMmi: OpenBroadcastMmi::<Impl, IMPL_OFFSET>,
            CloseMmiDialog: CloseMmiDialog::<Impl, IMPL_OFFSET>,
            CreateDialogRequestNumber: CreateDialogRequestNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_ConditionalAccessEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_DRIDRMService_Impl: Sized {
    fn SetDRM(&mut self, bstrnewdrm: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetDRMStatus(&mut self, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetPairingStatus(&mut self, penumpairingstatus: *mut BDA_DrmPairingError) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_DRIDRMService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DRIDRMService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DRIDRMService_Vtbl {
        unsafe extern "system" fn SetDRM<Impl: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrnewdrm: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDRM(::core::mem::transmute_copy(&bstrnewdrm)).into()
        }
        unsafe extern "system" fn GetDRMStatus<Impl: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDRMStatus(::core::mem::transmute_copy(&pbstrdrmuuidlist), ::core::mem::transmute_copy(&drmuuid)).into()
        }
        unsafe extern "system" fn GetPairingStatus<Impl: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penumpairingstatus: *mut BDA_DrmPairingError) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPairingStatus(::core::mem::transmute_copy(&penumpairingstatus)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDRM: SetDRM::<Impl, IMPL_OFFSET>,
            GetDRMStatus: GetDRMStatus::<Impl, IMPL_OFFSET>,
            GetPairingStatus: GetPairingStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DRIDRMService as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_DRIWMDRMSession_Impl: Sized {
    fn AcknowledgeLicense(&mut self, hrlicenseack: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn ProcessLicenseChallenge(&mut self, dwcblicensemessage: u32, pblicensemessage: *const u8, pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> ::windows::core::Result<()>;
    fn ProcessRegistrationChallenge(&mut self, dwcbregistrationmessage: u32, pbregistrationmessage: *const u8, pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> ::windows::core::Result<()>;
    fn SetRevInfo(&mut self, dwrevinfolen: u32, pbrevinfo: *const u8, pdwresponse: *mut u32) -> ::windows::core::Result<()>;
    fn SetCrl(&mut self, dwcrllen: u32, pbcrllen: *const u8, pdwresponse: *mut u32) -> ::windows::core::Result<()>;
    fn GetHMSAssociationData(&mut self) -> ::windows::core::Result<()>;
    fn GetLastCardeaError(&mut self, pdwerror: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_DRIWMDRMSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DRIWMDRMSession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DRIWMDRMSession_Vtbl {
        unsafe extern "system" fn AcknowledgeLicense<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hrlicenseack: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AcknowledgeLicense(::core::mem::transmute_copy(&hrlicenseack)).into()
        }
        unsafe extern "system" fn ProcessLicenseChallenge<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcblicensemessage: u32, pblicensemessage: *const u8, pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessLicenseChallenge(::core::mem::transmute_copy(&dwcblicensemessage), ::core::mem::transmute_copy(&pblicensemessage), ::core::mem::transmute_copy(&pdwcblicenseresponse), ::core::mem::transmute_copy(&ppblicenseresponse)).into()
        }
        unsafe extern "system" fn ProcessRegistrationChallenge<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcbregistrationmessage: u32, pbregistrationmessage: *const u8, pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessRegistrationChallenge(::core::mem::transmute_copy(&dwcbregistrationmessage), ::core::mem::transmute_copy(&pbregistrationmessage), ::core::mem::transmute_copy(&pdwcbregistrationresponse), ::core::mem::transmute_copy(&ppbregistrationresponse)).into()
        }
        unsafe extern "system" fn SetRevInfo<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrevinfolen: u32, pbrevinfo: *const u8, pdwresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRevInfo(::core::mem::transmute_copy(&dwrevinfolen), ::core::mem::transmute_copy(&pbrevinfo), ::core::mem::transmute_copy(&pdwresponse)).into()
        }
        unsafe extern "system" fn SetCrl<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcrllen: u32, pbcrllen: *const u8, pdwresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCrl(::core::mem::transmute_copy(&dwcrllen), ::core::mem::transmute_copy(&pbcrllen), ::core::mem::transmute_copy(&pdwresponse)).into()
        }
        unsafe extern "system" fn GetHMSAssociationData<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetHMSAssociationData().into()
        }
        unsafe extern "system" fn GetLastCardeaError<Impl: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwerror: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLastCardeaError(::core::mem::transmute_copy(&pdwerror)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AcknowledgeLicense: AcknowledgeLicense::<Impl, IMPL_OFFSET>,
            ProcessLicenseChallenge: ProcessLicenseChallenge::<Impl, IMPL_OFFSET>,
            ProcessRegistrationChallenge: ProcessRegistrationChallenge::<Impl, IMPL_OFFSET>,
            SetRevInfo: SetRevInfo::<Impl, IMPL_OFFSET>,
            SetCrl: SetCrl::<Impl, IMPL_OFFSET>,
            GetHMSAssociationData: GetHMSAssociationData::<Impl, IMPL_OFFSET>,
            GetLastCardeaError: GetLastCardeaError::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DRIWMDRMSession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_DRM_Impl: Sized {
    fn GetDRMPairingStatus(&mut self, pdwstatus: *mut u32, pherror: *mut ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn PerformDRMPairing(&mut self, fsync: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_DRM_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DRM_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DRM_Vtbl {
        unsafe extern "system" fn GetDRMPairingStatus<Impl: IBDA_DRM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstatus: *mut u32, pherror: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDRMPairingStatus(::core::mem::transmute_copy(&pdwstatus), ::core::mem::transmute_copy(&pherror)).into()
        }
        unsafe extern "system" fn PerformDRMPairing<Impl: IBDA_DRM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fsync: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PerformDRMPairing(::core::mem::transmute_copy(&fsync)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDRMPairingStatus: GetDRMPairingStatus::<Impl, IMPL_OFFSET>,
            PerformDRMPairing: PerformDRMPairing::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DRM as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_DRMService_Impl: Sized {
    fn SetDRM(&mut self, puuidnewdrm: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDRMStatus(&mut self, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_DRMService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DRMService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DRMService_Vtbl {
        unsafe extern "system" fn SetDRM<Impl: IBDA_DRMService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puuidnewdrm: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDRM(::core::mem::transmute_copy(&puuidnewdrm)).into()
        }
        unsafe extern "system" fn GetDRMStatus<Impl: IBDA_DRMService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrdrmuuidlist: *mut super::super::Foundation::BSTR, drmuuid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDRMStatus(::core::mem::transmute_copy(&pbstrdrmuuidlist), ::core::mem::transmute_copy(&drmuuid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDRM: SetDRM::<Impl, IMPL_OFFSET>,
            GetDRMStatus: GetDRMStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DRMService as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_DeviceControl_Impl: Sized {
    fn StartChanges(&mut self) -> ::windows::core::Result<()>;
    fn CheckChanges(&mut self) -> ::windows::core::Result<()>;
    fn CommitChanges(&mut self) -> ::windows::core::Result<()>;
    fn GetChangeState(&mut self, pstate: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_DeviceControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DeviceControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DeviceControl_Vtbl {
        unsafe extern "system" fn StartChanges<Impl: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartChanges().into()
        }
        unsafe extern "system" fn CheckChanges<Impl: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CheckChanges().into()
        }
        unsafe extern "system" fn CommitChanges<Impl: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CommitChanges().into()
        }
        unsafe extern "system" fn GetChangeState<Impl: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetChangeState(::core::mem::transmute_copy(&pstate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartChanges: StartChanges::<Impl, IMPL_OFFSET>,
            CheckChanges: CheckChanges::<Impl, IMPL_OFFSET>,
            CommitChanges: CommitChanges::<Impl, IMPL_OFFSET>,
            GetChangeState: GetChangeState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DeviceControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
pub trait IBDA_DiagnosticProperties_Impl: Sized + super::super::System::Com::StructuredStorage::IPropertyBag_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
impl IBDA_DiagnosticProperties_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DiagnosticProperties_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DiagnosticProperties_Vtbl {
        Self { base: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DiagnosticProperties as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_DigitalDemodulator_Impl: Sized {
    fn SetModulationType(&mut self, pmodulationtype: *const ModulationType) -> ::windows::core::Result<()>;
    fn ModulationType(&mut self, pmodulationtype: *mut ModulationType) -> ::windows::core::Result<()>;
    fn SetInnerFECMethod(&mut self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()>;
    fn InnerFECMethod(&mut self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()>;
    fn SetInnerFECRate(&mut self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn InnerFECRate(&mut self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn SetOuterFECMethod(&mut self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()>;
    fn OuterFECMethod(&mut self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()>;
    fn SetOuterFECRate(&mut self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn OuterFECRate(&mut self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn SetSymbolRate(&mut self, psymbolrate: *const u32) -> ::windows::core::Result<()>;
    fn SymbolRate(&mut self, psymbolrate: *mut u32) -> ::windows::core::Result<()>;
    fn SetSpectralInversion(&mut self, pspectralinversion: *const SpectralInversion) -> ::windows::core::Result<()>;
    fn SpectralInversion(&mut self, pspectralinversion: *mut SpectralInversion) -> ::windows::core::Result<()>;
}
impl IBDA_DigitalDemodulator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DigitalDemodulator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DigitalDemodulator_Vtbl {
        unsafe extern "system" fn SetModulationType<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmodulationtype: *const ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetModulationType(::core::mem::transmute_copy(&pmodulationtype)).into()
        }
        unsafe extern "system" fn ModulationType<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmodulationtype: *mut ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ModulationType(::core::mem::transmute_copy(&pmodulationtype)).into()
        }
        unsafe extern "system" fn SetInnerFECMethod<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecmethod: *const FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInnerFECMethod(::core::mem::transmute_copy(&pfecmethod)).into()
        }
        unsafe extern "system" fn InnerFECMethod<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecmethod: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InnerFECMethod(::core::mem::transmute_copy(&pfecmethod)).into()
        }
        unsafe extern "system" fn SetInnerFECRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInnerFECRate(::core::mem::transmute_copy(&pfecrate)).into()
        }
        unsafe extern "system" fn InnerFECRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InnerFECRate(::core::mem::transmute_copy(&pfecrate)).into()
        }
        unsafe extern "system" fn SetOuterFECMethod<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecmethod: *const FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOuterFECMethod(::core::mem::transmute_copy(&pfecmethod)).into()
        }
        unsafe extern "system" fn OuterFECMethod<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecmethod: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OuterFECMethod(::core::mem::transmute_copy(&pfecmethod)).into()
        }
        unsafe extern "system" fn SetOuterFECRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOuterFECRate(::core::mem::transmute_copy(&pfecrate)).into()
        }
        unsafe extern "system" fn OuterFECRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OuterFECRate(::core::mem::transmute_copy(&pfecrate)).into()
        }
        unsafe extern "system" fn SetSymbolRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psymbolrate: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbolRate(::core::mem::transmute_copy(&psymbolrate)).into()
        }
        unsafe extern "system" fn SymbolRate<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psymbolrate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SymbolRate(::core::mem::transmute_copy(&psymbolrate)).into()
        }
        unsafe extern "system" fn SetSpectralInversion<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pspectralinversion: *const SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSpectralInversion(::core::mem::transmute_copy(&pspectralinversion)).into()
        }
        unsafe extern "system" fn SpectralInversion<Impl: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pspectralinversion: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SpectralInversion(::core::mem::transmute_copy(&pspectralinversion)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetModulationType: SetModulationType::<Impl, IMPL_OFFSET>,
            ModulationType: ModulationType::<Impl, IMPL_OFFSET>,
            SetInnerFECMethod: SetInnerFECMethod::<Impl, IMPL_OFFSET>,
            InnerFECMethod: InnerFECMethod::<Impl, IMPL_OFFSET>,
            SetInnerFECRate: SetInnerFECRate::<Impl, IMPL_OFFSET>,
            InnerFECRate: InnerFECRate::<Impl, IMPL_OFFSET>,
            SetOuterFECMethod: SetOuterFECMethod::<Impl, IMPL_OFFSET>,
            OuterFECMethod: OuterFECMethod::<Impl, IMPL_OFFSET>,
            SetOuterFECRate: SetOuterFECRate::<Impl, IMPL_OFFSET>,
            OuterFECRate: OuterFECRate::<Impl, IMPL_OFFSET>,
            SetSymbolRate: SetSymbolRate::<Impl, IMPL_OFFSET>,
            SymbolRate: SymbolRate::<Impl, IMPL_OFFSET>,
            SetSpectralInversion: SetSpectralInversion::<Impl, IMPL_OFFSET>,
            SpectralInversion: SpectralInversion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_DigitalDemodulator2_Impl: Sized + IBDA_DigitalDemodulator_Impl {
    fn SetGuardInterval(&mut self, pguardinterval: *const GuardInterval) -> ::windows::core::Result<()>;
    fn GuardInterval(&mut self, pguardinterval: *mut GuardInterval) -> ::windows::core::Result<()>;
    fn SetTransmissionMode(&mut self, ptransmissionmode: *const TransmissionMode) -> ::windows::core::Result<()>;
    fn TransmissionMode(&mut self, ptransmissionmode: *mut TransmissionMode) -> ::windows::core::Result<()>;
    fn SetRollOff(&mut self, prolloff: *const RollOff) -> ::windows::core::Result<()>;
    fn RollOff(&mut self, prolloff: *mut RollOff) -> ::windows::core::Result<()>;
    fn SetPilot(&mut self, ppilot: *const Pilot) -> ::windows::core::Result<()>;
    fn Pilot(&mut self, ppilot: *mut Pilot) -> ::windows::core::Result<()>;
}
impl IBDA_DigitalDemodulator2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DigitalDemodulator2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DigitalDemodulator2_Vtbl {
        unsafe extern "system" fn SetGuardInterval<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguardinterval: *const GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGuardInterval(::core::mem::transmute_copy(&pguardinterval)).into()
        }
        unsafe extern "system" fn GuardInterval<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguardinterval: *mut GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GuardInterval(::core::mem::transmute_copy(&pguardinterval)).into()
        }
        unsafe extern "system" fn SetTransmissionMode<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptransmissionmode: *const TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTransmissionMode(::core::mem::transmute_copy(&ptransmissionmode)).into()
        }
        unsafe extern "system" fn TransmissionMode<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptransmissionmode: *mut TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TransmissionMode(::core::mem::transmute_copy(&ptransmissionmode)).into()
        }
        unsafe extern "system" fn SetRollOff<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prolloff: *const RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRollOff(::core::mem::transmute_copy(&prolloff)).into()
        }
        unsafe extern "system" fn RollOff<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prolloff: *mut RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RollOff(::core::mem::transmute_copy(&prolloff)).into()
        }
        unsafe extern "system" fn SetPilot<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppilot: *const Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPilot(::core::mem::transmute_copy(&ppilot)).into()
        }
        unsafe extern "system" fn Pilot<Impl: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppilot: *mut Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pilot(::core::mem::transmute_copy(&ppilot)).into()
        }
        Self {
            base: IBDA_DigitalDemodulator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetGuardInterval: SetGuardInterval::<Impl, IMPL_OFFSET>,
            GuardInterval: GuardInterval::<Impl, IMPL_OFFSET>,
            SetTransmissionMode: SetTransmissionMode::<Impl, IMPL_OFFSET>,
            TransmissionMode: TransmissionMode::<Impl, IMPL_OFFSET>,
            SetRollOff: SetRollOff::<Impl, IMPL_OFFSET>,
            RollOff: RollOff::<Impl, IMPL_OFFSET>,
            SetPilot: SetPilot::<Impl, IMPL_OFFSET>,
            Pilot: Pilot::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator2 as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_DigitalDemodulator3_Impl: Sized + IBDA_DigitalDemodulator_Impl + IBDA_DigitalDemodulator2_Impl {
    fn SetSignalTimeouts(&mut self, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> ::windows::core::Result<()>;
    fn SignalTimeouts(&mut self, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> ::windows::core::Result<()>;
    fn SetPLPNumber(&mut self, pplpnumber: *const u32) -> ::windows::core::Result<()>;
    fn PLPNumber(&mut self, pplpnumber: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_DigitalDemodulator3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DigitalDemodulator3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DigitalDemodulator3_Vtbl {
        unsafe extern "system" fn SetSignalTimeouts<Impl: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalTimeouts(::core::mem::transmute_copy(&psignaltimeouts)).into()
        }
        unsafe extern "system" fn SignalTimeouts<Impl: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalTimeouts(::core::mem::transmute_copy(&psignaltimeouts)).into()
        }
        unsafe extern "system" fn SetPLPNumber<Impl: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pplpnumber: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPLPNumber(::core::mem::transmute_copy(&pplpnumber)).into()
        }
        unsafe extern "system" fn PLPNumber<Impl: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pplpnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PLPNumber(::core::mem::transmute_copy(&pplpnumber)).into()
        }
        Self {
            base: IBDA_DigitalDemodulator2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetSignalTimeouts: SetSignalTimeouts::<Impl, IMPL_OFFSET>,
            SignalTimeouts: SignalTimeouts::<Impl, IMPL_OFFSET>,
            SetPLPNumber: SetPLPNumber::<Impl, IMPL_OFFSET>,
            PLPNumber: PLPNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_DiseqCommand_Impl: Sized {
    fn SetEnableDiseqCommands(&mut self, benable: super::super::Foundation::BOOLEAN) -> ::windows::core::Result<()>;
    fn SetDiseqLNBSource(&mut self, ullnbsource: u32) -> ::windows::core::Result<()>;
    fn SetDiseqUseToneBurst(&mut self, busetoneburst: super::super::Foundation::BOOLEAN) -> ::windows::core::Result<()>;
    fn SetDiseqRepeats(&mut self, ulrepeats: u32) -> ::windows::core::Result<()>;
    fn SetDiseqSendCommand(&mut self, ulrequestid: u32, ulcbcommandlen: u32, pbcommand: *const u8) -> ::windows::core::Result<()>;
    fn DiseqResponse(&mut self, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_DiseqCommand_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_DiseqCommand_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_DiseqCommand_Vtbl {
        unsafe extern "system" fn SetEnableDiseqCommands<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benable: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableDiseqCommands(::core::mem::transmute_copy(&benable)).into()
        }
        unsafe extern "system" fn SetDiseqLNBSource<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullnbsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiseqLNBSource(::core::mem::transmute_copy(&ullnbsource)).into()
        }
        unsafe extern "system" fn SetDiseqUseToneBurst<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, busetoneburst: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiseqUseToneBurst(::core::mem::transmute_copy(&busetoneburst)).into()
        }
        unsafe extern "system" fn SetDiseqRepeats<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrepeats: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiseqRepeats(::core::mem::transmute_copy(&ulrepeats)).into()
        }
        unsafe extern "system" fn SetDiseqSendCommand<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, ulcbcommandlen: u32, pbcommand: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiseqSendCommand(::core::mem::transmute_copy(&ulrequestid), ::core::mem::transmute_copy(&ulcbcommandlen), ::core::mem::transmute_copy(&pbcommand)).into()
        }
        unsafe extern "system" fn DiseqResponse<Impl: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DiseqResponse(::core::mem::transmute_copy(&ulrequestid), ::core::mem::transmute_copy(&pulcbresponselen), ::core::mem::transmute_copy(&pbresponse)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetEnableDiseqCommands: SetEnableDiseqCommands::<Impl, IMPL_OFFSET>,
            SetDiseqLNBSource: SetDiseqLNBSource::<Impl, IMPL_OFFSET>,
            SetDiseqUseToneBurst: SetDiseqUseToneBurst::<Impl, IMPL_OFFSET>,
            SetDiseqRepeats: SetDiseqRepeats::<Impl, IMPL_OFFSET>,
            SetDiseqSendCommand: SetDiseqSendCommand::<Impl, IMPL_OFFSET>,
            DiseqResponse: DiseqResponse::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_DiseqCommand as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_EasMessage_Impl: Sized {
    fn EasMessage(&mut self, uleventid: u32, ppeasobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IBDA_EasMessage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_EasMessage_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_EasMessage_Vtbl {
        unsafe extern "system" fn EasMessage<Impl: IBDA_EasMessage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uleventid: u32, ppeasobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EasMessage(::core::mem::transmute_copy(&uleventid), ::core::mem::transmute_copy(&ppeasobject)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), EasMessage: EasMessage::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_EasMessage as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_Encoder_Impl: Sized {
    fn QueryCapabilities(&mut self, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> ::windows::core::Result<()>;
    fn EnumAudioCapability(&mut self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> ::windows::core::Result<()>;
    fn EnumVideoCapability(&mut self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> ::windows::core::Result<()>;
    fn SetParameters(&mut self, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> ::windows::core::Result<()>;
    fn GetState(&mut self, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut super::super::Foundation::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_Encoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_Encoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_Encoder_Vtbl {
        unsafe extern "system" fn QueryCapabilities<Impl: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryCapabilities(::core::mem::transmute_copy(&numaudiofmts), ::core::mem::transmute_copy(&numvideofmts)).into()
        }
        unsafe extern "system" fn EnumAudioCapability<Impl: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnumAudioCapability(::core::mem::transmute_copy(&fmtindex), ::core::mem::transmute_copy(&methodid), ::core::mem::transmute_copy(&algorithmtype), ::core::mem::transmute_copy(&samplingrate), ::core::mem::transmute_copy(&bitdepth), ::core::mem::transmute_copy(&numchannels)).into()
        }
        unsafe extern "system" fn EnumVideoCapability<Impl: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnumVideoCapability(::core::mem::transmute_copy(&fmtindex), ::core::mem::transmute_copy(&methodid), ::core::mem::transmute_copy(&algorithmtype), ::core::mem::transmute_copy(&verticalsize), ::core::mem::transmute_copy(&horizontalsize), ::core::mem::transmute_copy(&aspectratio), ::core::mem::transmute_copy(&frameratecode), ::core::mem::transmute_copy(&progressivesequence)).into()
        }
        unsafe extern "system" fn SetParameters<Impl: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetParameters(::core::mem::transmute_copy(&audiobitratemode), ::core::mem::transmute_copy(&audiobitrate), ::core::mem::transmute_copy(&audiomethodid), ::core::mem::transmute_copy(&audioprogram), ::core::mem::transmute_copy(&videobitratemode), ::core::mem::transmute_copy(&videobitrate), ::core::mem::transmute_copy(&videomethodid)).into()
        }
        unsafe extern "system" fn GetState<Impl: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut super::super::Foundation::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this)
                .GetState(
                    ::core::mem::transmute_copy(&audiobitratemax),
                    ::core::mem::transmute_copy(&audiobitratemin),
                    ::core::mem::transmute_copy(&audiobitratemode),
                    ::core::mem::transmute_copy(&audiobitratestepping),
                    ::core::mem::transmute_copy(&audiobitrate),
                    ::core::mem::transmute_copy(&audiomethodid),
                    ::core::mem::transmute_copy(&availableaudioprograms),
                    ::core::mem::transmute_copy(&audioprogram),
                    ::core::mem::transmute_copy(&videobitratemax),
                    ::core::mem::transmute_copy(&videobitratemin),
                    ::core::mem::transmute_copy(&videobitratemode),
                    ::core::mem::transmute_copy(&videobitrate),
                    ::core::mem::transmute_copy(&videobitratestepping),
                    ::core::mem::transmute_copy(&videomethodid),
                    ::core::mem::transmute_copy(&signalsourceid),
                    ::core::mem::transmute_copy(&signalformat),
                    ::core::mem::transmute_copy(&signallock),
                    ::core::mem::transmute_copy(&signallevel),
                    ::core::mem::transmute_copy(&signaltonoiseratio),
                )
                .into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            QueryCapabilities: QueryCapabilities::<Impl, IMPL_OFFSET>,
            EnumAudioCapability: EnumAudioCapability::<Impl, IMPL_OFFSET>,
            EnumVideoCapability: EnumVideoCapability::<Impl, IMPL_OFFSET>,
            SetParameters: SetParameters::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_Encoder as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_EthernetFilter_Impl: Sized {
    fn GetMulticastListSize(&mut self, pulcbaddresses: *mut u32) -> ::windows::core::Result<()>;
    fn PutMulticastList(&mut self, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::Result<()>;
    fn GetMulticastList(&mut self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::Result<()>;
    fn PutMulticastMode(&mut self, ulmodemask: u32) -> ::windows::core::Result<()>;
    fn GetMulticastMode(&mut self) -> ::windows::core::Result<u32>;
}
impl IBDA_EthernetFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_EthernetFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_EthernetFilter_Vtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastListSize(::core::mem::transmute_copy(&pulcbaddresses)).into()
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastList(::core::mem::transmute_copy(&ulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastList(::core::mem::transmute_copy(&pulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastMode(::core::mem::transmute_copy(&ulmodemask)).into()
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pulmodemask = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Impl, IMPL_OFFSET>,
            PutMulticastList: PutMulticastList::<Impl, IMPL_OFFSET>,
            GetMulticastList: GetMulticastList::<Impl, IMPL_OFFSET>,
            PutMulticastMode: PutMulticastMode::<Impl, IMPL_OFFSET>,
            GetMulticastMode: GetMulticastMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_EthernetFilter as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_EventingService_Impl: Sized {
    fn CompleteEvent(&mut self, uleventid: u32, uleventresult: u32) -> ::windows::core::Result<()>;
}
impl IBDA_EventingService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_EventingService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_EventingService_Vtbl {
        unsafe extern "system" fn CompleteEvent<Impl: IBDA_EventingService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uleventid: u32, uleventresult: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompleteEvent(::core::mem::transmute_copy(&uleventid), ::core::mem::transmute_copy(&uleventresult)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CompleteEvent: CompleteEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_EventingService as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_FDC_Impl: Sized {
    fn GetStatus(&mut self, currentbitrate: *mut u32, carrierlock: *mut super::super::Foundation::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut super::super::Foundation::BOOL, currentpidlist: *mut super::super::Foundation::BSTR, currenttidlist: *mut super::super::Foundation::BSTR, overflow: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn RequestTables(&mut self, tableids: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn AddPid(&mut self, pidstoadd: &super::super::Foundation::BSTR) -> ::windows::core::Result<u32>;
    fn RemovePid(&mut self, pidstoremove: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn AddTid(&mut self, tidstoadd: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn RemoveTid(&mut self, tidstoremove: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetTableSection(&mut self, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_FDC_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_FDC_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_FDC_Vtbl {
        unsafe extern "system" fn GetStatus<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentbitrate: *mut u32, carrierlock: *mut super::super::Foundation::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut super::super::Foundation::BOOL, currentpidlist: *mut super::super::Foundation::BSTR, currenttidlist: *mut super::super::Foundation::BSTR, overflow: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStatus(::core::mem::transmute_copy(&currentbitrate), ::core::mem::transmute_copy(&carrierlock), ::core::mem::transmute_copy(&currentfrequency), ::core::mem::transmute_copy(&currentspectruminversion), ::core::mem::transmute_copy(&currentpidlist), ::core::mem::transmute_copy(&currenttidlist), ::core::mem::transmute_copy(&overflow)).into()
        }
        unsafe extern "system" fn RequestTables<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableids: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestTables(::core::mem::transmute_copy(&tableids)).into()
        }
        unsafe extern "system" fn AddPid<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pidstoadd: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, remainingfilterentries: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddPid(::core::mem::transmute_copy(&pidstoadd)) {
                ::core::result::Result::Ok(ok__) => {
                    *remainingfilterentries = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePid<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pidstoremove: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePid(::core::mem::transmute_copy(&pidstoremove)).into()
        }
        unsafe extern "system" fn AddTid<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tidstoadd: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, currenttidlist: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddTid(::core::mem::transmute_copy(&tidstoadd)) {
                ::core::result::Result::Ok(ok__) => {
                    *currenttidlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTid<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tidstoremove: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTid(::core::mem::transmute_copy(&tidstoremove)).into()
        }
        unsafe extern "system" fn GetTableSection<Impl: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableSection(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&maxbuffersize), ::core::mem::transmute_copy(&actualsize), ::core::mem::transmute_copy(&secbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            RequestTables: RequestTables::<Impl, IMPL_OFFSET>,
            AddPid: AddPid::<Impl, IMPL_OFFSET>,
            RemovePid: RemovePid::<Impl, IMPL_OFFSET>,
            AddTid: AddTid::<Impl, IMPL_OFFSET>,
            RemoveTid: RemoveTid::<Impl, IMPL_OFFSET>,
            GetTableSection: GetTableSection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_FDC as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_FrequencyFilter_Impl: Sized {
    fn SetAutotune(&mut self, ultransponder: u32) -> ::windows::core::Result<()>;
    fn Autotune(&mut self, pultransponder: *mut u32) -> ::windows::core::Result<()>;
    fn SetFrequency(&mut self, ulfrequency: u32) -> ::windows::core::Result<()>;
    fn Frequency(&mut self, pulfrequency: *mut u32) -> ::windows::core::Result<()>;
    fn SetPolarity(&mut self, polarity: Polarisation) -> ::windows::core::Result<()>;
    fn Polarity(&mut self, ppolarity: *mut Polarisation) -> ::windows::core::Result<()>;
    fn SetRange(&mut self, ulrange: u32) -> ::windows::core::Result<()>;
    fn Range(&mut self, pulrange: *mut u32) -> ::windows::core::Result<()>;
    fn SetBandwidth(&mut self, ulbandwidth: u32) -> ::windows::core::Result<()>;
    fn Bandwidth(&mut self, pulbandwidth: *mut u32) -> ::windows::core::Result<()>;
    fn SetFrequencyMultiplier(&mut self, ulmultiplier: u32) -> ::windows::core::Result<()>;
    fn FrequencyMultiplier(&mut self, pulmultiplier: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_FrequencyFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_FrequencyFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_FrequencyFilter_Vtbl {
        unsafe extern "system" fn SetAutotune<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultransponder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutotune(::core::mem::transmute_copy(&ultransponder)).into()
        }
        unsafe extern "system" fn Autotune<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pultransponder: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Autotune(::core::mem::transmute_copy(&pultransponder)).into()
        }
        unsafe extern "system" fn SetFrequency<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulfrequency: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrequency(::core::mem::transmute_copy(&ulfrequency)).into()
        }
        unsafe extern "system" fn Frequency<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulfrequency: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Frequency(::core::mem::transmute_copy(&pulfrequency)).into()
        }
        unsafe extern "system" fn SetPolarity<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, polarity: Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPolarity(::core::mem::transmute_copy(&polarity)).into()
        }
        unsafe extern "system" fn Polarity<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppolarity: *mut Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Polarity(::core::mem::transmute_copy(&ppolarity)).into()
        }
        unsafe extern "system" fn SetRange<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrange: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRange(::core::mem::transmute_copy(&ulrange)).into()
        }
        unsafe extern "system" fn Range<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulrange: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Range(::core::mem::transmute_copy(&pulrange)).into()
        }
        unsafe extern "system" fn SetBandwidth<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbandwidth: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBandwidth(::core::mem::transmute_copy(&ulbandwidth)).into()
        }
        unsafe extern "system" fn Bandwidth<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulbandwidth: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Bandwidth(::core::mem::transmute_copy(&pulbandwidth)).into()
        }
        unsafe extern "system" fn SetFrequencyMultiplier<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmultiplier: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrequencyMultiplier(::core::mem::transmute_copy(&ulmultiplier)).into()
        }
        unsafe extern "system" fn FrequencyMultiplier<Impl: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulmultiplier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FrequencyMultiplier(::core::mem::transmute_copy(&pulmultiplier)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAutotune: SetAutotune::<Impl, IMPL_OFFSET>,
            Autotune: Autotune::<Impl, IMPL_OFFSET>,
            SetFrequency: SetFrequency::<Impl, IMPL_OFFSET>,
            Frequency: Frequency::<Impl, IMPL_OFFSET>,
            SetPolarity: SetPolarity::<Impl, IMPL_OFFSET>,
            Polarity: Polarity::<Impl, IMPL_OFFSET>,
            SetRange: SetRange::<Impl, IMPL_OFFSET>,
            Range: Range::<Impl, IMPL_OFFSET>,
            SetBandwidth: SetBandwidth::<Impl, IMPL_OFFSET>,
            Bandwidth: Bandwidth::<Impl, IMPL_OFFSET>,
            SetFrequencyMultiplier: SetFrequencyMultiplier::<Impl, IMPL_OFFSET>,
            FrequencyMultiplier: FrequencyMultiplier::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_FrequencyFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_GuideDataDeliveryService_Impl: Sized {
    fn GetGuideDataType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetGuideData(&mut self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> ::windows::core::Result<()>;
    fn RequestGuideDataUpdate(&mut self) -> ::windows::core::Result<()>;
    fn GetTuneXmlFromServiceIdx(&mut self, ul64serviceidx: u64) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetServices(&mut self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> ::windows::core::Result<()>;
    fn GetServiceInfoFromTuneXml(&mut self, bstrtunexml: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_GuideDataDeliveryService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_GuideDataDeliveryService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_GuideDataDeliveryService_Vtbl {
        unsafe extern "system" fn GetGuideDataType<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguiddatatype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGuideDataType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguiddatatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuideData<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetGuideData(::core::mem::transmute_copy(&pulcbbufferlen), ::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&pulguidedatapercentageprogress)).into()
        }
        unsafe extern "system" fn RequestGuideDataUpdate<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestGuideDataUpdate().into()
        }
        unsafe extern "system" fn GetTuneXmlFromServiceIdx<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ul64serviceidx: u64, pbstrtunexml: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTuneXmlFromServiceIdx(::core::mem::transmute_copy(&ul64serviceidx)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtunexml = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServices<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServices(::core::mem::transmute_copy(&pulcbbufferlen), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        unsafe extern "system" fn GetServiceInfoFromTuneXml<Impl: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrtunexml: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrservicedescription: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceInfoFromTuneXml(::core::mem::transmute_copy(&bstrtunexml)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrservicedescription = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetGuideDataType: GetGuideDataType::<Impl, IMPL_OFFSET>,
            GetGuideData: GetGuideData::<Impl, IMPL_OFFSET>,
            RequestGuideDataUpdate: RequestGuideDataUpdate::<Impl, IMPL_OFFSET>,
            GetTuneXmlFromServiceIdx: GetTuneXmlFromServiceIdx::<Impl, IMPL_OFFSET>,
            GetServices: GetServices::<Impl, IMPL_OFFSET>,
            GetServiceInfoFromTuneXml: GetServiceInfoFromTuneXml::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_GuideDataDeliveryService as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_IPSinkControl_Impl: Sized {
    fn GetMulticastList(&mut self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::Result<()>;
    fn GetAdapterIPAddress(&mut self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IBDA_IPSinkControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_IPSinkControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_IPSinkControl_Vtbl {
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPSinkControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastList(::core::mem::transmute_copy(&pulcbsize), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        unsafe extern "system" fn GetAdapterIPAddress<Impl: IBDA_IPSinkControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAdapterIPAddress(::core::mem::transmute_copy(&pulcbsize), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMulticastList: GetMulticastList::<Impl, IMPL_OFFSET>,
            GetAdapterIPAddress: GetAdapterIPAddress::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_IPSinkControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_IPSinkInfo_Impl: Sized {
    fn MulticastList(&mut self, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> ::windows::core::Result<()>;
    fn AdapterIPAddress(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn AdapterDescription(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_IPSinkInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_IPSinkInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_IPSinkInfo_Vtbl {
        unsafe extern "system" fn MulticastList<Impl: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MulticastList(::core::mem::transmute_copy(&pulcbaddresses), ::core::mem::transmute_copy(&ppbaddresslist)).into()
        }
        unsafe extern "system" fn AdapterIPAddress<Impl: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrbuffer: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AdapterIPAddress() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdapterDescription<Impl: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrbuffer: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AdapterDescription() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            MulticastList: MulticastList::<Impl, IMPL_OFFSET>,
            AdapterIPAddress: AdapterIPAddress::<Impl, IMPL_OFFSET>,
            AdapterDescription: AdapterDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_IPSinkInfo as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_IPV4Filter_Impl: Sized {
    fn GetMulticastListSize(&mut self, pulcbaddresses: *mut u32) -> ::windows::core::Result<()>;
    fn PutMulticastList(&mut self, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::Result<()>;
    fn GetMulticastList(&mut self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::Result<()>;
    fn PutMulticastMode(&mut self, ulmodemask: u32) -> ::windows::core::Result<()>;
    fn GetMulticastMode(&mut self) -> ::windows::core::Result<u32>;
}
impl IBDA_IPV4Filter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_IPV4Filter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_IPV4Filter_Vtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastListSize(::core::mem::transmute_copy(&pulcbaddresses)).into()
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastList(::core::mem::transmute_copy(&ulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastList(::core::mem::transmute_copy(&pulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastMode(::core::mem::transmute_copy(&ulmodemask)).into()
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pulmodemask = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Impl, IMPL_OFFSET>,
            PutMulticastList: PutMulticastList::<Impl, IMPL_OFFSET>,
            GetMulticastList: GetMulticastList::<Impl, IMPL_OFFSET>,
            PutMulticastMode: PutMulticastMode::<Impl, IMPL_OFFSET>,
            GetMulticastMode: GetMulticastMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_IPV4Filter as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_IPV6Filter_Impl: Sized {
    fn GetMulticastListSize(&mut self, pulcbaddresses: *mut u32) -> ::windows::core::Result<()>;
    fn PutMulticastList(&mut self, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::Result<()>;
    fn GetMulticastList(&mut self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::Result<()>;
    fn PutMulticastMode(&mut self, ulmodemask: u32) -> ::windows::core::Result<()>;
    fn GetMulticastMode(&mut self) -> ::windows::core::Result<u32>;
}
impl IBDA_IPV6Filter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_IPV6Filter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_IPV6Filter_Vtbl {
        unsafe extern "system" fn GetMulticastListSize<Impl: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastListSize(::core::mem::transmute_copy(&pulcbaddresses)).into()
        }
        unsafe extern "system" fn PutMulticastList<Impl: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastList(::core::mem::transmute_copy(&ulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn GetMulticastList<Impl: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMulticastList(::core::mem::transmute_copy(&pulcbaddresses), ::core::mem::transmute_copy(&paddresslist)).into()
        }
        unsafe extern "system" fn PutMulticastMode<Impl: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmodemask: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutMulticastMode(::core::mem::transmute_copy(&ulmodemask)).into()
        }
        unsafe extern "system" fn GetMulticastMode<Impl: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulmodemask: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMulticastMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pulmodemask = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Impl, IMPL_OFFSET>,
            PutMulticastList: PutMulticastList::<Impl, IMPL_OFFSET>,
            GetMulticastList: GetMulticastList::<Impl, IMPL_OFFSET>,
            PutMulticastMode: PutMulticastMode::<Impl, IMPL_OFFSET>,
            GetMulticastMode: GetMulticastMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_IPV6Filter as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_ISDBConditionalAccess_Impl: Sized {
    fn SetIsdbCasRequest(&mut self, ulrequestid: u32, ulcbrequestbufferlen: u32, pbrequestbuffer: *const u8) -> ::windows::core::Result<()>;
}
impl IBDA_ISDBConditionalAccess_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_ISDBConditionalAccess_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_ISDBConditionalAccess_Vtbl {
        unsafe extern "system" fn SetIsdbCasRequest<Impl: IBDA_ISDBConditionalAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrequestid: u32, ulcbrequestbufferlen: u32, pbrequestbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIsdbCasRequest(::core::mem::transmute_copy(&ulrequestid), ::core::mem::transmute_copy(&ulcbrequestbufferlen), ::core::mem::transmute_copy(&pbrequestbuffer)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetIsdbCasRequest: SetIsdbCasRequest::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_ISDBConditionalAccess as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_LNBInfo_Impl: Sized {
    fn SetLocalOscilatorFrequencyLowBand(&mut self, ulloflow: u32) -> ::windows::core::Result<()>;
    fn LocalOscilatorFrequencyLowBand(&mut self, pulloflow: *mut u32) -> ::windows::core::Result<()>;
    fn SetLocalOscilatorFrequencyHighBand(&mut self, ullofhigh: u32) -> ::windows::core::Result<()>;
    fn LocalOscilatorFrequencyHighBand(&mut self, pullofhigh: *mut u32) -> ::windows::core::Result<()>;
    fn SetHighLowSwitchFrequency(&mut self, ulswitchfrequency: u32) -> ::windows::core::Result<()>;
    fn HighLowSwitchFrequency(&mut self, pulswitchfrequency: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_LNBInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_LNBInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_LNBInfo_Vtbl {
        unsafe extern "system" fn SetLocalOscilatorFrequencyLowBand<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulloflow: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalOscilatorFrequencyLowBand(::core::mem::transmute_copy(&ulloflow)).into()
        }
        unsafe extern "system" fn LocalOscilatorFrequencyLowBand<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulloflow: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LocalOscilatorFrequencyLowBand(::core::mem::transmute_copy(&pulloflow)).into()
        }
        unsafe extern "system" fn SetLocalOscilatorFrequencyHighBand<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullofhigh: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalOscilatorFrequencyHighBand(::core::mem::transmute_copy(&ullofhigh)).into()
        }
        unsafe extern "system" fn LocalOscilatorFrequencyHighBand<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pullofhigh: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LocalOscilatorFrequencyHighBand(::core::mem::transmute_copy(&pullofhigh)).into()
        }
        unsafe extern "system" fn SetHighLowSwitchFrequency<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulswitchfrequency: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHighLowSwitchFrequency(::core::mem::transmute_copy(&ulswitchfrequency)).into()
        }
        unsafe extern "system" fn HighLowSwitchFrequency<Impl: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulswitchfrequency: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HighLowSwitchFrequency(::core::mem::transmute_copy(&pulswitchfrequency)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetLocalOscilatorFrequencyLowBand: SetLocalOscilatorFrequencyLowBand::<Impl, IMPL_OFFSET>,
            LocalOscilatorFrequencyLowBand: LocalOscilatorFrequencyLowBand::<Impl, IMPL_OFFSET>,
            SetLocalOscilatorFrequencyHighBand: SetLocalOscilatorFrequencyHighBand::<Impl, IMPL_OFFSET>,
            LocalOscilatorFrequencyHighBand: LocalOscilatorFrequencyHighBand::<Impl, IMPL_OFFSET>,
            SetHighLowSwitchFrequency: SetHighLowSwitchFrequency::<Impl, IMPL_OFFSET>,
            HighLowSwitchFrequency: HighLowSwitchFrequency::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_LNBInfo as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_MUX_Impl: Sized {
    fn SetPidList(&mut self, ulpidlistcount: u32, pbpidlistbuffer: *const BDA_MUX_PIDLISTITEM) -> ::windows::core::Result<()>;
    fn GetPidList(&mut self, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> ::windows::core::Result<()>;
}
impl IBDA_MUX_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_MUX_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_MUX_Vtbl {
        unsafe extern "system" fn SetPidList<Impl: IBDA_MUX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpidlistcount: u32, pbpidlistbuffer: *const BDA_MUX_PIDLISTITEM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPidList(::core::mem::transmute_copy(&ulpidlistcount), ::core::mem::transmute_copy(&pbpidlistbuffer)).into()
        }
        unsafe extern "system" fn GetPidList<Impl: IBDA_MUX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPidList(::core::mem::transmute_copy(&pulpidlistcount), ::core::mem::transmute_copy(&pbpidlistbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetPidList: SetPidList::<Impl, IMPL_OFFSET>,
            GetPidList: GetPidList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_MUX as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_NameValueService_Impl: Sized {
    fn GetValueNameByIndex(&mut self, ulindex: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetValue(&mut self, bstrname: &super::super::Foundation::BSTR, bstrlanguage: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetValue(&mut self, uldialogrequest: u32, bstrlanguage: &super::super::Foundation::BSTR, bstrname: &super::super::Foundation::BSTR, bstrvalue: &super::super::Foundation::BSTR, ulreserved: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_NameValueService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_NameValueService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_NameValueService_Vtbl {
        unsafe extern "system" fn GetValueNameByIndex<Impl: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulindex: u32, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValueNameByIndex(::core::mem::transmute_copy(&ulindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrvalue: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValue(::core::mem::transmute_copy(&bstrname), ::core::mem::transmute_copy(&bstrlanguage)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, bstrvalue: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ulreserved: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValue(::core::mem::transmute_copy(&uldialogrequest), ::core::mem::transmute_copy(&bstrlanguage), ::core::mem::transmute_copy(&bstrname), ::core::mem::transmute_copy(&bstrvalue), ::core::mem::transmute_copy(&ulreserved)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetValueNameByIndex: GetValueNameByIndex::<Impl, IMPL_OFFSET>,
            GetValue: GetValue::<Impl, IMPL_OFFSET>,
            SetValue: SetValue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_NameValueService as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_NetworkProvider_Impl: Sized {
    fn PutSignalSource(&mut self, ulsignalsource: u32) -> ::windows::core::Result<()>;
    fn GetSignalSource(&mut self, pulsignalsource: *mut u32) -> ::windows::core::Result<()>;
    fn GetNetworkType(&mut self, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn PutTuningSpace(&mut self, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetTuningSpace(&mut self, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn RegisterDeviceFilter(&mut self, punkfiltercontrol: &::core::option::Option<::windows::core::IUnknown>, ppvregisitrationcontext: *mut u32) -> ::windows::core::Result<()>;
    fn UnRegisterDeviceFilter(&mut self, pvregistrationcontext: u32) -> ::windows::core::Result<()>;
}
impl IBDA_NetworkProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_NetworkProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_NetworkProvider_Vtbl {
        unsafe extern "system" fn PutSignalSource<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulsignalsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutSignalSource(::core::mem::transmute_copy(&ulsignalsource)).into()
        }
        unsafe extern "system" fn GetSignalSource<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulsignalsource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSignalSource(::core::mem::transmute_copy(&pulsignalsource)).into()
        }
        unsafe extern "system" fn GetNetworkType<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNetworkType(::core::mem::transmute_copy(&pguidnetworktype)).into()
        }
        unsafe extern "system" fn PutTuningSpace<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutTuningSpace(::core::mem::transmute_copy(&guidtuningspace)).into()
        }
        unsafe extern "system" fn GetTuningSpace<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTuningSpace(::core::mem::transmute_copy(&pguidtuingspace)).into()
        }
        unsafe extern "system" fn RegisterDeviceFilter<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkfiltercontrol: *mut ::core::ffi::c_void, ppvregisitrationcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterDeviceFilter(::core::mem::transmute(&punkfiltercontrol), ::core::mem::transmute_copy(&ppvregisitrationcontext)).into()
        }
        unsafe extern "system" fn UnRegisterDeviceFilter<Impl: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnRegisterDeviceFilter(::core::mem::transmute_copy(&pvregistrationcontext)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            PutSignalSource: PutSignalSource::<Impl, IMPL_OFFSET>,
            GetSignalSource: GetSignalSource::<Impl, IMPL_OFFSET>,
            GetNetworkType: GetNetworkType::<Impl, IMPL_OFFSET>,
            PutTuningSpace: PutTuningSpace::<Impl, IMPL_OFFSET>,
            GetTuningSpace: GetTuningSpace::<Impl, IMPL_OFFSET>,
            RegisterDeviceFilter: RegisterDeviceFilter::<Impl, IMPL_OFFSET>,
            UnRegisterDeviceFilter: UnRegisterDeviceFilter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_NetworkProvider as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_NullTransform_Impl: Sized {
    fn Start(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
}
impl IBDA_NullTransform_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_NullTransform_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_NullTransform_Vtbl {
        unsafe extern "system" fn Start<Impl: IBDA_NullTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start().into()
        }
        unsafe extern "system" fn Stop<Impl: IBDA_NullTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Start: Start::<Impl, IMPL_OFFSET>, Stop: Stop::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_NullTransform as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_PinControl_Impl: Sized {
    fn GetPinID(&mut self, pulpinid: *mut u32) -> ::windows::core::Result<()>;
    fn GetPinType(&mut self, pulpintype: *mut u32) -> ::windows::core::Result<()>;
    fn RegistrationContext(&mut self, pulregistrationctx: *mut u32) -> ::windows::core::Result<()>;
}
impl IBDA_PinControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_PinControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_PinControl_Vtbl {
        unsafe extern "system" fn GetPinID<Impl: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPinID(::core::mem::transmute_copy(&pulpinid)).into()
        }
        unsafe extern "system" fn GetPinType<Impl: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulpintype: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPinType(::core::mem::transmute_copy(&pulpintype)).into()
        }
        unsafe extern "system" fn RegistrationContext<Impl: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulregistrationctx: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegistrationContext(::core::mem::transmute_copy(&pulregistrationctx)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPinID: GetPinID::<Impl, IMPL_OFFSET>,
            GetPinType: GetPinType::<Impl, IMPL_OFFSET>,
            RegistrationContext: RegistrationContext::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_PinControl as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_SignalProperties_Impl: Sized {
    fn PutNetworkType(&mut self, guidnetworktype: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetNetworkType(&mut self, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn PutSignalSource(&mut self, ulsignalsource: u32) -> ::windows::core::Result<()>;
    fn GetSignalSource(&mut self, pulsignalsource: *mut u32) -> ::windows::core::Result<()>;
    fn PutTuningSpace(&mut self, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetTuningSpace(&mut self, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
}
impl IBDA_SignalProperties_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_SignalProperties_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_SignalProperties_Vtbl {
        unsafe extern "system" fn PutNetworkType<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidnetworktype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutNetworkType(::core::mem::transmute_copy(&guidnetworktype)).into()
        }
        unsafe extern "system" fn GetNetworkType<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidnetworktype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNetworkType(::core::mem::transmute_copy(&pguidnetworktype)).into()
        }
        unsafe extern "system" fn PutSignalSource<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulsignalsource: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutSignalSource(::core::mem::transmute_copy(&ulsignalsource)).into()
        }
        unsafe extern "system" fn GetSignalSource<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulsignalsource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSignalSource(::core::mem::transmute_copy(&pulsignalsource)).into()
        }
        unsafe extern "system" fn PutTuningSpace<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidtuningspace: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PutTuningSpace(::core::mem::transmute_copy(&guidtuningspace)).into()
        }
        unsafe extern "system" fn GetTuningSpace<Impl: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtuingspace: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTuningSpace(::core::mem::transmute_copy(&pguidtuingspace)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            PutNetworkType: PutNetworkType::<Impl, IMPL_OFFSET>,
            GetNetworkType: GetNetworkType::<Impl, IMPL_OFFSET>,
            PutSignalSource: PutSignalSource::<Impl, IMPL_OFFSET>,
            GetSignalSource: GetSignalSource::<Impl, IMPL_OFFSET>,
            PutTuningSpace: PutTuningSpace::<Impl, IMPL_OFFSET>,
            GetTuningSpace: GetTuningSpace::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_SignalProperties as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_SignalStatistics_Impl: Sized {
    fn SetSignalStrength(&mut self, ldbstrength: i32) -> ::windows::core::Result<()>;
    fn SignalStrength(&mut self, pldbstrength: *mut i32) -> ::windows::core::Result<()>;
    fn SetSignalQuality(&mut self, lpercentquality: i32) -> ::windows::core::Result<()>;
    fn SignalQuality(&mut self, plpercentquality: *mut i32) -> ::windows::core::Result<()>;
    fn SetSignalPresent(&mut self, fpresent: super::super::Foundation::BOOLEAN) -> ::windows::core::Result<()>;
    fn SignalPresent(&mut self, pfpresent: *mut u8) -> ::windows::core::Result<()>;
    fn SetSignalLocked(&mut self, flocked: super::super::Foundation::BOOLEAN) -> ::windows::core::Result<()>;
    fn SignalLocked(&mut self, pflocked: *mut u8) -> ::windows::core::Result<()>;
    fn SetSampleTime(&mut self, lmssampletime: i32) -> ::windows::core::Result<()>;
    fn SampleTime(&mut self, plmssampletime: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_SignalStatistics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_SignalStatistics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_SignalStatistics_Vtbl {
        unsafe extern "system" fn SetSignalStrength<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ldbstrength: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalStrength(::core::mem::transmute_copy(&ldbstrength)).into()
        }
        unsafe extern "system" fn SignalStrength<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pldbstrength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalStrength(::core::mem::transmute_copy(&pldbstrength)).into()
        }
        unsafe extern "system" fn SetSignalQuality<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpercentquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalQuality(::core::mem::transmute_copy(&lpercentquality)).into()
        }
        unsafe extern "system" fn SignalQuality<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plpercentquality: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalQuality(::core::mem::transmute_copy(&plpercentquality)).into()
        }
        unsafe extern "system" fn SetSignalPresent<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpresent: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalPresent(::core::mem::transmute_copy(&fpresent)).into()
        }
        unsafe extern "system" fn SignalPresent<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfpresent: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalPresent(::core::mem::transmute_copy(&pfpresent)).into()
        }
        unsafe extern "system" fn SetSignalLocked<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flocked: super::super::Foundation::BOOLEAN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalLocked(::core::mem::transmute_copy(&flocked)).into()
        }
        unsafe extern "system" fn SignalLocked<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflocked: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalLocked(::core::mem::transmute_copy(&pflocked)).into()
        }
        unsafe extern "system" fn SetSampleTime<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lmssampletime: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleTime(::core::mem::transmute_copy(&lmssampletime)).into()
        }
        unsafe extern "system" fn SampleTime<Impl: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plmssampletime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SampleTime(::core::mem::transmute_copy(&plmssampletime)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetSignalStrength: SetSignalStrength::<Impl, IMPL_OFFSET>,
            SignalStrength: SignalStrength::<Impl, IMPL_OFFSET>,
            SetSignalQuality: SetSignalQuality::<Impl, IMPL_OFFSET>,
            SignalQuality: SignalQuality::<Impl, IMPL_OFFSET>,
            SetSignalPresent: SetSignalPresent::<Impl, IMPL_OFFSET>,
            SignalPresent: SignalPresent::<Impl, IMPL_OFFSET>,
            SetSignalLocked: SetSignalLocked::<Impl, IMPL_OFFSET>,
            SignalLocked: SignalLocked::<Impl, IMPL_OFFSET>,
            SetSampleTime: SetSampleTime::<Impl, IMPL_OFFSET>,
            SampleTime: SampleTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_SignalStatistics as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_TIF_REGISTRATION_Impl: Sized {
    fn RegisterTIFEx(&mut self, ptifinputpin: &::core::option::Option<IPin>, ppvregistrationcontext: *mut u32, ppmpeg2datacontrol: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn UnregisterTIF(&mut self, pvregistrationcontext: u32) -> ::windows::core::Result<()>;
}
impl IBDA_TIF_REGISTRATION_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_TIF_REGISTRATION_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_TIF_REGISTRATION_Vtbl {
        unsafe extern "system" fn RegisterTIFEx<Impl: IBDA_TIF_REGISTRATION_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptifinputpin: ::windows::core::RawPtr, ppvregistrationcontext: *mut u32, ppmpeg2datacontrol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterTIFEx(::core::mem::transmute(&ptifinputpin), ::core::mem::transmute_copy(&ppvregistrationcontext), ::core::mem::transmute_copy(&ppmpeg2datacontrol)).into()
        }
        unsafe extern "system" fn UnregisterTIF<Impl: IBDA_TIF_REGISTRATION_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterTIF(::core::mem::transmute_copy(&pvregistrationcontext)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterTIFEx: RegisterTIFEx::<Impl, IMPL_OFFSET>,
            UnregisterTIF: UnregisterTIF::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_TIF_REGISTRATION as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_Topology_Impl: Sized {
    fn GetNodeTypes(&mut self, pulcnodetypes: *mut u32, ulcnodetypesmax: u32, rgulnodetypes: *mut u32) -> ::windows::core::Result<()>;
    fn GetNodeDescriptors(&mut self, ulcnodedescriptors: *mut u32, ulcnodedescriptorsmax: u32, rgnodedescriptors: *mut BDANODE_DESCRIPTOR) -> ::windows::core::Result<()>;
    fn GetNodeInterfaces(&mut self, ulnodetype: u32, pulcinterfaces: *mut u32, ulcinterfacesmax: u32, rgguidinterfaces: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetPinTypes(&mut self, pulcpintypes: *mut u32, ulcpintypesmax: u32, rgulpintypes: *mut u32) -> ::windows::core::Result<()>;
    fn GetTemplateConnections(&mut self, pulcconnections: *mut u32, ulcconnectionsmax: u32, rgconnections: *mut BDA_TEMPLATE_CONNECTION) -> ::windows::core::Result<()>;
    fn CreatePin(&mut self, ulpintype: u32, pulpinid: *mut u32) -> ::windows::core::Result<()>;
    fn DeletePin(&mut self, ulpinid: u32) -> ::windows::core::Result<()>;
    fn SetMediaType(&mut self, ulpinid: u32, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn SetMedium(&mut self, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> ::windows::core::Result<()>;
    fn CreateTopology(&mut self, ulinputpinid: u32, uloutputpinid: u32) -> ::windows::core::Result<()>;
    fn GetControlNode(&mut self, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_Topology_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_Topology_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_Topology_Vtbl {
        unsafe extern "system" fn GetNodeTypes<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcnodetypes: *mut u32, ulcnodetypesmax: u32, rgulnodetypes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeTypes(::core::mem::transmute_copy(&pulcnodetypes), ::core::mem::transmute_copy(&ulcnodetypesmax), ::core::mem::transmute_copy(&rgulnodetypes)).into()
        }
        unsafe extern "system" fn GetNodeDescriptors<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcnodedescriptors: *mut u32, ulcnodedescriptorsmax: u32, rgnodedescriptors: *mut BDANODE_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeDescriptors(::core::mem::transmute_copy(&ulcnodedescriptors), ::core::mem::transmute_copy(&ulcnodedescriptorsmax), ::core::mem::transmute_copy(&rgnodedescriptors)).into()
        }
        unsafe extern "system" fn GetNodeInterfaces<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulnodetype: u32, pulcinterfaces: *mut u32, ulcinterfacesmax: u32, rgguidinterfaces: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeInterfaces(::core::mem::transmute_copy(&ulnodetype), ::core::mem::transmute_copy(&pulcinterfaces), ::core::mem::transmute_copy(&ulcinterfacesmax), ::core::mem::transmute_copy(&rgguidinterfaces)).into()
        }
        unsafe extern "system" fn GetPinTypes<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcpintypes: *mut u32, ulcpintypesmax: u32, rgulpintypes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPinTypes(::core::mem::transmute_copy(&pulcpintypes), ::core::mem::transmute_copy(&ulcpintypesmax), ::core::mem::transmute_copy(&rgulpintypes)).into()
        }
        unsafe extern "system" fn GetTemplateConnections<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcconnections: *mut u32, ulcconnectionsmax: u32, rgconnections: *mut BDA_TEMPLATE_CONNECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTemplateConnections(::core::mem::transmute_copy(&pulcconnections), ::core::mem::transmute_copy(&ulcconnectionsmax), ::core::mem::transmute_copy(&rgconnections)).into()
        }
        unsafe extern "system" fn CreatePin<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpintype: u32, pulpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreatePin(::core::mem::transmute_copy(&ulpintype), ::core::mem::transmute_copy(&pulpinid)).into()
        }
        unsafe extern "system" fn DeletePin<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeletePin(::core::mem::transmute_copy(&ulpinid)).into()
        }
        unsafe extern "system" fn SetMediaType<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpinid: u32, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute_copy(&ulpinid), ::core::mem::transmute_copy(&pmediatype)).into()
        }
        unsafe extern "system" fn SetMedium<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMedium(::core::mem::transmute_copy(&ulpinid), ::core::mem::transmute_copy(&pmedium)).into()
        }
        unsafe extern "system" fn CreateTopology<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateTopology(::core::mem::transmute_copy(&ulinputpinid), ::core::mem::transmute_copy(&uloutputpinid)).into()
        }
        unsafe extern "system" fn GetControlNode<Impl: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetControlNode(::core::mem::transmute_copy(&ulinputpinid), ::core::mem::transmute_copy(&uloutputpinid), ::core::mem::transmute_copy(&ulnodetype), ::core::mem::transmute_copy(&ppcontrolnode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNodeTypes: GetNodeTypes::<Impl, IMPL_OFFSET>,
            GetNodeDescriptors: GetNodeDescriptors::<Impl, IMPL_OFFSET>,
            GetNodeInterfaces: GetNodeInterfaces::<Impl, IMPL_OFFSET>,
            GetPinTypes: GetPinTypes::<Impl, IMPL_OFFSET>,
            GetTemplateConnections: GetTemplateConnections::<Impl, IMPL_OFFSET>,
            CreatePin: CreatePin::<Impl, IMPL_OFFSET>,
            DeletePin: DeletePin::<Impl, IMPL_OFFSET>,
            SetMediaType: SetMediaType::<Impl, IMPL_OFFSET>,
            SetMedium: SetMedium::<Impl, IMPL_OFFSET>,
            CreateTopology: CreateTopology::<Impl, IMPL_OFFSET>,
            GetControlNode: GetControlNode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_Topology as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_TransportStreamInfo_Impl: Sized {
    fn PatTableTickCount(&mut self) -> ::windows::core::Result<u32>;
}
impl IBDA_TransportStreamInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_TransportStreamInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_TransportStreamInfo_Vtbl {
        unsafe extern "system" fn PatTableTickCount<Impl: IBDA_TransportStreamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattickcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PatTableTickCount() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattickcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), PatTableTickCount: PatTableTickCount::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_TransportStreamInfo as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_TransportStreamSelector_Impl: Sized {
    fn SetTSID(&mut self, ustsid: u16) -> ::windows::core::Result<()>;
    fn GetTSInformation(&mut self, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> ::windows::core::Result<()>;
}
impl IBDA_TransportStreamSelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_TransportStreamSelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_TransportStreamSelector_Vtbl {
        unsafe extern "system" fn SetTSID<Impl: IBDA_TransportStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ustsid: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTSID(::core::mem::transmute_copy(&ustsid)).into()
        }
        unsafe extern "system" fn GetTSInformation<Impl: IBDA_TransportStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTSInformation(::core::mem::transmute_copy(&pultsinformationbufferlen), ::core::mem::transmute_copy(&pbtsinformationbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetTSID: SetTSID::<Impl, IMPL_OFFSET>,
            GetTSInformation: GetTSInformation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_TransportStreamSelector as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_UserActivityService_Impl: Sized {
    fn SetCurrentTunerUseReason(&mut self, dwusereason: u32) -> ::windows::core::Result<()>;
    fn GetUserActivityInterval(&mut self) -> ::windows::core::Result<u32>;
    fn UserActivityDetected(&mut self) -> ::windows::core::Result<()>;
}
impl IBDA_UserActivityService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_UserActivityService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_UserActivityService_Vtbl {
        unsafe extern "system" fn SetCurrentTunerUseReason<Impl: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwusereason: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentTunerUseReason(::core::mem::transmute_copy(&dwusereason)).into()
        }
        unsafe extern "system" fn GetUserActivityInterval<Impl: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwactivityinterval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUserActivityInterval() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwactivityinterval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UserActivityDetected<Impl: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UserActivityDetected().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetCurrentTunerUseReason: SetCurrentTunerUseReason::<Impl, IMPL_OFFSET>,
            GetUserActivityInterval: GetUserActivityInterval::<Impl, IMPL_OFFSET>,
            UserActivityDetected: UserActivityDetected::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_UserActivityService as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_VoidTransform_Impl: Sized {
    fn Start(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
}
impl IBDA_VoidTransform_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_VoidTransform_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_VoidTransform_Vtbl {
        unsafe extern "system" fn Start<Impl: IBDA_VoidTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start().into()
        }
        unsafe extern "system" fn Stop<Impl: IBDA_VoidTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Start: Start::<Impl, IMPL_OFFSET>, Stop: Stop::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_VoidTransform as ::windows::core::Interface>::IID
    }
}
pub trait IBDA_WMDRMSession_Impl: Sized {
    fn GetStatus(&mut self, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> ::windows::core::Result<()>;
    fn SetRevInfo(&mut self, ulrevinfolen: u32, pbrevinfo: *const u8) -> ::windows::core::Result<()>;
    fn SetCrl(&mut self, ulcrllen: u32, pbcrllen: *const u8) -> ::windows::core::Result<()>;
    fn TransactMessage(&mut self, ulcbrequest: u32, pbrequest: *const u8, pulcbresponse: *mut u32, pbresponse: *mut u8) -> ::windows::core::Result<()>;
    fn GetLicense(&mut self, uuidkey: *const ::windows::core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> ::windows::core::Result<()>;
    fn ReissueLicense(&mut self, uuidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn RenewLicense(&mut self, ulinxmrlicenselen: u32, pbinxmrlicense: *const u8, ulentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> ::windows::core::Result<()>;
    fn GetKeyInfo(&mut self, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> ::windows::core::Result<()>;
}
impl IBDA_WMDRMSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_WMDRMSession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_WMDRMSession_Vtbl {
        unsafe extern "system" fn GetStatus<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStatus(::core::mem::transmute_copy(&maxcapturetoken), ::core::mem::transmute_copy(&maxstreamingpid), ::core::mem::transmute_copy(&maxlicense), ::core::mem::transmute_copy(&minsecuritylevel), ::core::mem::transmute_copy(&revinfosequencenumber), ::core::mem::transmute_copy(&revinfoissuedtime), ::core::mem::transmute_copy(&revinfottl), ::core::mem::transmute_copy(&revlistversion), ::core::mem::transmute_copy(&ulstate)).into()
        }
        unsafe extern "system" fn SetRevInfo<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulrevinfolen: u32, pbrevinfo: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRevInfo(::core::mem::transmute_copy(&ulrevinfolen), ::core::mem::transmute_copy(&pbrevinfo)).into()
        }
        unsafe extern "system" fn SetCrl<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcrllen: u32, pbcrllen: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCrl(::core::mem::transmute_copy(&ulcrllen), ::core::mem::transmute_copy(&pbcrllen)).into()
        }
        unsafe extern "system" fn TransactMessage<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcbrequest: u32, pbrequest: *const u8, pulcbresponse: *mut u32, pbresponse: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TransactMessage(::core::mem::transmute_copy(&ulcbrequest), ::core::mem::transmute_copy(&pbrequest), ::core::mem::transmute_copy(&pulcbresponse), ::core::mem::transmute_copy(&pbresponse)).into()
        }
        unsafe extern "system" fn GetLicense<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uuidkey: *const ::windows::core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLicense(::core::mem::transmute_copy(&uuidkey), ::core::mem::transmute_copy(&pulpackagelen), ::core::mem::transmute_copy(&pbpackage)).into()
        }
        unsafe extern "system" fn ReissueLicense<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uuidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReissueLicense(::core::mem::transmute_copy(&uuidkey)).into()
        }
        unsafe extern "system" fn RenewLicense<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulinxmrlicenselen: u32, pbinxmrlicense: *const u8, ulentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenewLicense(::core::mem::transmute_copy(&ulinxmrlicenselen), ::core::mem::transmute_copy(&pbinxmrlicense), ::core::mem::transmute_copy(&ulentitlementtokenlen), ::core::mem::transmute_copy(&pbentitlementtoken), ::core::mem::transmute_copy(&puldescramblestatus), ::core::mem::transmute_copy(&puloutxmrlicenselen), ::core::mem::transmute_copy(&pboutxmrlicense)).into()
        }
        unsafe extern "system" fn GetKeyInfo<Impl: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetKeyInfo(::core::mem::transmute_copy(&pulkeyinfolen), ::core::mem::transmute_copy(&pbkeyinfo)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            SetRevInfo: SetRevInfo::<Impl, IMPL_OFFSET>,
            SetCrl: SetCrl::<Impl, IMPL_OFFSET>,
            TransactMessage: TransactMessage::<Impl, IMPL_OFFSET>,
            GetLicense: GetLicense::<Impl, IMPL_OFFSET>,
            ReissueLicense: ReissueLicense::<Impl, IMPL_OFFSET>,
            RenewLicense: RenewLicense::<Impl, IMPL_OFFSET>,
            GetKeyInfo: GetKeyInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_WMDRMSession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBDA_WMDRMTuner_Impl: Sized {
    fn PurchaseEntitlement(&mut self, uldialogrequest: u32, bstrlanguage: &super::super::Foundation::BSTR, ulpurchasetokenlen: u32, pbpurchasetoken: *const u8, puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> ::windows::core::Result<()>;
    fn CancelCaptureToken(&mut self, ulcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::Result<()>;
    fn SetPidProtection(&mut self, ulpid: u32, uuidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetPidProtection(&mut self, pulpid: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetSyncValue(&mut self, ulsyncvalue: u32) -> ::windows::core::Result<()>;
    fn GetStartCodeProfile(&mut self, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBDA_WMDRMTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBDA_WMDRMTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBDA_WMDRMTuner_Vtbl {
        unsafe extern "system" fn PurchaseEntitlement<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldialogrequest: u32, bstrlanguage: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ulpurchasetokenlen: u32, pbpurchasetoken: *const u8, puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PurchaseEntitlement(::core::mem::transmute_copy(&uldialogrequest), ::core::mem::transmute_copy(&bstrlanguage), ::core::mem::transmute_copy(&ulpurchasetokenlen), ::core::mem::transmute_copy(&pbpurchasetoken), ::core::mem::transmute_copy(&puldescramblestatus), ::core::mem::transmute_copy(&pulcapturetokenlen), ::core::mem::transmute_copy(&pbcapturetoken)).into()
        }
        unsafe extern "system" fn CancelCaptureToken<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcapturetokenlen: u32, pbcapturetoken: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelCaptureToken(::core::mem::transmute_copy(&ulcapturetokenlen), ::core::mem::transmute_copy(&pbcapturetoken)).into()
        }
        unsafe extern "system" fn SetPidProtection<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpid: u32, uuidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPidProtection(::core::mem::transmute_copy(&ulpid), ::core::mem::transmute_copy(&uuidkey)).into()
        }
        unsafe extern "system" fn GetPidProtection<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulpid: u32, uuidkey: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPidProtection(::core::mem::transmute_copy(&pulpid)) {
                ::core::result::Result::Ok(ok__) => {
                    *uuidkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncValue<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulsyncvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncValue(::core::mem::transmute_copy(&ulsyncvalue)).into()
        }
        unsafe extern "system" fn GetStartCodeProfile<Impl: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStartCodeProfile(::core::mem::transmute_copy(&pulstartcodeprofilelen), ::core::mem::transmute_copy(&pbstartcodeprofile)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            PurchaseEntitlement: PurchaseEntitlement::<Impl, IMPL_OFFSET>,
            CancelCaptureToken: CancelCaptureToken::<Impl, IMPL_OFFSET>,
            SetPidProtection: SetPidProtection::<Impl, IMPL_OFFSET>,
            GetPidProtection: GetPidProtection::<Impl, IMPL_OFFSET>,
            SetSyncValue: SetSyncValue::<Impl, IMPL_OFFSET>,
            GetStartCodeProfile: GetStartCodeProfile::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBDA_WMDRMTuner as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IBPCSatelliteTuner_Impl: Sized + IAMTuner_Impl {
    fn DefaultSubChannelTypes(&mut self, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> ::windows::core::Result<()>;
    fn SetDefaultSubChannelTypes(&mut self, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> ::windows::core::Result<()>;
    fn IsTapingPermitted(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IBPCSatelliteTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBPCSatelliteTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBPCSatelliteTuner_Vtbl {
        unsafe extern "system" fn DefaultSubChannelTypes<Impl: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DefaultSubChannelTypes(::core::mem::transmute_copy(&pldefaultvideotype), ::core::mem::transmute_copy(&pldefaultaudiotype)).into()
        }
        unsafe extern "system" fn SetDefaultSubChannelTypes<Impl: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSubChannelTypes(::core::mem::transmute_copy(&ldefaultvideotype), ::core::mem::transmute_copy(&ldefaultaudiotype)).into()
        }
        unsafe extern "system" fn IsTapingPermitted<Impl: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsTapingPermitted().into()
        }
        Self {
            base: IAMTuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            DefaultSubChannelTypes: DefaultSubChannelTypes::<Impl, IMPL_OFFSET>,
            SetDefaultSubChannelTypes: SetDefaultSubChannelTypes::<Impl, IMPL_OFFSET>,
            IsTapingPermitted: IsTapingPermitted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBPCSatelliteTuner as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IBaseFilter_Impl: Sized + super::super::System::Com::IPersist_Impl + IMediaFilter_Impl {
    fn EnumPins(&mut self) -> ::windows::core::Result<IEnumPins>;
    fn FindPin(&mut self, id: super::super::Foundation::PWSTR) -> ::windows::core::Result<IPin>;
    fn QueryFilterInfo(&mut self) -> ::windows::core::Result<FILTER_INFO>;
    fn JoinFilterGraph(&mut self, pgraph: &::core::option::Option<IFilterGraph>, pname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn QueryVendorInfo(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IBaseFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBaseFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBaseFilter_Vtbl {
        unsafe extern "system" fn EnumPins<Impl: IBaseFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumPins() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindPin<Impl: IBaseFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: super::super::Foundation::PWSTR, pppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindPin(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *pppin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryFilterInfo<Impl: IBaseFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinfo: *mut FILTER_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryFilterInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *pinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn JoinFilterGraph<Impl: IBaseFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr, pname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).JoinFilterGraph(::core::mem::transmute(&pgraph), ::core::mem::transmute_copy(&pname)).into()
        }
        unsafe extern "system" fn QueryVendorInfo<Impl: IBaseFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvendorinfo: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryVendorInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *pvendorinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMediaFilter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            EnumPins: EnumPins::<Impl, IMPL_OFFSET>,
            FindPin: FindPin::<Impl, IMPL_OFFSET>,
            QueryFilterInfo: QueryFilterInfo::<Impl, IMPL_OFFSET>,
            JoinFilterGraph: JoinFilterGraph::<Impl, IMPL_OFFSET>,
            QueryVendorInfo: QueryVendorInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBaseFilter as ::windows::core::Interface>::IID
    }
}
pub trait IBaseVideoMixer_Impl: Sized {
    fn SetLeadPin(&mut self, ipin: i32) -> ::windows::core::Result<()>;
    fn GetLeadPin(&mut self) -> ::windows::core::Result<i32>;
    fn GetInputPinCount(&mut self) -> ::windows::core::Result<i32>;
    fn IsUsingClock(&mut self) -> ::windows::core::Result<i32>;
    fn SetUsingClock(&mut self, bvalue: i32) -> ::windows::core::Result<()>;
    fn GetClockPeriod(&mut self) -> ::windows::core::Result<i32>;
    fn SetClockPeriod(&mut self, bvalue: i32) -> ::windows::core::Result<()>;
}
impl IBaseVideoMixer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBaseVideoMixer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBaseVideoMixer_Vtbl {
        unsafe extern "system" fn SetLeadPin<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ipin: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeadPin(::core::mem::transmute_copy(&ipin)).into()
        }
        unsafe extern "system" fn GetLeadPin<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pipin: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeadPin() {
                ::core::result::Result::Ok(ok__) => {
                    *pipin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputPinCount<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pipincount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputPinCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pipincount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingClock<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsUsingClock() {
                ::core::result::Result::Ok(ok__) => {
                    *pbvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUsingClock<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bvalue: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUsingClock(::core::mem::transmute_copy(&bvalue)).into()
        }
        unsafe extern "system" fn GetClockPeriod<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetClockPeriod() {
                ::core::result::Result::Ok(ok__) => {
                    *pbvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockPeriod<Impl: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bvalue: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClockPeriod(::core::mem::transmute_copy(&bvalue)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetLeadPin: SetLeadPin::<Impl, IMPL_OFFSET>,
            GetLeadPin: GetLeadPin::<Impl, IMPL_OFFSET>,
            GetInputPinCount: GetInputPinCount::<Impl, IMPL_OFFSET>,
            IsUsingClock: IsUsingClock::<Impl, IMPL_OFFSET>,
            SetUsingClock: SetUsingClock::<Impl, IMPL_OFFSET>,
            GetClockPeriod: GetClockPeriod::<Impl, IMPL_OFFSET>,
            SetClockPeriod: SetClockPeriod::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBaseVideoMixer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IBasicAudio_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn SetVolume(&mut self, lvolume: i32) -> ::windows::core::Result<()>;
    fn Volume(&mut self) -> ::windows::core::Result<i32>;
    fn SetBalance(&mut self, lbalance: i32) -> ::windows::core::Result<()>;
    fn Balance(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IBasicAudio_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBasicAudio_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBasicAudio_Vtbl {
        unsafe extern "system" fn SetVolume<Impl: IBasicAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvolume: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(::core::mem::transmute_copy(&lvolume)).into()
        }
        unsafe extern "system" fn Volume<Impl: IBasicAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plvolume: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Volume() {
                ::core::result::Result::Ok(ok__) => {
                    *plvolume = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IBasicAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lbalance: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(::core::mem::transmute_copy(&lbalance)).into()
        }
        unsafe extern "system" fn Balance<Impl: IBasicAudio_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plbalance: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Balance() {
                ::core::result::Result::Ok(ok__) => {
                    *plbalance = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            Volume: Volume::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            Balance: Balance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBasicAudio as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IBasicVideo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn AvgTimePerFrame(&mut self) -> ::windows::core::Result<f64>;
    fn BitRate(&mut self) -> ::windows::core::Result<i32>;
    fn BitErrorRate(&mut self) -> ::windows::core::Result<i32>;
    fn VideoWidth(&mut self) -> ::windows::core::Result<i32>;
    fn VideoHeight(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourceLeft(&mut self, sourceleft: i32) -> ::windows::core::Result<()>;
    fn SourceLeft(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourceWidth(&mut self, sourcewidth: i32) -> ::windows::core::Result<()>;
    fn SourceWidth(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourceTop(&mut self, sourcetop: i32) -> ::windows::core::Result<()>;
    fn SourceTop(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourceHeight(&mut self, sourceheight: i32) -> ::windows::core::Result<()>;
    fn SourceHeight(&mut self) -> ::windows::core::Result<i32>;
    fn SetDestinationLeft(&mut self, destinationleft: i32) -> ::windows::core::Result<()>;
    fn DestinationLeft(&mut self) -> ::windows::core::Result<i32>;
    fn SetDestinationWidth(&mut self, destinationwidth: i32) -> ::windows::core::Result<()>;
    fn DestinationWidth(&mut self) -> ::windows::core::Result<i32>;
    fn SetDestinationTop(&mut self, destinationtop: i32) -> ::windows::core::Result<()>;
    fn DestinationTop(&mut self) -> ::windows::core::Result<i32>;
    fn SetDestinationHeight(&mut self, destinationheight: i32) -> ::windows::core::Result<()>;
    fn DestinationHeight(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourcePosition(&mut self, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::Result<()>;
    fn GetSourcePosition(&mut self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn SetDefaultSourcePosition(&mut self) -> ::windows::core::Result<()>;
    fn SetDestinationPosition(&mut self, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::Result<()>;
    fn GetDestinationPosition(&mut self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn SetDefaultDestinationPosition(&mut self) -> ::windows::core::Result<()>;
    fn GetVideoSize(&mut self, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetVideoPaletteEntries(&mut self, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> ::windows::core::Result<()>;
    fn GetCurrentImage(&mut self, pbuffersize: *mut i32, pdibimage: *mut i32) -> ::windows::core::Result<()>;
    fn IsUsingDefaultSource(&mut self) -> ::windows::core::Result<()>;
    fn IsUsingDefaultDestination(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IBasicVideo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBasicVideo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBasicVideo_Vtbl {
        unsafe extern "system" fn AvgTimePerFrame<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pavgtimeperframe: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvgTimePerFrame() {
                ::core::result::Result::Ok(ok__) => {
                    *pavgtimeperframe = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BitRate<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbitrate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BitRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pbitrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BitErrorRate<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbiterrorrate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BitErrorRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pbiterrorrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoWidth<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideowidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *pvideowidth = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoHeight<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideoheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *pvideoheight = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceLeft<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourceleft: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceLeft(::core::mem::transmute_copy(&sourceleft)).into()
        }
        unsafe extern "system" fn SourceLeft<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourceleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *psourceleft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceWidth<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcewidth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceWidth(::core::mem::transmute_copy(&sourcewidth)).into()
        }
        unsafe extern "system" fn SourceWidth<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcewidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *psourcewidth = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceTop<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourcetop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceTop(::core::mem::transmute_copy(&sourcetop)).into()
        }
        unsafe extern "system" fn SourceTop<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcetop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceTop() {
                ::core::result::Result::Ok(ok__) => {
                    *psourcetop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceHeight<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourceheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceHeight(::core::mem::transmute_copy(&sourceheight)).into()
        }
        unsafe extern "system" fn SourceHeight<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourceheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *psourceheight = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationLeft<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destinationleft: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationLeft(::core::mem::transmute_copy(&destinationleft)).into()
        }
        unsafe extern "system" fn DestinationLeft<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdestinationleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *pdestinationleft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationWidth<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destinationwidth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationWidth(::core::mem::transmute_copy(&destinationwidth)).into()
        }
        unsafe extern "system" fn DestinationWidth<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdestinationwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *pdestinationwidth = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationTop<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destinationtop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationTop(::core::mem::transmute_copy(&destinationtop)).into()
        }
        unsafe extern "system" fn DestinationTop<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdestinationtop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationTop() {
                ::core::result::Result::Ok(ok__) => {
                    *pdestinationtop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationHeight<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destinationheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationHeight(::core::mem::transmute_copy(&destinationheight)).into()
        }
        unsafe extern "system" fn DestinationHeight<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdestinationheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DestinationHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *pdestinationheight = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourcePosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourcePosition(::core::mem::transmute_copy(&left), ::core::mem::transmute_copy(&top), ::core::mem::transmute_copy(&width), ::core::mem::transmute_copy(&height)).into()
        }
        unsafe extern "system" fn GetSourcePosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSourcePosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn SetDefaultSourcePosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSourcePosition().into()
        }
        unsafe extern "system" fn SetDestinationPosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationPosition(::core::mem::transmute_copy(&left), ::core::mem::transmute_copy(&top), ::core::mem::transmute_copy(&width), ::core::mem::transmute_copy(&height)).into()
        }
        unsafe extern "system" fn GetDestinationPosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDestinationPosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn SetDefaultDestinationPosition<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultDestinationPosition().into()
        }
        unsafe extern "system" fn GetVideoSize<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn GetVideoPaletteEntries<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPaletteEntries(::core::mem::transmute_copy(&startindex), ::core::mem::transmute_copy(&entries), ::core::mem::transmute_copy(&pretrieved), ::core::mem::transmute_copy(&ppalette)).into()
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffersize: *mut i32, pdibimage: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentImage(::core::mem::transmute_copy(&pbuffersize), ::core::mem::transmute_copy(&pdibimage)).into()
        }
        unsafe extern "system" fn IsUsingDefaultSource<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsUsingDefaultSource().into()
        }
        unsafe extern "system" fn IsUsingDefaultDestination<Impl: IBasicVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsUsingDefaultDestination().into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AvgTimePerFrame: AvgTimePerFrame::<Impl, IMPL_OFFSET>,
            BitRate: BitRate::<Impl, IMPL_OFFSET>,
            BitErrorRate: BitErrorRate::<Impl, IMPL_OFFSET>,
            VideoWidth: VideoWidth::<Impl, IMPL_OFFSET>,
            VideoHeight: VideoHeight::<Impl, IMPL_OFFSET>,
            SetSourceLeft: SetSourceLeft::<Impl, IMPL_OFFSET>,
            SourceLeft: SourceLeft::<Impl, IMPL_OFFSET>,
            SetSourceWidth: SetSourceWidth::<Impl, IMPL_OFFSET>,
            SourceWidth: SourceWidth::<Impl, IMPL_OFFSET>,
            SetSourceTop: SetSourceTop::<Impl, IMPL_OFFSET>,
            SourceTop: SourceTop::<Impl, IMPL_OFFSET>,
            SetSourceHeight: SetSourceHeight::<Impl, IMPL_OFFSET>,
            SourceHeight: SourceHeight::<Impl, IMPL_OFFSET>,
            SetDestinationLeft: SetDestinationLeft::<Impl, IMPL_OFFSET>,
            DestinationLeft: DestinationLeft::<Impl, IMPL_OFFSET>,
            SetDestinationWidth: SetDestinationWidth::<Impl, IMPL_OFFSET>,
            DestinationWidth: DestinationWidth::<Impl, IMPL_OFFSET>,
            SetDestinationTop: SetDestinationTop::<Impl, IMPL_OFFSET>,
            DestinationTop: DestinationTop::<Impl, IMPL_OFFSET>,
            SetDestinationHeight: SetDestinationHeight::<Impl, IMPL_OFFSET>,
            DestinationHeight: DestinationHeight::<Impl, IMPL_OFFSET>,
            SetSourcePosition: SetSourcePosition::<Impl, IMPL_OFFSET>,
            GetSourcePosition: GetSourcePosition::<Impl, IMPL_OFFSET>,
            SetDefaultSourcePosition: SetDefaultSourcePosition::<Impl, IMPL_OFFSET>,
            SetDestinationPosition: SetDestinationPosition::<Impl, IMPL_OFFSET>,
            GetDestinationPosition: GetDestinationPosition::<Impl, IMPL_OFFSET>,
            SetDefaultDestinationPosition: SetDefaultDestinationPosition::<Impl, IMPL_OFFSET>,
            GetVideoSize: GetVideoSize::<Impl, IMPL_OFFSET>,
            GetVideoPaletteEntries: GetVideoPaletteEntries::<Impl, IMPL_OFFSET>,
            GetCurrentImage: GetCurrentImage::<Impl, IMPL_OFFSET>,
            IsUsingDefaultSource: IsUsingDefaultSource::<Impl, IMPL_OFFSET>,
            IsUsingDefaultDestination: IsUsingDefaultDestination::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBasicVideo as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IBasicVideo2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IBasicVideo_Impl {
    fn GetPreferredAspectRatio(&mut self, plaspectx: *mut i32, plaspecty: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IBasicVideo2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBasicVideo2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBasicVideo2_Vtbl {
        unsafe extern "system" fn GetPreferredAspectRatio<Impl: IBasicVideo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plaspectx: *mut i32, plaspecty: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPreferredAspectRatio(::core::mem::transmute_copy(&plaspectx), ::core::mem::transmute_copy(&plaspecty)).into()
        }
        Self { base: IBasicVideo_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetPreferredAspectRatio: GetPreferredAspectRatio::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBasicVideo2 as ::windows::core::Interface>::IID
    }
}
pub trait IBroadcastEvent_Impl: Sized {
    fn Fire(&mut self, eventid: &::windows::core::GUID) -> ::windows::core::Result<()>;
}
impl IBroadcastEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBroadcastEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBroadcastEvent_Vtbl {
        unsafe extern "system" fn Fire<Impl: IBroadcastEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eventid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Fire(::core::mem::transmute_copy(&eventid)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Fire: Fire::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBroadcastEvent as ::windows::core::Interface>::IID
    }
}
pub trait IBroadcastEventEx_Impl: Sized + IBroadcastEvent_Impl {
    fn FireEx(&mut self, eventid: &::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::Result<()>;
}
impl IBroadcastEventEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBroadcastEventEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBroadcastEventEx_Vtbl {
        unsafe extern "system" fn FireEx<Impl: IBroadcastEventEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eventid: ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FireEx(::core::mem::transmute_copy(&eventid), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2), ::core::mem::transmute_copy(&param3), ::core::mem::transmute_copy(&param4)).into()
        }
        Self { base: IBroadcastEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), FireEx: FireEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBroadcastEventEx as ::windows::core::Interface>::IID
    }
}
pub trait IBufferingTime_Impl: Sized {
    fn GetBufferingTime(&mut self, pdwmilliseconds: *mut u32) -> ::windows::core::Result<()>;
    fn SetBufferingTime(&mut self, dwmilliseconds: u32) -> ::windows::core::Result<()>;
}
impl IBufferingTime_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IBufferingTime_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IBufferingTime_Vtbl {
        unsafe extern "system" fn GetBufferingTime<Impl: IBufferingTime_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmilliseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBufferingTime(::core::mem::transmute_copy(&pdwmilliseconds)).into()
        }
        unsafe extern "system" fn SetBufferingTime<Impl: IBufferingTime_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmilliseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBufferingTime(::core::mem::transmute_copy(&dwmilliseconds)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetBufferingTime: GetBufferingTime::<Impl, IMPL_OFFSET>,
            SetBufferingTime: SetBufferingTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IBufferingTime as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ICAT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self, dwtimeout: u32) -> ::windows::core::Result<ICAT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ICAT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICAT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICAT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: ICAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICAT as ::windows::core::Interface>::IID
    }
}
pub trait ICCSubStreamFiltering_Impl: Sized {
    fn SubstreamTypes(&mut self) -> ::windows::core::Result<i32>;
    fn SetSubstreamTypes(&mut self, types: i32) -> ::windows::core::Result<()>;
}
impl ICCSubStreamFiltering_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICCSubStreamFiltering_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICCSubStreamFiltering_Vtbl {
        unsafe extern "system" fn SubstreamTypes<Impl: ICCSubStreamFiltering_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptypes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SubstreamTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *ptypes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubstreamTypes<Impl: ICCSubStreamFiltering_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, types: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSubstreamTypes(::core::mem::transmute_copy(&types)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SubstreamTypes: SubstreamTypes::<Impl, IMPL_OFFSET>,
            SetSubstreamTypes: SetSubstreamTypes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICCSubStreamFiltering as ::windows::core::Interface>::IID
    }
}
pub trait ICameraControl_Impl: Sized {
    fn Exposure(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetExposure(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Exposure(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Focus(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetFocus(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Focus(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Iris(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetIris(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Iris(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Zoom(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetZoom(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Zoom(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn FocalLengths(&mut self, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> ::windows::core::Result<()>;
    fn Pan(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPan(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Pan(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Tilt(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetTilt(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Tilt(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn PanTilt(&mut self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPanTilt(&mut self, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::Result<()>;
    fn Roll(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetRoll(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Roll(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn ExposureRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetExposureRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_ExposureRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn FocusRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetFocusRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_FocusRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn IrisRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetIrisRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_IrisRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn ZoomRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetZoomRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_ZoomRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn PanRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPanRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn TiltRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetTiltRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_TiltRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn PanTiltRelative(&mut self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPanTiltRelative(&mut self, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_PanRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn RollRelative(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetRollRelative(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_RollRelative(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn ScanMode(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetScanMode(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn PrivacyMode(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPrivacyMode(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
}
impl ICameraControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICameraControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICameraControl_Vtbl {
        unsafe extern "system" fn Exposure<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Exposure(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetExposure<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExposure(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Exposure<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Exposure(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Focus<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Focus(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetFocus<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocus(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Focus<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Focus(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Iris<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Iris(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetIris<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIris(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Iris<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Iris(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Zoom<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Zoom(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetZoom<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoom(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Zoom<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Zoom(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn FocalLengths<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FocalLengths(::core::mem::transmute_copy(&plocularfocallength), ::core::mem::transmute_copy(&plobjectivefocallengthmin), ::core::mem::transmute_copy(&plobjectivefocallengthmax)).into()
        }
        unsafe extern "system" fn Pan<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pan(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPan<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPan(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Pan<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Pan(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Tilt<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Tilt(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetTilt<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTilt(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Tilt<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Tilt(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn PanTilt<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PanTilt(::core::mem::transmute_copy(&ppanvalue), ::core::mem::transmute_copy(&ptiltvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPanTilt<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanTilt(::core::mem::transmute_copy(&panvalue), ::core::mem::transmute_copy(&tiltvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn Roll<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Roll(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetRoll<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRoll(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Roll<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Roll(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn ExposureRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExposureRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetExposureRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExposureRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_ExposureRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_ExposureRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn FocusRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FocusRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetFocusRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocusRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_FocusRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_FocusRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn IrisRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IrisRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetIrisRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIrisRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_IrisRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_IrisRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn ZoomRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ZoomRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetZoomRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZoomRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_ZoomRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_ZoomRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn PanRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PanRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPanRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn TiltRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TiltRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetTiltRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTiltRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_TiltRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_TiltRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn PanTiltRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PanTiltRelative(::core::mem::transmute_copy(&ppanvalue), ::core::mem::transmute_copy(&ptiltvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPanTiltRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPanTiltRelative(::core::mem::transmute_copy(&panvalue), ::core::mem::transmute_copy(&tiltvalue), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_PanRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_PanRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn RollRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RollRelative(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetRollRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRollRelative(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_RollRelative<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_RollRelative(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn ScanMode<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScanMode(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetScanMode<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetScanMode(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn PrivacyMode<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrivacyMode(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPrivacyMode<Impl: ICameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrivacyMode(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Exposure: Exposure::<Impl, IMPL_OFFSET>,
            SetExposure: SetExposure::<Impl, IMPL_OFFSET>,
            getRange_Exposure: getRange_Exposure::<Impl, IMPL_OFFSET>,
            Focus: Focus::<Impl, IMPL_OFFSET>,
            SetFocus: SetFocus::<Impl, IMPL_OFFSET>,
            getRange_Focus: getRange_Focus::<Impl, IMPL_OFFSET>,
            Iris: Iris::<Impl, IMPL_OFFSET>,
            SetIris: SetIris::<Impl, IMPL_OFFSET>,
            getRange_Iris: getRange_Iris::<Impl, IMPL_OFFSET>,
            Zoom: Zoom::<Impl, IMPL_OFFSET>,
            SetZoom: SetZoom::<Impl, IMPL_OFFSET>,
            getRange_Zoom: getRange_Zoom::<Impl, IMPL_OFFSET>,
            FocalLengths: FocalLengths::<Impl, IMPL_OFFSET>,
            Pan: Pan::<Impl, IMPL_OFFSET>,
            SetPan: SetPan::<Impl, IMPL_OFFSET>,
            getRange_Pan: getRange_Pan::<Impl, IMPL_OFFSET>,
            Tilt: Tilt::<Impl, IMPL_OFFSET>,
            SetTilt: SetTilt::<Impl, IMPL_OFFSET>,
            getRange_Tilt: getRange_Tilt::<Impl, IMPL_OFFSET>,
            PanTilt: PanTilt::<Impl, IMPL_OFFSET>,
            SetPanTilt: SetPanTilt::<Impl, IMPL_OFFSET>,
            Roll: Roll::<Impl, IMPL_OFFSET>,
            SetRoll: SetRoll::<Impl, IMPL_OFFSET>,
            getRange_Roll: getRange_Roll::<Impl, IMPL_OFFSET>,
            ExposureRelative: ExposureRelative::<Impl, IMPL_OFFSET>,
            SetExposureRelative: SetExposureRelative::<Impl, IMPL_OFFSET>,
            getRange_ExposureRelative: getRange_ExposureRelative::<Impl, IMPL_OFFSET>,
            FocusRelative: FocusRelative::<Impl, IMPL_OFFSET>,
            SetFocusRelative: SetFocusRelative::<Impl, IMPL_OFFSET>,
            getRange_FocusRelative: getRange_FocusRelative::<Impl, IMPL_OFFSET>,
            IrisRelative: IrisRelative::<Impl, IMPL_OFFSET>,
            SetIrisRelative: SetIrisRelative::<Impl, IMPL_OFFSET>,
            getRange_IrisRelative: getRange_IrisRelative::<Impl, IMPL_OFFSET>,
            ZoomRelative: ZoomRelative::<Impl, IMPL_OFFSET>,
            SetZoomRelative: SetZoomRelative::<Impl, IMPL_OFFSET>,
            getRange_ZoomRelative: getRange_ZoomRelative::<Impl, IMPL_OFFSET>,
            PanRelative: PanRelative::<Impl, IMPL_OFFSET>,
            SetPanRelative: SetPanRelative::<Impl, IMPL_OFFSET>,
            TiltRelative: TiltRelative::<Impl, IMPL_OFFSET>,
            SetTiltRelative: SetTiltRelative::<Impl, IMPL_OFFSET>,
            getRange_TiltRelative: getRange_TiltRelative::<Impl, IMPL_OFFSET>,
            PanTiltRelative: PanTiltRelative::<Impl, IMPL_OFFSET>,
            SetPanTiltRelative: SetPanTiltRelative::<Impl, IMPL_OFFSET>,
            getRange_PanRelative: getRange_PanRelative::<Impl, IMPL_OFFSET>,
            RollRelative: RollRelative::<Impl, IMPL_OFFSET>,
            SetRollRelative: SetRollRelative::<Impl, IMPL_OFFSET>,
            getRange_RollRelative: getRange_RollRelative::<Impl, IMPL_OFFSET>,
            ScanMode: ScanMode::<Impl, IMPL_OFFSET>,
            SetScanMode: SetScanMode::<Impl, IMPL_OFFSET>,
            PrivacyMode: PrivacyMode::<Impl, IMPL_OFFSET>,
            SetPrivacyMode: SetPrivacyMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICameraControl as ::windows::core::Interface>::IID
    }
}
pub trait ICaptionServiceDescriptor_Impl: Sized {
    fn GetNumberOfServices(&mut self) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, bindex: u8, langcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetCaptionServiceNumber(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetCCType(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetEasyReader(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetWideAspectRatio(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
}
impl ICaptionServiceDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptionServiceDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptionServiceDescriptor_Vtbl {
        unsafe extern "system" fn GetNumberOfServices<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfServices() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, langcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&bindex), ::core::mem::transmute_copy(&langcode)).into()
        }
        unsafe extern "system" fn GetCaptionServiceNumber<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaptionServiceNumber(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCCType<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCCType(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEasyReader<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEasyReader(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWideAspectRatio<Impl: ICaptionServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetWideAspectRatio(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNumberOfServices: GetNumberOfServices::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetCaptionServiceNumber: GetCaptionServiceNumber::<Impl, IMPL_OFFSET>,
            GetCCType: GetCCType::<Impl, IMPL_OFFSET>,
            GetEasyReader: GetEasyReader::<Impl, IMPL_OFFSET>,
            GetWideAspectRatio: GetWideAspectRatio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptionServiceDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait ICaptureGraphBuilder_Impl: Sized {
    fn SetFiltergraph(&mut self, pfg: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
    fn GetFiltergraph(&mut self) -> ::windows::core::Result<IGraphBuilder>;
    fn SetOutputFileName(&mut self, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::core::option::Option<IBaseFilter>, ppsink: *mut ::core::option::Option<IFileSinkFilter>) -> ::windows::core::Result<()>;
    fn FindInterface(&mut self, pcategory: *const ::windows::core::GUID, pf: &::core::option::Option<IBaseFilter>, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn RenderStream(&mut self, pcategory: *const ::windows::core::GUID, psource: &::core::option::Option<::windows::core::IUnknown>, pfcompressor: &::core::option::Option<IBaseFilter>, pfrenderer: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn ControlStream(&mut self, pcategory: *const ::windows::core::GUID, pfilter: &::core::option::Option<IBaseFilter>, pstart: *mut i64, pstop: *mut i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::Result<()>;
    fn AllocCapFile(&mut self, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::Result<()>;
    fn CopyCaptureFile(&mut self, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: &::core::option::Option<IAMCopyCaptureFileProgress>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl ICaptureGraphBuilder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureGraphBuilder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureGraphBuilder_Vtbl {
        unsafe extern "system" fn SetFiltergraph<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfg: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFiltergraph(::core::mem::transmute(&pfg)).into()
        }
        unsafe extern "system" fn GetFiltergraph<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppfg: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph() {
                ::core::result::Result::Ok(ok__) => {
                    *ppfg = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFileName<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::windows::core::RawPtr, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFileName(::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&lpstrfile), ::core::mem::transmute_copy(&ppf), ::core::mem::transmute_copy(&ppsink)).into()
        }
        unsafe extern "system" fn FindInterface<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, pf: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FindInterface(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute(&pf), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppint)).into()
        }
        unsafe extern "system" fn RenderStream<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, psource: *mut ::core::ffi::c_void, pfcompressor: ::windows::core::RawPtr, pfrenderer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenderStream(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute(&psource), ::core::mem::transmute(&pfcompressor), ::core::mem::transmute(&pfrenderer)).into()
        }
        unsafe extern "system" fn ControlStream<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, pfilter: ::windows::core::RawPtr, pstart: *mut i64, pstop: *mut i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ControlStream(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&pstart), ::core::mem::transmute_copy(&pstop), ::core::mem::transmute_copy(&wstartcookie), ::core::mem::transmute_copy(&wstopcookie)).into()
        }
        unsafe extern "system" fn AllocCapFile<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AllocCapFile(::core::mem::transmute_copy(&lpstr), ::core::mem::transmute_copy(&dwlsize)).into()
        }
        unsafe extern "system" fn CopyCaptureFile<Impl: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopyCaptureFile(::core::mem::transmute_copy(&lpwstrold), ::core::mem::transmute_copy(&lpwstrnew), ::core::mem::transmute_copy(&fallowescabort), ::core::mem::transmute(&pcallback)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFiltergraph: SetFiltergraph::<Impl, IMPL_OFFSET>,
            GetFiltergraph: GetFiltergraph::<Impl, IMPL_OFFSET>,
            SetOutputFileName: SetOutputFileName::<Impl, IMPL_OFFSET>,
            FindInterface: FindInterface::<Impl, IMPL_OFFSET>,
            RenderStream: RenderStream::<Impl, IMPL_OFFSET>,
            ControlStream: ControlStream::<Impl, IMPL_OFFSET>,
            AllocCapFile: AllocCapFile::<Impl, IMPL_OFFSET>,
            CopyCaptureFile: CopyCaptureFile::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureGraphBuilder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait ICaptureGraphBuilder2_Impl: Sized {
    fn SetFiltergraph(&mut self, pfg: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
    fn GetFiltergraph(&mut self) -> ::windows::core::Result<IGraphBuilder>;
    fn SetOutputFileName(&mut self, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::core::option::Option<IBaseFilter>, ppsink: *mut ::core::option::Option<IFileSinkFilter>) -> ::windows::core::Result<()>;
    fn FindInterface(&mut self, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pf: &::core::option::Option<IBaseFilter>, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn RenderStream(&mut self, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, psource: &::core::option::Option<::windows::core::IUnknown>, pfcompressor: &::core::option::Option<IBaseFilter>, pfrenderer: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn ControlStream(&mut self, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pfilter: &::core::option::Option<IBaseFilter>, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::Result<()>;
    fn AllocCapFile(&mut self, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::Result<()>;
    fn CopyCaptureFile(&mut self, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: &::core::option::Option<IAMCopyCaptureFileProgress>) -> ::windows::core::Result<()>;
    fn FindPin(&mut self, psource: &::core::option::Option<::windows::core::IUnknown>, pindir: PIN_DIRECTION, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, funconnected: super::super::Foundation::BOOL, num: i32) -> ::windows::core::Result<IPin>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl ICaptureGraphBuilder2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICaptureGraphBuilder2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICaptureGraphBuilder2_Vtbl {
        unsafe extern "system" fn SetFiltergraph<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfg: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFiltergraph(::core::mem::transmute(&pfg)).into()
        }
        unsafe extern "system" fn GetFiltergraph<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppfg: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph() {
                ::core::result::Result::Ok(ok__) => {
                    *ppfg = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFileName<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *const ::windows::core::GUID, lpstrfile: super::super::Foundation::PWSTR, ppf: *mut ::windows::core::RawPtr, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFileName(::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&lpstrfile), ::core::mem::transmute_copy(&ppf), ::core::mem::transmute_copy(&ppsink)).into()
        }
        unsafe extern "system" fn FindInterface<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pf: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FindInterface(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute(&pf), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppint)).into()
        }
        unsafe extern "system" fn RenderStream<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, psource: *mut ::core::ffi::c_void, pfcompressor: ::windows::core::RawPtr, pfrenderer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenderStream(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute(&psource), ::core::mem::transmute(&pfcompressor), ::core::mem::transmute(&pfrenderer)).into()
        }
        unsafe extern "system" fn ControlStream<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, pfilter: ::windows::core::RawPtr, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ControlStream(::core::mem::transmute_copy(&pcategory), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&pstart), ::core::mem::transmute_copy(&pstop), ::core::mem::transmute_copy(&wstartcookie), ::core::mem::transmute_copy(&wstopcookie)).into()
        }
        unsafe extern "system" fn AllocCapFile<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpstr: super::super::Foundation::PWSTR, dwlsize: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AllocCapFile(::core::mem::transmute_copy(&lpstr), ::core::mem::transmute_copy(&dwlsize)).into()
        }
        unsafe extern "system" fn CopyCaptureFile<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwstrold: super::super::Foundation::PWSTR, lpwstrnew: super::super::Foundation::PWSTR, fallowescabort: i32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopyCaptureFile(::core::mem::transmute_copy(&lpwstrold), ::core::mem::transmute_copy(&lpwstrnew), ::core::mem::transmute_copy(&fallowescabort), ::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn FindPin<Impl: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psource: *mut ::core::ffi::c_void, pindir: PIN_DIRECTION, pcategory: *const ::windows::core::GUID, ptype: *const ::windows::core::GUID, funconnected: super::super::Foundation::BOOL, num: i32, pppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindPin(::core::mem::transmute(&psource), ::core::mem::transmute_copy(&pindir), ::core::mem::transmute_copy(&pcategory), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&funconnected), ::core::mem::transmute_copy(&num)) {
                ::core::result::Result::Ok(ok__) => {
                    *pppin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFiltergraph: SetFiltergraph::<Impl, IMPL_OFFSET>,
            GetFiltergraph: GetFiltergraph::<Impl, IMPL_OFFSET>,
            SetOutputFileName: SetOutputFileName::<Impl, IMPL_OFFSET>,
            FindInterface: FindInterface::<Impl, IMPL_OFFSET>,
            RenderStream: RenderStream::<Impl, IMPL_OFFSET>,
            ControlStream: ControlStream::<Impl, IMPL_OFFSET>,
            AllocCapFile: AllocCapFile::<Impl, IMPL_OFFSET>,
            CopyCaptureFile: CopyCaptureFile::<Impl, IMPL_OFFSET>,
            FindPin: FindPin::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICaptureGraphBuilder2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IChannelIDTuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl {
    fn ChannelID(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetChannelID(&mut self, channelid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IChannelIDTuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChannelIDTuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChannelIDTuneRequest_Vtbl {
        unsafe extern "system" fn ChannelID<Impl: IChannelIDTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channelid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChannelID() {
                ::core::result::Result::Ok(ok__) => {
                    *channelid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannelID<Impl: IChannelIDTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channelid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChannelID(::core::mem::transmute_copy(&channelid)).into()
        }
        Self {
            base: ITuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ChannelID: ChannelID::<Impl, IMPL_OFFSET>,
            SetChannelID: SetChannelID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChannelIDTuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IChannelTuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl {
    fn Channel(&mut self) -> ::windows::core::Result<i32>;
    fn SetChannel(&mut self, channel: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IChannelTuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IChannelTuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IChannelTuneRequest_Vtbl {
        unsafe extern "system" fn Channel<Impl: IChannelTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Channel() {
                ::core::result::Result::Ok(ok__) => {
                    *channel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannel<Impl: IChannelTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChannel(::core::mem::transmute_copy(&channel)).into()
        }
        Self {
            base: ITuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Channel: Channel::<Impl, IMPL_OFFSET>,
            SetChannel: SetChannel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IChannelTuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IComponent_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Type(&mut self) -> ::windows::core::Result<IComponentType>;
    fn SetType(&mut self, ct: &::core::option::Option<IComponentType>) -> ::windows::core::Result<()>;
    fn DescLangID(&mut self) -> ::windows::core::Result<i32>;
    fn SetDescLangID(&mut self, langid: i32) -> ::windows::core::Result<()>;
    fn Status(&mut self) -> ::windows::core::Result<ComponentStatus>;
    fn SetStatus(&mut self, status: ComponentStatus) -> ::windows::core::Result<()>;
    fn Description(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetDescription(&mut self, description: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IComponent>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IComponent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComponent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComponent_Vtbl {
        unsafe extern "system" fn Type<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Type() {
                ::core::result::Result::Ok(ok__) => {
                    *ct = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ct: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetType(::core::mem::transmute(&ct)).into()
        }
        unsafe extern "system" fn DescLangID<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, langid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DescLangID() {
                ::core::result::Result::Ok(ok__) => {
                    *langid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescLangID<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, langid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescLangID(::core::mem::transmute_copy(&langid)).into()
        }
        unsafe extern "system" fn Status<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, status: *mut ComponentStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Status() {
                ::core::result::Result::Ok(ok__) => {
                    *status = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStatus<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, status: ComponentStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStatus(::core::mem::transmute_copy(&status)).into()
        }
        unsafe extern "system" fn Description<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, description: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *description = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, description: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(::core::mem::transmute_copy(&description)).into()
        }
        unsafe extern "system" fn Clone<Impl: IComponent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newcomponent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Type: Type::<Impl, IMPL_OFFSET>,
            SetType: SetType::<Impl, IMPL_OFFSET>,
            DescLangID: DescLangID::<Impl, IMPL_OFFSET>,
            SetDescLangID: SetDescLangID::<Impl, IMPL_OFFSET>,
            Status: Status::<Impl, IMPL_OFFSET>,
            SetStatus: SetStatus::<Impl, IMPL_OFFSET>,
            Description: Description::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComponent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IComponentType_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Category(&mut self) -> ::windows::core::Result<ComponentCategory>;
    fn SetCategory(&mut self, category: ComponentCategory) -> ::windows::core::Result<()>;
    fn MediaMajorType(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetMediaMajorType(&mut self, mediamajortype: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn _MediaMajorType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Set_MediaMajorType(&mut self, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn MediaSubType(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetMediaSubType(&mut self, mediasubtype: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn _MediaSubType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Set_MediaSubType(&mut self, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn MediaFormatType(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetMediaFormatType(&mut self, mediaformattype: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn _MediaFormatType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Set_MediaFormatType(&mut self, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn MediaType(&mut self) -> ::windows::core::Result<AM_MEDIA_TYPE>;
    fn SetMediaType(&mut self, mediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IComponentType>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IComponentType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComponentType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComponentType_Vtbl {
        unsafe extern "system" fn Category<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, category: *mut ComponentCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Category() {
                ::core::result::Result::Ok(ok__) => {
                    *category = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCategory<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, category: ComponentCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCategory(::core::mem::transmute_copy(&category)).into()
        }
        unsafe extern "system" fn MediaMajorType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediamajortype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaMajorType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediamajortype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaMajorType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediamajortype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaMajorType(::core::mem::transmute_copy(&mediamajortype)).into()
        }
        unsafe extern "system" fn _MediaMajorType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediamajortypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._MediaMajorType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediamajortypeguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaMajorType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_MediaMajorType(::core::mem::transmute_copy(&mediamajortypeguid)).into()
        }
        unsafe extern "system" fn MediaSubType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediasubtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaSubType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediasubtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaSubType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediasubtype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaSubType(::core::mem::transmute_copy(&mediasubtype)).into()
        }
        unsafe extern "system" fn _MediaSubType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediasubtypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._MediaSubType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediasubtypeguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaSubType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_MediaSubType(::core::mem::transmute_copy(&mediasubtypeguid)).into()
        }
        unsafe extern "system" fn MediaFormatType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaformattype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaFormatType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediaformattype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaFormatType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaformattype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaFormatType(::core::mem::transmute_copy(&mediaformattype)).into()
        }
        unsafe extern "system" fn _MediaFormatType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaformattypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._MediaFormatType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediaformattypeguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_MediaFormatType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_MediaFormatType(::core::mem::transmute_copy(&mediaformattypeguid)).into()
        }
        unsafe extern "system" fn MediaType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediatype: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *mediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute_copy(&mediatype)).into()
        }
        unsafe extern "system" fn Clone<Impl: IComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newct: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newct = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Category: Category::<Impl, IMPL_OFFSET>,
            SetCategory: SetCategory::<Impl, IMPL_OFFSET>,
            MediaMajorType: MediaMajorType::<Impl, IMPL_OFFSET>,
            SetMediaMajorType: SetMediaMajorType::<Impl, IMPL_OFFSET>,
            _MediaMajorType: _MediaMajorType::<Impl, IMPL_OFFSET>,
            Set_MediaMajorType: Set_MediaMajorType::<Impl, IMPL_OFFSET>,
            MediaSubType: MediaSubType::<Impl, IMPL_OFFSET>,
            SetMediaSubType: SetMediaSubType::<Impl, IMPL_OFFSET>,
            _MediaSubType: _MediaSubType::<Impl, IMPL_OFFSET>,
            Set_MediaSubType: Set_MediaSubType::<Impl, IMPL_OFFSET>,
            MediaFormatType: MediaFormatType::<Impl, IMPL_OFFSET>,
            SetMediaFormatType: SetMediaFormatType::<Impl, IMPL_OFFSET>,
            _MediaFormatType: _MediaFormatType::<Impl, IMPL_OFFSET>,
            Set_MediaFormatType: Set_MediaFormatType::<Impl, IMPL_OFFSET>,
            MediaType: MediaType::<Impl, IMPL_OFFSET>,
            SetMediaType: SetMediaType::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComponentType as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IComponentTypes_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn EnumComponentTypes(&mut self) -> ::windows::core::Result<IEnumComponentTypes>;
    fn Item(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IComponentType>;
    fn SetItem(&mut self, index: &super::super::System::Com::VARIANT, componenttype: &::core::option::Option<IComponentType>) -> ::windows::core::Result<()>;
    fn Add(&mut self, componenttype: &::core::option::Option<IComponentType>) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn Remove(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IComponentTypes>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IComponentTypes_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComponentTypes_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComponentTypes_Vtbl {
        unsafe extern "system" fn Count<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *count = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponentTypes<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumComponentTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, componenttype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *componenttype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, componenttype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(::core::mem::transmute_copy(&index), ::core::mem::transmute(&componenttype)).into()
        }
        unsafe extern "system" fn Add<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, componenttype: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Add(::core::mem::transmute(&componenttype)) {
                ::core::result::Result::Ok(ok__) => {
                    *newindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&index)).into()
        }
        unsafe extern "system" fn Clone<Impl: IComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            EnumComponentTypes: EnumComponentTypes::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComponentTypes as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IComponents_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn EnumComponents(&mut self) -> ::windows::core::Result<IEnumComponents>;
    fn Item(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IComponent>;
    fn Add(&mut self, component: &::core::option::Option<IComponent>) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn Remove(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IComponents>;
    fn SetItem(&mut self, index: &super::super::System::Com::VARIANT, ppcomponent: &::core::option::Option<IComponent>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IComponents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComponents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComponents_Vtbl {
        unsafe extern "system" fn Count<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *count = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponents<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumComponents() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcomponent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, component: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Add(::core::mem::transmute(&component)) {
                ::core::result::Result::Ok(ok__) => {
                    *newindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&index)).into()
        }
        unsafe extern "system" fn Clone<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(::core::mem::transmute_copy(&index), ::core::mem::transmute(&ppcomponent)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            EnumComponents: EnumComponents::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComponents as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IComponentsOld_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn EnumComponents(&mut self) -> ::windows::core::Result<IEnumComponents>;
    fn Item(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IComponent>;
    fn Add(&mut self, component: &::core::option::Option<IComponent>) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn Remove(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IComponents>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IComponentsOld_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IComponentsOld_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IComponentsOld_Vtbl {
        unsafe extern "system" fn Count<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *count = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumComponents<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumComponents() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppcomponent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcomponent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, component: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Add(::core::mem::transmute(&component)) {
                ::core::result::Result::Ok(ok__) => {
                    *newindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&index)).into()
        }
        unsafe extern "system" fn Clone<Impl: IComponentsOld_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            EnumComponents: EnumComponents::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IComponentsOld as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_WindowsMediaFormat"))]
pub trait IConfigAsfWriter_Impl: Sized {
    fn ConfigureFilterUsingProfileId(&mut self, dwprofileid: u32) -> ::windows::core::Result<()>;
    fn GetCurrentProfileId(&mut self) -> ::windows::core::Result<u32>;
    fn ConfigureFilterUsingProfileGuid(&mut self, guidprofile: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetCurrentProfileGuid(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn ConfigureFilterUsingProfile(&mut self, pprofile: &::core::option::Option<super::WindowsMediaFormat::IWMProfile>) -> ::windows::core::Result<()>;
    fn GetCurrentProfile(&mut self) -> ::windows::core::Result<super::WindowsMediaFormat::IWMProfile>;
    fn SetIndexMode(&mut self, bindexfile: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetIndexMode(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl IConfigAsfWriter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IConfigAsfWriter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IConfigAsfWriter_Vtbl {
        unsafe extern "system" fn ConfigureFilterUsingProfileId<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwprofileid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConfigureFilterUsingProfileId(::core::mem::transmute_copy(&dwprofileid)).into()
        }
        unsafe extern "system" fn GetCurrentProfileId<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwprofileid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfileId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwprofileid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfileGuid<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidprofile: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConfigureFilterUsingProfileGuid(::core::mem::transmute_copy(&guidprofile)).into()
        }
        unsafe extern "system" fn GetCurrentProfileGuid<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprofileguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfileGuid() {
                ::core::result::Result::Ok(ok__) => {
                    *pprofileguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfile<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConfigureFilterUsingProfile(::core::mem::transmute(&pprofile)).into()
        }
        unsafe extern "system" fn GetCurrentProfile<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentProfile() {
                ::core::result::Result::Ok(ok__) => {
                    *ppprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexMode<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindexfile: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIndexMode(::core::mem::transmute_copy(&bindexfile)).into()
        }
        unsafe extern "system" fn GetIndexMode<Impl: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbindexfile: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIndexMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbindexfile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ConfigureFilterUsingProfileId: ConfigureFilterUsingProfileId::<Impl, IMPL_OFFSET>,
            GetCurrentProfileId: GetCurrentProfileId::<Impl, IMPL_OFFSET>,
            ConfigureFilterUsingProfileGuid: ConfigureFilterUsingProfileGuid::<Impl, IMPL_OFFSET>,
            GetCurrentProfileGuid: GetCurrentProfileGuid::<Impl, IMPL_OFFSET>,
            ConfigureFilterUsingProfile: ConfigureFilterUsingProfile::<Impl, IMPL_OFFSET>,
            GetCurrentProfile: GetCurrentProfile::<Impl, IMPL_OFFSET>,
            SetIndexMode: SetIndexMode::<Impl, IMPL_OFFSET>,
            GetIndexMode: GetIndexMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IConfigAsfWriter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_WindowsMediaFormat"))]
pub trait IConfigAsfWriter2_Impl: Sized + IConfigAsfWriter_Impl {
    fn StreamNumFromPin(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<u16>;
    fn SetParam(&mut self, dwparam: u32, dwparam1: u32, dwparam2: u32) -> ::windows::core::Result<()>;
    fn GetParam(&mut self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::Result<()>;
    fn ResetMultiPassState(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl IConfigAsfWriter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IConfigAsfWriter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IConfigAsfWriter2_Vtbl {
        unsafe extern "system" fn StreamNumFromPin<Impl: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pwstreamnum: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StreamNumFromPin(::core::mem::transmute(&ppin)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwstreamnum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParam<Impl: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparam: u32, dwparam1: u32, dwparam2: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetParam(::core::mem::transmute_copy(&dwparam), ::core::mem::transmute_copy(&dwparam1), ::core::mem::transmute_copy(&dwparam2)).into()
        }
        unsafe extern "system" fn GetParam<Impl: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParam(::core::mem::transmute_copy(&dwparam), ::core::mem::transmute_copy(&pdwparam1), ::core::mem::transmute_copy(&pdwparam2)).into()
        }
        unsafe extern "system" fn ResetMultiPassState<Impl: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetMultiPassState().into()
        }
        Self {
            base: IConfigAsfWriter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            StreamNumFromPin: StreamNumFromPin::<Impl, IMPL_OFFSET>,
            SetParam: SetParam::<Impl, IMPL_OFFSET>,
            GetParam: GetParam::<Impl, IMPL_OFFSET>,
            ResetMultiPassState: ResetMultiPassState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IConfigAsfWriter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IConfigAviMux_Impl: Sized {
    fn SetMasterStream(&mut self, istream: i32) -> ::windows::core::Result<()>;
    fn GetMasterStream(&mut self) -> ::windows::core::Result<i32>;
    fn SetOutputCompatibilityIndex(&mut self, foldindex: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetOutputCompatibilityIndex(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IConfigAviMux_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IConfigAviMux_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IConfigAviMux_Vtbl {
        unsafe extern "system" fn SetMasterStream<Impl: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, istream: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMasterStream(::core::mem::transmute_copy(&istream)).into()
        }
        unsafe extern "system" fn GetMasterStream<Impl: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstream: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMasterStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputCompatibilityIndex<Impl: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, foldindex: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputCompatibilityIndex(::core::mem::transmute_copy(&foldindex)).into()
        }
        unsafe extern "system" fn GetOutputCompatibilityIndex<Impl: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfoldindex: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputCompatibilityIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *pfoldindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMasterStream: SetMasterStream::<Impl, IMPL_OFFSET>,
            GetMasterStream: GetMasterStream::<Impl, IMPL_OFFSET>,
            SetOutputCompatibilityIndex: SetOutputCompatibilityIndex::<Impl, IMPL_OFFSET>,
            GetOutputCompatibilityIndex: GetOutputCompatibilityIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IConfigAviMux as ::windows::core::Interface>::IID
    }
}
pub trait IConfigInterleaving_Impl: Sized {
    fn SetMode(&mut self, mode: InterleavingMode) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<InterleavingMode>;
    fn SetInterleaving(&mut self, prtinterleave: *const i64, prtpreroll: *const i64) -> ::windows::core::Result<()>;
    fn Interleaving(&mut self, prtinterleave: *mut i64, prtpreroll: *mut i64) -> ::windows::core::Result<()>;
}
impl IConfigInterleaving_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IConfigInterleaving_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IConfigInterleaving_Vtbl {
        unsafe extern "system" fn SetMode<Impl: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: InterleavingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn Mode<Impl: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut InterleavingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *pmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInterleaving<Impl: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtinterleave: *const i64, prtpreroll: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInterleaving(::core::mem::transmute_copy(&prtinterleave), ::core::mem::transmute_copy(&prtpreroll)).into()
        }
        unsafe extern "system" fn Interleaving<Impl: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtinterleave: *mut i64, prtpreroll: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Interleaving(::core::mem::transmute_copy(&prtinterleave), ::core::mem::transmute_copy(&prtpreroll)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            SetInterleaving: SetInterleaving::<Impl, IMPL_OFFSET>,
            Interleaving: Interleaving::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IConfigInterleaving as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ICreateDevEnum_Impl: Sized {
    fn CreateClassEnumerator(&mut self, clsiddeviceclass: *const ::windows::core::GUID, ppenummoniker: *mut ::core::option::Option<super::super::System::Com::IEnumMoniker>, dwflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl ICreateDevEnum_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICreateDevEnum_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICreateDevEnum_Vtbl {
        unsafe extern "system" fn CreateClassEnumerator<Impl: ICreateDevEnum_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsiddeviceclass: *const ::windows::core::GUID, ppenummoniker: *mut ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateClassEnumerator(::core::mem::transmute_copy(&clsiddeviceclass), ::core::mem::transmute_copy(&ppenummoniker), ::core::mem::transmute_copy(&dwflags)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateClassEnumerator: CreateClassEnumerator::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICreateDevEnum as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Registry"))]
pub trait ICreatePropBagOnRegKey_Impl: Sized {
    fn Create(&mut self, hkey: super::super::System::Registry::HKEY, subkey: super::super::Foundation::PWSTR, uloptions: u32, samdesired: u32, iid: *const ::windows::core::GUID, ppbag: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Registry"))]
impl ICreatePropBagOnRegKey_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICreatePropBagOnRegKey_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICreatePropBagOnRegKey_Vtbl {
        unsafe extern "system" fn Create<Impl: ICreatePropBagOnRegKey_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hkey: super::super::System::Registry::HKEY, subkey: super::super::Foundation::PWSTR, uloptions: u32, samdesired: u32, iid: *const ::windows::core::GUID, ppbag: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Create(::core::mem::transmute_copy(&hkey), ::core::mem::transmute_copy(&subkey), ::core::mem::transmute_copy(&uloptions), ::core::mem::transmute_copy(&samdesired), ::core::mem::transmute_copy(&iid), ::core::mem::transmute_copy(&ppbag)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Create: Create::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICreatePropBagOnRegKey as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IDDrawExclModeVideo_Impl: Sized {
    fn SetDDrawObject(&mut self, pddrawobject: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw>) -> ::windows::core::Result<()>;
    fn GetDDrawObject(&mut self, ppddrawobject: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw>, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetDDrawSurface(&mut self, pddrawsurface: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>) -> ::windows::core::Result<()>;
    fn GetDDrawSurface(&mut self, ppddrawsurface: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetDrawParameters(&mut self, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetNativeVideoProps(&mut self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::Result<()>;
    fn SetCallbackInterface(&mut self, pcallback: &::core::option::Option<IDDrawExclModeVideoCallback>, dwflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IDDrawExclModeVideo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDDrawExclModeVideo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDDrawExclModeVideo_Vtbl {
        unsafe extern "system" fn SetDDrawObject<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pddrawobject: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDDrawObject(::core::mem::transmute(&pddrawobject)).into()
        }
        unsafe extern "system" fn GetDDrawObject<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppddrawobject: *mut ::windows::core::RawPtr, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDDrawObject(::core::mem::transmute_copy(&ppddrawobject), ::core::mem::transmute_copy(&pbusingexternal)).into()
        }
        unsafe extern "system" fn SetDDrawSurface<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pddrawsurface: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDDrawSurface(::core::mem::transmute(&pddrawsurface)).into()
        }
        unsafe extern "system" fn GetDDrawSurface<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppddrawsurface: *mut ::windows::core::RawPtr, pbusingexternal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDDrawSurface(::core::mem::transmute_copy(&ppddrawsurface), ::core::mem::transmute_copy(&pbusingexternal)).into()
        }
        unsafe extern "system" fn SetDrawParameters<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDrawParameters(::core::mem::transmute_copy(&prcsource), ::core::mem::transmute_copy(&prctarget)).into()
        }
        unsafe extern "system" fn GetNativeVideoProps<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoProps(::core::mem::transmute_copy(&pdwvideowidth), ::core::mem::transmute_copy(&pdwvideoheight), ::core::mem::transmute_copy(&pdwpictaspectratiox), ::core::mem::transmute_copy(&pdwpictaspectratioy)).into()
        }
        unsafe extern "system" fn SetCallbackInterface<Impl: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCallbackInterface(::core::mem::transmute(&pcallback), ::core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDDrawObject: SetDDrawObject::<Impl, IMPL_OFFSET>,
            GetDDrawObject: GetDDrawObject::<Impl, IMPL_OFFSET>,
            SetDDrawSurface: SetDDrawSurface::<Impl, IMPL_OFFSET>,
            GetDDrawSurface: GetDDrawSurface::<Impl, IMPL_OFFSET>,
            SetDrawParameters: SetDrawParameters::<Impl, IMPL_OFFSET>,
            GetNativeVideoProps: GetNativeVideoProps::<Impl, IMPL_OFFSET>,
            SetCallbackInterface: SetCallbackInterface::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDDrawExclModeVideo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDDrawExclModeVideoCallback_Impl: Sized {
    fn OnUpdateOverlay(&mut self, bbefore: super::super::Foundation::BOOL, dwflags: u32, boldvisible: super::super::Foundation::BOOL, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: super::super::Foundation::BOOL, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn OnUpdateColorKey(&mut self, pkey: *const COLORKEY, dwcolor: u32) -> ::windows::core::Result<()>;
    fn OnUpdateSize(&mut self, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDDrawExclModeVideoCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDDrawExclModeVideoCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDDrawExclModeVideoCallback_Vtbl {
        unsafe extern "system" fn OnUpdateOverlay<Impl: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bbefore: super::super::Foundation::BOOL, dwflags: u32, boldvisible: super::super::Foundation::BOOL, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: super::super::Foundation::BOOL, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdateOverlay(::core::mem::transmute_copy(&bbefore), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&boldvisible), ::core::mem::transmute_copy(&prcoldsrc), ::core::mem::transmute_copy(&prcolddest), ::core::mem::transmute_copy(&bnewvisible), ::core::mem::transmute_copy(&prcnewsrc), ::core::mem::transmute_copy(&prcnewdest)).into()
        }
        unsafe extern "system" fn OnUpdateColorKey<Impl: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkey: *const COLORKEY, dwcolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdateColorKey(::core::mem::transmute_copy(&pkey), ::core::mem::transmute_copy(&dwcolor)).into()
        }
        unsafe extern "system" fn OnUpdateSize<Impl: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdateSize(::core::mem::transmute_copy(&dwwidth), ::core::mem::transmute_copy(&dwheight), ::core::mem::transmute_copy(&dwarwidth), ::core::mem::transmute_copy(&dwarheight)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnUpdateOverlay: OnUpdateOverlay::<Impl, IMPL_OFFSET>,
            OnUpdateColorKey: OnUpdateColorKey::<Impl, IMPL_OFFSET>,
            OnUpdateSize: OnUpdateSize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDDrawExclModeVideoCallback as ::windows::core::Interface>::IID
    }
}
pub trait IDMOWrapperFilter_Impl: Sized {
    fn Init(&mut self, clsiddmo: *const ::windows::core::GUID, catdmo: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
}
impl IDMOWrapperFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDMOWrapperFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDMOWrapperFilter_Vtbl {
        unsafe extern "system" fn Init<Impl: IDMOWrapperFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsiddmo: *const ::windows::core::GUID, catdmo: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Init(::core::mem::transmute_copy(&clsiddmo), ::core::mem::transmute_copy(&catdmo)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Init: Init::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDMOWrapperFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDShowPlugin_Impl: Sized {
    fn URL(&mut self, purl: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn UserAgent(&mut self, puseragent: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDShowPlugin_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDShowPlugin_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDShowPlugin_Vtbl {
        unsafe extern "system" fn URL<Impl: IDShowPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, purl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).URL(::core::mem::transmute_copy(&purl)).into()
        }
        unsafe extern "system" fn UserAgent<Impl: IDShowPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puseragent: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UserAgent(::core::mem::transmute_copy(&puseragent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), URL: URL::<Impl, IMPL_OFFSET>, UserAgent: UserAgent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDShowPlugin as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDTFilter_Impl: Sized {
    fn EvalRatObjOK(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
    fn GetCurrRating(&mut self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::Result<()>;
    fn BlockedRatingAttributes(&mut self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel) -> ::windows::core::Result<i32>;
    fn SetBlockedRatingAttributes(&mut self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::Result<()>;
    fn BlockUnRated(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetBlockUnRated(&mut self, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn BlockUnRatedDelay(&mut self) -> ::windows::core::Result<i32>;
    fn SetBlockUnRatedDelay(&mut self, msecsdelaybeforeblock: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDTFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilter_Vtbl {
        unsafe extern "system" fn EvalRatObjOK<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EvalRatObjOK() {
                ::core::result::Result::Ok(ok__) => {
                    *phrcocreateretval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrRating<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrRating(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&plbfenattr)).into()
        }
        unsafe extern "system" fn BlockedRatingAttributes<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlockedRatingAttributes(::core::mem::transmute_copy(&ensystem), ::core::mem::transmute_copy(&enlevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *plbfenattr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockedRatingAttributes<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockedRatingAttributes(::core::mem::transmute_copy(&ensystem), ::core::mem::transmute_copy(&enlevel), ::core::mem::transmute_copy(&lbfattrs)).into()
        }
        unsafe extern "system" fn BlockUnRated<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfblockunratedshows: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlockUnRated() {
                ::core::result::Result::Ok(ok__) => {
                    *pfblockunratedshows = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRated<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockUnRated(::core::mem::transmute_copy(&fblockunratedshows)).into()
        }
        unsafe extern "system" fn BlockUnRatedDelay<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmsecsdelaybeforeblock: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlockUnRatedDelay() {
                ::core::result::Result::Ok(ok__) => {
                    *pmsecsdelaybeforeblock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRatedDelay<Impl: IDTFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, msecsdelaybeforeblock: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockUnRatedDelay(::core::mem::transmute_copy(&msecsdelaybeforeblock)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            EvalRatObjOK: EvalRatObjOK::<Impl, IMPL_OFFSET>,
            GetCurrRating: GetCurrRating::<Impl, IMPL_OFFSET>,
            BlockedRatingAttributes: BlockedRatingAttributes::<Impl, IMPL_OFFSET>,
            SetBlockedRatingAttributes: SetBlockedRatingAttributes::<Impl, IMPL_OFFSET>,
            BlockUnRated: BlockUnRated::<Impl, IMPL_OFFSET>,
            SetBlockUnRated: SetBlockUnRated::<Impl, IMPL_OFFSET>,
            BlockUnRatedDelay: BlockUnRatedDelay::<Impl, IMPL_OFFSET>,
            SetBlockUnRatedDelay: SetBlockUnRatedDelay::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDTFilter2_Impl: Sized + IDTFilter_Impl {
    fn ChallengeUrl(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetCurrLicenseExpDate(&mut self, prottype: *const ProtType) -> ::windows::core::Result<i32>;
    fn GetLastErrorCode(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDTFilter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilter2_Vtbl {
        unsafe extern "system" fn ChallengeUrl<Impl: IDTFilter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrchallengeurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChallengeUrl() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrchallengeurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IDTFilter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(::core::mem::transmute_copy(&prottype)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdatetime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IDTFilter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLastErrorCode().into()
        }
        Self {
            base: IDTFilter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ChallengeUrl: ChallengeUrl::<Impl, IMPL_OFFSET>,
            GetCurrLicenseExpDate: GetCurrLicenseExpDate::<Impl, IMPL_OFFSET>,
            GetLastErrorCode: GetLastErrorCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDTFilter3_Impl: Sized + IDTFilter_Impl + IDTFilter2_Impl {
    fn GetProtectionType(&mut self) -> ::windows::core::Result<ProtType>;
    fn LicenseHasExpirationDate(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetRights(&mut self, bstrrights: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDTFilter3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilter3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilter3_Vtbl {
        unsafe extern "system" fn GetProtectionType<Impl: IDTFilter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprotectiontype: *mut ProtType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtectionType() {
                ::core::result::Result::Ok(ok__) => {
                    *pprotectiontype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LicenseHasExpirationDate<Impl: IDTFilter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflicensehasexpirationdate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LicenseHasExpirationDate() {
                ::core::result::Result::Ok(ok__) => {
                    *pflicensehasexpirationdate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRights<Impl: IDTFilter3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrrights: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRights(::core::mem::transmute_copy(&bstrrights)).into()
        }
        Self {
            base: IDTFilter2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetProtectionType: GetProtectionType::<Impl, IMPL_OFFSET>,
            LicenseHasExpirationDate: LicenseHasExpirationDate::<Impl, IMPL_OFFSET>,
            SetRights: SetRights::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilter3 as ::windows::core::Interface>::IID
    }
}
pub trait IDTFilterConfig_Impl: Sized {
    fn GetSecureChannelObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IDTFilterConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilterConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilterConfig_Vtbl {
        unsafe extern "system" fn GetSecureChannelObject<Impl: IDTFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkdrmsecurechannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetSecureChannelObject: GetSecureChannelObject::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilterConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDTFilterEvents_Impl: Sized + super::super::System::Com::IDispatch_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDTFilterEvents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilterEvents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilterEvents_Vtbl {
        Self { base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilterEvents as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDTFilterLicenseRenewal_Impl: Sized {
    fn GetLicenseRenewalData(&mut self, ppwszfilename: *mut super::super::Foundation::PWSTR, ppwszexpiredkid: *mut super::super::Foundation::PWSTR, ppwsztunerid: *mut super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDTFilterLicenseRenewal_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDTFilterLicenseRenewal_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDTFilterLicenseRenewal_Vtbl {
        unsafe extern "system" fn GetLicenseRenewalData<Impl: IDTFilterLicenseRenewal_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppwszfilename: *mut super::super::Foundation::PWSTR, ppwszexpiredkid: *mut super::super::Foundation::PWSTR, ppwsztunerid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLicenseRenewalData(::core::mem::transmute_copy(&ppwszfilename), ::core::mem::transmute_copy(&ppwszexpiredkid), ::core::mem::transmute_copy(&ppwsztunerid)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetLicenseRenewalData: GetLicenseRenewalData::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDTFilterLicenseRenewal as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBCLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBCLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBCLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBCLocator_Vtbl {
        Self { base: IDigitalLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBCLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBSLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl {
    fn SignalPolarisation(&mut self) -> ::windows::core::Result<Polarisation>;
    fn SetSignalPolarisation(&mut self, polarisationval: Polarisation) -> ::windows::core::Result<()>;
    fn WestPosition(&mut self) -> ::windows::core::Result<i16>;
    fn SetWestPosition(&mut self, westlongitude: i16) -> ::windows::core::Result<()>;
    fn OrbitalPosition(&mut self) -> ::windows::core::Result<i32>;
    fn SetOrbitalPosition(&mut self, longitude: i32) -> ::windows::core::Result<()>;
    fn Azimuth(&mut self) -> ::windows::core::Result<i32>;
    fn SetAzimuth(&mut self, azimuth: i32) -> ::windows::core::Result<()>;
    fn Elevation(&mut self) -> ::windows::core::Result<i32>;
    fn SetElevation(&mut self, elevation: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBSLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBSLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBSLocator_Vtbl {
        unsafe extern "system" fn SignalPolarisation<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, polarisationval: *mut Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SignalPolarisation() {
                ::core::result::Result::Ok(ok__) => {
                    *polarisationval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalPolarisation<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, polarisationval: Polarisation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalPolarisation(::core::mem::transmute_copy(&polarisationval)).into()
        }
        unsafe extern "system" fn WestPosition<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, westlongitude: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WestPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *westlongitude = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWestPosition<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, westlongitude: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWestPosition(::core::mem::transmute_copy(&westlongitude)).into()
        }
        unsafe extern "system" fn OrbitalPosition<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, longitude: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OrbitalPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *longitude = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrbitalPosition<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, longitude: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOrbitalPosition(::core::mem::transmute_copy(&longitude)).into()
        }
        unsafe extern "system" fn Azimuth<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, azimuth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Azimuth() {
                ::core::result::Result::Ok(ok__) => {
                    *azimuth = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAzimuth<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, azimuth: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAzimuth(::core::mem::transmute_copy(&azimuth)).into()
        }
        unsafe extern "system" fn Elevation<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, elevation: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Elevation() {
                ::core::result::Result::Ok(ok__) => {
                    *elevation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetElevation<Impl: IDVBSLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, elevation: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetElevation(::core::mem::transmute_copy(&elevation)).into()
        }
        Self {
            base: IDigitalLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SignalPolarisation: SignalPolarisation::<Impl, IMPL_OFFSET>,
            SetSignalPolarisation: SetSignalPolarisation::<Impl, IMPL_OFFSET>,
            WestPosition: WestPosition::<Impl, IMPL_OFFSET>,
            SetWestPosition: SetWestPosition::<Impl, IMPL_OFFSET>,
            OrbitalPosition: OrbitalPosition::<Impl, IMPL_OFFSET>,
            SetOrbitalPosition: SetOrbitalPosition::<Impl, IMPL_OFFSET>,
            Azimuth: Azimuth::<Impl, IMPL_OFFSET>,
            SetAzimuth: SetAzimuth::<Impl, IMPL_OFFSET>,
            Elevation: Elevation::<Impl, IMPL_OFFSET>,
            SetElevation: SetElevation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBSLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBSLocator2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl + IDVBSLocator_Impl {
    fn DiseqLNBSource(&mut self) -> ::windows::core::Result<LNB_Source>;
    fn SetDiseqLNBSource(&mut self, diseqlnbsourceval: LNB_Source) -> ::windows::core::Result<()>;
    fn LocalOscillatorOverrideLow(&mut self) -> ::windows::core::Result<i32>;
    fn SetLocalOscillatorOverrideLow(&mut self, localoscillatoroverridelowval: i32) -> ::windows::core::Result<()>;
    fn LocalOscillatorOverrideHigh(&mut self) -> ::windows::core::Result<i32>;
    fn SetLocalOscillatorOverrideHigh(&mut self, localoscillatoroverridehighval: i32) -> ::windows::core::Result<()>;
    fn LocalLNBSwitchOverride(&mut self) -> ::windows::core::Result<i32>;
    fn SetLocalLNBSwitchOverride(&mut self, locallnbswitchoverrideval: i32) -> ::windows::core::Result<()>;
    fn LocalSpectralInversionOverride(&mut self) -> ::windows::core::Result<SpectralInversion>;
    fn SetLocalSpectralInversionOverride(&mut self, localspectralinversionoverrideval: SpectralInversion) -> ::windows::core::Result<()>;
    fn SignalRollOff(&mut self) -> ::windows::core::Result<RollOff>;
    fn SetSignalRollOff(&mut self, rolloffval: RollOff) -> ::windows::core::Result<()>;
    fn SignalPilot(&mut self) -> ::windows::core::Result<Pilot>;
    fn SetSignalPilot(&mut self, pilotval: Pilot) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBSLocator2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBSLocator2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBSLocator2_Vtbl {
        unsafe extern "system" fn DiseqLNBSource<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, diseqlnbsourceval: *mut LNB_Source) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DiseqLNBSource() {
                ::core::result::Result::Ok(ok__) => {
                    *diseqlnbsourceval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDiseqLNBSource<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, diseqlnbsourceval: LNB_Source) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiseqLNBSource(::core::mem::transmute_copy(&diseqlnbsourceval)).into()
        }
        unsafe extern "system" fn LocalOscillatorOverrideLow<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localoscillatoroverridelowval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LocalOscillatorOverrideLow() {
                ::core::result::Result::Ok(ok__) => {
                    *localoscillatoroverridelowval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalOscillatorOverrideLow<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localoscillatoroverridelowval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalOscillatorOverrideLow(::core::mem::transmute_copy(&localoscillatoroverridelowval)).into()
        }
        unsafe extern "system" fn LocalOscillatorOverrideHigh<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localoscillatoroverridehighval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LocalOscillatorOverrideHigh() {
                ::core::result::Result::Ok(ok__) => {
                    *localoscillatoroverridehighval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalOscillatorOverrideHigh<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localoscillatoroverridehighval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalOscillatorOverrideHigh(::core::mem::transmute_copy(&localoscillatoroverridehighval)).into()
        }
        unsafe extern "system" fn LocalLNBSwitchOverride<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locallnbswitchoverrideval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LocalLNBSwitchOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *locallnbswitchoverrideval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalLNBSwitchOverride<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locallnbswitchoverrideval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalLNBSwitchOverride(::core::mem::transmute_copy(&locallnbswitchoverrideval)).into()
        }
        unsafe extern "system" fn LocalSpectralInversionOverride<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localspectralinversionoverrideval: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LocalSpectralInversionOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *localspectralinversionoverrideval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocalSpectralInversionOverride<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, localspectralinversionoverrideval: SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocalSpectralInversionOverride(::core::mem::transmute_copy(&localspectralinversionoverrideval)).into()
        }
        unsafe extern "system" fn SignalRollOff<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rolloffval: *mut RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SignalRollOff() {
                ::core::result::Result::Ok(ok__) => {
                    *rolloffval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalRollOff<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rolloffval: RollOff) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalRollOff(::core::mem::transmute_copy(&rolloffval)).into()
        }
        unsafe extern "system" fn SignalPilot<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pilotval: *mut Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SignalPilot() {
                ::core::result::Result::Ok(ok__) => {
                    *pilotval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSignalPilot<Impl: IDVBSLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pilotval: Pilot) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSignalPilot(::core::mem::transmute_copy(&pilotval)).into()
        }
        Self {
            base: IDVBSLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            DiseqLNBSource: DiseqLNBSource::<Impl, IMPL_OFFSET>,
            SetDiseqLNBSource: SetDiseqLNBSource::<Impl, IMPL_OFFSET>,
            LocalOscillatorOverrideLow: LocalOscillatorOverrideLow::<Impl, IMPL_OFFSET>,
            SetLocalOscillatorOverrideLow: SetLocalOscillatorOverrideLow::<Impl, IMPL_OFFSET>,
            LocalOscillatorOverrideHigh: LocalOscillatorOverrideHigh::<Impl, IMPL_OFFSET>,
            SetLocalOscillatorOverrideHigh: SetLocalOscillatorOverrideHigh::<Impl, IMPL_OFFSET>,
            LocalLNBSwitchOverride: LocalLNBSwitchOverride::<Impl, IMPL_OFFSET>,
            SetLocalLNBSwitchOverride: SetLocalLNBSwitchOverride::<Impl, IMPL_OFFSET>,
            LocalSpectralInversionOverride: LocalSpectralInversionOverride::<Impl, IMPL_OFFSET>,
            SetLocalSpectralInversionOverride: SetLocalSpectralInversionOverride::<Impl, IMPL_OFFSET>,
            SignalRollOff: SignalRollOff::<Impl, IMPL_OFFSET>,
            SetSignalRollOff: SetSignalRollOff::<Impl, IMPL_OFFSET>,
            SignalPilot: SignalPilot::<Impl, IMPL_OFFSET>,
            SetSignalPilot: SetSignalPilot::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBSLocator2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBSTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IDVBTuningSpace_Impl + IDVBTuningSpace2_Impl {
    fn LowOscillator(&mut self) -> ::windows::core::Result<i32>;
    fn SetLowOscillator(&mut self, lowoscillator: i32) -> ::windows::core::Result<()>;
    fn HighOscillator(&mut self) -> ::windows::core::Result<i32>;
    fn SetHighOscillator(&mut self, highoscillator: i32) -> ::windows::core::Result<()>;
    fn LNBSwitch(&mut self) -> ::windows::core::Result<i32>;
    fn SetLNBSwitch(&mut self, lnbswitch: i32) -> ::windows::core::Result<()>;
    fn InputRange(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetInputRange(&mut self, inputrange: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SpectralInversion(&mut self) -> ::windows::core::Result<SpectralInversion>;
    fn SetSpectralInversion(&mut self, spectralinversionval: SpectralInversion) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBSTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBSTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBSTuningSpace_Vtbl {
        unsafe extern "system" fn LowOscillator<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lowoscillator: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LowOscillator() {
                ::core::result::Result::Ok(ok__) => {
                    *lowoscillator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLowOscillator<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lowoscillator: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLowOscillator(::core::mem::transmute_copy(&lowoscillator)).into()
        }
        unsafe extern "system" fn HighOscillator<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, highoscillator: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HighOscillator() {
                ::core::result::Result::Ok(ok__) => {
                    *highoscillator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHighOscillator<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, highoscillator: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHighOscillator(::core::mem::transmute_copy(&highoscillator)).into()
        }
        unsafe extern "system" fn LNBSwitch<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lnbswitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LNBSwitch() {
                ::core::result::Result::Ok(ok__) => {
                    *lnbswitch = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLNBSwitch<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lnbswitch: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLNBSwitch(::core::mem::transmute_copy(&lnbswitch)).into()
        }
        unsafe extern "system" fn InputRange<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputrange: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputRange() {
                ::core::result::Result::Ok(ok__) => {
                    *inputrange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputRange<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputrange: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputRange(::core::mem::transmute_copy(&inputrange)).into()
        }
        unsafe extern "system" fn SpectralInversion<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, spectralinversionval: *mut SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SpectralInversion() {
                ::core::result::Result::Ok(ok__) => {
                    *spectralinversionval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpectralInversion<Impl: IDVBSTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, spectralinversionval: SpectralInversion) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSpectralInversion(::core::mem::transmute_copy(&spectralinversionval)).into()
        }
        Self {
            base: IDVBTuningSpace2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            LowOscillator: LowOscillator::<Impl, IMPL_OFFSET>,
            SetLowOscillator: SetLowOscillator::<Impl, IMPL_OFFSET>,
            HighOscillator: HighOscillator::<Impl, IMPL_OFFSET>,
            SetHighOscillator: SetHighOscillator::<Impl, IMPL_OFFSET>,
            LNBSwitch: LNBSwitch::<Impl, IMPL_OFFSET>,
            SetLNBSwitch: SetLNBSwitch::<Impl, IMPL_OFFSET>,
            InputRange: InputRange::<Impl, IMPL_OFFSET>,
            SetInputRange: SetInputRange::<Impl, IMPL_OFFSET>,
            SpectralInversion: SpectralInversion::<Impl, IMPL_OFFSET>,
            SetSpectralInversion: SetSpectralInversion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBSTuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBTLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl {
    fn Bandwidth(&mut self) -> ::windows::core::Result<i32>;
    fn SetBandwidth(&mut self, bandwidthval: i32) -> ::windows::core::Result<()>;
    fn LPInnerFEC(&mut self) -> ::windows::core::Result<FECMethod>;
    fn SetLPInnerFEC(&mut self, fec: FECMethod) -> ::windows::core::Result<()>;
    fn LPInnerFECRate(&mut self) -> ::windows::core::Result<BinaryConvolutionCodeRate>;
    fn SetLPInnerFECRate(&mut self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn HAlpha(&mut self) -> ::windows::core::Result<HierarchyAlpha>;
    fn SetHAlpha(&mut self, alpha: HierarchyAlpha) -> ::windows::core::Result<()>;
    fn Guard(&mut self) -> ::windows::core::Result<GuardInterval>;
    fn SetGuard(&mut self, gi: GuardInterval) -> ::windows::core::Result<()>;
    fn Mode(&mut self) -> ::windows::core::Result<TransmissionMode>;
    fn SetMode(&mut self, mode: TransmissionMode) -> ::windows::core::Result<()>;
    fn OtherFrequencyInUse(&mut self) -> ::windows::core::Result<i16>;
    fn SetOtherFrequencyInUse(&mut self, otherfrequencyinuseval: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBTLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBTLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBTLocator_Vtbl {
        unsafe extern "system" fn Bandwidth<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bandwidthval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bandwidth() {
                ::core::result::Result::Ok(ok__) => {
                    *bandwidthval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBandwidth<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bandwidthval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBandwidth(::core::mem::transmute_copy(&bandwidthval)).into()
        }
        unsafe extern "system" fn LPInnerFEC<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LPInnerFEC() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLPInnerFEC<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLPInnerFEC(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn LPInnerFECRate<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LPInnerFECRate() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLPInnerFECRate<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLPInnerFECRate(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn HAlpha<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, alpha: *mut HierarchyAlpha) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HAlpha() {
                ::core::result::Result::Ok(ok__) => {
                    *alpha = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHAlpha<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, alpha: HierarchyAlpha) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHAlpha(::core::mem::transmute_copy(&alpha)).into()
        }
        unsafe extern "system" fn Guard<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, gi: *mut GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Guard() {
                ::core::result::Result::Ok(ok__) => {
                    *gi = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGuard<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, gi: GuardInterval) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGuard(::core::mem::transmute_copy(&gi)).into()
        }
        unsafe extern "system" fn Mode<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: *mut TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *mode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: TransmissionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn OtherFrequencyInUse<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, otherfrequencyinuseval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OtherFrequencyInUse() {
                ::core::result::Result::Ok(ok__) => {
                    *otherfrequencyinuseval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOtherFrequencyInUse<Impl: IDVBTLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, otherfrequencyinuseval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOtherFrequencyInUse(::core::mem::transmute_copy(&otherfrequencyinuseval)).into()
        }
        Self {
            base: IDigitalLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Bandwidth: Bandwidth::<Impl, IMPL_OFFSET>,
            SetBandwidth: SetBandwidth::<Impl, IMPL_OFFSET>,
            LPInnerFEC: LPInnerFEC::<Impl, IMPL_OFFSET>,
            SetLPInnerFEC: SetLPInnerFEC::<Impl, IMPL_OFFSET>,
            LPInnerFECRate: LPInnerFECRate::<Impl, IMPL_OFFSET>,
            SetLPInnerFECRate: SetLPInnerFECRate::<Impl, IMPL_OFFSET>,
            HAlpha: HAlpha::<Impl, IMPL_OFFSET>,
            SetHAlpha: SetHAlpha::<Impl, IMPL_OFFSET>,
            Guard: Guard::<Impl, IMPL_OFFSET>,
            SetGuard: SetGuard::<Impl, IMPL_OFFSET>,
            Mode: Mode::<Impl, IMPL_OFFSET>,
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            OtherFrequencyInUse: OtherFrequencyInUse::<Impl, IMPL_OFFSET>,
            SetOtherFrequencyInUse: SetOtherFrequencyInUse::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBTLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBTLocator2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl + IDVBTLocator_Impl {
    fn PhysicalLayerPipeId(&mut self) -> ::windows::core::Result<i32>;
    fn SetPhysicalLayerPipeId(&mut self, physicallayerpipeidval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBTLocator2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBTLocator2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBTLocator2_Vtbl {
        unsafe extern "system" fn PhysicalLayerPipeId<Impl: IDVBTLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, physicallayerpipeidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PhysicalLayerPipeId() {
                ::core::result::Result::Ok(ok__) => {
                    *physicallayerpipeidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPhysicalLayerPipeId<Impl: IDVBTLocator2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, physicallayerpipeidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPhysicalLayerPipeId(::core::mem::transmute_copy(&physicallayerpipeidval)).into()
        }
        Self {
            base: IDVBTLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            PhysicalLayerPipeId: PhysicalLayerPipeId::<Impl, IMPL_OFFSET>,
            SetPhysicalLayerPipeId: SetPhysicalLayerPipeId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBTLocator2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBTuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl {
    fn ONID(&mut self) -> ::windows::core::Result<i32>;
    fn SetONID(&mut self, onid: i32) -> ::windows::core::Result<()>;
    fn TSID(&mut self) -> ::windows::core::Result<i32>;
    fn SetTSID(&mut self, tsid: i32) -> ::windows::core::Result<()>;
    fn SID(&mut self) -> ::windows::core::Result<i32>;
    fn SetSID(&mut self, sid: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBTuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBTuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBTuneRequest_Vtbl {
        unsafe extern "system" fn ONID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, onid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ONID() {
                ::core::result::Result::Ok(ok__) => {
                    *onid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetONID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, onid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetONID(::core::mem::transmute_copy(&onid)).into()
        }
        unsafe extern "system" fn TSID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TSID() {
                ::core::result::Result::Ok(ok__) => {
                    *tsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTSID(::core::mem::transmute_copy(&tsid)).into()
        }
        unsafe extern "system" fn SID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SID() {
                ::core::result::Result::Ok(ok__) => {
                    *sid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSID<Impl: IDVBTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSID(::core::mem::transmute_copy(&sid)).into()
        }
        Self {
            base: ITuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ONID: ONID::<Impl, IMPL_OFFSET>,
            SetONID: SetONID::<Impl, IMPL_OFFSET>,
            TSID: TSID::<Impl, IMPL_OFFSET>,
            SetTSID: SetTSID::<Impl, IMPL_OFFSET>,
            SID: SID::<Impl, IMPL_OFFSET>,
            SetSID: SetSID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBTuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl {
    fn SystemType(&mut self) -> ::windows::core::Result<DVBSystemType>;
    fn SetSystemType(&mut self, systype: DVBSystemType) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBTuningSpace_Vtbl {
        unsafe extern "system" fn SystemType<Impl: IDVBTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, systype: *mut DVBSystemType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SystemType() {
                ::core::result::Result::Ok(ok__) => {
                    *systype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSystemType<Impl: IDVBTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, systype: DVBSystemType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSystemType(::core::mem::transmute_copy(&systype)).into()
        }
        Self {
            base: ITuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SystemType: SystemType::<Impl, IMPL_OFFSET>,
            SetSystemType: SetSystemType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBTuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDVBTuningSpace2_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IDVBTuningSpace_Impl {
    fn NetworkID(&mut self) -> ::windows::core::Result<i32>;
    fn SetNetworkID(&mut self, networkid: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDVBTuningSpace2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVBTuningSpace2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVBTuningSpace2_Vtbl {
        unsafe extern "system" fn NetworkID<Impl: IDVBTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networkid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NetworkID() {
                ::core::result::Result::Ok(ok__) => {
                    *networkid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNetworkID<Impl: IDVBTuningSpace2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networkid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNetworkID(::core::mem::transmute_copy(&networkid)).into()
        }
        Self {
            base: IDVBTuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            NetworkID: NetworkID::<Impl, IMPL_OFFSET>,
            SetNetworkID: SetNetworkID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVBTuningSpace2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_BAT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetBouquetId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32, ppdescriptor: *const ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordTransportStreamId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordOriginalNetworkId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IDVB_BAT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_BAT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_BAT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_BAT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBouquetId<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBouquetId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_BAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetBouquetId: GetBouquetId::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordTransportStreamId: GetRecordTransportStreamId::<Impl, IMPL_OFFSET>,
            GetRecordOriginalNetworkId: GetRecordOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_BAT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_DIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>) -> ::windows::core::Result<()>;
    fn GetTransitionFlag(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_DIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_DIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_DIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_DIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist)).into()
        }
        unsafe extern "system" fn GetTransitionFlag<Impl: IDVB_DIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransitionFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetTransitionFlag: GetTransitionFlag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_DIT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_EIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetServiceId(&mut self) -> ::windows::core::Result<u16>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetSegmentLastSectionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetLastTableId(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordEventId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordStartTime(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetRecordDuration(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_TIME>;
    fn GetRecordRunningStatus(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordFreeCAMode(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IDVB_EIT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_EIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_EIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_EIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSegmentLastSectionNumber<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSegmentLastSectionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastTableId<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLastTableId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFreeCAMode<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordFreeCAMode(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *ppeit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetServiceId: GetServiceId::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetSegmentLastSectionNumber: GetSegmentLastSectionNumber::<Impl, IMPL_OFFSET>,
            GetLastTableId: GetLastTableId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordEventId: GetRecordEventId::<Impl, IMPL_OFFSET>,
            GetRecordStartTime: GetRecordStartTime::<Impl, IMPL_OFFSET>,
            GetRecordDuration: GetRecordDuration::<Impl, IMPL_OFFSET>,
            GetRecordRunningStatus: GetRecordRunningStatus::<Impl, IMPL_OFFSET>,
            GetRecordFreeCAMode: GetRecordFreeCAMode::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_EIT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_EIT2_Impl: Sized + IDVB_EIT_Impl {
    fn GetSegmentInfo(&mut self, pbtid: *mut u8, pbsegment: *mut u8) -> ::windows::core::Result<()>;
    fn GetRecordSection(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_EIT2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_EIT2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_EIT2_Vtbl {
        unsafe extern "system" fn GetSegmentInfo<Impl: IDVB_EIT2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbtid: *mut u8, pbsegment: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSegmentInfo(::core::mem::transmute_copy(&pbtid), ::core::mem::transmute_copy(&pbsegment)).into()
        }
        unsafe extern "system" fn GetRecordSection<Impl: IDVB_EIT2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordSection(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDVB_EIT_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSegmentInfo: GetSegmentInfo::<Impl, IMPL_OFFSET>,
            GetRecordSection: GetRecordSection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_EIT2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_NIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordTransportStreamId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordOriginalNetworkId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IDVB_NIT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_NIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_NIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_NIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkId<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppnit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *ppnit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_NIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetNetworkId: GetNetworkId::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordTransportStreamId: GetRecordTransportStreamId::<Impl, IMPL_OFFSET>,
            GetRecordOriginalNetworkId: GetRecordOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_NIT as ::windows::core::Interface>::IID
    }
}
pub trait IDVB_RST_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordTransportStreamId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordOriginalNetworkId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordServiceId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordEventId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordRunningStatus(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
}
impl IDVB_RST_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_RST_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_RST_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransportStreamId<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTransportStreamId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordOriginalNetworkId<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordOriginalNetworkId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_RST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordTransportStreamId: GetRecordTransportStreamId::<Impl, IMPL_OFFSET>,
            GetRecordOriginalNetworkId: GetRecordOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordEventId: GetRecordEventId::<Impl, IMPL_OFFSET>,
            GetRecordRunningStatus: GetRecordRunningStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_RST as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_SDT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordServiceId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordEITScheduleFlag(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordEITPresentFollowingFlag(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordRunningStatus(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordFreeCAMode(&mut self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IDVB_SDT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_SDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_SDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_SDT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEITScheduleFlag<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEITScheduleFlag(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEITPresentFollowingFlag<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEITPresentFollowingFlag(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFreeCAMode<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordFreeCAMode(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IDVB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordEITScheduleFlag: GetRecordEITScheduleFlag::<Impl, IMPL_OFFSET>,
            GetRecordEITPresentFollowingFlag: GetRecordEITPresentFollowingFlag::<Impl, IMPL_OFFSET>,
            GetRecordRunningStatus: GetRecordRunningStatus::<Impl, IMPL_OFFSET>,
            GetRecordFreeCAMode: GetRecordFreeCAMode::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_SDT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVB_SIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordServiceId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordRunningStatus(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self, dwtimeout: u32) -> ::windows::core::Result<IDVB_SIT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVB_SIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_SIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_SIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRunningStatus<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordRunningStatus(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IDVB_SIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordRunningStatus: GetRecordRunningStatus::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_SIT as ::windows::core::Interface>::IID
    }
}
pub trait IDVB_ST_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>) -> ::windows::core::Result<()>;
    fn GetDataLength(&mut self) -> ::windows::core::Result<u16>;
    fn GetData(&mut self) -> ::windows::core::Result<*mut u8>;
}
impl IDVB_ST_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_ST_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_ST_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_ST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist)).into()
        }
        unsafe extern "system" fn GetDataLength<Impl: IDVB_ST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetData<Impl: IDVB_ST_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetData() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetDataLength: GetDataLength::<Impl, IMPL_OFFSET>,
            GetData: GetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_ST as ::windows::core::Interface>::IID
    }
}
pub trait IDVB_TDT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>) -> ::windows::core::Result<()>;
    fn GetUTCTime(&mut self) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
}
impl IDVB_TDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_TDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_TDT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_TDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist)).into()
        }
        unsafe extern "system" fn GetUTCTime<Impl: IDVB_TDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUTCTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetUTCTime: GetUTCTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_TDT as ::windows::core::Interface>::IID
    }
}
pub trait IDVB_TOT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>) -> ::windows::core::Result<()>;
    fn GetUTCTime(&mut self) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
impl IDVB_TOT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVB_TOT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVB_TOT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDVB_TOT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist)).into()
        }
        unsafe extern "system" fn GetUTCTime<Impl: IDVB_TOT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUTCTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IDVB_TOT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IDVB_TOT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IDVB_TOT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetUTCTime: GetUTCTime::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVB_TOT as ::windows::core::Interface>::IID
    }
}
pub trait IDVEnc_Impl: Sized {
    fn IFormatResolution(&mut self, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> ::windows::core::Result<()>;
    fn SetIFormatResolution(&mut self, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> ::windows::core::Result<()>;
}
impl IDVEnc_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVEnc_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVEnc_Vtbl {
        unsafe extern "system" fn IFormatResolution<Impl: IDVEnc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IFormatResolution(::core::mem::transmute_copy(&videoformat), ::core::mem::transmute_copy(&dvformat), ::core::mem::transmute_copy(&resolution), ::core::mem::transmute_copy(&fdvinfo), ::core::mem::transmute_copy(&sdvinfo)).into()
        }
        unsafe extern "system" fn SetIFormatResolution<Impl: IDVEnc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIFormatResolution(::core::mem::transmute_copy(&videoformat), ::core::mem::transmute_copy(&dvformat), ::core::mem::transmute_copy(&resolution), ::core::mem::transmute_copy(&fdvinfo), ::core::mem::transmute_copy(&sdvinfo)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IFormatResolution: IFormatResolution::<Impl, IMPL_OFFSET>,
            SetIFormatResolution: SetIFormatResolution::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVEnc as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDVRGB219_Impl: Sized {
    fn SetRGB219(&mut self, bstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDVRGB219_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVRGB219_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVRGB219_Vtbl {
        unsafe extern "system" fn SetRGB219<Impl: IDVRGB219_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRGB219(::core::mem::transmute_copy(&bstate)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetRGB219: SetRGB219::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVRGB219 as ::windows::core::Interface>::IID
    }
}
pub trait IDVSplitter_Impl: Sized {
    fn DiscardAlternateVideoFrames(&mut self, ndiscard: i32) -> ::windows::core::Result<()>;
}
impl IDVSplitter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDVSplitter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDVSplitter_Vtbl {
        unsafe extern "system" fn DiscardAlternateVideoFrames<Impl: IDVSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ndiscard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DiscardAlternateVideoFrames(::core::mem::transmute_copy(&ndiscard)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            DiscardAlternateVideoFrames: DiscardAlternateVideoFrames::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDVSplitter as ::windows::core::Interface>::IID
    }
}
pub trait IDecimateVideoImage_Impl: Sized {
    fn SetDecimationImageSize(&mut self, lwidth: i32, lheight: i32) -> ::windows::core::Result<()>;
    fn ResetDecimationImageSize(&mut self) -> ::windows::core::Result<()>;
}
impl IDecimateVideoImage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDecimateVideoImage_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDecimateVideoImage_Vtbl {
        unsafe extern "system" fn SetDecimationImageSize<Impl: IDecimateVideoImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lwidth: i32, lheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDecimationImageSize(::core::mem::transmute_copy(&lwidth), ::core::mem::transmute_copy(&lheight)).into()
        }
        unsafe extern "system" fn ResetDecimationImageSize<Impl: IDecimateVideoImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetDecimationImageSize().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDecimationImageSize: SetDecimationImageSize::<Impl, IMPL_OFFSET>,
            ResetDecimationImageSize: ResetDecimationImageSize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDecimateVideoImage as ::windows::core::Interface>::IID
    }
}
pub trait IDeferredCommand_Impl: Sized {
    fn Cancel(&mut self) -> ::windows::core::Result<()>;
    fn Confidence(&mut self) -> ::windows::core::Result<i32>;
    fn Postpone(&mut self, newtime: f64) -> ::windows::core::Result<()>;
    fn GetHResult(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
}
impl IDeferredCommand_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDeferredCommand_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDeferredCommand_Vtbl {
        unsafe extern "system" fn Cancel<Impl: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Cancel().into()
        }
        unsafe extern "system" fn Confidence<Impl: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pconfidence: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Confidence() {
                ::core::result::Result::Ok(ok__) => {
                    *pconfidence = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Postpone<Impl: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Postpone(::core::mem::transmute_copy(&newtime)).into()
        }
        unsafe extern "system" fn GetHResult<Impl: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phrresult: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHResult() {
                ::core::result::Result::Ok(ok__) => {
                    *phrresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
            Confidence: Confidence::<Impl, IMPL_OFFSET>,
            Postpone: Postpone::<Impl, IMPL_OFFSET>,
            GetHResult: GetHResult::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDeferredCommand as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDigitalCableLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl + IATSCLocator_Impl + IATSCLocator2_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDigitalCableLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDigitalCableLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDigitalCableLocator_Vtbl {
        Self { base: IATSCLocator2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDigitalCableLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDigitalCableTuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl + IChannelTuneRequest_Impl + IATSCChannelTuneRequest_Impl {
    fn MajorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMajorChannel(&mut self, majorchannel: i32) -> ::windows::core::Result<()>;
    fn SourceID(&mut self) -> ::windows::core::Result<i32>;
    fn SetSourceID(&mut self, sourceid: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDigitalCableTuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDigitalCableTuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDigitalCableTuneRequest_Vtbl {
        unsafe extern "system" fn MajorChannel<Impl: IDigitalCableTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmajorchannel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MajorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *pmajorchannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMajorChannel<Impl: IDigitalCableTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, majorchannel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMajorChannel(::core::mem::transmute_copy(&majorchannel)).into()
        }
        unsafe extern "system" fn SourceID<Impl: IDigitalCableTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourceid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceID() {
                ::core::result::Result::Ok(ok__) => {
                    *psourceid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceID<Impl: IDigitalCableTuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sourceid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceID(::core::mem::transmute_copy(&sourceid)).into()
        }
        Self {
            base: IATSCChannelTuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MajorChannel: MajorChannel::<Impl, IMPL_OFFSET>,
            SetMajorChannel: SetMajorChannel::<Impl, IMPL_OFFSET>,
            SourceID: SourceID::<Impl, IMPL_OFFSET>,
            SetSourceID: SetSourceID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDigitalCableTuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDigitalCableTuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuningSpace_Impl + IAnalogTVTuningSpace_Impl + IATSCTuningSpace_Impl {
    fn MinMajorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinMajorChannel(&mut self, newminmajorchannelval: i32) -> ::windows::core::Result<()>;
    fn MaxMajorChannel(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxMajorChannel(&mut self, newmaxmajorchannelval: i32) -> ::windows::core::Result<()>;
    fn MinSourceID(&mut self) -> ::windows::core::Result<i32>;
    fn SetMinSourceID(&mut self, newminsourceidval: i32) -> ::windows::core::Result<()>;
    fn MaxSourceID(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxSourceID(&mut self, newmaxsourceidval: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDigitalCableTuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDigitalCableTuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDigitalCableTuningSpace_Vtbl {
        unsafe extern "system" fn MinMajorChannel<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minmajorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinMajorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *minmajorchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinMajorChannel<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminmajorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinMajorChannel(::core::mem::transmute_copy(&newminmajorchannelval)).into()
        }
        unsafe extern "system" fn MaxMajorChannel<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxmajorchannelval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxMajorChannel() {
                ::core::result::Result::Ok(ok__) => {
                    *maxmajorchannelval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxMajorChannel<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxmajorchannelval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxMajorChannel(::core::mem::transmute_copy(&newmaxmajorchannelval)).into()
        }
        unsafe extern "system" fn MinSourceID<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, minsourceidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinSourceID() {
                ::core::result::Result::Ok(ok__) => {
                    *minsourceidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinSourceID<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newminsourceidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMinSourceID(::core::mem::transmute_copy(&newminsourceidval)).into()
        }
        unsafe extern "system" fn MaxSourceID<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxsourceidval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxSourceID() {
                ::core::result::Result::Ok(ok__) => {
                    *maxsourceidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSourceID<Impl: IDigitalCableTuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newmaxsourceidval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxSourceID(::core::mem::transmute_copy(&newmaxsourceidval)).into()
        }
        Self {
            base: IATSCTuningSpace_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            MinMajorChannel: MinMajorChannel::<Impl, IMPL_OFFSET>,
            SetMinMajorChannel: SetMinMajorChannel::<Impl, IMPL_OFFSET>,
            MaxMajorChannel: MaxMajorChannel::<Impl, IMPL_OFFSET>,
            SetMaxMajorChannel: SetMaxMajorChannel::<Impl, IMPL_OFFSET>,
            MinSourceID: MinSourceID::<Impl, IMPL_OFFSET>,
            SetMinSourceID: SetMinSourceID::<Impl, IMPL_OFFSET>,
            MaxSourceID: MaxSourceID::<Impl, IMPL_OFFSET>,
            SetMaxSourceID: SetMaxSourceID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDigitalCableTuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IDigitalLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IDigitalLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDigitalLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDigitalLocator_Vtbl {
        Self { base: ILocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDigitalLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IDirectDrawMediaSample_Impl: Sized {
    fn GetSurfaceAndReleaseLock(&mut self, ppdirectdrawsurface: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn LockMediaSamplePointer(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IDirectDrawMediaSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectDrawMediaSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectDrawMediaSample_Vtbl {
        unsafe extern "system" fn GetSurfaceAndReleaseLock<Impl: IDirectDrawMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirectdrawsurface: *mut ::windows::core::RawPtr, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSurfaceAndReleaseLock(::core::mem::transmute_copy(&ppdirectdrawsurface), ::core::mem::transmute_copy(&prect)).into()
        }
        unsafe extern "system" fn LockMediaSamplePointer<Impl: IDirectDrawMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockMediaSamplePointer().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSurfaceAndReleaseLock: GetSurfaceAndReleaseLock::<Impl, IMPL_OFFSET>,
            LockMediaSamplePointer: LockMediaSamplePointer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectDrawMediaSample as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawMediaSampleAllocator_Impl: Sized {
    fn GetDirectDraw(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawMediaSampleAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectDrawMediaSampleAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectDrawMediaSampleAllocator_Vtbl {
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawMediaSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdirectdraw = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetDirectDraw: GetDirectDraw::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectDrawMediaSampleAllocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IDirectDrawMediaStream_Impl: Sized + IMediaStream_Impl {
    fn GetFormat(&mut self, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawPalette>, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> ::windows::core::Result<()>;
    fn SetFormat(&mut self, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawPalette>) -> ::windows::core::Result<()>;
    fn GetDirectDraw(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
    fn SetDirectDraw(&mut self, pdirectdraw: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw>) -> ::windows::core::Result<()>;
    fn CreateSample(&mut self, psurface: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *const super::super::Foundation::RECT, dwflags: u32) -> ::windows::core::Result<IDirectDrawStreamSample>;
    fn GetTimePerFrame(&mut self) -> ::windows::core::Result<i64>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IDirectDrawMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectDrawMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectDrawMediaStream_Vtbl {
        unsafe extern "system" fn GetFormat<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: *mut ::windows::core::RawPtr, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFormat(::core::mem::transmute_copy(&pddsdcurrent), ::core::mem::transmute_copy(&ppdirectdrawpalette), ::core::mem::transmute_copy(&pddsddesired), ::core::mem::transmute_copy(&pdwflags)).into()
        }
        unsafe extern "system" fn SetFormat<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFormat(::core::mem::transmute_copy(&pddsurfacedesc), ::core::mem::transmute(&pdirectdrawpalette)).into()
        }
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdirectdraw = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDirectDraw<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdirectdraw: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectDraw(::core::mem::transmute(&pdirectdraw)).into()
        }
        unsafe extern "system" fn CreateSample<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psurface: ::windows::core::RawPtr, prect: *const super::super::Foundation::RECT, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSample(::core::mem::transmute(&psurface), ::core::mem::transmute_copy(&prect), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimePerFrame<Impl: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pframetime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimePerFrame() {
                ::core::result::Result::Ok(ok__) => {
                    *pframetime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetFormat: GetFormat::<Impl, IMPL_OFFSET>,
            SetFormat: SetFormat::<Impl, IMPL_OFFSET>,
            GetDirectDraw: GetDirectDraw::<Impl, IMPL_OFFSET>,
            SetDirectDraw: SetDirectDraw::<Impl, IMPL_OFFSET>,
            CreateSample: CreateSample::<Impl, IMPL_OFFSET>,
            GetTimePerFrame: GetTimePerFrame::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectDrawMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IDirectDrawStreamSample_Impl: Sized + IStreamSample_Impl {
    fn GetSurface(&mut self, ppdirectdrawsurface: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn SetRect(&mut self, prect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IDirectDrawStreamSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectDrawStreamSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectDrawStreamSample_Vtbl {
        unsafe extern "system" fn GetSurface<Impl: IDirectDrawStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirectdrawsurface: *mut ::windows::core::RawPtr, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSurface(::core::mem::transmute_copy(&ppdirectdrawsurface), ::core::mem::transmute_copy(&prect)).into()
        }
        unsafe extern "system" fn SetRect<Impl: IDirectDrawStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRect(::core::mem::transmute_copy(&prect)).into()
        }
        Self {
            base: IStreamSample_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSurface: GetSurface::<Impl, IMPL_OFFSET>,
            SetRect: SetRect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectDrawStreamSample as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawVideo_Impl: Sized {
    fn GetSwitches(&mut self) -> ::windows::core::Result<u32>;
    fn SetSwitches(&mut self, switches: u32) -> ::windows::core::Result<()>;
    fn GetCaps(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::DDCAPS_DX7>;
    fn GetEmulatedCaps(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::DDCAPS_DX7>;
    fn GetSurfaceDesc(&mut self, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> ::windows::core::Result<()>;
    fn GetFourCCCodes(&mut self, pcount: *mut u32, pcodes: *mut u32) -> ::windows::core::Result<()>;
    fn SetDirectDraw(&mut self, pdirectdraw: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw>) -> ::windows::core::Result<()>;
    fn GetDirectDraw(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
    fn GetSurfaceType(&mut self) -> ::windows::core::Result<u32>;
    fn SetDefault(&mut self) -> ::windows::core::Result<()>;
    fn UseScanLine(&mut self, usescanline: i32) -> ::windows::core::Result<()>;
    fn CanUseScanLine(&mut self) -> ::windows::core::Result<i32>;
    fn UseOverlayStretch(&mut self, useoverlaystretch: i32) -> ::windows::core::Result<()>;
    fn CanUseOverlayStretch(&mut self) -> ::windows::core::Result<i32>;
    fn UseWhenFullScreen(&mut self, usewhenfullscreen: i32) -> ::windows::core::Result<()>;
    fn WillUseFullScreen(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawVideo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectDrawVideo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectDrawVideo_Vtbl {
        unsafe extern "system" fn GetSwitches<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pswitches: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSwitches() {
                ::core::result::Result::Ok(ok__) => {
                    *pswitches = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSwitches<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, switches: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSwitches(::core::mem::transmute_copy(&switches)).into()
        }
        unsafe extern "system" fn GetCaps<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEmulatedCaps<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEmulatedCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurfaceDesc<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSurfaceDesc(::core::mem::transmute_copy(&psurfacedesc)).into()
        }
        unsafe extern "system" fn GetFourCCCodes<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcount: *mut u32, pcodes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFourCCCodes(::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pcodes)).into()
        }
        unsafe extern "system" fn SetDirectDraw<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdirectdraw: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectDraw(::core::mem::transmute(&pdirectdraw)).into()
        }
        unsafe extern "system" fn GetDirectDraw<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirectdraw: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectDraw() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdirectdraw = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurfaceType<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psurfacetype: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSurfaceType() {
                ::core::result::Result::Ok(ok__) => {
                    *psurfacetype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefault<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefault().into()
        }
        unsafe extern "system" fn UseScanLine<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usescanline: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UseScanLine(::core::mem::transmute_copy(&usescanline)).into()
        }
        unsafe extern "system" fn CanUseScanLine<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usescanline: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUseScanLine() {
                ::core::result::Result::Ok(ok__) => {
                    *usescanline = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseOverlayStretch<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlaystretch: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UseOverlayStretch(::core::mem::transmute_copy(&useoverlaystretch)).into()
        }
        unsafe extern "system" fn CanUseOverlayStretch<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlaystretch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanUseOverlayStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *useoverlaystretch = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseWhenFullScreen<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usewhenfullscreen: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UseWhenFullScreen(::core::mem::transmute_copy(&usewhenfullscreen)).into()
        }
        unsafe extern "system" fn WillUseFullScreen<Impl: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, usewhenfullscreen: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WillUseFullScreen() {
                ::core::result::Result::Ok(ok__) => {
                    *usewhenfullscreen = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSwitches: GetSwitches::<Impl, IMPL_OFFSET>,
            SetSwitches: SetSwitches::<Impl, IMPL_OFFSET>,
            GetCaps: GetCaps::<Impl, IMPL_OFFSET>,
            GetEmulatedCaps: GetEmulatedCaps::<Impl, IMPL_OFFSET>,
            GetSurfaceDesc: GetSurfaceDesc::<Impl, IMPL_OFFSET>,
            GetFourCCCodes: GetFourCCCodes::<Impl, IMPL_OFFSET>,
            SetDirectDraw: SetDirectDraw::<Impl, IMPL_OFFSET>,
            GetDirectDraw: GetDirectDraw::<Impl, IMPL_OFFSET>,
            GetSurfaceType: GetSurfaceType::<Impl, IMPL_OFFSET>,
            SetDefault: SetDefault::<Impl, IMPL_OFFSET>,
            UseScanLine: UseScanLine::<Impl, IMPL_OFFSET>,
            CanUseScanLine: CanUseScanLine::<Impl, IMPL_OFFSET>,
            UseOverlayStretch: UseOverlayStretch::<Impl, IMPL_OFFSET>,
            CanUseOverlayStretch: CanUseOverlayStretch::<Impl, IMPL_OFFSET>,
            UseWhenFullScreen: UseWhenFullScreen::<Impl, IMPL_OFFSET>,
            WillUseFullScreen: WillUseFullScreen::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectDrawVideo as ::windows::core::Interface>::IID
    }
}
pub trait IDistributorNotify_Impl: Sized {
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Run(&mut self, tstart: i64) -> ::windows::core::Result<()>;
    fn SetSyncSource(&mut self, pclock: &::core::option::Option<super::IReferenceClock>) -> ::windows::core::Result<()>;
    fn NotifyGraphChange(&mut self) -> ::windows::core::Result<()>;
}
impl IDistributorNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDistributorNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDistributorNotify_Vtbl {
        unsafe extern "system" fn Stop<Impl: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Pause<Impl: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Run<Impl: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tstart: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Run(::core::mem::transmute_copy(&tstart)).into()
        }
        unsafe extern "system" fn SetSyncSource<Impl: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncSource(::core::mem::transmute(&pclock)).into()
        }
        unsafe extern "system" fn NotifyGraphChange<Impl: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyGraphChange().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Run: Run::<Impl, IMPL_OFFSET>,
            SetSyncSource: SetSyncSource::<Impl, IMPL_OFFSET>,
            NotifyGraphChange: NotifyGraphChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDistributorNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IDrawVideoImage_Impl: Sized {
    fn DrawVideoImageBegin(&mut self) -> ::windows::core::Result<()>;
    fn DrawVideoImageEnd(&mut self) -> ::windows::core::Result<()>;
    fn DrawVideoImageDraw(&mut self, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IDrawVideoImage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDrawVideoImage_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDrawVideoImage_Vtbl {
        unsafe extern "system" fn DrawVideoImageBegin<Impl: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DrawVideoImageBegin().into()
        }
        unsafe extern "system" fn DrawVideoImageEnd<Impl: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DrawVideoImageEnd().into()
        }
        unsafe extern "system" fn DrawVideoImageDraw<Impl: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DrawVideoImageDraw(::core::mem::transmute_copy(&hdc), ::core::mem::transmute_copy(&lprcsrc), ::core::mem::transmute_copy(&lprcdst)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            DrawVideoImageBegin: DrawVideoImageBegin::<Impl, IMPL_OFFSET>,
            DrawVideoImageEnd: DrawVideoImageEnd::<Impl, IMPL_OFFSET>,
            DrawVideoImageDraw: DrawVideoImageDraw::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDrawVideoImage as ::windows::core::Interface>::IID
    }
}
pub trait IDvbCableDeliverySystemDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetFrequency(&mut self) -> ::windows::core::Result<u32>;
    fn GetFECOuter(&mut self) -> ::windows::core::Result<u8>;
    fn GetModulation(&mut self) -> ::windows::core::Result<u8>;
    fn GetSymbolRate(&mut self) -> ::windows::core::Result<u32>;
    fn GetFECInner(&mut self) -> ::windows::core::Result<u8>;
}
impl IDvbCableDeliverySystemDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbCableDeliverySystemDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbCableDeliverySystemDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrequency<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECOuter<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFECOuter() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModulation<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetModulation() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolRate<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSymbolRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECInner<Impl: IDvbCableDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFECInner() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetFrequency: GetFrequency::<Impl, IMPL_OFFSET>,
            GetFECOuter: GetFECOuter::<Impl, IMPL_OFFSET>,
            GetModulation: GetModulation::<Impl, IMPL_OFFSET>,
            GetSymbolRate: GetSymbolRate::<Impl, IMPL_OFFSET>,
            GetFECInner: GetFECInner::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbCableDeliverySystemDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbComponentDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetStreamContent(&mut self) -> ::windows::core::Result<u8>;
    fn GetComponentType(&mut self) -> ::windows::core::Result<u8>;
    fn GetComponentTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbComponentDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbComponentDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbComponentDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamContent<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamContent() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentType<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetStreamContent: GetStreamContent::<Impl, IMPL_OFFSET>,
            GetComponentType: GetComponentType::<Impl, IMPL_OFFSET>,
            GetComponentTag: GetComponentTag::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbComponentDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbContentDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordContentNibbles(&mut self, brecordindex: u8, pbvallevel1: *mut u8, pbvallevel2: *mut u8) -> ::windows::core::Result<()>;
    fn GetRecordUserNibbles(&mut self, brecordindex: u8, pbval1: *mut u8, pbval2: *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbContentDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbContentDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbContentDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordContentNibbles<Impl: IDvbContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbvallevel1: *mut u8, pbvallevel2: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordContentNibbles(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pbvallevel1), ::core::mem::transmute_copy(&pbvallevel2)).into()
        }
        unsafe extern "system" fn GetRecordUserNibbles<Impl: IDvbContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval1: *mut u8, pbval2: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordUserNibbles(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pbval1), ::core::mem::transmute_copy(&pbval2)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordContentNibbles: GetRecordContentNibbles::<Impl, IMPL_OFFSET>,
            GetRecordUserNibbles: GetRecordUserNibbles::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbContentDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbContentIdentifierDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordCrid(&mut self, brecordindex: u8, pbtype: *mut u8, pblocation: *mut u8, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbContentIdentifierDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbContentIdentifierDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbContentIdentifierDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbContentIdentifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbContentIdentifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbContentIdentifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCrid<Impl: IDvbContentIdentifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbtype: *mut u8, pblocation: *mut u8, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordCrid(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pbtype), ::core::mem::transmute_copy(&pblocation), ::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&ppbbytes)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordCrid: GetRecordCrid::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbContentIdentifierDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbDataBroadcastDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetDataBroadcastID(&mut self) -> ::windows::core::Result<u16>;
    fn GetComponentTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetSelectorLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetSelectorBytes(&mut self, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::Result<()>;
    fn GetLangID(&mut self) -> ::windows::core::Result<u32>;
    fn GetTextLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetText(&mut self, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbDataBroadcastDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbDataBroadcastDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbDataBroadcastDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBroadcastID<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataBroadcastID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorLength<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSelectorLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorBytes<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSelectorBytes(::core::mem::transmute_copy(&pblen), ::core::mem::transmute_copy(&pbval)).into()
        }
        unsafe extern "system" fn GetLangID<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLangID() {
                ::core::result::Result::Ok(ok__) => {
                    *pulval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextLength<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetText<Impl: IDvbDataBroadcastDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetText(::core::mem::transmute_copy(&pblen), ::core::mem::transmute_copy(&pbval)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetDataBroadcastID: GetDataBroadcastID::<Impl, IMPL_OFFSET>,
            GetComponentTag: GetComponentTag::<Impl, IMPL_OFFSET>,
            GetSelectorLength: GetSelectorLength::<Impl, IMPL_OFFSET>,
            GetSelectorBytes: GetSelectorBytes::<Impl, IMPL_OFFSET>,
            GetLangID: GetLangID::<Impl, IMPL_OFFSET>,
            GetTextLength: GetTextLength::<Impl, IMPL_OFFSET>,
            GetText: GetText::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbDataBroadcastDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbDataBroadcastIDDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetDataBroadcastID(&mut self) -> ::windows::core::Result<u16>;
    fn GetIDSelectorBytes(&mut self, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbDataBroadcastIDDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbDataBroadcastIDDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbDataBroadcastIDDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDataBroadcastIDDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDataBroadcastIDDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBroadcastID<Impl: IDvbDataBroadcastIDDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataBroadcastID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIDSelectorBytes<Impl: IDvbDataBroadcastIDDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIDSelectorBytes(::core::mem::transmute_copy(&pblen), ::core::mem::transmute_copy(&pbval)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetDataBroadcastID: GetDataBroadcastID::<Impl, IMPL_OFFSET>,
            GetIDSelectorBytes: GetIDSelectorBytes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbDataBroadcastIDDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbDefaultAuthorityDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetDefaultAuthority(&mut self, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbDefaultAuthorityDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbDefaultAuthorityDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbDefaultAuthorityDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbDefaultAuthorityDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbDefaultAuthorityDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultAuthority<Impl: IDvbDefaultAuthorityDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pblength: *mut u8, ppbbytes: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDefaultAuthority(::core::mem::transmute_copy(&pblength), ::core::mem::transmute_copy(&ppbbytes)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetDefaultAuthority: GetDefaultAuthority::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbDefaultAuthorityDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbExtendedEventDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetDescriptorNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetLastDescriptorNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordItemW(&mut self, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetConcatenatedItemW(&mut self, pfollowingdescriptor: &::core::option::Option<IDvbExtendedEventDescriptor>, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetConcatenatedTextW(&mut self, followingdescriptor: &::core::option::Option<IDvbExtendedEventDescriptor>, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetRecordItemRawBytes(&mut self, brecordindex: u8, ppbrawitem: *mut *mut u8, pbitemlength: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbExtendedEventDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbExtendedEventDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbExtendedEventDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescriptorNumber<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDescriptorNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastDescriptorNumber<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLastDescriptorNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordItemW<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordItemW(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&convmode), ::core::mem::transmute_copy(&pbstrdesc), ::core::mem::transmute_copy(&pbstritem)).into()
        }
        unsafe extern "system" fn GetConcatenatedItemW<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfollowingdescriptor: ::windows::core::RawPtr, convmode: DVB_STRCONV_MODE, pbstrdesc: *mut super::super::Foundation::BSTR, pbstritem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetConcatenatedItemW(::core::mem::transmute(&pfollowingdescriptor), ::core::mem::transmute_copy(&convmode), ::core::mem::transmute_copy(&pbstrdesc), ::core::mem::transmute_copy(&pbstritem)).into()
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConcatenatedTextW<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, followingdescriptor: ::windows::core::RawPtr, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConcatenatedTextW(::core::mem::transmute(&followingdescriptor), ::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordItemRawBytes<Impl: IDvbExtendedEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ppbrawitem: *mut *mut u8, pbitemlength: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordItemRawBytes(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&ppbrawitem), ::core::mem::transmute_copy(&pbitemlength)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetDescriptorNumber: GetDescriptorNumber::<Impl, IMPL_OFFSET>,
            GetLastDescriptorNumber: GetLastDescriptorNumber::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordItemW: GetRecordItemW::<Impl, IMPL_OFFSET>,
            GetConcatenatedItemW: GetConcatenatedItemW::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
            GetConcatenatedTextW: GetConcatenatedTextW::<Impl, IMPL_OFFSET>,
            GetRecordItemRawBytes: GetRecordItemRawBytes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbExtendedEventDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbFrequencyListDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCodingType(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordCentreFrequency(&mut self, brecordindex: u8) -> ::windows::core::Result<u32>;
}
impl IDvbFrequencyListDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbFrequencyListDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbFrequencyListDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbFrequencyListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbFrequencyListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodingType<Impl: IDvbFrequencyListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCodingType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbFrequencyListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCentreFrequency<Impl: IDvbFrequencyListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCentreFrequency(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCodingType: GetCodingType::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordCentreFrequency: GetRecordCentreFrequency::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbFrequencyListDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbHDSimulcastLogicalChannelDescriptor_Impl: Sized + IDvbLogicalChannelDescriptor_Impl + IDvbLogicalChannelDescriptor2_Impl {}
impl IDvbHDSimulcastLogicalChannelDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbHDSimulcastLogicalChannelDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbHDSimulcastLogicalChannelDescriptor_Vtbl {
        Self { base: IDvbLogicalChannelDescriptor2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbHDSimulcastLogicalChannelDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbLinkageDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetTSId(&mut self) -> ::windows::core::Result<u16>;
    fn GetONId(&mut self) -> ::windows::core::Result<u16>;
    fn GetServiceId(&mut self) -> ::windows::core::Result<u16>;
    fn GetLinkageType(&mut self) -> ::windows::core::Result<u8>;
    fn GetPrivateDataLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetPrivateData(&mut self, pblen: *mut u8, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbLinkageDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbLinkageDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbLinkageDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSId<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTSId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetONId<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetONId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLinkageType<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLinkageType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataLength<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateData<Impl: IDvbLinkageDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pblen: *mut u8, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPrivateData(::core::mem::transmute_copy(&pblen), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetTSId: GetTSId::<Impl, IMPL_OFFSET>,
            GetONId: GetONId::<Impl, IMPL_OFFSET>,
            GetServiceId: GetServiceId::<Impl, IMPL_OFFSET>,
            GetLinkageType: GetLinkageType::<Impl, IMPL_OFFSET>,
            GetPrivateDataLength: GetPrivateDataLength::<Impl, IMPL_OFFSET>,
            GetPrivateData: GetPrivateData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbLinkageDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbLogicalChannel2Descriptor_Impl: Sized + IDvbLogicalChannelDescriptor_Impl + IDvbLogicalChannelDescriptor2_Impl {
    fn GetCountOfLists(&mut self) -> ::windows::core::Result<u8>;
    fn GetListId(&mut self, blistindex: u8) -> ::windows::core::Result<u8>;
    fn GetListNameW(&mut self, blistindex: u8, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetListCountryCode(&mut self, blistindex: u8, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetListCountOfRecords(&mut self, bchannellistindex: u8) -> ::windows::core::Result<u8>;
    fn GetListRecordServiceId(&mut self, blistindex: u8, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetListRecordLogicalChannelNumber(&mut self, blistindex: u8, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetListRecordLogicalChannelAndVisibility(&mut self, blistindex: u8, brecordindex: u8) -> ::windows::core::Result<u16>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbLogicalChannel2Descriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbLogicalChannel2Descriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbLogicalChannel2Descriptor_Vtbl {
        unsafe extern "system" fn GetCountOfLists<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfLists() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListId<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListId(::core::mem::transmute_copy(&blistindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListNameW<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListNameW(::core::mem::transmute_copy(&blistindex), ::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListCountryCode<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetListCountryCode(::core::mem::transmute_copy(&blistindex), ::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetListCountOfRecords<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bchannellistindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListCountOfRecords(::core::mem::transmute_copy(&bchannellistindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordServiceId<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListRecordServiceId(::core::mem::transmute_copy(&blistindex), ::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordLogicalChannelNumber<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListRecordLogicalChannelNumber(::core::mem::transmute_copy(&blistindex), ::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetListRecordLogicalChannelAndVisibility<Impl: IDvbLogicalChannel2Descriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, blistindex: u8, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetListRecordLogicalChannelAndVisibility(::core::mem::transmute_copy(&blistindex), ::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDvbLogicalChannelDescriptor2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetCountOfLists: GetCountOfLists::<Impl, IMPL_OFFSET>,
            GetListId: GetListId::<Impl, IMPL_OFFSET>,
            GetListNameW: GetListNameW::<Impl, IMPL_OFFSET>,
            GetListCountryCode: GetListCountryCode::<Impl, IMPL_OFFSET>,
            GetListCountOfRecords: GetListCountOfRecords::<Impl, IMPL_OFFSET>,
            GetListRecordServiceId: GetListRecordServiceId::<Impl, IMPL_OFFSET>,
            GetListRecordLogicalChannelNumber: GetListRecordLogicalChannelNumber::<Impl, IMPL_OFFSET>,
            GetListRecordLogicalChannelAndVisibility: GetListRecordLogicalChannelAndVisibility::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbLogicalChannel2Descriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbLogicalChannelDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordServiceId(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetRecordLogicalChannelNumber(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
}
impl IDvbLogicalChannelDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbLogicalChannelDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbLogicalChannelDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbLogicalChannelDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbLogicalChannelDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbLogicalChannelDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbLogicalChannelDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLogicalChannelNumber<Impl: IDvbLogicalChannelDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordLogicalChannelNumber(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordLogicalChannelNumber: GetRecordLogicalChannelNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbLogicalChannelDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbLogicalChannelDescriptor2_Impl: Sized + IDvbLogicalChannelDescriptor_Impl {
    fn GetRecordLogicalChannelAndVisibility(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
}
impl IDvbLogicalChannelDescriptor2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbLogicalChannelDescriptor2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbLogicalChannelDescriptor2_Vtbl {
        unsafe extern "system" fn GetRecordLogicalChannelAndVisibility<Impl: IDvbLogicalChannelDescriptor2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordLogicalChannelAndVisibility(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDvbLogicalChannelDescriptor_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetRecordLogicalChannelAndVisibility: GetRecordLogicalChannelAndVisibility::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbLogicalChannelDescriptor2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbMultilingualServiceNameDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordLangId(&mut self, brecordindex: u8) -> ::windows::core::Result<u32>;
    fn GetRecordServiceProviderNameW(&mut self, brecordindex: u8, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetRecordServiceNameW(&mut self, brecordindex: u8, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbMultilingualServiceNameDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbMultilingualServiceNameDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbMultilingualServiceNameDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ulval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceProviderNameW<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceProviderNameW(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceNameW<Impl: IDvbMultilingualServiceNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceNameW(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordLangId: GetRecordLangId::<Impl, IMPL_OFFSET>,
            GetRecordServiceProviderNameW: GetRecordServiceProviderNameW::<Impl, IMPL_OFFSET>,
            GetRecordServiceNameW: GetRecordServiceNameW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbMultilingualServiceNameDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbNetworkNameDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetNetworkName(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetNetworkNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbNetworkNameDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbNetworkNameDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbNetworkNameDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbNetworkNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbNetworkNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkName<Impl: IDvbNetworkNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNetworkName() {
                ::core::result::Result::Ok(ok__) => {
                    *pszname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkNameW<Impl: IDvbNetworkNameDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNetworkNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetNetworkName: GetNetworkName::<Impl, IMPL_OFFSET>,
            GetNetworkNameW: GetNetworkNameW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbNetworkNameDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbParentalRatingDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordRating(&mut self, brecordindex: u8, pszcountrycode: *mut u8, pbval: *mut u8) -> ::windows::core::Result<()>;
}
impl IDvbParentalRatingDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbParentalRatingDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbParentalRatingDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbParentalRatingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbParentalRatingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbParentalRatingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordRating<Impl: IDvbParentalRatingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pszcountrycode: *mut u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordRating(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pszcountrycode), ::core::mem::transmute_copy(&pbval)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordRating: GetRecordRating::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbParentalRatingDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbPrivateDataSpecifierDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetPrivateDataSpecifier(&mut self) -> ::windows::core::Result<u32>;
}
impl IDvbPrivateDataSpecifierDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbPrivateDataSpecifierDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbPrivateDataSpecifierDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbPrivateDataSpecifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbPrivateDataSpecifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataSpecifier<Impl: IDvbPrivateDataSpecifierDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataSpecifier() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetPrivateDataSpecifier: GetPrivateDataSpecifier::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbPrivateDataSpecifierDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbSatelliteDeliverySystemDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetFrequency(&mut self) -> ::windows::core::Result<u32>;
    fn GetOrbitalPosition(&mut self) -> ::windows::core::Result<u16>;
    fn GetWestEastFlag(&mut self) -> ::windows::core::Result<u8>;
    fn GetPolarization(&mut self) -> ::windows::core::Result<u8>;
    fn GetModulation(&mut self) -> ::windows::core::Result<u8>;
    fn GetSymbolRate(&mut self) -> ::windows::core::Result<u32>;
    fn GetFECInner(&mut self) -> ::windows::core::Result<u8>;
}
impl IDvbSatelliteDeliverySystemDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbSatelliteDeliverySystemDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFrequency<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOrbitalPosition<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOrbitalPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWestEastFlag<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetWestEastFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPolarization<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPolarization() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModulation<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetModulation() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolRate<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSymbolRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFECInner<Impl: IDvbSatelliteDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFECInner() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetFrequency: GetFrequency::<Impl, IMPL_OFFSET>,
            GetOrbitalPosition: GetOrbitalPosition::<Impl, IMPL_OFFSET>,
            GetWestEastFlag: GetWestEastFlag::<Impl, IMPL_OFFSET>,
            GetPolarization: GetPolarization::<Impl, IMPL_OFFSET>,
            GetModulation: GetModulation::<Impl, IMPL_OFFSET>,
            GetSymbolRate: GetSymbolRate::<Impl, IMPL_OFFSET>,
            GetFECInner: GetFECInner::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbSatelliteDeliverySystemDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbServiceAttributeDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordServiceId(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetRecordNumericSelectionFlag(&mut self, brecordindex: u8) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRecordVisibleServiceFlag(&mut self, brecordindex: u8) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbServiceAttributeDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbServiceAttributeDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbServiceAttributeDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumericSelectionFlag<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNumericSelectionFlag(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVisibleServiceFlag<Impl: IDvbServiceAttributeDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordVisibleServiceFlag(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordNumericSelectionFlag: GetRecordNumericSelectionFlag::<Impl, IMPL_OFFSET>,
            GetRecordVisibleServiceFlag: GetRecordVisibleServiceFlag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbServiceAttributeDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbServiceDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetServiceType(&mut self) -> ::windows::core::Result<u8>;
    fn GetServiceProviderName(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetServiceProviderNameW(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetServiceName(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetProcessedServiceName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetServiceNameEmphasized(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbServiceDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbServiceDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbServiceDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceType<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProviderName<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderName() {
                ::core::result::Result::Ok(ok__) => {
                    *pszname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProviderNameW<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderNameW() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceName<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszname: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceName() {
                ::core::result::Result::Ok(ok__) => {
                    *pszname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessedServiceName<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcessedServiceName() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceNameEmphasized<Impl: IDvbServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceNameEmphasized() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetServiceType: GetServiceType::<Impl, IMPL_OFFSET>,
            GetServiceProviderName: GetServiceProviderName::<Impl, IMPL_OFFSET>,
            GetServiceProviderNameW: GetServiceProviderNameW::<Impl, IMPL_OFFSET>,
            GetServiceName: GetServiceName::<Impl, IMPL_OFFSET>,
            GetProcessedServiceName: GetProcessedServiceName::<Impl, IMPL_OFFSET>,
            GetServiceNameEmphasized: GetServiceNameEmphasized::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbServiceDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbServiceDescriptor2_Impl: Sized + IDvbServiceDescriptor_Impl {
    fn GetServiceProviderNameW2(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetServiceNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbServiceDescriptor2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbServiceDescriptor2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbServiceDescriptor2_Vtbl {
        unsafe extern "system" fn GetServiceProviderNameW2<Impl: IDvbServiceDescriptor2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceProviderNameW2(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceNameW<Impl: IDvbServiceDescriptor2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDvbServiceDescriptor_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetServiceProviderNameW2: GetServiceProviderNameW2::<Impl, IMPL_OFFSET>,
            GetServiceNameW: GetServiceNameW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbServiceDescriptor2 as ::windows::core::Interface>::IID
    }
}
pub trait IDvbServiceListDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordServiceId(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetRecordServiceType(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
}
impl IDvbServiceListDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbServiceListDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbServiceListDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbServiceListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbServiceListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbServiceListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceId<Impl: IDvbServiceListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceType<Impl: IDvbServiceListDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceType(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordServiceId: GetRecordServiceId::<Impl, IMPL_OFFSET>,
            GetRecordServiceType: GetRecordServiceType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbServiceListDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvbShortEventDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetEventNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvbShortEventDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbShortEventDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbShortEventDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbShortEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbShortEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IDvbShortEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetEventNameW<Impl: IDvbShortEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEventNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextW<Impl: IDvbShortEventDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetEventNameW: GetEventNameW::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbShortEventDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbSiParser_Impl: Sized {
    fn Initialize(&mut self, punkmpeg2data: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetPAT(&mut self) -> ::windows::core::Result<IPAT>;
    fn GetCAT(&mut self, dwtimeout: u32) -> ::windows::core::Result<ICAT>;
    fn GetPMT(&mut self, pid: u16, pwprogramnumber: *const u16) -> ::windows::core::Result<IPMT>;
    fn GetTSDT(&mut self) -> ::windows::core::Result<ITSDT>;
    fn GetNIT(&mut self, tableid: u8, pwnetworkid: *const u16) -> ::windows::core::Result<IDVB_NIT>;
    fn GetSDT(&mut self, tableid: u8, pwtransportstreamid: *const u16) -> ::windows::core::Result<IDVB_SDT>;
    fn GetEIT(&mut self, tableid: u8, pwserviceid: *const u16) -> ::windows::core::Result<IDVB_EIT>;
    fn GetBAT(&mut self, pwbouquetid: *const u16) -> ::windows::core::Result<IDVB_BAT>;
    fn GetRST(&mut self, dwtimeout: u32) -> ::windows::core::Result<IDVB_RST>;
    fn GetST(&mut self, pid: u16, dwtimeout: u32) -> ::windows::core::Result<IDVB_ST>;
    fn GetTDT(&mut self) -> ::windows::core::Result<IDVB_TDT>;
    fn GetTOT(&mut self) -> ::windows::core::Result<IDVB_TOT>;
    fn GetDIT(&mut self, dwtimeout: u32) -> ::windows::core::Result<IDVB_DIT>;
    fn GetSIT(&mut self, dwtimeout: u32) -> ::windows::core::Result<IDVB_SIT>;
}
impl IDvbSiParser_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbSiParser_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbSiParser_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkmpeg2data: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&punkmpeg2data)).into()
        }
        unsafe extern "system" fn GetPAT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPAT() {
                ::core::result::Result::Ok(ok__) => {
                    *pppat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppcat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCAT(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPMT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, pwprogramnumber: *const u16, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPMT(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&pwprogramnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *pppmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSDT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTSDT() {
                ::core::result::Result::Ok(ok__) => {
                    *pptsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNIT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwnetworkid: *const u16, ppnit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNIT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwnetworkid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSDT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtransportstreamid: *const u16, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSDT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwtransportstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEIT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwserviceid: *const u16, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEIT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwserviceid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppeit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBAT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwbouquetid: *const u16, ppbat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBAT(::core::mem::transmute_copy(&pwbouquetid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppbat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRST<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, pprst: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRST(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *pprst = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetST<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, dwtimeout: u32, ppst: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetST(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppst = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTDT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTDT() {
                ::core::result::Result::Ok(ok__) => {
                    *pptdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTOT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptot: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTOT() {
                ::core::result::Result::Ok(ok__) => {
                    *pptot = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDIT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppdit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDIT(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSIT<Impl: IDvbSiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtimeout: u32, ppsit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSIT(::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetPAT: GetPAT::<Impl, IMPL_OFFSET>,
            GetCAT: GetCAT::<Impl, IMPL_OFFSET>,
            GetPMT: GetPMT::<Impl, IMPL_OFFSET>,
            GetTSDT: GetTSDT::<Impl, IMPL_OFFSET>,
            GetNIT: GetNIT::<Impl, IMPL_OFFSET>,
            GetSDT: GetSDT::<Impl, IMPL_OFFSET>,
            GetEIT: GetEIT::<Impl, IMPL_OFFSET>,
            GetBAT: GetBAT::<Impl, IMPL_OFFSET>,
            GetRST: GetRST::<Impl, IMPL_OFFSET>,
            GetST: GetST::<Impl, IMPL_OFFSET>,
            GetTDT: GetTDT::<Impl, IMPL_OFFSET>,
            GetTOT: GetTOT::<Impl, IMPL_OFFSET>,
            GetDIT: GetDIT::<Impl, IMPL_OFFSET>,
            GetSIT: GetSIT::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbSiParser as ::windows::core::Interface>::IID
    }
}
pub trait IDvbSiParser2_Impl: Sized + IDvbSiParser_Impl {
    fn GetEIT2(&mut self, tableid: u8, pwserviceid: *const u16, pbsegment: *const u8) -> ::windows::core::Result<IDVB_EIT2>;
}
impl IDvbSiParser2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbSiParser2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbSiParser2_Vtbl {
        unsafe extern "system" fn GetEIT2<Impl: IDvbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwserviceid: *const u16, pbsegment: *const u8, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEIT2(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwserviceid), ::core::mem::transmute_copy(&pbsegment)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppeit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IDvbSiParser_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetEIT2: GetEIT2::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbSiParser2 as ::windows::core::Interface>::IID
    }
}
pub trait IDvbSubtitlingDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordLangId(&mut self, brecordindex: u8) -> ::windows::core::Result<u32>;
    fn GetRecordSubtitlingType(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordCompositionPageID(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetRecordAncillaryPageID(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
}
impl IDvbSubtitlingDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbSubtitlingDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbSubtitlingDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordSubtitlingType<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordSubtitlingType(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCompositionPageID<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCompositionPageID(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordAncillaryPageID<Impl: IDvbSubtitlingDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordAncillaryPageID(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordLangId: GetRecordLangId::<Impl, IMPL_OFFSET>,
            GetRecordSubtitlingType: GetRecordSubtitlingType::<Impl, IMPL_OFFSET>,
            GetRecordCompositionPageID: GetRecordCompositionPageID::<Impl, IMPL_OFFSET>,
            GetRecordAncillaryPageID: GetRecordAncillaryPageID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbSubtitlingDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbTeletextDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordLangId(&mut self, brecordindex: u8) -> ::windows::core::Result<u32>;
    fn GetRecordTeletextType(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordMagazineNumber(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordPageNumber(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
}
impl IDvbTeletextDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbTeletextDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbTeletextDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordLangId<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pulval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordLangId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTeletextType<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTeletextType(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMagazineNumber<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordMagazineNumber(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordPageNumber<Impl: IDvbTeletextDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordPageNumber(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordLangId: GetRecordLangId::<Impl, IMPL_OFFSET>,
            GetRecordTeletextType: GetRecordTeletextType::<Impl, IMPL_OFFSET>,
            GetRecordMagazineNumber: GetRecordMagazineNumber::<Impl, IMPL_OFFSET>,
            GetRecordPageNumber: GetRecordPageNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbTeletextDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbTerrestrial2DeliverySystemDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetTagExtension(&mut self) -> ::windows::core::Result<u8>;
    fn GetCentreFrequency(&mut self) -> ::windows::core::Result<u32>;
    fn GetPLPId(&mut self) -> ::windows::core::Result<u8>;
    fn GetT2SystemId(&mut self) -> ::windows::core::Result<u16>;
    fn GetMultipleInputMode(&mut self) -> ::windows::core::Result<u8>;
    fn GetBandwidth(&mut self) -> ::windows::core::Result<u8>;
    fn GetGuardInterval(&mut self) -> ::windows::core::Result<u8>;
    fn GetTransmissionMode(&mut self) -> ::windows::core::Result<u8>;
    fn GetCellId(&mut self) -> ::windows::core::Result<u16>;
    fn GetOtherFrequencyFlag(&mut self) -> ::windows::core::Result<u8>;
    fn GetTFSFlag(&mut self) -> ::windows::core::Result<u8>;
}
impl IDvbTerrestrial2DeliverySystemDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbTerrestrial2DeliverySystemDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTagExtension<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTagExtension() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCentreFrequency<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCentreFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPLPId<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPLPId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetT2SystemId<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetT2SystemId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMultipleInputMode<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMultipleInputMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidth<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBandwidth() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCellId<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCellId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOtherFrequencyFlag<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOtherFrequencyFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTFSFlag<Impl: IDvbTerrestrial2DeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTFSFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetTagExtension: GetTagExtension::<Impl, IMPL_OFFSET>,
            GetCentreFrequency: GetCentreFrequency::<Impl, IMPL_OFFSET>,
            GetPLPId: GetPLPId::<Impl, IMPL_OFFSET>,
            GetT2SystemId: GetT2SystemId::<Impl, IMPL_OFFSET>,
            GetMultipleInputMode: GetMultipleInputMode::<Impl, IMPL_OFFSET>,
            GetBandwidth: GetBandwidth::<Impl, IMPL_OFFSET>,
            GetGuardInterval: GetGuardInterval::<Impl, IMPL_OFFSET>,
            GetTransmissionMode: GetTransmissionMode::<Impl, IMPL_OFFSET>,
            GetCellId: GetCellId::<Impl, IMPL_OFFSET>,
            GetOtherFrequencyFlag: GetOtherFrequencyFlag::<Impl, IMPL_OFFSET>,
            GetTFSFlag: GetTFSFlag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbTerrestrial2DeliverySystemDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvbTerrestrialDeliverySystemDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCentreFrequency(&mut self) -> ::windows::core::Result<u32>;
    fn GetBandwidth(&mut self) -> ::windows::core::Result<u8>;
    fn GetConstellation(&mut self) -> ::windows::core::Result<u8>;
    fn GetHierarchyInformation(&mut self) -> ::windows::core::Result<u8>;
    fn GetCodeRateHPStream(&mut self) -> ::windows::core::Result<u8>;
    fn GetCodeRateLPStream(&mut self) -> ::windows::core::Result<u8>;
    fn GetGuardInterval(&mut self) -> ::windows::core::Result<u8>;
    fn GetTransmissionMode(&mut self) -> ::windows::core::Result<u8>;
    fn GetOtherFrequencyFlag(&mut self) -> ::windows::core::Result<u8>;
}
impl IDvbTerrestrialDeliverySystemDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvbTerrestrialDeliverySystemDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCentreFrequency<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCentreFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidth<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBandwidth() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConstellation<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConstellation() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHierarchyInformation<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHierarchyInformation() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodeRateHPStream<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCodeRateHPStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodeRateLPStream<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCodeRateLPStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOtherFrequencyFlag<Impl: IDvbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOtherFrequencyFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCentreFrequency: GetCentreFrequency::<Impl, IMPL_OFFSET>,
            GetBandwidth: GetBandwidth::<Impl, IMPL_OFFSET>,
            GetConstellation: GetConstellation::<Impl, IMPL_OFFSET>,
            GetHierarchyInformation: GetHierarchyInformation::<Impl, IMPL_OFFSET>,
            GetCodeRateHPStream: GetCodeRateHPStream::<Impl, IMPL_OFFSET>,
            GetCodeRateLPStream: GetCodeRateLPStream::<Impl, IMPL_OFFSET>,
            GetGuardInterval: GetGuardInterval::<Impl, IMPL_OFFSET>,
            GetTransmissionMode: GetTransmissionMode::<Impl, IMPL_OFFSET>,
            GetOtherFrequencyFlag: GetOtherFrequencyFlag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvbTerrestrialDeliverySystemDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IDvdCmd_Impl: Sized {
    fn WaitForStart(&mut self) -> ::windows::core::Result<()>;
    fn WaitForEnd(&mut self) -> ::windows::core::Result<()>;
}
impl IDvdCmd_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdCmd_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdCmd_Vtbl {
        unsafe extern "system" fn WaitForStart<Impl: IDvdCmd_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitForStart().into()
        }
        unsafe extern "system" fn WaitForEnd<Impl: IDvdCmd_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitForEnd().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            WaitForStart: WaitForStart::<Impl, IMPL_OFFSET>,
            WaitForEnd: WaitForEnd::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdCmd as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvdControl_Impl: Sized {
    fn TitlePlay(&mut self, ultitle: u32) -> ::windows::core::Result<()>;
    fn ChapterPlay(&mut self, ultitle: u32, ulchapter: u32) -> ::windows::core::Result<()>;
    fn TimePlay(&mut self, ultitle: u32, bcdtime: u32) -> ::windows::core::Result<()>;
    fn StopForResume(&mut self) -> ::windows::core::Result<()>;
    fn GoUp(&mut self) -> ::windows::core::Result<()>;
    fn TimeSearch(&mut self, bcdtime: u32) -> ::windows::core::Result<()>;
    fn ChapterSearch(&mut self, ulchapter: u32) -> ::windows::core::Result<()>;
    fn PrevPGSearch(&mut self) -> ::windows::core::Result<()>;
    fn TopPGSearch(&mut self) -> ::windows::core::Result<()>;
    fn NextPGSearch(&mut self) -> ::windows::core::Result<()>;
    fn ForwardScan(&mut self, dwspeed: f64) -> ::windows::core::Result<()>;
    fn BackwardScan(&mut self, dwspeed: f64) -> ::windows::core::Result<()>;
    fn MenuCall(&mut self, menuid: DVD_MENU_ID) -> ::windows::core::Result<()>;
    fn Resume(&mut self) -> ::windows::core::Result<()>;
    fn UpperButtonSelect(&mut self) -> ::windows::core::Result<()>;
    fn LowerButtonSelect(&mut self) -> ::windows::core::Result<()>;
    fn LeftButtonSelect(&mut self) -> ::windows::core::Result<()>;
    fn RightButtonSelect(&mut self) -> ::windows::core::Result<()>;
    fn ButtonActivate(&mut self) -> ::windows::core::Result<()>;
    fn ButtonSelectAndActivate(&mut self, ulbutton: u32) -> ::windows::core::Result<()>;
    fn StillOff(&mut self) -> ::windows::core::Result<()>;
    fn PauseOn(&mut self) -> ::windows::core::Result<()>;
    fn PauseOff(&mut self) -> ::windows::core::Result<()>;
    fn MenuLanguageSelect(&mut self, language: u32) -> ::windows::core::Result<()>;
    fn AudioStreamChange(&mut self, ulaudio: u32) -> ::windows::core::Result<()>;
    fn SubpictureStreamChange(&mut self, ulsubpicture: u32, bdisplay: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn AngleChange(&mut self, ulangle: u32) -> ::windows::core::Result<()>;
    fn ParentalLevelSelect(&mut self, ulparentallevel: u32) -> ::windows::core::Result<()>;
    fn ParentalCountrySelect(&mut self, wcountry: u16) -> ::windows::core::Result<()>;
    fn KaraokeAudioPresentationModeChange(&mut self, ulmode: u32) -> ::windows::core::Result<()>;
    fn VideoModePreferrence(&mut self, ulpreferreddisplaymode: u32) -> ::windows::core::Result<()>;
    fn SetRoot(&mut self, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn MouseActivate(&mut self, point: &super::super::Foundation::POINT) -> ::windows::core::Result<()>;
    fn MouseSelect(&mut self, point: &super::super::Foundation::POINT) -> ::windows::core::Result<()>;
    fn ChapterPlayAutoStop(&mut self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvdControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdControl_Vtbl {
        unsafe extern "system" fn TitlePlay<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TitlePlay(::core::mem::transmute_copy(&ultitle)).into()
        }
        unsafe extern "system" fn ChapterPlay<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChapterPlay(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&ulchapter)).into()
        }
        unsafe extern "system" fn TimePlay<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, bcdtime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TimePlay(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&bcdtime)).into()
        }
        unsafe extern "system" fn StopForResume<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopForResume().into()
        }
        unsafe extern "system" fn GoUp<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GoUp().into()
        }
        unsafe extern "system" fn TimeSearch<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bcdtime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TimeSearch(::core::mem::transmute_copy(&bcdtime)).into()
        }
        unsafe extern "system" fn ChapterSearch<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulchapter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChapterSearch(::core::mem::transmute_copy(&ulchapter)).into()
        }
        unsafe extern "system" fn PrevPGSearch<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrevPGSearch().into()
        }
        unsafe extern "system" fn TopPGSearch<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TopPGSearch().into()
        }
        unsafe extern "system" fn NextPGSearch<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NextPGSearch().into()
        }
        unsafe extern "system" fn ForwardScan<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwspeed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ForwardScan(::core::mem::transmute_copy(&dwspeed)).into()
        }
        unsafe extern "system" fn BackwardScan<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwspeed: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BackwardScan(::core::mem::transmute_copy(&dwspeed)).into()
        }
        unsafe extern "system" fn MenuCall<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menuid: DVD_MENU_ID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MenuCall(::core::mem::transmute_copy(&menuid)).into()
        }
        unsafe extern "system" fn Resume<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Resume().into()
        }
        unsafe extern "system" fn UpperButtonSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpperButtonSelect().into()
        }
        unsafe extern "system" fn LowerButtonSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LowerButtonSelect().into()
        }
        unsafe extern "system" fn LeftButtonSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LeftButtonSelect().into()
        }
        unsafe extern "system" fn RightButtonSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RightButtonSelect().into()
        }
        unsafe extern "system" fn ButtonActivate<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ButtonActivate().into()
        }
        unsafe extern "system" fn ButtonSelectAndActivate<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ButtonSelectAndActivate(::core::mem::transmute_copy(&ulbutton)).into()
        }
        unsafe extern "system" fn StillOff<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StillOff().into()
        }
        unsafe extern "system" fn PauseOn<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PauseOn().into()
        }
        unsafe extern "system" fn PauseOff<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PauseOff().into()
        }
        unsafe extern "system" fn MenuLanguageSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, language: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MenuLanguageSelect(::core::mem::transmute_copy(&language)).into()
        }
        unsafe extern "system" fn AudioStreamChange<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulaudio: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AudioStreamChange(::core::mem::transmute_copy(&ulaudio)).into()
        }
        unsafe extern "system" fn SubpictureStreamChange<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulsubpicture: u32, bdisplay: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SubpictureStreamChange(::core::mem::transmute_copy(&ulsubpicture), ::core::mem::transmute_copy(&bdisplay)).into()
        }
        unsafe extern "system" fn AngleChange<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulangle: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AngleChange(::core::mem::transmute_copy(&ulangle)).into()
        }
        unsafe extern "system" fn ParentalLevelSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulparentallevel: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ParentalLevelSelect(::core::mem::transmute_copy(&ulparentallevel)).into()
        }
        unsafe extern "system" fn ParentalCountrySelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wcountry: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ParentalCountrySelect(::core::mem::transmute_copy(&wcountry)).into()
        }
        unsafe extern "system" fn KaraokeAudioPresentationModeChange<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KaraokeAudioPresentationModeChange(::core::mem::transmute_copy(&ulmode)).into()
        }
        unsafe extern "system" fn VideoModePreferrence<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpreferreddisplaymode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).VideoModePreferrence(::core::mem::transmute_copy(&ulpreferreddisplaymode)).into()
        }
        unsafe extern "system" fn SetRoot<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRoot(::core::mem::transmute_copy(&pszpath)).into()
        }
        unsafe extern "system" fn MouseActivate<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseActivate(::core::mem::transmute_copy(&point)).into()
        }
        unsafe extern "system" fn MouseSelect<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseSelect(::core::mem::transmute_copy(&point)).into()
        }
        unsafe extern "system" fn ChapterPlayAutoStop<Impl: IDvdControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChapterPlayAutoStop(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&ulchapter), ::core::mem::transmute_copy(&ulchapterstoplay)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            TitlePlay: TitlePlay::<Impl, IMPL_OFFSET>,
            ChapterPlay: ChapterPlay::<Impl, IMPL_OFFSET>,
            TimePlay: TimePlay::<Impl, IMPL_OFFSET>,
            StopForResume: StopForResume::<Impl, IMPL_OFFSET>,
            GoUp: GoUp::<Impl, IMPL_OFFSET>,
            TimeSearch: TimeSearch::<Impl, IMPL_OFFSET>,
            ChapterSearch: ChapterSearch::<Impl, IMPL_OFFSET>,
            PrevPGSearch: PrevPGSearch::<Impl, IMPL_OFFSET>,
            TopPGSearch: TopPGSearch::<Impl, IMPL_OFFSET>,
            NextPGSearch: NextPGSearch::<Impl, IMPL_OFFSET>,
            ForwardScan: ForwardScan::<Impl, IMPL_OFFSET>,
            BackwardScan: BackwardScan::<Impl, IMPL_OFFSET>,
            MenuCall: MenuCall::<Impl, IMPL_OFFSET>,
            Resume: Resume::<Impl, IMPL_OFFSET>,
            UpperButtonSelect: UpperButtonSelect::<Impl, IMPL_OFFSET>,
            LowerButtonSelect: LowerButtonSelect::<Impl, IMPL_OFFSET>,
            LeftButtonSelect: LeftButtonSelect::<Impl, IMPL_OFFSET>,
            RightButtonSelect: RightButtonSelect::<Impl, IMPL_OFFSET>,
            ButtonActivate: ButtonActivate::<Impl, IMPL_OFFSET>,
            ButtonSelectAndActivate: ButtonSelectAndActivate::<Impl, IMPL_OFFSET>,
            StillOff: StillOff::<Impl, IMPL_OFFSET>,
            PauseOn: PauseOn::<Impl, IMPL_OFFSET>,
            PauseOff: PauseOff::<Impl, IMPL_OFFSET>,
            MenuLanguageSelect: MenuLanguageSelect::<Impl, IMPL_OFFSET>,
            AudioStreamChange: AudioStreamChange::<Impl, IMPL_OFFSET>,
            SubpictureStreamChange: SubpictureStreamChange::<Impl, IMPL_OFFSET>,
            AngleChange: AngleChange::<Impl, IMPL_OFFSET>,
            ParentalLevelSelect: ParentalLevelSelect::<Impl, IMPL_OFFSET>,
            ParentalCountrySelect: ParentalCountrySelect::<Impl, IMPL_OFFSET>,
            KaraokeAudioPresentationModeChange: KaraokeAudioPresentationModeChange::<Impl, IMPL_OFFSET>,
            VideoModePreferrence: VideoModePreferrence::<Impl, IMPL_OFFSET>,
            SetRoot: SetRoot::<Impl, IMPL_OFFSET>,
            MouseActivate: MouseActivate::<Impl, IMPL_OFFSET>,
            MouseSelect: MouseSelect::<Impl, IMPL_OFFSET>,
            ChapterPlayAutoStop: ChapterPlayAutoStop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvdControl2_Impl: Sized {
    fn PlayTitle(&mut self, ultitle: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayChapterInTitle(&mut self, ultitle: u32, ulchapter: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayAtTimeInTitle(&mut self, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::core::option::Option<IDvdCmd>) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn ReturnFromSubmenu(&mut self, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayAtTime(&mut self, ptime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::core::option::Option<IDvdCmd>) -> ::windows::core::Result<()>;
    fn PlayChapter(&mut self, ulchapter: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayPrevChapter(&mut self, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn ReplayChapter(&mut self, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayNextChapter(&mut self, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayForwards(&mut self, dspeed: f64, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayBackwards(&mut self, dspeed: f64, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn ShowMenu(&mut self, menuid: DVD_MENU_ID, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn Resume(&mut self, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SelectRelativeButton(&mut self, buttondir: DVD_RELATIVE_BUTTON) -> ::windows::core::Result<()>;
    fn ActivateButton(&mut self) -> ::windows::core::Result<()>;
    fn SelectButton(&mut self, ulbutton: u32) -> ::windows::core::Result<()>;
    fn SelectAndActivateButton(&mut self, ulbutton: u32) -> ::windows::core::Result<()>;
    fn StillOff(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self, bstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SelectAudioStream(&mut self, ulaudio: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SelectSubpictureStream(&mut self, ulsubpicture: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SetSubpictureState(&mut self, bstate: super::super::Foundation::BOOL, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SelectAngle(&mut self, ulangle: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SelectParentalLevel(&mut self, ulparentallevel: u32) -> ::windows::core::Result<()>;
    fn SelectParentalCountry(&mut self, bcountry: *mut u8) -> ::windows::core::Result<()>;
    fn SelectKaraokeAudioPresentationMode(&mut self, ulmode: u32) -> ::windows::core::Result<()>;
    fn SelectVideoModePreference(&mut self, ulpreferreddisplaymode: u32) -> ::windows::core::Result<()>;
    fn SetDVDDirectory(&mut self, pszwpath: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn ActivateAtPosition(&mut self, point: &super::super::Foundation::POINT) -> ::windows::core::Result<()>;
    fn SelectAtPosition(&mut self, point: &super::super::Foundation::POINT) -> ::windows::core::Result<()>;
    fn PlayChaptersAutoStop(&mut self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn AcceptParentalLevelChange(&mut self, baccept: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetOption(&mut self, flag: DVD_OPTION_FLAG, fstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetState(&mut self, pstate: &::core::option::Option<IDvdState>, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn PlayPeriodInTitleAutoStop(&mut self, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, pendtime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::core::option::Option<IDvdCmd>) -> ::windows::core::Result<()>;
    fn SetGPRM(&mut self, ulindex: u32, wvalue: u16, dwflags: u32) -> ::windows::core::Result<IDvdCmd>;
    fn SelectDefaultMenuLanguage(&mut self, language: u32) -> ::windows::core::Result<()>;
    fn SelectDefaultAudioLanguage(&mut self, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> ::windows::core::Result<()>;
    fn SelectDefaultSubpictureLanguage(&mut self, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvdControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdControl2_Vtbl {
        unsafe extern "system" fn PlayTitle<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayTitle(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayChapterInTitle(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&ulchapter), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTimeInTitle(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&ppcmd)).into()
        }
        unsafe extern "system" fn Stop<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReturnFromSubmenu(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayAtTime<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTime(::core::mem::transmute_copy(&ptime), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&ppcmd)).into()
        }
        unsafe extern "system" fn PlayChapter<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulchapter: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayChapter(::core::mem::transmute_copy(&ulchapter), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayPrevChapter(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReplayChapter<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReplayChapter(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayNextChapter(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayForwards<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayForwards(::core::mem::transmute_copy(&dspeed), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayBackwards<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayBackwards(::core::mem::transmute_copy(&dspeed), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowMenu<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menuid: DVD_MENU_ID, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShowMenu(::core::mem::transmute_copy(&menuid), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Resume<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Resume(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectRelativeButton<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buttondir: DVD_RELATIVE_BUTTON) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectRelativeButton(::core::mem::transmute_copy(&buttondir)).into()
        }
        unsafe extern "system" fn ActivateButton<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateButton().into()
        }
        unsafe extern "system" fn SelectButton<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectButton(::core::mem::transmute_copy(&ulbutton)).into()
        }
        unsafe extern "system" fn SelectAndActivateButton<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbutton: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAndActivateButton(::core::mem::transmute_copy(&ulbutton)).into()
        }
        unsafe extern "system" fn StillOff<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StillOff().into()
        }
        unsafe extern "system" fn Pause<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause(::core::mem::transmute_copy(&bstate)).into()
        }
        unsafe extern "system" fn SelectAudioStream<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulaudio: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectAudioStream(::core::mem::transmute_copy(&ulaudio), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectSubpictureStream<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulsubpicture: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectSubpictureStream(::core::mem::transmute_copy(&ulsubpicture), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubpictureState<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstate: super::super::Foundation::BOOL, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetSubpictureState(::core::mem::transmute_copy(&bstate), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAngle<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulangle: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SelectAngle(::core::mem::transmute_copy(&ulangle), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectParentalLevel<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulparentallevel: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectParentalLevel(::core::mem::transmute_copy(&ulparentallevel)).into()
        }
        unsafe extern "system" fn SelectParentalCountry<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bcountry: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectParentalCountry(::core::mem::transmute_copy(&bcountry)).into()
        }
        unsafe extern "system" fn SelectKaraokeAudioPresentationMode<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectKaraokeAudioPresentationMode(::core::mem::transmute_copy(&ulmode)).into()
        }
        unsafe extern "system" fn SelectVideoModePreference<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulpreferreddisplaymode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectVideoModePreference(::core::mem::transmute_copy(&ulpreferreddisplaymode)).into()
        }
        unsafe extern "system" fn SetDVDDirectory<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDVDDirectory(::core::mem::transmute_copy(&pszwpath)).into()
        }
        unsafe extern "system" fn ActivateAtPosition<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateAtPosition(::core::mem::transmute_copy(&point)).into()
        }
        unsafe extern "system" fn SelectAtPosition<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAtPosition(::core::mem::transmute_copy(&point)).into()
        }
        unsafe extern "system" fn PlayChaptersAutoStop<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayChaptersAutoStop(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&ulchapter), ::core::mem::transmute_copy(&ulchapterstoplay), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptParentalLevelChange<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, baccept: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AcceptParentalLevelChange(::core::mem::transmute_copy(&baccept)).into()
        }
        unsafe extern "system" fn SetOption<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flag: DVD_OPTION_FLAG, fstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOption(::core::mem::transmute_copy(&flag), ::core::mem::transmute_copy(&fstate)).into()
        }
        unsafe extern "system" fn SetState<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstate: ::windows::core::RawPtr, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetState(::core::mem::transmute(&pstate), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayPeriodInTitleAutoStop<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pstarttime: *mut DVD_HMSF_TIMECODE, pendtime: *mut DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayPeriodInTitleAutoStop(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&pendtime), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&ppcmd)).into()
        }
        unsafe extern "system" fn SetGPRM<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulindex: u32, wvalue: u16, dwflags: u32, ppcmd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetGPRM(::core::mem::transmute_copy(&ulindex), ::core::mem::transmute_copy(&wvalue), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcmd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectDefaultMenuLanguage<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, language: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectDefaultMenuLanguage(::core::mem::transmute_copy(&language)).into()
        }
        unsafe extern "system" fn SelectDefaultAudioLanguage<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectDefaultAudioLanguage(::core::mem::transmute_copy(&language), ::core::mem::transmute_copy(&audioextension)).into()
        }
        unsafe extern "system" fn SelectDefaultSubpictureLanguage<Impl: IDvdControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectDefaultSubpictureLanguage(::core::mem::transmute_copy(&language), ::core::mem::transmute_copy(&subpictureextension)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            PlayTitle: PlayTitle::<Impl, IMPL_OFFSET>,
            PlayChapterInTitle: PlayChapterInTitle::<Impl, IMPL_OFFSET>,
            PlayAtTimeInTitle: PlayAtTimeInTitle::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            ReturnFromSubmenu: ReturnFromSubmenu::<Impl, IMPL_OFFSET>,
            PlayAtTime: PlayAtTime::<Impl, IMPL_OFFSET>,
            PlayChapter: PlayChapter::<Impl, IMPL_OFFSET>,
            PlayPrevChapter: PlayPrevChapter::<Impl, IMPL_OFFSET>,
            ReplayChapter: ReplayChapter::<Impl, IMPL_OFFSET>,
            PlayNextChapter: PlayNextChapter::<Impl, IMPL_OFFSET>,
            PlayForwards: PlayForwards::<Impl, IMPL_OFFSET>,
            PlayBackwards: PlayBackwards::<Impl, IMPL_OFFSET>,
            ShowMenu: ShowMenu::<Impl, IMPL_OFFSET>,
            Resume: Resume::<Impl, IMPL_OFFSET>,
            SelectRelativeButton: SelectRelativeButton::<Impl, IMPL_OFFSET>,
            ActivateButton: ActivateButton::<Impl, IMPL_OFFSET>,
            SelectButton: SelectButton::<Impl, IMPL_OFFSET>,
            SelectAndActivateButton: SelectAndActivateButton::<Impl, IMPL_OFFSET>,
            StillOff: StillOff::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            SelectAudioStream: SelectAudioStream::<Impl, IMPL_OFFSET>,
            SelectSubpictureStream: SelectSubpictureStream::<Impl, IMPL_OFFSET>,
            SetSubpictureState: SetSubpictureState::<Impl, IMPL_OFFSET>,
            SelectAngle: SelectAngle::<Impl, IMPL_OFFSET>,
            SelectParentalLevel: SelectParentalLevel::<Impl, IMPL_OFFSET>,
            SelectParentalCountry: SelectParentalCountry::<Impl, IMPL_OFFSET>,
            SelectKaraokeAudioPresentationMode: SelectKaraokeAudioPresentationMode::<Impl, IMPL_OFFSET>,
            SelectVideoModePreference: SelectVideoModePreference::<Impl, IMPL_OFFSET>,
            SetDVDDirectory: SetDVDDirectory::<Impl, IMPL_OFFSET>,
            ActivateAtPosition: ActivateAtPosition::<Impl, IMPL_OFFSET>,
            SelectAtPosition: SelectAtPosition::<Impl, IMPL_OFFSET>,
            PlayChaptersAutoStop: PlayChaptersAutoStop::<Impl, IMPL_OFFSET>,
            AcceptParentalLevelChange: AcceptParentalLevelChange::<Impl, IMPL_OFFSET>,
            SetOption: SetOption::<Impl, IMPL_OFFSET>,
            SetState: SetState::<Impl, IMPL_OFFSET>,
            PlayPeriodInTitleAutoStop: PlayPeriodInTitleAutoStop::<Impl, IMPL_OFFSET>,
            SetGPRM: SetGPRM::<Impl, IMPL_OFFSET>,
            SelectDefaultMenuLanguage: SelectDefaultMenuLanguage::<Impl, IMPL_OFFSET>,
            SelectDefaultAudioLanguage: SelectDefaultAudioLanguage::<Impl, IMPL_OFFSET>,
            SelectDefaultSubpictureLanguage: SelectDefaultSubpictureLanguage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvdGraphBuilder_Impl: Sized {
    fn GetFiltergraph(&mut self) -> ::windows::core::Result<IGraphBuilder>;
    fn GetDvdInterface(&mut self, riid: *const ::windows::core::GUID, ppvif: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn RenderDvdVideoVolume(&mut self, lpcwszpathname: super::super::Foundation::PWSTR, dwflags: u32) -> ::windows::core::Result<AM_DVD_RENDERSTATUS>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvdGraphBuilder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdGraphBuilder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdGraphBuilder_Vtbl {
        unsafe extern "system" fn GetFiltergraph<Impl: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppgb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFiltergraph() {
                ::core::result::Result::Ok(ok__) => {
                    *ppgb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDvdInterface<Impl: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvif: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDvdInterface(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvif)).into()
        }
        unsafe extern "system" fn RenderDvdVideoVolume<Impl: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpcwszpathname: super::super::Foundation::PWSTR, dwflags: u32, pstatus: *mut AM_DVD_RENDERSTATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RenderDvdVideoVolume(::core::mem::transmute_copy(&lpcwszpathname), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFiltergraph: GetFiltergraph::<Impl, IMPL_OFFSET>,
            GetDvdInterface: GetDvdInterface::<Impl, IMPL_OFFSET>,
            RenderDvdVideoVolume: RenderDvdVideoVolume::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdGraphBuilder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvdInfo_Impl: Sized {
    fn GetCurrentDomain(&mut self, pdomain: *mut DVD_DOMAIN) -> ::windows::core::Result<()>;
    fn GetCurrentLocation(&mut self) -> ::windows::core::Result<DVD_PLAYBACK_LOCATION>;
    fn GetTotalTitleTime(&mut self) -> ::windows::core::Result<u32>;
    fn GetCurrentButton(&mut self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentAngle(&mut self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentAudio(&mut self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentSubpicture(&mut self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetCurrentUOPS(&mut self) -> ::windows::core::Result<u32>;
    fn GetAllSPRMs(&mut self) -> ::windows::core::Result<*mut u16>;
    fn GetAllGPRMs(&mut self) -> ::windows::core::Result<*mut u16>;
    fn GetAudioLanguage(&mut self, ulstream: u32) -> ::windows::core::Result<u32>;
    fn GetSubpictureLanguage(&mut self, ulstream: u32) -> ::windows::core::Result<u32>;
    fn GetTitleAttributes(&mut self, ultitle: u32) -> ::windows::core::Result<DVD_ATR>;
    fn GetVMGAttributes(&mut self) -> ::windows::core::Result<DVD_ATR>;
    fn GetCurrentVideoAttributes(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetCurrentAudioAttributes(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetCurrentSubpictureAttributes(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetCurrentVolumeInfo(&mut self, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::Result<()>;
    fn GetDVDTextInfo(&mut self, ptextmanager: *mut u8, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::Result<()>;
    fn GetPlayerParentalLevel(&mut self, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> ::windows::core::Result<()>;
    fn GetNumberOfChapters(&mut self, ultitle: u32) -> ::windows::core::Result<u32>;
    fn GetTitleParentalLevels(&mut self, ultitle: u32) -> ::windows::core::Result<u32>;
    fn GetRoot(&mut self, proot: super::super::Foundation::PSTR, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvdInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdInfo_Vtbl {
        unsafe extern "system" fn GetCurrentDomain<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentDomain(::core::mem::transmute_copy(&pdomain)).into()
        }
        unsafe extern "system" fn GetCurrentLocation<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentLocation() {
                ::core::result::Result::Ok(ok__) => {
                    *plocation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pultotaltime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTotalTitleTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pultotaltime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentButton<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentButton(::core::mem::transmute_copy(&pulbuttonsavailable), ::core::mem::transmute_copy(&pulcurrentbutton)).into()
        }
        unsafe extern "system" fn GetCurrentAngle<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentAngle(::core::mem::transmute_copy(&pulanglesavailable), ::core::mem::transmute_copy(&pulcurrentangle)).into()
        }
        unsafe extern "system" fn GetCurrentAudio<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentAudio(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream)).into()
        }
        unsafe extern "system" fn GetCurrentSubpicture<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentSubpicture(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream), ::core::mem::transmute_copy(&pisdisabled)).into()
        }
        unsafe extern "system" fn GetCurrentUOPS<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puop: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentUOPS() {
                ::core::result::Result::Ok(ok__) => {
                    *puop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllSPRMs() {
                ::core::result::Result::Ok(ok__) => {
                    *pregisterarray = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllGPRMs() {
                ::core::result::Result::Ok(ok__) => {
                    *pregisterarray = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioLanguage(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *planguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSubpictureLanguage(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *planguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, patr: *mut DVD_ATR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTitleAttributes(::core::mem::transmute_copy(&ultitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVMGAttributes<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_ATR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVMGAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentVideoAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentAudioAttributes<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentAudioAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentSubpictureAttributes<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentSubpictureAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVolumeInfo<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentVolumeInfo(::core::mem::transmute_copy(&pulnumofvol), ::core::mem::transmute_copy(&pulthisvolnum), ::core::mem::transmute_copy(&pside), ::core::mem::transmute_copy(&pulnumoftitles)).into()
        }
        unsafe extern "system" fn GetDVDTextInfo<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptextmanager: *mut u8, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDTextInfo(::core::mem::transmute_copy(&ptextmanager), ::core::mem::transmute_copy(&ulbufsize), ::core::mem::transmute_copy(&pulactualsize)).into()
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPlayerParentalLevel(::core::mem::transmute_copy(&pulparentallevel), ::core::mem::transmute_copy(&pulcountrycode)).into()
        }
        unsafe extern "system" fn GetNumberOfChapters<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulnumberofchapters: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfChapters(::core::mem::transmute_copy(&ultitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulnumberofchapters = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTitleParentalLevels(::core::mem::transmute_copy(&ultitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulparentallevels = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRoot<Impl: IDvdInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, proot: super::super::Foundation::PSTR, ulbufsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRoot(::core::mem::transmute_copy(&proot), ::core::mem::transmute_copy(&ulbufsize), ::core::mem::transmute_copy(&pulactualsize)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCurrentDomain: GetCurrentDomain::<Impl, IMPL_OFFSET>,
            GetCurrentLocation: GetCurrentLocation::<Impl, IMPL_OFFSET>,
            GetTotalTitleTime: GetTotalTitleTime::<Impl, IMPL_OFFSET>,
            GetCurrentButton: GetCurrentButton::<Impl, IMPL_OFFSET>,
            GetCurrentAngle: GetCurrentAngle::<Impl, IMPL_OFFSET>,
            GetCurrentAudio: GetCurrentAudio::<Impl, IMPL_OFFSET>,
            GetCurrentSubpicture: GetCurrentSubpicture::<Impl, IMPL_OFFSET>,
            GetCurrentUOPS: GetCurrentUOPS::<Impl, IMPL_OFFSET>,
            GetAllSPRMs: GetAllSPRMs::<Impl, IMPL_OFFSET>,
            GetAllGPRMs: GetAllGPRMs::<Impl, IMPL_OFFSET>,
            GetAudioLanguage: GetAudioLanguage::<Impl, IMPL_OFFSET>,
            GetSubpictureLanguage: GetSubpictureLanguage::<Impl, IMPL_OFFSET>,
            GetTitleAttributes: GetTitleAttributes::<Impl, IMPL_OFFSET>,
            GetVMGAttributes: GetVMGAttributes::<Impl, IMPL_OFFSET>,
            GetCurrentVideoAttributes: GetCurrentVideoAttributes::<Impl, IMPL_OFFSET>,
            GetCurrentAudioAttributes: GetCurrentAudioAttributes::<Impl, IMPL_OFFSET>,
            GetCurrentSubpictureAttributes: GetCurrentSubpictureAttributes::<Impl, IMPL_OFFSET>,
            GetCurrentVolumeInfo: GetCurrentVolumeInfo::<Impl, IMPL_OFFSET>,
            GetDVDTextInfo: GetDVDTextInfo::<Impl, IMPL_OFFSET>,
            GetPlayerParentalLevel: GetPlayerParentalLevel::<Impl, IMPL_OFFSET>,
            GetNumberOfChapters: GetNumberOfChapters::<Impl, IMPL_OFFSET>,
            GetTitleParentalLevels: GetTitleParentalLevels::<Impl, IMPL_OFFSET>,
            GetRoot: GetRoot::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IDvdInfo2_Impl: Sized {
    fn GetCurrentDomain(&mut self) -> ::windows::core::Result<DVD_DOMAIN>;
    fn GetCurrentLocation(&mut self) -> ::windows::core::Result<DVD_PLAYBACK_LOCATION2>;
    fn GetTotalTitleTime(&mut self, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentButton(&mut self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentAngle(&mut self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentAudio(&mut self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::Result<()>;
    fn GetCurrentSubpicture(&mut self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetCurrentUOPS(&mut self) -> ::windows::core::Result<u32>;
    fn GetAllSPRMs(&mut self) -> ::windows::core::Result<*mut u16>;
    fn GetAllGPRMs(&mut self) -> ::windows::core::Result<*mut u16>;
    fn GetAudioLanguage(&mut self, ulstream: u32) -> ::windows::core::Result<u32>;
    fn GetSubpictureLanguage(&mut self, ulstream: u32) -> ::windows::core::Result<u32>;
    fn GetTitleAttributes(&mut self, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> ::windows::core::Result<()>;
    fn GetVMGAttributes(&mut self) -> ::windows::core::Result<DVD_MenuAttributes>;
    fn GetCurrentVideoAttributes(&mut self) -> ::windows::core::Result<DVD_VideoAttributes>;
    fn GetAudioAttributes(&mut self, ulstream: u32) -> ::windows::core::Result<DVD_AudioAttributes>;
    fn GetKaraokeAttributes(&mut self, ulstream: u32) -> ::windows::core::Result<DVD_KaraokeAttributes>;
    fn GetSubpictureAttributes(&mut self, ulstream: u32) -> ::windows::core::Result<DVD_SubpictureAttributes>;
    fn GetDVDVolumeInfo(&mut self, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::Result<()>;
    fn GetDVDTextNumberOfLanguages(&mut self) -> ::windows::core::Result<u32>;
    fn GetDVDTextLanguageInfo(&mut self, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> ::windows::core::Result<()>;
    fn GetDVDTextStringAsNative(&mut self, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::Result<()>;
    fn GetDVDTextStringAsUnicode(&mut self, ullangindex: u32, ulstringindex: u32, pchwbuffer: super::super::Foundation::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::Result<()>;
    fn GetPlayerParentalLevel(&mut self, pulparentallevel: *mut u32, pbcountrycode: *mut u8) -> ::windows::core::Result<()>;
    fn GetNumberOfChapters(&mut self, ultitle: u32) -> ::windows::core::Result<u32>;
    fn GetTitleParentalLevels(&mut self, ultitle: u32) -> ::windows::core::Result<u32>;
    fn GetDVDDirectory(&mut self, pszwpath: super::super::Foundation::PWSTR, ulmaxsize: u32, pulactualsize: *mut u32) -> ::windows::core::Result<()>;
    fn IsAudioStreamEnabled(&mut self, ulstreamnum: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetDiscID(&mut self, pszwpath: super::super::Foundation::PWSTR) -> ::windows::core::Result<u64>;
    fn GetState(&mut self) -> ::windows::core::Result<IDvdState>;
    fn GetMenuLanguages(&mut self, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> ::windows::core::Result<()>;
    fn GetButtonAtPosition(&mut self, point: &super::super::Foundation::POINT) -> ::windows::core::Result<u32>;
    fn GetCmdFromEvent(&mut self, lparam1: isize) -> ::windows::core::Result<IDvdCmd>;
    fn GetDefaultMenuLanguage(&mut self) -> ::windows::core::Result<u32>;
    fn GetDefaultAudioLanguage(&mut self, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> ::windows::core::Result<()>;
    fn GetDefaultSubpictureLanguage(&mut self, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::Result<()>;
    fn GetDecoderCaps(&mut self) -> ::windows::core::Result<DVD_DECODER_CAPS>;
    fn GetButtonRect(&mut self, ulbutton: u32) -> ::windows::core::Result<super::super::Foundation::RECT>;
    fn IsSubpictureStreamEnabled(&mut self, ulstreamnum: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IDvdInfo2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdInfo2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdInfo2_Vtbl {
        unsafe extern "system" fn GetCurrentDomain<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentDomain() {
                ::core::result::Result::Ok(ok__) => {
                    *pdomain = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentLocation<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION2) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentLocation() {
                ::core::result::Result::Ok(ok__) => {
                    *plocation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTotalTitleTime(::core::mem::transmute_copy(&ptotaltime), ::core::mem::transmute_copy(&ultimecodeflags)).into()
        }
        unsafe extern "system" fn GetCurrentButton<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentButton(::core::mem::transmute_copy(&pulbuttonsavailable), ::core::mem::transmute_copy(&pulcurrentbutton)).into()
        }
        unsafe extern "system" fn GetCurrentAngle<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentAngle(::core::mem::transmute_copy(&pulanglesavailable), ::core::mem::transmute_copy(&pulcurrentangle)).into()
        }
        unsafe extern "system" fn GetCurrentAudio<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentAudio(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream)).into()
        }
        unsafe extern "system" fn GetCurrentSubpicture<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentSubpicture(::core::mem::transmute_copy(&pulstreamsavailable), ::core::mem::transmute_copy(&pulcurrentstream), ::core::mem::transmute_copy(&pbisdisabled)).into()
        }
        unsafe extern "system" fn GetCurrentUOPS<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puluops: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentUOPS() {
                ::core::result::Result::Ok(ok__) => {
                    *puluops = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllSPRMs() {
                ::core::result::Result::Ok(ok__) => {
                    *pregisterarray = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pregisterarray: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllGPRMs() {
                ::core::result::Result::Ok(ok__) => {
                    *pregisterarray = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioLanguage(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *planguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSubpictureLanguage(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *planguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTitleAttributes(::core::mem::transmute_copy(&ultitle), ::core::mem::transmute_copy(&pmenu), ::core::mem::transmute_copy(&ptitle)).into()
        }
        unsafe extern "system" fn GetVMGAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_MenuAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVMGAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, patr: *mut DVD_VideoAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentVideoAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, patr: *mut DVD_AudioAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioAttributes(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKaraokeAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, pattributes: *mut DVD_KaraokeAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetKaraokeAttributes(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *pattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubpictureAttributes<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstream: u32, patr: *mut DVD_SubpictureAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSubpictureAttributes(::core::mem::transmute_copy(&ulstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *patr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDVolumeInfo<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDVolumeInfo(::core::mem::transmute_copy(&pulnumofvolumes), ::core::mem::transmute_copy(&pulvolume), ::core::mem::transmute_copy(&pside), ::core::mem::transmute_copy(&pulnumoftitles)).into()
        }
        unsafe extern "system" fn GetDVDTextNumberOfLanguages<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulnumoflangs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDVDTextNumberOfLanguages() {
                ::core::result::Result::Ok(ok__) => {
                    *pulnumoflangs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDTextLanguageInfo<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDTextLanguageInfo(::core::mem::transmute_copy(&ullangindex), ::core::mem::transmute_copy(&pulnumofstrings), ::core::mem::transmute_copy(&plangcode), ::core::mem::transmute_copy(&pbcharacterset)).into()
        }
        unsafe extern "system" fn GetDVDTextStringAsNative<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDTextStringAsNative(::core::mem::transmute_copy(&ullangindex), ::core::mem::transmute_copy(&ulstringindex), ::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&ulmaxbuffersize), ::core::mem::transmute_copy(&pulactualsize), ::core::mem::transmute_copy(&ptype)).into()
        }
        unsafe extern "system" fn GetDVDTextStringAsUnicode<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pchwbuffer: super::super::Foundation::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDTextStringAsUnicode(::core::mem::transmute_copy(&ullangindex), ::core::mem::transmute_copy(&ulstringindex), ::core::mem::transmute_copy(&pchwbuffer), ::core::mem::transmute_copy(&ulmaxbuffersize), ::core::mem::transmute_copy(&pulactualsize), ::core::mem::transmute_copy(&ptype)).into()
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32, pbcountrycode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPlayerParentalLevel(::core::mem::transmute_copy(&pulparentallevel), ::core::mem::transmute_copy(&pbcountrycode)).into()
        }
        unsafe extern "system" fn GetNumberOfChapters<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulnumofchapters: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfChapters(::core::mem::transmute_copy(&ultitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulnumofchapters = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTitleParentalLevels(::core::mem::transmute_copy(&ultitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulparentallevels = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDVDDirectory<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR, ulmaxsize: u32, pulactualsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDVDDirectory(::core::mem::transmute_copy(&pszwpath), ::core::mem::transmute_copy(&ulmaxsize), ::core::mem::transmute_copy(&pulactualsize)).into()
        }
        unsafe extern "system" fn IsAudioStreamEnabled<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioStreamEnabled(::core::mem::transmute_copy(&ulstreamnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDiscID<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszwpath: super::super::Foundation::PWSTR, pulldiscid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDiscID(::core::mem::transmute_copy(&pszwpath)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulldiscid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatedata: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState() {
                ::core::result::Result::Ok(ok__) => {
                    *pstatedata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMenuLanguages<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMenuLanguages(::core::mem::transmute_copy(&planguages), ::core::mem::transmute_copy(&ulmaxlanguages), ::core::mem::transmute_copy(&pulactuallanguages)).into()
        }
        unsafe extern "system" fn GetButtonAtPosition<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, point: super::super::Foundation::POINT, pulbuttonindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetButtonAtPosition(::core::mem::transmute_copy(&point)) {
                ::core::result::Result::Ok(ok__) => {
                    *pulbuttonindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCmdFromEvent<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lparam1: isize, pcmdobj: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCmdFromEvent(::core::mem::transmute_copy(&lparam1)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcmdobj = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultMenuLanguage<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planguage: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultMenuLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *planguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultAudioLanguage<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDefaultAudioLanguage(::core::mem::transmute_copy(&planguage), ::core::mem::transmute_copy(&paudioextension)).into()
        }
        unsafe extern "system" fn GetDefaultSubpictureLanguage<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDefaultSubpictureLanguage(::core::mem::transmute_copy(&planguage), ::core::mem::transmute_copy(&psubpictureextension)).into()
        }
        unsafe extern "system" fn GetDecoderCaps<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcaps: *mut DVD_DECODER_CAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDecoderCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetButtonRect<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbutton: u32, prect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetButtonRect(::core::mem::transmute_copy(&ulbutton)) {
                ::core::result::Result::Ok(ok__) => {
                    *prect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSubpictureStreamEnabled<Impl: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSubpictureStreamEnabled(::core::mem::transmute_copy(&ulstreamnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCurrentDomain: GetCurrentDomain::<Impl, IMPL_OFFSET>,
            GetCurrentLocation: GetCurrentLocation::<Impl, IMPL_OFFSET>,
            GetTotalTitleTime: GetTotalTitleTime::<Impl, IMPL_OFFSET>,
            GetCurrentButton: GetCurrentButton::<Impl, IMPL_OFFSET>,
            GetCurrentAngle: GetCurrentAngle::<Impl, IMPL_OFFSET>,
            GetCurrentAudio: GetCurrentAudio::<Impl, IMPL_OFFSET>,
            GetCurrentSubpicture: GetCurrentSubpicture::<Impl, IMPL_OFFSET>,
            GetCurrentUOPS: GetCurrentUOPS::<Impl, IMPL_OFFSET>,
            GetAllSPRMs: GetAllSPRMs::<Impl, IMPL_OFFSET>,
            GetAllGPRMs: GetAllGPRMs::<Impl, IMPL_OFFSET>,
            GetAudioLanguage: GetAudioLanguage::<Impl, IMPL_OFFSET>,
            GetSubpictureLanguage: GetSubpictureLanguage::<Impl, IMPL_OFFSET>,
            GetTitleAttributes: GetTitleAttributes::<Impl, IMPL_OFFSET>,
            GetVMGAttributes: GetVMGAttributes::<Impl, IMPL_OFFSET>,
            GetCurrentVideoAttributes: GetCurrentVideoAttributes::<Impl, IMPL_OFFSET>,
            GetAudioAttributes: GetAudioAttributes::<Impl, IMPL_OFFSET>,
            GetKaraokeAttributes: GetKaraokeAttributes::<Impl, IMPL_OFFSET>,
            GetSubpictureAttributes: GetSubpictureAttributes::<Impl, IMPL_OFFSET>,
            GetDVDVolumeInfo: GetDVDVolumeInfo::<Impl, IMPL_OFFSET>,
            GetDVDTextNumberOfLanguages: GetDVDTextNumberOfLanguages::<Impl, IMPL_OFFSET>,
            GetDVDTextLanguageInfo: GetDVDTextLanguageInfo::<Impl, IMPL_OFFSET>,
            GetDVDTextStringAsNative: GetDVDTextStringAsNative::<Impl, IMPL_OFFSET>,
            GetDVDTextStringAsUnicode: GetDVDTextStringAsUnicode::<Impl, IMPL_OFFSET>,
            GetPlayerParentalLevel: GetPlayerParentalLevel::<Impl, IMPL_OFFSET>,
            GetNumberOfChapters: GetNumberOfChapters::<Impl, IMPL_OFFSET>,
            GetTitleParentalLevels: GetTitleParentalLevels::<Impl, IMPL_OFFSET>,
            GetDVDDirectory: GetDVDDirectory::<Impl, IMPL_OFFSET>,
            IsAudioStreamEnabled: IsAudioStreamEnabled::<Impl, IMPL_OFFSET>,
            GetDiscID: GetDiscID::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            GetMenuLanguages: GetMenuLanguages::<Impl, IMPL_OFFSET>,
            GetButtonAtPosition: GetButtonAtPosition::<Impl, IMPL_OFFSET>,
            GetCmdFromEvent: GetCmdFromEvent::<Impl, IMPL_OFFSET>,
            GetDefaultMenuLanguage: GetDefaultMenuLanguage::<Impl, IMPL_OFFSET>,
            GetDefaultAudioLanguage: GetDefaultAudioLanguage::<Impl, IMPL_OFFSET>,
            GetDefaultSubpictureLanguage: GetDefaultSubpictureLanguage::<Impl, IMPL_OFFSET>,
            GetDecoderCaps: GetDecoderCaps::<Impl, IMPL_OFFSET>,
            GetButtonRect: GetButtonRect::<Impl, IMPL_OFFSET>,
            IsSubpictureStreamEnabled: IsSubpictureStreamEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdInfo2 as ::windows::core::Interface>::IID
    }
}
pub trait IDvdState_Impl: Sized {
    fn GetDiscID(&mut self) -> ::windows::core::Result<u64>;
    fn GetParentalLevel(&mut self) -> ::windows::core::Result<u32>;
}
impl IDvdState_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDvdState_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDvdState_Vtbl {
        unsafe extern "system" fn GetDiscID<Impl: IDvdState_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulluniqueid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDiscID() {
                ::core::result::Result::Ok(ok__) => {
                    *pulluniqueid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalLevel<Impl: IDvdState_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulparentallevel: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParentalLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *pulparentallevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDiscID: GetDiscID::<Impl, IMPL_OFFSET>,
            GetParentalLevel: GetParentalLevel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDvdState as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESCloseMmiEvent_Impl: Sized + IESEvent_Impl {
    fn GetDialogNumber(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESCloseMmiEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESCloseMmiEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESCloseMmiEvent_Vtbl {
        unsafe extern "system" fn GetDialogNumber<Impl: IESCloseMmiEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdialognumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDialogNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pdialognumber = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetDialogNumber: GetDialogNumber::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESCloseMmiEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESEvent_Impl: Sized {
    fn GetEventId(&mut self) -> ::windows::core::Result<u32>;
    fn GetEventType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetCompletionStatus(&mut self, dwresult: u32) -> ::windows::core::Result<()>;
    fn GetData(&mut self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY>;
    fn GetStringData(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESEvent_Vtbl {
        unsafe extern "system" fn GetEventId<Impl: IESEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdweventid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEventId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdweventid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEventType<Impl: IESEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguideventtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEventType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguideventtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompletionStatus<Impl: IESEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwresult: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCompletionStatus(::core::mem::transmute_copy(&dwresult)).into()
        }
        unsafe extern "system" fn GetData<Impl: IESEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetData() {
                ::core::result::Result::Ok(ok__) => {
                    *pbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStringData<Impl: IESEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrdata: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStringData() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEventId: GetEventId::<Impl, IMPL_OFFSET>,
            GetEventType: GetEventType::<Impl, IMPL_OFFSET>,
            SetCompletionStatus: SetCompletionStatus::<Impl, IMPL_OFFSET>,
            GetData: GetData::<Impl, IMPL_OFFSET>,
            GetStringData: GetStringData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IESEventFactory_Impl: Sized {
    fn CreateESEvent(&mut self, pserviceprovider: &::core::option::Option<::windows::core::IUnknown>, dweventid: u32, guideventtype: &::windows::core::GUID, dweventdatalength: u32, peventdata: *const u8, bstrbaseurl: &super::super::Foundation::BSTR, pinitcontext: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<IESEvent>;
}
#[cfg(feature = "Win32_Foundation")]
impl IESEventFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESEventFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESEventFactory_Vtbl {
        unsafe extern "system" fn CreateESEvent<Impl: IESEventFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pserviceprovider: *mut ::core::ffi::c_void, dweventid: u32, guideventtype: ::windows::core::GUID, dweventdatalength: u32, peventdata: *const u8, bstrbaseurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pinitcontext: *mut ::core::ffi::c_void, ppesevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateESEvent(::core::mem::transmute(&pserviceprovider), ::core::mem::transmute_copy(&dweventid), ::core::mem::transmute_copy(&guideventtype), ::core::mem::transmute_copy(&dweventdatalength), ::core::mem::transmute_copy(&peventdata), ::core::mem::transmute_copy(&bstrbaseurl), ::core::mem::transmute(&pinitcontext)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppesevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateESEvent: CreateESEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESEventFactory as ::windows::core::Interface>::IID
    }
}
pub trait IESEventService_Impl: Sized {
    fn FireESEvent(&mut self, pesevent: &::core::option::Option<IESEvent>) -> ::windows::core::Result<()>;
}
impl IESEventService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESEventService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESEventService_Vtbl {
        unsafe extern "system" fn FireESEvent<Impl: IESEventService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pesevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FireESEvent(::core::mem::transmute(&pesevent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), FireESEvent: FireESEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESEventService as ::windows::core::Interface>::IID
    }
}
pub trait IESEventServiceConfiguration_Impl: Sized {
    fn SetParent(&mut self, peventservice: &::core::option::Option<IESEventService>) -> ::windows::core::Result<()>;
    fn RemoveParent(&mut self) -> ::windows::core::Result<()>;
    fn SetOwner(&mut self, pesevents: &::core::option::Option<IESEvents>) -> ::windows::core::Result<()>;
    fn RemoveOwner(&mut self) -> ::windows::core::Result<()>;
    fn SetGraph(&mut self, pgraph: &::core::option::Option<IFilterGraph>) -> ::windows::core::Result<()>;
    fn RemoveGraph(&mut self, pgraph: &::core::option::Option<IFilterGraph>) -> ::windows::core::Result<()>;
}
impl IESEventServiceConfiguration_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESEventServiceConfiguration_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESEventServiceConfiguration_Vtbl {
        unsafe extern "system" fn SetParent<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peventservice: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetParent(::core::mem::transmute(&peventservice)).into()
        }
        unsafe extern "system" fn RemoveParent<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveParent().into()
        }
        unsafe extern "system" fn SetOwner<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pesevents: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOwner(::core::mem::transmute(&pesevents)).into()
        }
        unsafe extern "system" fn RemoveOwner<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveOwner().into()
        }
        unsafe extern "system" fn SetGraph<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGraph(::core::mem::transmute(&pgraph)).into()
        }
        unsafe extern "system" fn RemoveGraph<Impl: IESEventServiceConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveGraph(::core::mem::transmute(&pgraph)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetParent: SetParent::<Impl, IMPL_OFFSET>,
            RemoveParent: RemoveParent::<Impl, IMPL_OFFSET>,
            SetOwner: SetOwner::<Impl, IMPL_OFFSET>,
            RemoveOwner: RemoveOwner::<Impl, IMPL_OFFSET>,
            SetGraph: SetGraph::<Impl, IMPL_OFFSET>,
            RemoveGraph: RemoveGraph::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESEventServiceConfiguration as ::windows::core::Interface>::IID
    }
}
pub trait IESEvents_Impl: Sized {
    fn OnESEventReceived(&mut self, guideventtype: &::windows::core::GUID, pesevent: &::core::option::Option<IESEvent>) -> ::windows::core::Result<()>;
}
impl IESEvents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESEvents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESEvents_Vtbl {
        unsafe extern "system" fn OnESEventReceived<Impl: IESEvents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guideventtype: ::windows::core::GUID, pesevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnESEventReceived(::core::mem::transmute_copy(&guideventtype), ::core::mem::transmute(&pesevent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnESEventReceived: OnESEventReceived::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESEvents as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESFileExpiryDateEvent_Impl: Sized + IESEvent_Impl {
    fn GetTunerId(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetExpiryDate(&mut self) -> ::windows::core::Result<u64>;
    fn GetFinalExpiryDate(&mut self) -> ::windows::core::Result<u64>;
    fn GetMaxRenewalCount(&mut self) -> ::windows::core::Result<u32>;
    fn IsEntitlementTokenPresent(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn DoesExpireAfterFirstUse(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESFileExpiryDateEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESFileExpiryDateEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESFileExpiryDateEvent_Vtbl {
        unsafe extern "system" fn GetTunerId<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtunerid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTunerId() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidtunerid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiryDate<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExpiryDate() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwexpirydate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFinalExpiryDate<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFinalExpiryDate() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwexpirydate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxRenewalCount<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxrenewalcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaxRenewalCount() {
                ::core::result::Result::Ok(ok__) => {
                    *dwmaxrenewalcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEntitlementTokenPresent<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfenttokenpresent: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEntitlementTokenPresent() {
                ::core::result::Result::Ok(ok__) => {
                    *pfenttokenpresent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DoesExpireAfterFirstUse<Impl: IESFileExpiryDateEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfexpireafterfirstuse: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DoesExpireAfterFirstUse() {
                ::core::result::Result::Ok(ok__) => {
                    *pfexpireafterfirstuse = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetTunerId: GetTunerId::<Impl, IMPL_OFFSET>,
            GetExpiryDate: GetExpiryDate::<Impl, IMPL_OFFSET>,
            GetFinalExpiryDate: GetFinalExpiryDate::<Impl, IMPL_OFFSET>,
            GetMaxRenewalCount: GetMaxRenewalCount::<Impl, IMPL_OFFSET>,
            IsEntitlementTokenPresent: IsEntitlementTokenPresent::<Impl, IMPL_OFFSET>,
            DoesExpireAfterFirstUse: DoesExpireAfterFirstUse::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESFileExpiryDateEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESIsdbCasResponseEvent_Impl: Sized + IESEvent_Impl {
    fn GetRequestId(&mut self) -> ::windows::core::Result<u32>;
    fn GetStatus(&mut self) -> ::windows::core::Result<u32>;
    fn GetDataLength(&mut self) -> ::windows::core::Result<u32>;
    fn GetResponseData(&mut self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESIsdbCasResponseEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESIsdbCasResponseEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESIsdbCasResponseEvent_Vtbl {
        unsafe extern "system" fn GetRequestId<Impl: IESIsdbCasResponseEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prequestid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRequestId() {
                ::core::result::Result::Ok(ok__) => {
                    *prequestid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IESIsdbCasResponseEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataLength<Impl: IESIsdbCasResponseEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prequestlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataLength() {
                ::core::result::Result::Ok(ok__) => {
                    *prequestlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetResponseData<Impl: IESIsdbCasResponseEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetResponseData() {
                ::core::result::Result::Ok(ok__) => {
                    *pbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetRequestId: GetRequestId::<Impl, IMPL_OFFSET>,
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            GetDataLength: GetDataLength::<Impl, IMPL_OFFSET>,
            GetResponseData: GetResponseData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESIsdbCasResponseEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESLicenseRenewalResultEvent_Impl: Sized + IESEvent_Impl {
    fn GetCallersId(&mut self) -> ::windows::core::Result<u32>;
    fn GetFileName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn IsRenewalSuccessful(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn IsCheckEntitlementCallRequired(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetDescrambledStatus(&mut self) -> ::windows::core::Result<u32>;
    fn GetRenewalResultCode(&mut self) -> ::windows::core::Result<u32>;
    fn GetCASFailureCode(&mut self) -> ::windows::core::Result<u32>;
    fn GetRenewalHResult(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
    fn GetEntitlementTokenLength(&mut self) -> ::windows::core::Result<u32>;
    fn GetEntitlementToken(&mut self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY>;
    fn GetExpiryDate(&mut self) -> ::windows::core::Result<u64>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESLicenseRenewalResultEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESLicenseRenewalResultEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESLicenseRenewalResultEvent_Vtbl {
        unsafe extern "system" fn GetCallersId<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcallersid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCallersId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcallersid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFileName<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrfilename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFileName() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrfilename = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRenewalSuccessful<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfrenewalsuccessful: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsRenewalSuccessful() {
                ::core::result::Result::Ok(ok__) => {
                    *pfrenewalsuccessful = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCheckEntitlementCallRequired<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfcheckenttokencallneeded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCheckEntitlementCallRequired() {
                ::core::result::Result::Ok(ok__) => {
                    *pfcheckenttokencallneeded = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescrambledStatus<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdescrambledstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDescrambledStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pdescrambledstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenewalResultCode<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrenewalresultcode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenewalResultCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrenewalresultcode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASFailureCode<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcasfailurecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCASFailureCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcasfailurecode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenewalHResult<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phr: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenewalHResult() {
                ::core::result::Result::Ok(ok__) => {
                    *phr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntitlementTokenLength<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntitlementTokenLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntitlementToken<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntitlementToken() {
                ::core::result::Result::Ok(ok__) => {
                    *pbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiryDate<Impl: IESLicenseRenewalResultEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwexpirydate: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExpiryDate() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwexpirydate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetCallersId: GetCallersId::<Impl, IMPL_OFFSET>,
            GetFileName: GetFileName::<Impl, IMPL_OFFSET>,
            IsRenewalSuccessful: IsRenewalSuccessful::<Impl, IMPL_OFFSET>,
            IsCheckEntitlementCallRequired: IsCheckEntitlementCallRequired::<Impl, IMPL_OFFSET>,
            GetDescrambledStatus: GetDescrambledStatus::<Impl, IMPL_OFFSET>,
            GetRenewalResultCode: GetRenewalResultCode::<Impl, IMPL_OFFSET>,
            GetCASFailureCode: GetCASFailureCode::<Impl, IMPL_OFFSET>,
            GetRenewalHResult: GetRenewalHResult::<Impl, IMPL_OFFSET>,
            GetEntitlementTokenLength: GetEntitlementTokenLength::<Impl, IMPL_OFFSET>,
            GetEntitlementToken: GetEntitlementToken::<Impl, IMPL_OFFSET>,
            GetExpiryDate: GetExpiryDate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESLicenseRenewalResultEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESOpenMmiEvent_Impl: Sized + IESEvent_Impl {
    fn GetDialogNumber(&mut self, pdialogrequest: *mut u32, pdialognumber: *mut u32) -> ::windows::core::Result<()>;
    fn GetDialogType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetDialogData(&mut self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY>;
    fn GetDialogStringData(&mut self, pbstrbaseurl: *mut super::super::Foundation::BSTR, pbstrdata: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESOpenMmiEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESOpenMmiEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESOpenMmiEvent_Vtbl {
        unsafe extern "system" fn GetDialogNumber<Impl: IESOpenMmiEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdialogrequest: *mut u32, pdialognumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDialogNumber(::core::mem::transmute_copy(&pdialogrequest), ::core::mem::transmute_copy(&pdialognumber)).into()
        }
        unsafe extern "system" fn GetDialogType<Impl: IESOpenMmiEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guiddialogtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDialogType() {
                ::core::result::Result::Ok(ok__) => {
                    *guiddialogtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDialogData<Impl: IESOpenMmiEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDialogData() {
                ::core::result::Result::Ok(ok__) => {
                    *pbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDialogStringData<Impl: IESOpenMmiEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrbaseurl: *mut super::super::Foundation::BSTR, pbstrdata: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDialogStringData(::core::mem::transmute_copy(&pbstrbaseurl), ::core::mem::transmute_copy(&pbstrdata)).into()
        }
        Self {
            base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDialogNumber: GetDialogNumber::<Impl, IMPL_OFFSET>,
            GetDialogType: GetDialogType::<Impl, IMPL_OFFSET>,
            GetDialogData: GetDialogData::<Impl, IMPL_OFFSET>,
            GetDialogStringData: GetDialogStringData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESOpenMmiEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESRequestTunerEvent_Impl: Sized + IESEvent_Impl {
    fn GetPriority(&mut self) -> ::windows::core::Result<u8>;
    fn GetReason(&mut self) -> ::windows::core::Result<u8>;
    fn GetConsequences(&mut self) -> ::windows::core::Result<u8>;
    fn GetEstimatedTime(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESRequestTunerEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESRequestTunerEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESRequestTunerEvent_Vtbl {
        unsafe extern "system" fn GetPriority<Impl: IESRequestTunerEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbypriority: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPriority() {
                ::core::result::Result::Ok(ok__) => {
                    *pbypriority = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReason<Impl: IESRequestTunerEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbyreason: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetReason() {
                ::core::result::Result::Ok(ok__) => {
                    *pbyreason = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConsequences<Impl: IESRequestTunerEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbyconsequences: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConsequences() {
                ::core::result::Result::Ok(ok__) => {
                    *pbyconsequences = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEstimatedTime<Impl: IESRequestTunerEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwestimatedtime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEstimatedTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwestimatedtime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetPriority: GetPriority::<Impl, IMPL_OFFSET>,
            GetReason: GetReason::<Impl, IMPL_OFFSET>,
            GetConsequences: GetConsequences::<Impl, IMPL_OFFSET>,
            GetEstimatedTime: GetEstimatedTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESRequestTunerEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IESValueUpdatedEvent_Impl: Sized + IESEvent_Impl {
    fn GetValueNames(&mut self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IESValueUpdatedEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IESValueUpdatedEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IESValueUpdatedEvent_Vtbl {
        unsafe extern "system" fn GetValueNames<Impl: IESValueUpdatedEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrnames: *mut *mut super::super::System::Com::SAFEARRAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValueNames() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrnames = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IESEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetValueNames: GetValueNames::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IESValueUpdatedEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IETFilter_Impl: Sized {
    fn EvalRatObjOK(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
    fn GetCurrRating(&mut self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::Result<()>;
    fn GetCurrLicenseExpDate(&mut self, prottype: *const ProtType) -> ::windows::core::Result<i32>;
    fn GetLastErrorCode(&mut self) -> ::windows::core::Result<()>;
    fn SetRecordingOn(&mut self, frecstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IETFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IETFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IETFilter_Vtbl {
        unsafe extern "system" fn EvalRatObjOK<Impl: IETFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EvalRatObjOK() {
                ::core::result::Result::Ok(ok__) => {
                    *phrcocreateretval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrRating<Impl: IETFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrRating(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&plbfenattr)).into()
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IETFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(::core::mem::transmute_copy(&prottype)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdatetime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IETFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLastErrorCode().into()
        }
        unsafe extern "system" fn SetRecordingOn<Impl: IETFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frecstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRecordingOn(::core::mem::transmute_copy(&frecstate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            EvalRatObjOK: EvalRatObjOK::<Impl, IMPL_OFFSET>,
            GetCurrRating: GetCurrRating::<Impl, IMPL_OFFSET>,
            GetCurrLicenseExpDate: GetCurrLicenseExpDate::<Impl, IMPL_OFFSET>,
            GetLastErrorCode: GetLastErrorCode::<Impl, IMPL_OFFSET>,
            SetRecordingOn: SetRecordingOn::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IETFilter as ::windows::core::Interface>::IID
    }
}
pub trait IETFilterConfig_Impl: Sized {
    fn InitLicense(&mut self, licenseid: i32) -> ::windows::core::Result<()>;
    fn GetSecureChannelObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IETFilterConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IETFilterConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IETFilterConfig_Vtbl {
        unsafe extern "system" fn InitLicense<Impl: IETFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, licenseid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitLicense(::core::mem::transmute_copy(&licenseid)).into()
        }
        unsafe extern "system" fn GetSecureChannelObject<Impl: IETFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkdrmsecurechannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitLicense: InitLicense::<Impl, IMPL_OFFSET>,
            GetSecureChannelObject: GetSecureChannelObject::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IETFilterConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IETFilterEvents_Impl: Sized + super::super::System::Com::IDispatch_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IETFilterEvents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IETFilterEvents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IETFilterEvents_Vtbl {
        Self { base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IETFilterEvents as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IEncoderAPI_Impl: Sized {
    fn IsSupported(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn IsAvailable(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetParameterRange(&mut self, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn GetParameterValues(&mut self, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::Result<()>;
    fn GetDefaultValue(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn GetValue(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn SetValue(&mut self, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IEncoderAPI_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEncoderAPI_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEncoderAPI_Vtbl {
        unsafe extern "system" fn IsSupported<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSupported(::core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn IsAvailable<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsAvailable(::core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn GetParameterRange<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParameterRange(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&valuemin), ::core::mem::transmute_copy(&valuemax), ::core::mem::transmute_copy(&steppingdelta)).into()
        }
        unsafe extern "system" fn GetParameterValues<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParameterValues(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&values), ::core::mem::transmute_copy(&valuescount)).into()
        }
        unsafe extern "system" fn GetDefaultValue<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultValue(::core::mem::transmute_copy(&api)) {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValue(::core::mem::transmute_copy(&api)) {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValue(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&value)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsSupported: IsSupported::<Impl, IMPL_OFFSET>,
            IsAvailable: IsAvailable::<Impl, IMPL_OFFSET>,
            GetParameterRange: GetParameterRange::<Impl, IMPL_OFFSET>,
            GetParameterValues: GetParameterValues::<Impl, IMPL_OFFSET>,
            GetDefaultValue: GetDefaultValue::<Impl, IMPL_OFFSET>,
            GetValue: GetValue::<Impl, IMPL_OFFSET>,
            SetValue: SetValue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEncoderAPI as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumComponentTypes_Impl: Sized {
    fn Next(&mut self, celt: u32, rgelt: *mut ::core::option::Option<IComponentType>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumComponentTypes>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumComponentTypes_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumComponentTypes_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumComponentTypes_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumComponentTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumComponentTypes as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumComponents_Impl: Sized {
    fn Next(&mut self, celt: u32, rgelt: *mut ::core::option::Option<IComponent>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumComponents>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumComponents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumComponents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumComponents_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumComponents_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumComponents as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumFilters_Impl: Sized {
    fn Next(&mut self, cfilters: u32, ppfilter: *mut ::core::option::Option<IBaseFilter>, pcfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, cfilters: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumFilters>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumFilters_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumFilters_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumFilters_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cfilters: u32, ppfilter: *mut ::windows::core::RawPtr, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&cfilters), ::core::mem::transmute_copy(&ppfilter), ::core::mem::transmute_copy(&pcfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cfilters: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&cfilters)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumFilters as ::windows::core::Interface>::IID
    }
}
pub trait IEnumGuideDataProperties_Impl: Sized {
    fn Next(&mut self, celt: u32, ppprop: *mut ::core::option::Option<IGuideDataProperty>, pcelt: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumGuideDataProperties>;
}
impl IEnumGuideDataProperties_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumGuideDataProperties_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumGuideDataProperties_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumGuideDataProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, ppprop: *mut ::windows::core::RawPtr, pcelt: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&ppprop), ::core::mem::transmute_copy(&pcelt)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumGuideDataProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumGuideDataProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumGuideDataProperties_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumGuideDataProperties as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumMSVidGraphSegment_Impl: Sized {
    fn Next(&mut self, celt: u32, rgelt: *mut ::core::option::Option<IMSVidGraphSegment>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumMSVidGraphSegment>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumMSVidGraphSegment_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumMSVidGraphSegment_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumMSVidGraphSegment_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumMSVidGraphSegment as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IEnumMediaTypes_Impl: Sized {
    fn Next(&mut self, cmediatypes: u32, ppmediatypes: *mut *mut AM_MEDIA_TYPE, pcfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, cmediatypes: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumMediaTypes>;
}
#[cfg(feature = "Win32_Foundation")]
impl IEnumMediaTypes_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumMediaTypes_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumMediaTypes_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cmediatypes: u32, ppmediatypes: *mut *mut AM_MEDIA_TYPE, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&cmediatypes), ::core::mem::transmute_copy(&ppmediatypes), ::core::mem::transmute_copy(&pcfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cmediatypes: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&cmediatypes)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumMediaTypes as ::windows::core::Interface>::IID
    }
}
pub trait IEnumPIDMap_Impl: Sized {
    fn Next(&mut self, crequest: u32, ppidmap: *mut PID_MAP, pcreceived: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, crecords: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumPIDMap>;
}
impl IEnumPIDMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumPIDMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumPIDMap_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crequest: u32, ppidmap: *mut PID_MAP, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&crequest), ::core::mem::transmute_copy(&ppidmap), ::core::mem::transmute_copy(&pcreceived)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&crecords)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumpidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumpidmap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumPIDMap as ::windows::core::Interface>::IID
    }
}
pub trait IEnumPins_Impl: Sized {
    fn Next(&mut self, cpins: u32, pppins: *mut ::core::option::Option<IPin>, pcfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, cpins: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumPins>;
}
impl IEnumPins_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumPins_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumPins_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumPins_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cpins: u32, pppins: *mut ::windows::core::RawPtr, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&cpins), ::core::mem::transmute_copy(&pppins), ::core::mem::transmute_copy(&pcfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumPins_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cpins: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&cpins)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumPins_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumPins_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumPins as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IEnumRegFilters_Impl: Sized {
    fn Next(&mut self, cfilters: u32, apregfilter: *mut *mut REGFILTER, pcfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, cfilters: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumRegFilters>;
}
#[cfg(feature = "Win32_Foundation")]
impl IEnumRegFilters_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumRegFilters_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumRegFilters_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cfilters: u32, apregfilter: *mut *mut REGFILTER, pcfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&cfilters), ::core::mem::transmute_copy(&apregfilter), ::core::mem::transmute_copy(&pcfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cfilters: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&cfilters)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumRegFilters as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IEnumStreamBufferRecordingAttrib_Impl: Sized {
    fn Next(&mut self, crequest: u32, pstreambufferattribute: *mut STREAMBUFFER_ATTRIBUTE, pcreceived: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, crecords: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumStreamBufferRecordingAttrib>;
}
#[cfg(feature = "Win32_Foundation")]
impl IEnumStreamBufferRecordingAttrib_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumStreamBufferRecordingAttrib_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumStreamBufferRecordingAttrib_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumStreamBufferRecordingAttrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreambufferattribute: *mut STREAMBUFFER_ATTRIBUTE, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&crequest), ::core::mem::transmute_copy(&pstreambufferattribute), ::core::mem::transmute_copy(&pcreceived)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumStreamBufferRecordingAttrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&crecords)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumStreamBufferRecordingAttrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumStreamBufferRecordingAttrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumstreambufferattrib: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumstreambufferattrib = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumStreamBufferRecordingAttrib as ::windows::core::Interface>::IID
    }
}
pub trait IEnumStreamIdMap_Impl: Sized {
    fn Next(&mut self, crequest: u32, pstreamidmap: *mut STREAM_ID_MAP, pcreceived: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, crecords: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumStreamIdMap>;
}
impl IEnumStreamIdMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumStreamIdMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumStreamIdMap_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreamidmap: *mut STREAM_ID_MAP, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&crequest), ::core::mem::transmute_copy(&pstreamidmap), ::core::mem::transmute_copy(&pcreceived)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&crecords)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumstreamidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumstreamidmap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumStreamIdMap as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumTuneRequests_Impl: Sized {
    fn Next(&mut self, celt: u32, ppprop: *mut ::core::option::Option<ITuneRequest>, pcelt: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumTuneRequests>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumTuneRequests_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumTuneRequests_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumTuneRequests_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumTuneRequests_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, ppprop: *mut ::windows::core::RawPtr, pcelt: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&ppprop), ::core::mem::transmute_copy(&pcelt)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumTuneRequests_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumTuneRequests_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumTuneRequests_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumTuneRequests as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumTuningSpaces_Impl: Sized {
    fn Next(&mut self, celt: u32, rgelt: *mut ::core::option::Option<ITuningSpace>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IEnumTuningSpaces>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumTuningSpaces_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEnumTuningSpaces_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEnumTuningSpaces_Vtbl {
        unsafe extern "system" fn Next<Impl: IEnumTuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut ::windows::core::RawPtr, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Impl: IEnumTuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Impl: IEnumTuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: IEnumTuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEnumTuningSpaces as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IEvalRat_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn BlockedRatingAttributes(&mut self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel) -> ::windows::core::Result<i32>;
    fn SetBlockedRatingAttributes(&mut self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::Result<()>;
    fn BlockUnRated(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetBlockUnRated(&mut self, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn MostRestrictiveRating(&mut self, ensystem1: EnTvRat_System, enenlevel1: EnTvRat_GenericLevel, lbfenattr1: i32, ensystem2: EnTvRat_System, enenlevel2: EnTvRat_GenericLevel, lbfenattr2: i32, pensystem: *mut EnTvRat_System, penenlevel: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::Result<()>;
    fn TestRating(&mut self, enshowsystem: EnTvRat_System, enshowlevel: EnTvRat_GenericLevel, lbfenshowattributes: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IEvalRat_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEvalRat_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEvalRat_Vtbl {
        unsafe extern "system" fn BlockedRatingAttributes<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, plbfattrs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlockedRatingAttributes(::core::mem::transmute_copy(&ensystem), ::core::mem::transmute_copy(&enlevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *plbfattrs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockedRatingAttributes<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockedRatingAttributes(::core::mem::transmute_copy(&ensystem), ::core::mem::transmute_copy(&enlevel), ::core::mem::transmute_copy(&lbfattrs)).into()
        }
        unsafe extern "system" fn BlockUnRated<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfblockunratedshows: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BlockUnRated() {
                ::core::result::Result::Ok(ok__) => {
                    *pfblockunratedshows = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlockUnRated<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fblockunratedshows: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockUnRated(::core::mem::transmute_copy(&fblockunratedshows)).into()
        }
        unsafe extern "system" fn MostRestrictiveRating<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem1: EnTvRat_System, enenlevel1: EnTvRat_GenericLevel, lbfenattr1: i32, ensystem2: EnTvRat_System, enenlevel2: EnTvRat_GenericLevel, lbfenattr2: i32, pensystem: *mut EnTvRat_System, penenlevel: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MostRestrictiveRating(::core::mem::transmute_copy(&ensystem1), ::core::mem::transmute_copy(&enenlevel1), ::core::mem::transmute_copy(&lbfenattr1), ::core::mem::transmute_copy(&ensystem2), ::core::mem::transmute_copy(&enenlevel2), ::core::mem::transmute_copy(&lbfenattr2), ::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penenlevel), ::core::mem::transmute_copy(&plbfenattr)).into()
        }
        unsafe extern "system" fn TestRating<Impl: IEvalRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enshowsystem: EnTvRat_System, enshowlevel: EnTvRat_GenericLevel, lbfenshowattributes: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TestRating(::core::mem::transmute_copy(&enshowsystem), ::core::mem::transmute_copy(&enshowlevel), ::core::mem::transmute_copy(&lbfenshowattributes)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            BlockedRatingAttributes: BlockedRatingAttributes::<Impl, IMPL_OFFSET>,
            SetBlockedRatingAttributes: SetBlockedRatingAttributes::<Impl, IMPL_OFFSET>,
            BlockUnRated: BlockUnRated::<Impl, IMPL_OFFSET>,
            SetBlockUnRated: SetBlockUnRated::<Impl, IMPL_OFFSET>,
            MostRestrictiveRating: MostRestrictiveRating::<Impl, IMPL_OFFSET>,
            TestRating: TestRating::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEvalRat as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFileSinkFilter_Impl: Sized {
    fn SetFileName(&mut self, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn GetCurFile(&mut self, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFileSinkFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFileSinkFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFileSinkFilter_Vtbl {
        unsafe extern "system" fn SetFileName<Impl: IFileSinkFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFileName(::core::mem::transmute_copy(&pszfilename), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn GetCurFile<Impl: IFileSinkFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurFile(::core::mem::transmute_copy(&ppszfilename), ::core::mem::transmute_copy(&pmt)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFileName: SetFileName::<Impl, IMPL_OFFSET>,
            GetCurFile: GetCurFile::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFileSinkFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFileSinkFilter2_Impl: Sized + IFileSinkFilter_Impl {
    fn SetMode(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetMode(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFileSinkFilter2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFileSinkFilter2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFileSinkFilter2_Vtbl {
        unsafe extern "system" fn SetMode<Impl: IFileSinkFilter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetMode<Impl: IFileSinkFilter2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IFileSinkFilter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            GetMode: GetMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFileSinkFilter2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFileSourceFilter_Impl: Sized {
    fn Load(&mut self, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn GetCurFile(&mut self, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFileSourceFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFileSourceFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFileSourceFilter_Vtbl {
        unsafe extern "system" fn Load<Impl: IFileSourceFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Load(::core::mem::transmute_copy(&pszfilename), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn GetCurFile<Impl: IFileSourceFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszfilename: *mut super::super::Foundation::PWSTR, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurFile(::core::mem::transmute_copy(&ppszfilename), ::core::mem::transmute_copy(&pmt)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Load: Load::<Impl, IMPL_OFFSET>,
            GetCurFile: GetCurFile::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFileSourceFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IFilterChain_Impl: Sized {
    fn StartChain(&mut self, pstartfilter: &::core::option::Option<IBaseFilter>, pendfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn PauseChain(&mut self, pstartfilter: &::core::option::Option<IBaseFilter>, pendfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn StopChain(&mut self, pstartfilter: &::core::option::Option<IBaseFilter>, pendfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn RemoveChain(&mut self, pstartfilter: &::core::option::Option<IBaseFilter>, pendfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IFilterChain_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterChain_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterChain_Vtbl {
        unsafe extern "system" fn StartChain<Impl: IFilterChain_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartChain(::core::mem::transmute(&pstartfilter), ::core::mem::transmute(&pendfilter)).into()
        }
        unsafe extern "system" fn PauseChain<Impl: IFilterChain_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PauseChain(::core::mem::transmute(&pstartfilter), ::core::mem::transmute(&pendfilter)).into()
        }
        unsafe extern "system" fn StopChain<Impl: IFilterChain_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopChain(::core::mem::transmute(&pstartfilter), ::core::mem::transmute(&pendfilter)).into()
        }
        unsafe extern "system" fn RemoveChain<Impl: IFilterChain_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstartfilter: ::windows::core::RawPtr, pendfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveChain(::core::mem::transmute(&pstartfilter), ::core::mem::transmute(&pendfilter)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartChain: StartChain::<Impl, IMPL_OFFSET>,
            PauseChain: PauseChain::<Impl, IMPL_OFFSET>,
            StopChain: StopChain::<Impl, IMPL_OFFSET>,
            RemoveChain: RemoveChain::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterChain as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph_Impl: Sized {
    fn AddFilter(&mut self, pfilter: &::core::option::Option<IBaseFilter>, pname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn RemoveFilter(&mut self, pfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn EnumFilters(&mut self) -> ::windows::core::Result<IEnumFilters>;
    fn FindFilterByName(&mut self, pname: super::super::Foundation::PWSTR) -> ::windows::core::Result<IBaseFilter>;
    fn ConnectDirect(&mut self, ppinout: &::core::option::Option<IPin>, ppinin: &::core::option::Option<IPin>, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn Reconnect(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn Disconnect(&mut self, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn SetDefaultSyncSource(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IFilterGraph_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterGraph_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterGraph_Vtbl {
        unsafe extern "system" fn AddFilter<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, pname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddFilter(::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&pname)).into()
        }
        unsafe extern "system" fn RemoveFilter<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFilter(::core::mem::transmute(&pfilter)).into()
        }
        unsafe extern "system" fn EnumFilters<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumFilters() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindFilterByName<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindFilterByName(::core::mem::transmute_copy(&pname)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppfilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectDirect<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, ppinin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConnectDirect(::core::mem::transmute(&ppinout), ::core::mem::transmute(&ppinin), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn Reconnect<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reconnect(::core::mem::transmute(&ppin)).into()
        }
        unsafe extern "system" fn Disconnect<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Disconnect(::core::mem::transmute(&ppin)).into()
        }
        unsafe extern "system" fn SetDefaultSyncSource<Impl: IFilterGraph_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSyncSource().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AddFilter: AddFilter::<Impl, IMPL_OFFSET>,
            RemoveFilter: RemoveFilter::<Impl, IMPL_OFFSET>,
            EnumFilters: EnumFilters::<Impl, IMPL_OFFSET>,
            FindFilterByName: FindFilterByName::<Impl, IMPL_OFFSET>,
            ConnectDirect: ConnectDirect::<Impl, IMPL_OFFSET>,
            Reconnect: Reconnect::<Impl, IMPL_OFFSET>,
            Disconnect: Disconnect::<Impl, IMPL_OFFSET>,
            SetDefaultSyncSource: SetDefaultSyncSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterGraph as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph2_Impl: Sized + IFilterGraph_Impl + IGraphBuilder_Impl {
    fn AddSourceFilterForMoniker(&mut self, pmoniker: &::core::option::Option<super::super::System::Com::IMoniker>, pctx: &::core::option::Option<super::super::System::Com::IBindCtx>, lpcwstrfiltername: super::super::Foundation::PWSTR) -> ::windows::core::Result<IBaseFilter>;
    fn ReconnectEx(&mut self, ppin: &::core::option::Option<IPin>, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn RenderEx(&mut self, ppinout: &::core::option::Option<IPin>, dwflags: u32, pvcontext: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IFilterGraph2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterGraph2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterGraph2_Vtbl {
        unsafe extern "system" fn AddSourceFilterForMoniker<Impl: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmoniker: ::windows::core::RawPtr, pctx: ::windows::core::RawPtr, lpcwstrfiltername: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddSourceFilterForMoniker(::core::mem::transmute(&pmoniker), ::core::mem::transmute(&pctx), ::core::mem::transmute_copy(&lpcwstrfiltername)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppfilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReconnectEx<Impl: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReconnectEx(::core::mem::transmute(&ppin), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn RenderEx<Impl: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, dwflags: u32, pvcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenderEx(::core::mem::transmute(&ppinout), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&pvcontext)).into()
        }
        Self {
            base: IGraphBuilder_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AddSourceFilterForMoniker: AddSourceFilterForMoniker::<Impl, IMPL_OFFSET>,
            ReconnectEx: ReconnectEx::<Impl, IMPL_OFFSET>,
            RenderEx: RenderEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterGraph2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph3_Impl: Sized + IFilterGraph_Impl + IGraphBuilder_Impl + IFilterGraph2_Impl {
    fn SetSyncSourceEx(&mut self, pclockformostoffiltergraph: &::core::option::Option<super::IReferenceClock>, pclockforfilter: &::core::option::Option<super::IReferenceClock>, pfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IFilterGraph3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterGraph3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterGraph3_Vtbl {
        unsafe extern "system" fn SetSyncSourceEx<Impl: IFilterGraph3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclockformostoffiltergraph: ::windows::core::RawPtr, pclockforfilter: ::windows::core::RawPtr, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncSourceEx(::core::mem::transmute(&pclockformostoffiltergraph), ::core::mem::transmute(&pclockforfilter), ::core::mem::transmute(&pfilter)).into()
        }
        Self { base: IFilterGraph2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetSyncSourceEx: SetSyncSourceEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterGraph3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IFilterInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn FindPin(&mut self, strpinid: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn Name(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn VendorInfo(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Filter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Pins(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn IsFileSource(&mut self) -> ::windows::core::Result<i32>;
    fn Filename(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetFilename(&mut self, strfilename: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IFilterInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterInfo_Vtbl {
        unsafe extern "system" fn FindPin<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strpinid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindPin(::core::mem::transmute_copy(&strpinid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Name<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Name() {
                ::core::result::Result::Ok(ok__) => {
                    *strname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VendorInfo<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strvendorinfo: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VendorInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *strvendorinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filter<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Filter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pins<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pins() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFileSource<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbissource: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFileSource() {
                ::core::result::Result::Ok(ok__) => {
                    *pbissource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filename<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstrfilename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Filename() {
                ::core::result::Result::Ok(ok__) => {
                    *pstrfilename = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilename<Impl: IFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFilename(::core::mem::transmute_copy(&strfilename)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            FindPin: FindPin::<Impl, IMPL_OFFSET>,
            Name: Name::<Impl, IMPL_OFFSET>,
            VendorInfo: VendorInfo::<Impl, IMPL_OFFSET>,
            Filter: Filter::<Impl, IMPL_OFFSET>,
            Pins: Pins::<Impl, IMPL_OFFSET>,
            IsFileSource: IsFileSource::<Impl, IMPL_OFFSET>,
            Filename: Filename::<Impl, IMPL_OFFSET>,
            SetFilename: SetFilename::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFilterMapper_Impl: Sized {
    fn RegisterFilter(&mut self, clsid: &::windows::core::GUID, name: super::super::Foundation::PWSTR, dwmerit: u32) -> ::windows::core::Result<()>;
    fn RegisterFilterInstance(&mut self, clsid: &::windows::core::GUID, name: super::super::Foundation::PWSTR) -> ::windows::core::Result<::windows::core::GUID>;
    fn RegisterPin(&mut self, filter: &::windows::core::GUID, name: super::super::Foundation::PWSTR, brendered: super::super::Foundation::BOOL, boutput: super::super::Foundation::BOOL, bzero: super::super::Foundation::BOOL, bmany: super::super::Foundation::BOOL, connectstofilter: &::windows::core::GUID, connectstopin: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn RegisterPinType(&mut self, clsfilter: &::windows::core::GUID, strname: super::super::Foundation::PWSTR, clsmajortype: &::windows::core::GUID, clssubtype: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn UnregisterFilter(&mut self, filter: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn UnregisterFilterInstance(&mut self, mrid: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn UnregisterPin(&mut self, filter: &::windows::core::GUID, name: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn EnumMatchingFilters(&mut self, ppenum: *mut ::core::option::Option<IEnumRegFilters>, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, clsinmaj: &::windows::core::GUID, clsinsub: &::windows::core::GUID, brender: super::super::Foundation::BOOL, boututneeded: super::super::Foundation::BOOL, clsoutmaj: &::windows::core::GUID, clsoutsub: &::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFilterMapper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterMapper_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterMapper_Vtbl {
        unsafe extern "system" fn RegisterFilter<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: ::windows::core::GUID, name: super::super::Foundation::PWSTR, dwmerit: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterFilter(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&name), ::core::mem::transmute_copy(&dwmerit)).into()
        }
        unsafe extern "system" fn RegisterFilterInstance<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: ::windows::core::GUID, name: super::super::Foundation::PWSTR, mrid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RegisterFilterInstance(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *mrid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterPin<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID, name: super::super::Foundation::PWSTR, brendered: super::super::Foundation::BOOL, boutput: super::super::Foundation::BOOL, bzero: super::super::Foundation::BOOL, bmany: super::super::Foundation::BOOL, connectstofilter: ::windows::core::GUID, connectstopin: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterPin(::core::mem::transmute_copy(&filter), ::core::mem::transmute_copy(&name), ::core::mem::transmute_copy(&brendered), ::core::mem::transmute_copy(&boutput), ::core::mem::transmute_copy(&bzero), ::core::mem::transmute_copy(&bmany), ::core::mem::transmute_copy(&connectstofilter), ::core::mem::transmute_copy(&connectstopin)).into()
        }
        unsafe extern "system" fn RegisterPinType<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsfilter: ::windows::core::GUID, strname: super::super::Foundation::PWSTR, clsmajortype: ::windows::core::GUID, clssubtype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterPinType(::core::mem::transmute_copy(&clsfilter), ::core::mem::transmute_copy(&strname), ::core::mem::transmute_copy(&clsmajortype), ::core::mem::transmute_copy(&clssubtype)).into()
        }
        unsafe extern "system" fn UnregisterFilter<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterFilter(::core::mem::transmute_copy(&filter)).into()
        }
        unsafe extern "system" fn UnregisterFilterInstance<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mrid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterFilterInstance(::core::mem::transmute_copy(&mrid)).into()
        }
        unsafe extern "system" fn UnregisterPin<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filter: ::windows::core::GUID, name: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterPin(::core::mem::transmute_copy(&filter), ::core::mem::transmute_copy(&name)).into()
        }
        unsafe extern "system" fn EnumMatchingFilters<Impl: IFilterMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, clsinmaj: ::windows::core::GUID, clsinsub: ::windows::core::GUID, brender: super::super::Foundation::BOOL, boututneeded: super::super::Foundation::BOOL, clsoutmaj: ::windows::core::GUID, clsoutsub: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnumMatchingFilters(::core::mem::transmute_copy(&ppenum), ::core::mem::transmute_copy(&dwmerit), ::core::mem::transmute_copy(&binputneeded), ::core::mem::transmute_copy(&clsinmaj), ::core::mem::transmute_copy(&clsinsub), ::core::mem::transmute_copy(&brender), ::core::mem::transmute_copy(&boututneeded), ::core::mem::transmute_copy(&clsoutmaj), ::core::mem::transmute_copy(&clsoutsub)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterFilter: RegisterFilter::<Impl, IMPL_OFFSET>,
            RegisterFilterInstance: RegisterFilterInstance::<Impl, IMPL_OFFSET>,
            RegisterPin: RegisterPin::<Impl, IMPL_OFFSET>,
            RegisterPinType: RegisterPinType::<Impl, IMPL_OFFSET>,
            UnregisterFilter: UnregisterFilter::<Impl, IMPL_OFFSET>,
            UnregisterFilterInstance: UnregisterFilterInstance::<Impl, IMPL_OFFSET>,
            UnregisterPin: UnregisterPin::<Impl, IMPL_OFFSET>,
            EnumMatchingFilters: EnumMatchingFilters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterMapper as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IFilterMapper2_Impl: Sized {
    fn CreateCategory(&mut self, clsidcategory: *const ::windows::core::GUID, dwcategorymerit: u32, description: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn UnregisterFilter(&mut self, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, filter: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn RegisterFilter(&mut self, clsidfilter: *const ::windows::core::GUID, name: super::super::Foundation::PWSTR, ppmoniker: *mut ::core::option::Option<super::super::System::Com::IMoniker>, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, prf2: *const REGFILTER2) -> ::windows::core::Result<()>;
    fn EnumMatchingFilters(&mut self, ppenum: *mut ::core::option::Option<super::super::System::Com::IEnumMoniker>, dwflags: u32, bexactmatch: super::super::Foundation::BOOL, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, cinputtypes: u32, pinputtypes: *const ::windows::core::GUID, pmedin: *const REGPINMEDIUM, ppincategoryin: *const ::windows::core::GUID, brender: super::super::Foundation::BOOL, boutputneeded: super::super::Foundation::BOOL, coutputtypes: u32, poutputtypes: *const ::windows::core::GUID, pmedout: *const REGPINMEDIUM, ppincategoryout: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IFilterMapper2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterMapper2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterMapper2_Vtbl {
        unsafe extern "system" fn CreateCategory<Impl: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsidcategory: *const ::windows::core::GUID, dwcategorymerit: u32, description: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateCategory(::core::mem::transmute_copy(&clsidcategory), ::core::mem::transmute_copy(&dwcategorymerit), ::core::mem::transmute_copy(&description)).into()
        }
        unsafe extern "system" fn UnregisterFilter<Impl: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, filter: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterFilter(::core::mem::transmute_copy(&pclsidcategory), ::core::mem::transmute_copy(&szinstance), ::core::mem::transmute_copy(&filter)).into()
        }
        unsafe extern "system" fn RegisterFilter<Impl: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsidfilter: *const ::windows::core::GUID, name: super::super::Foundation::PWSTR, ppmoniker: *mut ::windows::core::RawPtr, pclsidcategory: *const ::windows::core::GUID, szinstance: super::super::Foundation::PWSTR, prf2: *const REGFILTER2) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterFilter(::core::mem::transmute_copy(&clsidfilter), ::core::mem::transmute_copy(&name), ::core::mem::transmute_copy(&ppmoniker), ::core::mem::transmute_copy(&pclsidcategory), ::core::mem::transmute_copy(&szinstance), ::core::mem::transmute_copy(&prf2)).into()
        }
        unsafe extern "system" fn EnumMatchingFilters<Impl: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr, dwflags: u32, bexactmatch: super::super::Foundation::BOOL, dwmerit: u32, binputneeded: super::super::Foundation::BOOL, cinputtypes: u32, pinputtypes: *const ::windows::core::GUID, pmedin: *const REGPINMEDIUM, ppincategoryin: *const ::windows::core::GUID, brender: super::super::Foundation::BOOL, boutputneeded: super::super::Foundation::BOOL, coutputtypes: u32, poutputtypes: *const ::windows::core::GUID, pmedout: *const REGPINMEDIUM, ppincategoryout: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this)
                .EnumMatchingFilters(
                    ::core::mem::transmute_copy(&ppenum),
                    ::core::mem::transmute_copy(&dwflags),
                    ::core::mem::transmute_copy(&bexactmatch),
                    ::core::mem::transmute_copy(&dwmerit),
                    ::core::mem::transmute_copy(&binputneeded),
                    ::core::mem::transmute_copy(&cinputtypes),
                    ::core::mem::transmute_copy(&pinputtypes),
                    ::core::mem::transmute_copy(&pmedin),
                    ::core::mem::transmute_copy(&ppincategoryin),
                    ::core::mem::transmute_copy(&brender),
                    ::core::mem::transmute_copy(&boutputneeded),
                    ::core::mem::transmute_copy(&coutputtypes),
                    ::core::mem::transmute_copy(&poutputtypes),
                    ::core::mem::transmute_copy(&pmedout),
                    ::core::mem::transmute_copy(&ppincategoryout),
                )
                .into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateCategory: CreateCategory::<Impl, IMPL_OFFSET>,
            UnregisterFilter: UnregisterFilter::<Impl, IMPL_OFFSET>,
            RegisterFilter: RegisterFilter::<Impl, IMPL_OFFSET>,
            EnumMatchingFilters: EnumMatchingFilters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterMapper2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IFilterMapper3_Impl: Sized + IFilterMapper2_Impl {
    fn GetICreateDevEnum(&mut self) -> ::windows::core::Result<ICreateDevEnum>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IFilterMapper3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFilterMapper3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFilterMapper3_Vtbl {
        unsafe extern "system" fn GetICreateDevEnum<Impl: IFilterMapper3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetICreateDevEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IFilterMapper2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetICreateDevEnum: GetICreateDevEnum::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFilterMapper3 as ::windows::core::Interface>::IID
    }
}
pub trait IFrequencyMap_Impl: Sized {
    fn FrequencyMapping(&mut self, ulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::Result<()>;
    fn SetFrequencyMapping(&mut self, ulcount: u32, plist: *const u32) -> ::windows::core::Result<()>;
    fn CountryCode(&mut self) -> ::windows::core::Result<u32>;
    fn SetCountryCode(&mut self, ulcountrycode: u32) -> ::windows::core::Result<()>;
    fn DefaultFrequencyMapping(&mut self, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::Result<()>;
    fn CountryCodeList(&mut self, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::Result<()>;
}
impl IFrequencyMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFrequencyMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFrequencyMap_Vtbl {
        unsafe extern "system" fn FrequencyMapping<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FrequencyMapping(::core::mem::transmute_copy(&ulcount), ::core::mem::transmute_copy(&ppullist)).into()
        }
        unsafe extern "system" fn SetFrequencyMapping<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcount: u32, plist: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrequencyMapping(::core::mem::transmute_copy(&ulcount), ::core::mem::transmute_copy(&plist)).into()
        }
        unsafe extern "system" fn CountryCode<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcountrycode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pulcountrycode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcountrycode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&ulcountrycode)).into()
        }
        unsafe extern "system" fn DefaultFrequencyMapping<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DefaultFrequencyMapping(::core::mem::transmute_copy(&ulcountrycode), ::core::mem::transmute_copy(&pulcount), ::core::mem::transmute_copy(&ppullist)).into()
        }
        unsafe extern "system" fn CountryCodeList<Impl: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcount: *mut u32, ppullist: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CountryCodeList(::core::mem::transmute_copy(&pulcount), ::core::mem::transmute_copy(&ppullist)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            FrequencyMapping: FrequencyMapping::<Impl, IMPL_OFFSET>,
            SetFrequencyMapping: SetFrequencyMapping::<Impl, IMPL_OFFSET>,
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
            DefaultFrequencyMapping: DefaultFrequencyMapping::<Impl, IMPL_OFFSET>,
            CountryCodeList: CountryCodeList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFrequencyMap as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFullScreenVideo_Impl: Sized {
    fn CountModes(&mut self) -> ::windows::core::Result<i32>;
    fn GetModeInfo(&mut self, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> ::windows::core::Result<()>;
    fn GetCurrentMode(&mut self) -> ::windows::core::Result<i32>;
    fn IsModeAvailable(&mut self, mode: i32) -> ::windows::core::Result<()>;
    fn IsModeEnabled(&mut self, mode: i32) -> ::windows::core::Result<()>;
    fn SetEnabled(&mut self, mode: i32, benabled: i32) -> ::windows::core::Result<()>;
    fn GetClipFactor(&mut self) -> ::windows::core::Result<i32>;
    fn SetClipFactor(&mut self, clipfactor: i32) -> ::windows::core::Result<()>;
    fn SetMessageDrain(&mut self, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn GetMessageDrain(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn SetMonitor(&mut self, monitor: i32) -> ::windows::core::Result<()>;
    fn GetMonitor(&mut self) -> ::windows::core::Result<i32>;
    fn HideOnDeactivate(&mut self, hide: i32) -> ::windows::core::Result<()>;
    fn IsHideOnDeactivate(&mut self) -> ::windows::core::Result<()>;
    fn SetCaption(&mut self, strcaption: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetCaption(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetDefault(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFullScreenVideo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFullScreenVideo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFullScreenVideo_Vtbl {
        unsafe extern "system" fn CountModes<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmodes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountModes() {
                ::core::result::Result::Ok(ok__) => {
                    *pmodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetModeInfo<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetModeInfo(::core::mem::transmute_copy(&mode), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight), ::core::mem::transmute_copy(&pdepth)).into()
        }
        unsafe extern "system" fn GetCurrentMode<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsModeAvailable<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsModeAvailable(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn IsModeEnabled<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsModeEnabled(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn SetEnabled<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: i32, benabled: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnabled(::core::mem::transmute_copy(&mode), ::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn GetClipFactor<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclipfactor: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetClipFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *pclipfactor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipFactor<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clipfactor: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClipFactor(::core::mem::transmute_copy(&clipfactor)).into()
        }
        unsafe extern "system" fn SetMessageDrain<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMessageDrain(::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn GetMessageDrain<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMessageDrain() {
                ::core::result::Result::Ok(ok__) => {
                    *hwnd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonitor<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, monitor: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonitor(::core::mem::transmute_copy(&monitor)).into()
        }
        unsafe extern "system" fn GetMonitor<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, monitor: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMonitor() {
                ::core::result::Result::Ok(ok__) => {
                    *monitor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HideOnDeactivate<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hide: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HideOnDeactivate(::core::mem::transmute_copy(&hide)).into()
        }
        unsafe extern "system" fn IsHideOnDeactivate<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsHideOnDeactivate().into()
        }
        unsafe extern "system" fn SetCaption<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strcaption: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCaption(::core::mem::transmute_copy(&strcaption)).into()
        }
        unsafe extern "system" fn GetCaption<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstrcaption: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaption() {
                ::core::result::Result::Ok(ok__) => {
                    *pstrcaption = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefault<Impl: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefault().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CountModes: CountModes::<Impl, IMPL_OFFSET>,
            GetModeInfo: GetModeInfo::<Impl, IMPL_OFFSET>,
            GetCurrentMode: GetCurrentMode::<Impl, IMPL_OFFSET>,
            IsModeAvailable: IsModeAvailable::<Impl, IMPL_OFFSET>,
            IsModeEnabled: IsModeEnabled::<Impl, IMPL_OFFSET>,
            SetEnabled: SetEnabled::<Impl, IMPL_OFFSET>,
            GetClipFactor: GetClipFactor::<Impl, IMPL_OFFSET>,
            SetClipFactor: SetClipFactor::<Impl, IMPL_OFFSET>,
            SetMessageDrain: SetMessageDrain::<Impl, IMPL_OFFSET>,
            GetMessageDrain: GetMessageDrain::<Impl, IMPL_OFFSET>,
            SetMonitor: SetMonitor::<Impl, IMPL_OFFSET>,
            GetMonitor: GetMonitor::<Impl, IMPL_OFFSET>,
            HideOnDeactivate: HideOnDeactivate::<Impl, IMPL_OFFSET>,
            IsHideOnDeactivate: IsHideOnDeactivate::<Impl, IMPL_OFFSET>,
            SetCaption: SetCaption::<Impl, IMPL_OFFSET>,
            GetCaption: GetCaption::<Impl, IMPL_OFFSET>,
            SetDefault: SetDefault::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFullScreenVideo as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_WindowsAndMessaging"))]
pub trait IFullScreenVideoEx_Impl: Sized + IFullScreenVideo_Impl {
    fn SetAcceleratorTable(&mut self, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::Result<()>;
    fn GetAcceleratorTable(&mut self, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::Result<()>;
    fn KeepPixelAspectRatio(&mut self, keepaspect: i32) -> ::windows::core::Result<()>;
    fn IsKeepPixelAspectRatio(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_WindowsAndMessaging"))]
impl IFullScreenVideoEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFullScreenVideoEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFullScreenVideoEx_Vtbl {
        unsafe extern "system" fn SetAcceleratorTable<Impl: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAcceleratorTable(::core::mem::transmute_copy(&hwnd), ::core::mem::transmute_copy(&haccel)).into()
        }
        unsafe extern "system" fn GetAcceleratorTable<Impl: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAcceleratorTable(::core::mem::transmute_copy(&phwnd), ::core::mem::transmute_copy(&phaccel)).into()
        }
        unsafe extern "system" fn KeepPixelAspectRatio<Impl: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keepaspect: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeepPixelAspectRatio(::core::mem::transmute_copy(&keepaspect)).into()
        }
        unsafe extern "system" fn IsKeepPixelAspectRatio<Impl: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkeepaspect: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsKeepPixelAspectRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *pkeepaspect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IFullScreenVideo_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetAcceleratorTable: SetAcceleratorTable::<Impl, IMPL_OFFSET>,
            GetAcceleratorTable: GetAcceleratorTable::<Impl, IMPL_OFFSET>,
            KeepPixelAspectRatio: KeepPixelAspectRatio::<Impl, IMPL_OFFSET>,
            IsKeepPixelAspectRatio: IsKeepPixelAspectRatio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFullScreenVideoEx as ::windows::core::Interface>::IID
    }
}
pub trait IGenericDescriptor_Impl: Sized {
    fn Initialize(&mut self, pbdesc: *const u8, bcount: i32) -> ::windows::core::Result<()>;
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetBody(&mut self) -> ::windows::core::Result<*mut u8>;
}
impl IGenericDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGenericDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGenericDescriptor_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IGenericDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdesc: *const u8, bcount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&pbdesc), ::core::mem::transmute_copy(&bcount)).into()
        }
        unsafe extern "system" fn GetTag<Impl: IGenericDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IGenericDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBody<Impl: IGenericDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbval: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBody() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetBody: GetBody::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGenericDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IGenericDescriptor2_Impl: Sized + IGenericDescriptor_Impl {
    fn Initialize2(&mut self, pbdesc: *const u8, wcount: u16) -> ::windows::core::Result<()>;
    fn GetLength2(&mut self) -> ::windows::core::Result<u16>;
}
impl IGenericDescriptor2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGenericDescriptor2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGenericDescriptor2_Vtbl {
        unsafe extern "system" fn Initialize2<Impl: IGenericDescriptor2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdesc: *const u8, wcount: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize2(::core::mem::transmute_copy(&pbdesc), ::core::mem::transmute_copy(&wcount)).into()
        }
        unsafe extern "system" fn GetLength2<Impl: IGenericDescriptor2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength2() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IGenericDescriptor_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Initialize2: Initialize2::<Impl, IMPL_OFFSET>,
            GetLength2: GetLength2::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGenericDescriptor2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Registry")]
pub trait IGetCapabilitiesKey_Impl: Sized {
    fn GetCapabilitiesKey(&mut self) -> ::windows::core::Result<super::super::System::Registry::HKEY>;
}
#[cfg(feature = "Win32_System_Registry")]
impl IGetCapabilitiesKey_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGetCapabilitiesKey_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGetCapabilitiesKey_Vtbl {
        unsafe extern "system" fn GetCapabilitiesKey<Impl: IGetCapabilitiesKey_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phkey: *mut super::super::System::Registry::HKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCapabilitiesKey() {
                ::core::result::Result::Ok(ok__) => {
                    *phkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetCapabilitiesKey: GetCapabilitiesKey::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGetCapabilitiesKey as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IGpnvsCommonBase_Impl: Sized {
    fn GetValueUpdateName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IGpnvsCommonBase_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGpnvsCommonBase_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGpnvsCommonBase_Vtbl {
        unsafe extern "system" fn GetValueUpdateName<Impl: IGpnvsCommonBase_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValueUpdateName() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetValueUpdateName: GetValueUpdateName::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGpnvsCommonBase as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IGraphBuilder_Impl: Sized + IFilterGraph_Impl {
    fn Connect(&mut self, ppinout: &::core::option::Option<IPin>, ppinin: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn Render(&mut self, ppinout: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn RenderFile(&mut self, lpcwstrfile: super::super::Foundation::PWSTR, lpcwstrplaylist: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn AddSourceFilter(&mut self, lpcwstrfilename: super::super::Foundation::PWSTR, lpcwstrfiltername: super::super::Foundation::PWSTR) -> ::windows::core::Result<IBaseFilter>;
    fn SetLogFile(&mut self, hfile: usize) -> ::windows::core::Result<()>;
    fn Abort(&mut self) -> ::windows::core::Result<()>;
    fn ShouldOperationContinue(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IGraphBuilder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGraphBuilder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGraphBuilder_Vtbl {
        unsafe extern "system" fn Connect<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, ppinin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Connect(::core::mem::transmute(&ppinout), ::core::mem::transmute(&ppinin)).into()
        }
        unsafe extern "system" fn Render<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Render(::core::mem::transmute(&ppinout)).into()
        }
        unsafe extern "system" fn RenderFile<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpcwstrfile: super::super::Foundation::PWSTR, lpcwstrplaylist: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenderFile(::core::mem::transmute_copy(&lpcwstrfile), ::core::mem::transmute_copy(&lpcwstrplaylist)).into()
        }
        unsafe extern "system" fn AddSourceFilter<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpcwstrfilename: super::super::Foundation::PWSTR, lpcwstrfiltername: super::super::Foundation::PWSTR, ppfilter: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddSourceFilter(::core::mem::transmute_copy(&lpcwstrfilename), ::core::mem::transmute_copy(&lpcwstrfiltername)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppfilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLogFile<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hfile: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLogFile(::core::mem::transmute_copy(&hfile)).into()
        }
        unsafe extern "system" fn Abort<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Abort().into()
        }
        unsafe extern "system" fn ShouldOperationContinue<Impl: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShouldOperationContinue().into()
        }
        Self {
            base: IFilterGraph_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Connect: Connect::<Impl, IMPL_OFFSET>,
            Render: Render::<Impl, IMPL_OFFSET>,
            RenderFile: RenderFile::<Impl, IMPL_OFFSET>,
            AddSourceFilter: AddSourceFilter::<Impl, IMPL_OFFSET>,
            SetLogFile: SetLogFile::<Impl, IMPL_OFFSET>,
            Abort: Abort::<Impl, IMPL_OFFSET>,
            ShouldOperationContinue: ShouldOperationContinue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGraphBuilder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IGraphConfig_Impl: Sized {
    fn Reconnect(&mut self, poutputpin: &::core::option::Option<IPin>, pinputpin: &::core::option::Option<IPin>, pmtfirstconnection: *const AM_MEDIA_TYPE, pusingfilter: &::core::option::Option<IBaseFilter>, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> ::windows::core::Result<()>;
    fn Reconfigure(&mut self, pcallback: &::core::option::Option<IGraphConfigCallback>, pvcontext: *mut ::core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn AddFilterToCache(&mut self, pfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn EnumCacheFilter(&mut self) -> ::windows::core::Result<IEnumFilters>;
    fn RemoveFilterFromCache(&mut self, pfilter: &::core::option::Option<IBaseFilter>) -> ::windows::core::Result<()>;
    fn GetStartTime(&mut self, prtstart: *mut i64) -> ::windows::core::Result<()>;
    fn PushThroughData(&mut self, poutputpin: &::core::option::Option<IPin>, pconnection: &::core::option::Option<IPinConnection>, heventabort: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn SetFilterFlags(&mut self, pfilter: &::core::option::Option<IBaseFilter>, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetFilterFlags(&mut self, pfilter: &::core::option::Option<IBaseFilter>, pdwflags: *mut u32) -> ::windows::core::Result<()>;
    fn RemoveFilterEx(&mut self, pfilter: &::core::option::Option<IBaseFilter>, flags: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IGraphConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGraphConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGraphConfig_Vtbl {
        unsafe extern "system" fn Reconnect<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poutputpin: ::windows::core::RawPtr, pinputpin: ::windows::core::RawPtr, pmtfirstconnection: *const AM_MEDIA_TYPE, pusingfilter: ::windows::core::RawPtr, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reconnect(::core::mem::transmute(&poutputpin), ::core::mem::transmute(&pinputpin), ::core::mem::transmute_copy(&pmtfirstconnection), ::core::mem::transmute(&pusingfilter), ::core::mem::transmute_copy(&habortevent), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn Reconfigure<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pvcontext: *mut ::core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reconfigure(::core::mem::transmute(&pcallback), ::core::mem::transmute_copy(&pvcontext), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&habortevent)).into()
        }
        unsafe extern "system" fn AddFilterToCache<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddFilterToCache(::core::mem::transmute(&pfilter)).into()
        }
        unsafe extern "system" fn EnumCacheFilter<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumCacheFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *penum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFilterFromCache<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFilterFromCache(::core::mem::transmute(&pfilter)).into()
        }
        unsafe extern "system" fn GetStartTime<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStartTime(::core::mem::transmute_copy(&prtstart)).into()
        }
        unsafe extern "system" fn PushThroughData<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poutputpin: ::windows::core::RawPtr, pconnection: ::windows::core::RawPtr, heventabort: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PushThroughData(::core::mem::transmute(&poutputpin), ::core::mem::transmute(&pconnection), ::core::mem::transmute_copy(&heventabort)).into()
        }
        unsafe extern "system" fn SetFilterFlags<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFilterFlags(::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFilterFlags<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFilterFlags(::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&pdwflags)).into()
        }
        unsafe extern "system" fn RemoveFilterEx<Impl: IGraphConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfilter: ::windows::core::RawPtr, flags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveFilterEx(::core::mem::transmute(&pfilter), ::core::mem::transmute_copy(&flags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Reconnect: Reconnect::<Impl, IMPL_OFFSET>,
            Reconfigure: Reconfigure::<Impl, IMPL_OFFSET>,
            AddFilterToCache: AddFilterToCache::<Impl, IMPL_OFFSET>,
            EnumCacheFilter: EnumCacheFilter::<Impl, IMPL_OFFSET>,
            RemoveFilterFromCache: RemoveFilterFromCache::<Impl, IMPL_OFFSET>,
            GetStartTime: GetStartTime::<Impl, IMPL_OFFSET>,
            PushThroughData: PushThroughData::<Impl, IMPL_OFFSET>,
            SetFilterFlags: SetFilterFlags::<Impl, IMPL_OFFSET>,
            GetFilterFlags: GetFilterFlags::<Impl, IMPL_OFFSET>,
            RemoveFilterEx: RemoveFilterEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGraphConfig as ::windows::core::Interface>::IID
    }
}
pub trait IGraphConfigCallback_Impl: Sized {
    fn Reconfigure(&mut self, pvcontext: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::Result<()>;
}
impl IGraphConfigCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGraphConfigCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGraphConfigCallback_Vtbl {
        unsafe extern "system" fn Reconfigure<Impl: IGraphConfigCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvcontext: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reconfigure(::core::mem::transmute_copy(&pvcontext), ::core::mem::transmute_copy(&dwflags)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Reconfigure: Reconfigure::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGraphConfigCallback as ::windows::core::Interface>::IID
    }
}
pub trait IGraphVersion_Impl: Sized {
    fn QueryVersion(&mut self) -> ::windows::core::Result<i32>;
}
impl IGraphVersion_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGraphVersion_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGraphVersion_Vtbl {
        unsafe extern "system" fn QueryVersion<Impl: IGraphVersion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pversion: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pversion = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), QueryVersion: QueryVersion::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGraphVersion as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IGuideData_Impl: Sized {
    fn GetServices(&mut self) -> ::windows::core::Result<IEnumTuneRequests>;
    fn GetServiceProperties(&mut self, ptunerequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<IEnumGuideDataProperties>;
    fn GetGuideProgramIDs(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn GetProgramProperties(&mut self, varprogramdescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IEnumGuideDataProperties>;
    fn GetScheduleEntryIDs(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn GetScheduleEntryProperties(&mut self, varscheduleentrydescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IEnumGuideDataProperties>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IGuideData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGuideData_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGuideData_Vtbl {
        unsafe extern "system" fn GetServices<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenumtunerequests: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServices() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenumtunerequests = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceProperties<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptunerequest: ::windows::core::RawPtr, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceProperties(::core::mem::transmute(&ptunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppenumproperties = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuideProgramIDs<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penumprograms: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGuideProgramIDs() {
                ::core::result::Result::Ok(ok__) => {
                    *penumprograms = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramProperties<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProgramProperties(::core::mem::transmute_copy(&varprogramdescriptionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppenumproperties = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScheduleEntryIDs<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penumscheduleentries: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetScheduleEntryIDs() {
                ::core::result::Result::Ok(ok__) => {
                    *penumscheduleentries = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScheduleEntryProperties<Impl: IGuideData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppenumproperties: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetScheduleEntryProperties(::core::mem::transmute_copy(&varscheduleentrydescriptionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppenumproperties = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetServices: GetServices::<Impl, IMPL_OFFSET>,
            GetServiceProperties: GetServiceProperties::<Impl, IMPL_OFFSET>,
            GetGuideProgramIDs: GetGuideProgramIDs::<Impl, IMPL_OFFSET>,
            GetProgramProperties: GetProgramProperties::<Impl, IMPL_OFFSET>,
            GetScheduleEntryIDs: GetScheduleEntryIDs::<Impl, IMPL_OFFSET>,
            GetScheduleEntryProperties: GetScheduleEntryProperties::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGuideData as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IGuideDataEvent_Impl: Sized {
    fn GuideDataAcquired(&mut self) -> ::windows::core::Result<()>;
    fn ProgramChanged(&mut self, varprogramdescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn ServiceChanged(&mut self, varservicedescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn ScheduleEntryChanged(&mut self, varscheduleentrydescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn ProgramDeleted(&mut self, varprogramdescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn ServiceDeleted(&mut self, varservicedescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn ScheduleDeleted(&mut self, varscheduleentrydescriptionid: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IGuideDataEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGuideDataEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGuideDataEvent_Vtbl {
        unsafe extern "system" fn GuideDataAcquired<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GuideDataAcquired().into()
        }
        unsafe extern "system" fn ProgramChanged<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProgramChanged(::core::mem::transmute_copy(&varprogramdescriptionid)).into()
        }
        unsafe extern "system" fn ServiceChanged<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varservicedescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ServiceChanged(::core::mem::transmute_copy(&varservicedescriptionid)).into()
        }
        unsafe extern "system" fn ScheduleEntryChanged<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScheduleEntryChanged(::core::mem::transmute_copy(&varscheduleentrydescriptionid)).into()
        }
        unsafe extern "system" fn ProgramDeleted<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varprogramdescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProgramDeleted(::core::mem::transmute_copy(&varprogramdescriptionid)).into()
        }
        unsafe extern "system" fn ServiceDeleted<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varservicedescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ServiceDeleted(::core::mem::transmute_copy(&varservicedescriptionid)).into()
        }
        unsafe extern "system" fn ScheduleDeleted<Impl: IGuideDataEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varscheduleentrydescriptionid: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScheduleDeleted(::core::mem::transmute_copy(&varscheduleentrydescriptionid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GuideDataAcquired: GuideDataAcquired::<Impl, IMPL_OFFSET>,
            ProgramChanged: ProgramChanged::<Impl, IMPL_OFFSET>,
            ServiceChanged: ServiceChanged::<Impl, IMPL_OFFSET>,
            ScheduleEntryChanged: ScheduleEntryChanged::<Impl, IMPL_OFFSET>,
            ProgramDeleted: ProgramDeleted::<Impl, IMPL_OFFSET>,
            ServiceDeleted: ServiceDeleted::<Impl, IMPL_OFFSET>,
            ScheduleDeleted: ScheduleDeleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGuideDataEvent as ::windows::core::Interface>::IID
    }
}
pub trait IGuideDataLoader_Impl: Sized {
    fn Init(&mut self, pguidestore: &::core::option::Option<IGuideData>) -> ::windows::core::Result<()>;
    fn Terminate(&mut self) -> ::windows::core::Result<()>;
}
impl IGuideDataLoader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGuideDataLoader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGuideDataLoader_Vtbl {
        unsafe extern "system" fn Init<Impl: IGuideDataLoader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidestore: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Init(::core::mem::transmute(&pguidestore)).into()
        }
        unsafe extern "system" fn Terminate<Impl: IGuideDataLoader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Terminate().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Init: Init::<Impl, IMPL_OFFSET>, Terminate: Terminate::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGuideDataLoader as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IGuideDataProperty_Impl: Sized {
    fn Name(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Language(&mut self) -> ::windows::core::Result<i32>;
    fn Value(&mut self) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IGuideDataProperty_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IGuideDataProperty_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IGuideDataProperty_Vtbl {
        unsafe extern "system" fn Name<Impl: IGuideDataProperty_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Name() {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: IGuideDataProperty_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idlang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *idlang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Value<Impl: IGuideDataProperty_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvar: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *pvar = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Name: Name::<Impl, IMPL_OFFSET>,
            Language: Language::<Impl, IMPL_OFFSET>,
            Value: Value::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IGuideDataProperty as ::windows::core::Interface>::IID
    }
}
pub trait IIPDVDec_Impl: Sized {
    fn IPDisplay(&mut self) -> ::windows::core::Result<i32>;
    fn SetIPDisplay(&mut self, displaypix: i32) -> ::windows::core::Result<()>;
}
impl IIPDVDec_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIPDVDec_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIPDVDec_Vtbl {
        unsafe extern "system" fn IPDisplay<Impl: IIPDVDec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, displaypix: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IPDisplay() {
                ::core::result::Result::Ok(ok__) => {
                    *displaypix = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIPDisplay<Impl: IIPDVDec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, displaypix: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIPDisplay(::core::mem::transmute_copy(&displaypix)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IPDisplay: IPDisplay::<Impl, IMPL_OFFSET>,
            SetIPDisplay: SetIPDisplay::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIPDVDec as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IISDBSLocator_Impl: Sized + super::super::System::Com::IDispatch_Impl + ILocator_Impl + IDigitalLocator_Impl + IDVBSLocator_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IISDBSLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDBSLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDBSLocator_Vtbl {
        Self { base: IDVBSLocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDBSLocator as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_BIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetBroadcastViewPropriety(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordBroadcasterId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_BIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_BIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_BIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBroadcastViewPropriety<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBroadcastViewPropriety() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordBroadcasterId<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordBroadcasterId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_BIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetBroadcastViewPropriety: GetBroadcastViewPropriety::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordBroadcasterId: GetRecordBroadcasterId::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_BIT as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_CDT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>, bsectionnumber: u8) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetDownloadDataId(&mut self) -> ::windows::core::Result<u16>;
    fn GetSectionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetDataType(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetSizeOfDataModule(&mut self) -> ::windows::core::Result<u32>;
    fn GetDataModule(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_CDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_CDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_CDT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr, bsectionnumber: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata), ::core::mem::transmute_copy(&bsectionnumber)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadDataId<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDownloadDataId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSectionNumber<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSectionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataType<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetSizeOfDataModule<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSizeOfDataModule() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataModule<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataModule() {
                ::core::result::Result::Ok(ok__) => {
                    *pbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_CDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetDownloadDataId: GetDownloadDataId::<Impl, IMPL_OFFSET>,
            GetSectionNumber: GetSectionNumber::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetDataType: GetDataType::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetSizeOfDataModule: GetSizeOfDataModule::<Impl, IMPL_OFFSET>,
            GetDataModule: GetDataModule::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_CDT as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_EMM_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetTableIdExtension(&mut self) -> ::windows::core::Result<u16>;
    fn GetDataBytes(&mut self, pwbufferlength: *mut u16, pbbuffer: *mut u8) -> ::windows::core::Result<()>;
    fn GetSharedEmmMessage(&mut self, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::Result<()>;
    fn GetIndividualEmmMessage(&mut self, punknown: &::core::option::Option<::windows::core::IUnknown>, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_EMM_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_EMM_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_EMM_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableIdExtension<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableIdExtension() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataBytes<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwbufferlength: *mut u16, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDataBytes(::core::mem::transmute_copy(&pwbufferlength), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        unsafe extern "system" fn GetSharedEmmMessage<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSharedEmmMessage(::core::mem::transmute_copy(&pwlength), ::core::mem::transmute_copy(&ppbmessage)).into()
        }
        unsafe extern "system" fn GetIndividualEmmMessage<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punknown: *mut ::core::ffi::c_void, pwlength: *mut u16, ppbmessage: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIndividualEmmMessage(::core::mem::transmute(&punknown), ::core::mem::transmute_copy(&pwlength), ::core::mem::transmute_copy(&ppbmessage)).into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_EMM_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetTableIdExtension: GetTableIdExtension::<Impl, IMPL_OFFSET>,
            GetDataBytes: GetDataBytes::<Impl, IMPL_OFFSET>,
            GetSharedEmmMessage: GetSharedEmmMessage::<Impl, IMPL_OFFSET>,
            GetIndividualEmmMessage: GetIndividualEmmMessage::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_EMM as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_LDT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetOriginalServiceId(&mut self) -> ::windows::core::Result<u16>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptionId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_LDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_LDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_LDT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalServiceId<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalServiceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptionId<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptionId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_LDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetOriginalServiceId: GetOriginalServiceId::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordDescriptionId: GetRecordDescriptionId::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_LDT as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_NBIT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordInformationId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordInformationType(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordDescriptionBodyLocation(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordMessageSectionNumber(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordUserDefined(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordNumberOfKeys(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordKeys(&mut self, dwrecordindex: u32) -> ::windows::core::Result<*mut u8>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_NBIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_NBIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_NBIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordInformationId<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordInformationId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordInformationType<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordInformationType(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptionBodyLocation<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptionBodyLocation(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordMessageSectionNumber<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordMessageSectionNumber(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordUserDefined<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordUserDefined(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfKeys<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfKeys(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordKeys<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbkeys: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordKeys(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbkeys = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_NBIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordInformationId: GetRecordInformationId::<Impl, IMPL_OFFSET>,
            GetRecordInformationType: GetRecordInformationType::<Impl, IMPL_OFFSET>,
            GetRecordDescriptionBodyLocation: GetRecordDescriptionBodyLocation::<Impl, IMPL_OFFSET>,
            GetRecordMessageSectionNumber: GetRecordMessageSectionNumber::<Impl, IMPL_OFFSET>,
            GetRecordUserDefined: GetRecordUserDefined::<Impl, IMPL_OFFSET>,
            GetRecordNumberOfKeys: GetRecordNumberOfKeys::<Impl, IMPL_OFFSET>,
            GetRecordKeys: GetRecordKeys::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_NBIT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IISDB_SDT_Impl: Sized + IDVB_SDT_Impl {
    fn GetRecordEITUserDefinedFlags(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
}
#[cfg(feature = "Win32_Foundation")]
impl IISDB_SDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_SDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_SDT_Vtbl {
        unsafe extern "system" fn GetRecordEITUserDefinedFlags<Impl: IISDB_SDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEITUserDefinedFlags(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDVB_SDT_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetRecordEITUserDefinedFlags: GetRecordEITUserDefinedFlags::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_SDT as ::windows::core::Interface>::IID
    }
}
pub trait IISDB_SDTT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetTableIdExt(&mut self) -> ::windows::core::Result<u16>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetOriginalNetworkId(&mut self) -> ::windows::core::Result<u16>;
    fn GetServiceId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordGroup(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordTargetVersion(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordNewVersion(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordDownloadLevel(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordVersionIndicator(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordScheduleTimeShiftInformation(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordCountOfSchedules(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordStartTimeByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetRecordDurationByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<MPEG_TIME>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetVersionHash(&mut self) -> ::windows::core::Result<u32>;
}
impl IISDB_SDTT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IISDB_SDTT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IISDB_SDTT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableIdExt<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableIdExt() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalNetworkId<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalNetworkId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordGroup<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordGroup(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTargetVersion<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTargetVersion(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNewVersion<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNewVersion(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDownloadLevel<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDownloadLevel(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordVersionIndicator<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordVersionIndicator(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordScheduleTimeShiftInformation<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordScheduleTimeShiftInformation(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfSchedules<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfSchedules(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTimeByIndex<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTimeByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDurationByIndex<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDurationByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetVersionHash<Impl: IISDB_SDTT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversionhash: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionHash() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversionhash = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetTableIdExt: GetTableIdExt::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetOriginalNetworkId: GetOriginalNetworkId::<Impl, IMPL_OFFSET>,
            GetServiceId: GetServiceId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordGroup: GetRecordGroup::<Impl, IMPL_OFFSET>,
            GetRecordTargetVersion: GetRecordTargetVersion::<Impl, IMPL_OFFSET>,
            GetRecordNewVersion: GetRecordNewVersion::<Impl, IMPL_OFFSET>,
            GetRecordDownloadLevel: GetRecordDownloadLevel::<Impl, IMPL_OFFSET>,
            GetRecordVersionIndicator: GetRecordVersionIndicator::<Impl, IMPL_OFFSET>,
            GetRecordScheduleTimeShiftInformation: GetRecordScheduleTimeShiftInformation::<Impl, IMPL_OFFSET>,
            GetRecordCountOfSchedules: GetRecordCountOfSchedules::<Impl, IMPL_OFFSET>,
            GetRecordStartTimeByIndex: GetRecordStartTimeByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDurationByIndex: GetRecordDurationByIndex::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetVersionHash: GetVersionHash::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IISDB_SDTT as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbAudioComponentDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetStreamContent(&mut self) -> ::windows::core::Result<u8>;
    fn GetComponentType(&mut self) -> ::windows::core::Result<u8>;
    fn GetComponentTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetStreamType(&mut self) -> ::windows::core::Result<u8>;
    fn GetSimulcastGroupTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetESMultiLingualFlag(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetMainComponentFlag(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetQualityIndicator(&mut self) -> ::windows::core::Result<u8>;
    fn GetSamplingRate(&mut self) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetLanguageCode2(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbAudioComponentDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbAudioComponentDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbAudioComponentDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamContent<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamContent() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentType<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamType<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSimulcastGroupTag<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSimulcastGroupTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetESMultiLingualFlag<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetESMultiLingualFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMainComponentFlag<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfval: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMainComponentFlag() {
                ::core::result::Result::Ok(ok__) => {
                    *pfval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityIndicator<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetQualityIndicator() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSamplingRate<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSamplingRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetLanguageCode2<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode2(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbAudioComponentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetStreamContent: GetStreamContent::<Impl, IMPL_OFFSET>,
            GetComponentType: GetComponentType::<Impl, IMPL_OFFSET>,
            GetComponentTag: GetComponentTag::<Impl, IMPL_OFFSET>,
            GetStreamType: GetStreamType::<Impl, IMPL_OFFSET>,
            GetSimulcastGroupTag: GetSimulcastGroupTag::<Impl, IMPL_OFFSET>,
            GetESMultiLingualFlag: GetESMultiLingualFlag::<Impl, IMPL_OFFSET>,
            GetMainComponentFlag: GetMainComponentFlag::<Impl, IMPL_OFFSET>,
            GetQualityIndicator: GetQualityIndicator::<Impl, IMPL_OFFSET>,
            GetSamplingRate: GetSamplingRate::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetLanguageCode2: GetLanguageCode2::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbAudioComponentDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbCAContractInformationDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCASystemId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCAUnitId(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordComponentTag(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetContractVerificationInfoLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetContractVerificationInfo(&mut self, bbuflength: u8) -> ::windows::core::Result<u8>;
    fn GetFeeNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbCAContractInformationDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbCAContractInformationDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbCAContractInformationDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCASystemId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAUnitId<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCAUnitId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordComponentTag<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordComponentTag(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContractVerificationInfoLength<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContractVerificationInfoLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContractVerificationInfo<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bbuflength: u8, pbbuf: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContractVerificationInfo(::core::mem::transmute_copy(&bbuflength)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbbuf = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFeeNameW<Impl: IIsdbCAContractInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFeeNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCASystemId: GetCASystemId::<Impl, IMPL_OFFSET>,
            GetCAUnitId: GetCAUnitId::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordComponentTag: GetRecordComponentTag::<Impl, IMPL_OFFSET>,
            GetContractVerificationInfoLength: GetContractVerificationInfoLength::<Impl, IMPL_OFFSET>,
            GetContractVerificationInfo: GetContractVerificationInfo::<Impl, IMPL_OFFSET>,
            GetFeeNameW: GetFeeNameW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbCAContractInformationDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbCADescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCASystemId(&mut self) -> ::windows::core::Result<u16>;
    fn GetReservedBits(&mut self) -> ::windows::core::Result<u8>;
    fn GetCAPID(&mut self) -> ::windows::core::Result<u16>;
    fn GetPrivateDataBytes(&mut self, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::Result<()>;
}
impl IIsdbCADescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbCADescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbCADescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCASystemId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReservedBits<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetReservedBits() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCAPID<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCAPID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataBytes<Impl: IIsdbCADescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPrivateDataBytes(::core::mem::transmute_copy(&pbbufferlength), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCASystemId: GetCASystemId::<Impl, IMPL_OFFSET>,
            GetReservedBits: GetReservedBits::<Impl, IMPL_OFFSET>,
            GetCAPID: GetCAPID::<Impl, IMPL_OFFSET>,
            GetPrivateDataBytes: GetPrivateDataBytes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbCADescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbCAServiceDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCASystemId(&mut self) -> ::windows::core::Result<u16>;
    fn GetCABroadcasterGroupId(&mut self) -> ::windows::core::Result<u8>;
    fn GetMessageControl(&mut self) -> ::windows::core::Result<u8>;
    fn GetServiceIds(&mut self, pbnumserviceids: *mut u8, pwserviceids: *mut u16) -> ::windows::core::Result<()>;
}
impl IIsdbCAServiceDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbCAServiceDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbCAServiceDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCASystemId<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCASystemId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCABroadcasterGroupId<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCABroadcasterGroupId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMessageControl<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMessageControl() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceIds<Impl: IIsdbCAServiceDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbnumserviceids: *mut u8, pwserviceids: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServiceIds(::core::mem::transmute_copy(&pbnumserviceids), ::core::mem::transmute_copy(&pwserviceids)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCASystemId: GetCASystemId::<Impl, IMPL_OFFSET>,
            GetCABroadcasterGroupId: GetCABroadcasterGroupId::<Impl, IMPL_OFFSET>,
            GetMessageControl: GetMessageControl::<Impl, IMPL_OFFSET>,
            GetServiceIds: GetServiceIds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbCAServiceDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbComponentGroupDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetComponentGroupType(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordGroupId(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordNumberOfCAUnit(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordCAUnitCAUnitId(&mut self, brecordindex: u8, bcaunitindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordCAUnitNumberOfComponents(&mut self, brecordindex: u8, bcaunitindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordCAUnitComponentTag(&mut self, brecordindex: u8, bcaunitindex: u8, bcomponentindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordTotalBitRate(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordTextW(&mut self, brecordindex: u8, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbComponentGroupDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbComponentGroupDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbComponentGroupDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentGroupType<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentGroupType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordGroupId<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordGroupId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfCAUnit<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfCAUnit(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitCAUnitId<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitCAUnitId(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&bcaunitindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitNumberOfComponents<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitNumberOfComponents(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&bcaunitindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCAUnitComponentTag<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bcaunitindex: u8, bcomponentindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCAUnitComponentTag(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&bcaunitindex), ::core::mem::transmute_copy(&bcomponentindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTotalBitRate<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTotalBitRate(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTextW<Impl: IIsdbComponentGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTextW(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetComponentGroupType: GetComponentGroupType::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordGroupId: GetRecordGroupId::<Impl, IMPL_OFFSET>,
            GetRecordNumberOfCAUnit: GetRecordNumberOfCAUnit::<Impl, IMPL_OFFSET>,
            GetRecordCAUnitCAUnitId: GetRecordCAUnitCAUnitId::<Impl, IMPL_OFFSET>,
            GetRecordCAUnitNumberOfComponents: GetRecordCAUnitNumberOfComponents::<Impl, IMPL_OFFSET>,
            GetRecordCAUnitComponentTag: GetRecordCAUnitComponentTag::<Impl, IMPL_OFFSET>,
            GetRecordTotalBitRate: GetRecordTotalBitRate::<Impl, IMPL_OFFSET>,
            GetRecordTextW: GetRecordTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbComponentGroupDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbDataContentDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetDataComponentId(&mut self) -> ::windows::core::Result<u16>;
    fn GetEntryComponent(&mut self) -> ::windows::core::Result<u8>;
    fn GetSelectorLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetSelectorBytes(&mut self, bbuflength: u8) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordComponentRef(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetLanguageCode(&mut self, pszcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbDataContentDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbDataContentDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbDataContentDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataComponentId<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataComponentId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryComponent<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntryComponent() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorLength<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSelectorLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectorBytes<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bbuflength: u8, pbbuf: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSelectorBytes(::core::mem::transmute_copy(&bbuflength)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbbuf = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordComponentRef<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordComponentRef(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguageCode<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLanguageCode(::core::mem::transmute_copy(&pszcode)).into()
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbDataContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetDataComponentId: GetDataComponentId::<Impl, IMPL_OFFSET>,
            GetEntryComponent: GetEntryComponent::<Impl, IMPL_OFFSET>,
            GetSelectorLength: GetSelectorLength::<Impl, IMPL_OFFSET>,
            GetSelectorBytes: GetSelectorBytes::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordComponentRef: GetRecordComponentRef::<Impl, IMPL_OFFSET>,
            GetLanguageCode: GetLanguageCode::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbDataContentDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbDigitalCopyControlDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCopyControl(&mut self, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordCopyControl(&mut self, brecordindex: u8, pbcomponenttag: *mut u8, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::Result<()>;
}
impl IIsdbDigitalCopyControlDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbDigitalCopyControlDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbDigitalCopyControlDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDigitalCopyControlDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDigitalCopyControlDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCopyControl<Impl: IIsdbDigitalCopyControlDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCopyControl(::core::mem::transmute_copy(&pbdigitalrecordingcontroldata), ::core::mem::transmute_copy(&pbcopycontroltype), ::core::mem::transmute_copy(&pbapscontroldata), ::core::mem::transmute_copy(&pbmaximumbitrate)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDigitalCopyControlDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCopyControl<Impl: IIsdbDigitalCopyControlDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbcomponenttag: *mut u8, pbdigitalrecordingcontroldata: *mut u8, pbcopycontroltype: *mut u8, pbapscontroldata: *mut u8, pbmaximumbitrate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordCopyControl(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pbcomponenttag), ::core::mem::transmute_copy(&pbdigitalrecordingcontroldata), ::core::mem::transmute_copy(&pbcopycontroltype), ::core::mem::transmute_copy(&pbapscontroldata), ::core::mem::transmute_copy(&pbmaximumbitrate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCopyControl: GetCopyControl::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordCopyControl: GetRecordCopyControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbDigitalCopyControlDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbDownloadContentDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetFlags(&mut self, pfreboot: *mut super::super::Foundation::BOOL, pfaddon: *mut super::super::Foundation::BOOL, pfcompatibility: *mut super::super::Foundation::BOOL, pfmoduleinfo: *mut super::super::Foundation::BOOL, pftextinfo: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetComponentSize(&mut self) -> ::windows::core::Result<u32>;
    fn GetDownloadId(&mut self) -> ::windows::core::Result<u32>;
    fn GetTimeOutValueDII(&mut self) -> ::windows::core::Result<u32>;
    fn GetLeakRate(&mut self) -> ::windows::core::Result<u32>;
    fn GetComponentTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetCompatiblityDescriptorLength(&mut self) -> ::windows::core::Result<u16>;
    fn GetCompatiblityDescriptor(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u16>;
    fn GetRecordModuleId(&mut self, wrecordindex: u16) -> ::windows::core::Result<u16>;
    fn GetRecordModuleSize(&mut self, wrecordindex: u16) -> ::windows::core::Result<u32>;
    fn GetRecordModuleInfoLength(&mut self, wrecordindex: u16) -> ::windows::core::Result<u8>;
    fn GetRecordModuleInfo(&mut self, wrecordindex: u16) -> ::windows::core::Result<*mut u8>;
    fn GetTextLanguageCode(&mut self, szcode: *mut u8) -> ::windows::core::Result<()>;
    fn GetTextW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbDownloadContentDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbDownloadContentDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbDownloadContentDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfreboot: *mut super::super::Foundation::BOOL, pfaddon: *mut super::super::Foundation::BOOL, pfcompatibility: *mut super::super::Foundation::BOOL, pfmoduleinfo: *mut super::super::Foundation::BOOL, pftextinfo: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFlags(::core::mem::transmute_copy(&pfreboot), ::core::mem::transmute_copy(&pfaddon), ::core::mem::transmute_copy(&pfcompatibility), ::core::mem::transmute_copy(&pfmoduleinfo), ::core::mem::transmute_copy(&pftextinfo)).into()
        }
        unsafe extern "system" fn GetComponentSize<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadId<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDownloadId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeOutValueDII<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimeOutValueDII() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeakRate<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLeakRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetComponentTag<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetComponentTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompatiblityDescriptorLength<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwlength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCompatiblityDescriptorLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pwlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompatiblityDescriptor<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCompatiblityDescriptor() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleId<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleId(::core::mem::transmute_copy(&wrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleSize<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleSize(::core::mem::transmute_copy(&wrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleInfoLength<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleInfoLength(::core::mem::transmute_copy(&wrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordModuleInfo<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wrecordindex: u16, ppbdata: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordModuleInfo(::core::mem::transmute_copy(&wrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppbdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextLanguageCode<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTextLanguageCode(::core::mem::transmute_copy(&szcode)).into()
        }
        unsafe extern "system" fn GetTextW<Impl: IIsdbDownloadContentDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            GetComponentSize: GetComponentSize::<Impl, IMPL_OFFSET>,
            GetDownloadId: GetDownloadId::<Impl, IMPL_OFFSET>,
            GetTimeOutValueDII: GetTimeOutValueDII::<Impl, IMPL_OFFSET>,
            GetLeakRate: GetLeakRate::<Impl, IMPL_OFFSET>,
            GetComponentTag: GetComponentTag::<Impl, IMPL_OFFSET>,
            GetCompatiblityDescriptorLength: GetCompatiblityDescriptorLength::<Impl, IMPL_OFFSET>,
            GetCompatiblityDescriptor: GetCompatiblityDescriptor::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordModuleId: GetRecordModuleId::<Impl, IMPL_OFFSET>,
            GetRecordModuleSize: GetRecordModuleSize::<Impl, IMPL_OFFSET>,
            GetRecordModuleInfoLength: GetRecordModuleInfoLength::<Impl, IMPL_OFFSET>,
            GetRecordModuleInfo: GetRecordModuleInfo::<Impl, IMPL_OFFSET>,
            GetTextLanguageCode: GetTextLanguageCode::<Impl, IMPL_OFFSET>,
            GetTextW: GetTextW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbDownloadContentDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbEmergencyInformationDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetServiceId(&mut self, brecordindex: u8) -> ::windows::core::Result<u16>;
    fn GetStartEndFlag(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetSignalLevel(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetAreaCode(&mut self, brecordindex: u8, ppwval: *mut *mut u16, pbnumareacodes: *mut u8) -> ::windows::core::Result<()>;
}
impl IIsdbEmergencyInformationDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbEmergencyInformationDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbEmergencyInformationDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceId<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartEndFlag<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStartEndFlag(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSignalLevel<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSignalLevel(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAreaCode<Impl: IIsdbEmergencyInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, ppwval: *mut *mut u16, pbnumareacodes: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAreaCode(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&ppwval), ::core::mem::transmute_copy(&pbnumareacodes)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetServiceId: GetServiceId::<Impl, IMPL_OFFSET>,
            GetStartEndFlag: GetStartEndFlag::<Impl, IMPL_OFFSET>,
            GetSignalLevel: GetSignalLevel::<Impl, IMPL_OFFSET>,
            GetAreaCode: GetAreaCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbEmergencyInformationDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbEventGroupDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetGroupType(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordEvent(&mut self, brecordindex: u8, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::Result<()>;
    fn GetCountOfRefRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRefRecordEvent(&mut self, brecordindex: u8, pworiginalnetworkid: *mut u16, pwtransportstreamid: *mut u16, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::Result<()>;
}
impl IIsdbEventGroupDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbEventGroupDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbEventGroupDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGroupType<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGroupType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEvent<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordEvent(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pwserviceid), ::core::mem::transmute_copy(&pweventid)).into()
        }
        unsafe extern "system" fn GetCountOfRefRecords<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRefRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRefRecordEvent<Impl: IIsdbEventGroupDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pworiginalnetworkid: *mut u16, pwtransportstreamid: *mut u16, pwserviceid: *mut u16, pweventid: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRefRecordEvent(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pworiginalnetworkid), ::core::mem::transmute_copy(&pwtransportstreamid), ::core::mem::transmute_copy(&pwserviceid), ::core::mem::transmute_copy(&pweventid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetGroupType: GetGroupType::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordEvent: GetRecordEvent::<Impl, IMPL_OFFSET>,
            GetCountOfRefRecords: GetCountOfRefRecords::<Impl, IMPL_OFFSET>,
            GetRefRecordEvent: GetRefRecordEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbEventGroupDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbHierarchicalTransmissionDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetFutureUse1(&mut self) -> ::windows::core::Result<u8>;
    fn GetQualityLevel(&mut self) -> ::windows::core::Result<u8>;
    fn GetFutureUse2(&mut self) -> ::windows::core::Result<u8>;
    fn GetReferencePid(&mut self) -> ::windows::core::Result<u16>;
}
impl IIsdbHierarchicalTransmissionDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbHierarchicalTransmissionDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFutureUse1<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFutureUse1() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityLevel<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetQualityLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFutureUse2<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFutureUse2() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReferencePid<Impl: IIsdbHierarchicalTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetReferencePid() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetFutureUse1: GetFutureUse1::<Impl, IMPL_OFFSET>,
            GetQualityLevel: GetQualityLevel::<Impl, IMPL_OFFSET>,
            GetFutureUse2: GetFutureUse2::<Impl, IMPL_OFFSET>,
            GetReferencePid: GetReferencePid::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbHierarchicalTransmissionDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbLogoTransmissionDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetLogoTransmissionType(&mut self) -> ::windows::core::Result<u8>;
    fn GetLogoId(&mut self) -> ::windows::core::Result<u16>;
    fn GetLogoVersion(&mut self) -> ::windows::core::Result<u16>;
    fn GetDownloadDataId(&mut self) -> ::windows::core::Result<u16>;
    fn GetLogoCharW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbLogoTransmissionDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbLogoTransmissionDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbLogoTransmissionDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoTransmissionType<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLogoTransmissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoId<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLogoId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoVersion<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLogoVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDownloadDataId<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDownloadDataId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLogoCharW<Impl: IIsdbLogoTransmissionDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrchar: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLogoCharW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrchar = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetLogoTransmissionType: GetLogoTransmissionType::<Impl, IMPL_OFFSET>,
            GetLogoId: GetLogoId::<Impl, IMPL_OFFSET>,
            GetLogoVersion: GetLogoVersion::<Impl, IMPL_OFFSET>,
            GetDownloadDataId: GetDownloadDataId::<Impl, IMPL_OFFSET>,
            GetLogoCharW: GetLogoCharW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbLogoTransmissionDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbSIParameterDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetParameterVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetUpdateTime(&mut self) -> ::windows::core::Result<MPEG_DATE>;
    fn GetRecordNumberOfTable(&mut self) -> ::windows::core::Result<u8>;
    fn GetTableId(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetTableDescriptionLength(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetTableDescriptionBytes(&mut self, brecordindex: u8, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::Result<()>;
}
impl IIsdbSIParameterDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbSIParameterDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbSIParameterDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterVersion<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParameterVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUpdateTime<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut MPEG_DATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUpdateTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfTable<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfTable() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableId<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableId(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptionLength<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptionLength(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptionBytes<Impl: IIsdbSIParameterDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbbufferlength: *mut u8, pbbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptionBytes(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&pbbufferlength), ::core::mem::transmute_copy(&pbbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetParameterVersion: GetParameterVersion::<Impl, IMPL_OFFSET>,
            GetUpdateTime: GetUpdateTime::<Impl, IMPL_OFFSET>,
            GetRecordNumberOfTable: GetRecordNumberOfTable::<Impl, IMPL_OFFSET>,
            GetTableId: GetTableId::<Impl, IMPL_OFFSET>,
            GetTableDescriptionLength: GetTableDescriptionLength::<Impl, IMPL_OFFSET>,
            GetTableDescriptionBytes: GetTableDescriptionBytes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbSIParameterDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbSeriesDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetSeriesId(&mut self) -> ::windows::core::Result<u16>;
    fn GetRepeatLabel(&mut self) -> ::windows::core::Result<u8>;
    fn GetProgramPattern(&mut self) -> ::windows::core::Result<u8>;
    fn GetExpireDate(&mut self, pfvalid: *mut super::super::Foundation::BOOL, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::Result<()>;
    fn GetEpisodeNumber(&mut self) -> ::windows::core::Result<u16>;
    fn GetLastEpisodeNumber(&mut self) -> ::windows::core::Result<u16>;
    fn GetSeriesNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbSeriesDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbSeriesDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbSeriesDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeriesId<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSeriesId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepeatLabel<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRepeatLabel() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgramPattern<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProgramPattern() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpireDate<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfvalid: *mut super::super::Foundation::BOOL, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExpireDate(::core::mem::transmute_copy(&pfvalid), ::core::mem::transmute_copy(&pmdtval)).into()
        }
        unsafe extern "system" fn GetEpisodeNumber<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEpisodeNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastEpisodeNumber<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLastEpisodeNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeriesNameW<Impl: IIsdbSeriesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSeriesNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetSeriesId: GetSeriesId::<Impl, IMPL_OFFSET>,
            GetRepeatLabel: GetRepeatLabel::<Impl, IMPL_OFFSET>,
            GetProgramPattern: GetProgramPattern::<Impl, IMPL_OFFSET>,
            GetExpireDate: GetExpireDate::<Impl, IMPL_OFFSET>,
            GetEpisodeNumber: GetEpisodeNumber::<Impl, IMPL_OFFSET>,
            GetLastEpisodeNumber: GetLastEpisodeNumber::<Impl, IMPL_OFFSET>,
            GetSeriesNameW: GetSeriesNameW::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbSeriesDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbSiParser2_Impl: Sized + IDvbSiParser_Impl + IDvbSiParser2_Impl {
    fn GetSDT2(&mut self, tableid: u8, pwtransportstreamid: *const u16) -> ::windows::core::Result<IISDB_SDT>;
    fn GetBIT(&mut self, tableid: u8, pworiginalnetworkid: *const u16) -> ::windows::core::Result<IISDB_BIT>;
    fn GetNBIT(&mut self, tableid: u8, pworiginalnetworkid: *const u16) -> ::windows::core::Result<IISDB_NBIT>;
    fn GetLDT(&mut self, tableid: u8, pworiginalserviceid: *const u16) -> ::windows::core::Result<IISDB_LDT>;
    fn GetSDTT(&mut self, tableid: u8, pwtableidext: *const u16) -> ::windows::core::Result<IISDB_SDTT>;
    fn GetCDT(&mut self, tableid: u8, bsectionnumber: u8, pwdownloaddataid: *const u16) -> ::windows::core::Result<IISDB_CDT>;
    fn GetEMM(&mut self, pid: u16, wtableidext: u16) -> ::windows::core::Result<IISDB_EMM>;
}
impl IIsdbSiParser2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbSiParser2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbSiParser2_Vtbl {
        unsafe extern "system" fn GetSDT2<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtransportstreamid: *const u16, ppsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSDT2(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwtransportstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBIT<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalnetworkid: *const u16, ppbit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBIT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pworiginalnetworkid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppbit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNBIT<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalnetworkid: *const u16, ppnbit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNBIT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pworiginalnetworkid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnbit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLDT<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pworiginalserviceid: *const u16, ppldt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLDT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pworiginalserviceid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppldt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSDTT<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, pwtableidext: *const u16, ppsdtt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSDTT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&pwtableidext)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsdtt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCDT<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tableid: u8, bsectionnumber: u8, pwdownloaddataid: *const u16, ppcdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCDT(::core::mem::transmute_copy(&tableid), ::core::mem::transmute_copy(&bsectionnumber), ::core::mem::transmute_copy(&pwdownloaddataid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEMM<Impl: IIsdbSiParser2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, wtableidext: u16, ppemm: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEMM(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&wtableidext)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppemm = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDvbSiParser2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSDT2: GetSDT2::<Impl, IMPL_OFFSET>,
            GetBIT: GetBIT::<Impl, IMPL_OFFSET>,
            GetNBIT: GetNBIT::<Impl, IMPL_OFFSET>,
            GetLDT: GetLDT::<Impl, IMPL_OFFSET>,
            GetSDTT: GetSDTT::<Impl, IMPL_OFFSET>,
            GetCDT: GetCDT::<Impl, IMPL_OFFSET>,
            GetEMM: GetEMM::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbSiParser2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IIsdbTSInformationDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetRemoteControlKeyId(&mut self) -> ::windows::core::Result<u8>;
    fn GetTSNameW(&mut self, convmode: DVB_STRCONV_MODE) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordTransmissionTypeInfo(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordNumberOfServices(&mut self, brecordindex: u8) -> ::windows::core::Result<u8>;
    fn GetRecordServiceIdByIndex(&mut self, brecordindex: u8, bserviceindex: u8) -> ::windows::core::Result<u16>;
}
#[cfg(feature = "Win32_Foundation")]
impl IIsdbTSInformationDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbTSInformationDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbTSInformationDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRemoteControlKeyId<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRemoteControlKeyId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTSNameW<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, convmode: DVB_STRCONV_MODE, pbstrname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTSNameW(::core::mem::transmute_copy(&convmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordTransmissionTypeInfo<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordTransmissionTypeInfo(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordNumberOfServices<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordNumberOfServices(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordServiceIdByIndex<Impl: IIsdbTSInformationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, bserviceindex: u8, pdwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordServiceIdByIndex(::core::mem::transmute_copy(&brecordindex), ::core::mem::transmute_copy(&bserviceindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetRemoteControlKeyId: GetRemoteControlKeyId::<Impl, IMPL_OFFSET>,
            GetTSNameW: GetTSNameW::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordTransmissionTypeInfo: GetRecordTransmissionTypeInfo::<Impl, IMPL_OFFSET>,
            GetRecordNumberOfServices: GetRecordNumberOfServices::<Impl, IMPL_OFFSET>,
            GetRecordServiceIdByIndex: GetRecordServiceIdByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbTSInformationDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IIsdbTerrestrialDeliverySystemDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u8>;
    fn GetAreaCode(&mut self) -> ::windows::core::Result<u16>;
    fn GetGuardInterval(&mut self) -> ::windows::core::Result<u8>;
    fn GetTransmissionMode(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u8>;
    fn GetRecordFrequency(&mut self, brecordindex: u8) -> ::windows::core::Result<u32>;
}
impl IIsdbTerrestrialDeliverySystemDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IIsdbTerrestrialDeliverySystemDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAreaCode<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAreaCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGuardInterval<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGuardInterval() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransmissionMode<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransmissionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordFrequency<Impl: IIsdbTerrestrialDeliverySystemDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brecordindex: u8, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordFrequency(::core::mem::transmute_copy(&brecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetAreaCode: GetAreaCode::<Impl, IMPL_OFFSET>,
            GetGuardInterval: GetGuardInterval::<Impl, IMPL_OFFSET>,
            GetTransmissionMode: GetTransmissionMode::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordFrequency: GetRecordFrequency::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IIsdbTerrestrialDeliverySystemDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IKsNodeControl_Impl: Sized {
    fn SetNodeId(&mut self, dwnodeid: u32) -> ::windows::core::Result<()>;
    fn SetKsControl(&mut self, pkscontrol: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IKsNodeControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IKsNodeControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IKsNodeControl_Vtbl {
        unsafe extern "system" fn SetNodeId<Impl: IKsNodeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnodeid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNodeId(::core::mem::transmute_copy(&dwnodeid)).into()
        }
        unsafe extern "system" fn SetKsControl<Impl: IKsNodeControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkscontrol: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKsControl(::core::mem::transmute_copy(&pkscontrol)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetNodeId: SetNodeId::<Impl, IMPL_OFFSET>,
            SetKsControl: SetKsControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IKsNodeControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
pub trait IKsTopologyInfo_Impl: Sized {
    fn NumCategories(&mut self) -> ::windows::core::Result<u32>;
    fn Category(&mut self, dwindex: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn NumConnections(&mut self) -> ::windows::core::Result<u32>;
    fn ConnectionInfo(&mut self, dwindex: u32) -> ::windows::core::Result<super::KernelStreaming::KSTOPOLOGY_CONNECTION>;
    fn NodeName(&mut self, dwnodeid: u32, pwchnodename: super::super::Foundation::PWSTR, dwbufsize: u32, pdwnamelen: *mut u32) -> ::windows::core::Result<()>;
    fn NumNodes(&mut self) -> ::windows::core::Result<u32>;
    fn NodeType(&mut self, dwnodeid: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn CreateNodeInstance(&mut self, dwnodeid: u32, iid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl IKsTopologyInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IKsTopologyInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IKsTopologyInfo_Vtbl {
        unsafe extern "system" fn NumCategories<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumcategories: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumCategories() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumcategories = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pcategory: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Category(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcategory = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumConnections<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumconnections: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumConnections() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumconnections = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionInfo<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pconnectioninfo: *mut super::KernelStreaming::KSTOPOLOGY_CONNECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectionInfo(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pconnectioninfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NodeName<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, pwchnodename: super::super::Foundation::PWSTR, dwbufsize: u32, pdwnamelen: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NodeName(::core::mem::transmute_copy(&dwnodeid), ::core::mem::transmute_copy(&pwchnodename), ::core::mem::transmute_copy(&dwbufsize), ::core::mem::transmute_copy(&pdwnamelen)).into()
        }
        unsafe extern "system" fn NumNodes<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumnodes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumnodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NodeType<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, pnodetype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NodeType(::core::mem::transmute_copy(&dwnodeid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pnodetype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateNodeInstance<Impl: IKsTopologyInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnodeid: u32, iid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateNodeInstance(::core::mem::transmute_copy(&dwnodeid), ::core::mem::transmute_copy(&iid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            NumCategories: NumCategories::<Impl, IMPL_OFFSET>,
            Category: Category::<Impl, IMPL_OFFSET>,
            NumConnections: NumConnections::<Impl, IMPL_OFFSET>,
            ConnectionInfo: ConnectionInfo::<Impl, IMPL_OFFSET>,
            NodeName: NodeName::<Impl, IMPL_OFFSET>,
            NumNodes: NumNodes::<Impl, IMPL_OFFSET>,
            NodeType: NodeType::<Impl, IMPL_OFFSET>,
            CreateNodeInstance: CreateNodeInstance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IKsTopologyInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ILanguageComponentType_Impl: Sized + super::super::System::Com::IDispatch_Impl + IComponentType_Impl {
    fn LangID(&mut self) -> ::windows::core::Result<i32>;
    fn SetLangID(&mut self, langid: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ILanguageComponentType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ILanguageComponentType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ILanguageComponentType_Vtbl {
        unsafe extern "system" fn LangID<Impl: ILanguageComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, langid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LangID() {
                ::core::result::Result::Ok(ok__) => {
                    *langid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLangID<Impl: ILanguageComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, langid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLangID(::core::mem::transmute_copy(&langid)).into()
        }
        Self {
            base: IComponentType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            LangID: LangID::<Impl, IMPL_OFFSET>,
            SetLangID: SetLangID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ILanguageComponentType as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ILocator_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn CarrierFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn SetCarrierFrequency(&mut self, frequency: i32) -> ::windows::core::Result<()>;
    fn InnerFEC(&mut self) -> ::windows::core::Result<FECMethod>;
    fn SetInnerFEC(&mut self, fec: FECMethod) -> ::windows::core::Result<()>;
    fn InnerFECRate(&mut self) -> ::windows::core::Result<BinaryConvolutionCodeRate>;
    fn SetInnerFECRate(&mut self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn OuterFEC(&mut self) -> ::windows::core::Result<FECMethod>;
    fn SetOuterFEC(&mut self, fec: FECMethod) -> ::windows::core::Result<()>;
    fn OuterFECRate(&mut self) -> ::windows::core::Result<BinaryConvolutionCodeRate>;
    fn SetOuterFECRate(&mut self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()>;
    fn Modulation(&mut self) -> ::windows::core::Result<ModulationType>;
    fn SetModulation(&mut self, modulation: ModulationType) -> ::windows::core::Result<()>;
    fn SymbolRate(&mut self) -> ::windows::core::Result<i32>;
    fn SetSymbolRate(&mut self, rate: i32) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<ILocator>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ILocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ILocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ILocator_Vtbl {
        unsafe extern "system" fn CarrierFrequency<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frequency: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CarrierFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *frequency = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCarrierFrequency<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frequency: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCarrierFrequency(::core::mem::transmute_copy(&frequency)).into()
        }
        unsafe extern "system" fn InnerFEC<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InnerFEC() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFEC<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInnerFEC(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn InnerFECRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InnerFECRate() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInnerFECRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInnerFECRate(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn OuterFEC<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OuterFEC() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFEC<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: FECMethod) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOuterFEC(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn OuterFECRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: *mut BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OuterFECRate() {
                ::core::result::Result::Ok(ok__) => {
                    *fec = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOuterFECRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fec: BinaryConvolutionCodeRate) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOuterFECRate(::core::mem::transmute_copy(&fec)).into()
        }
        unsafe extern "system" fn Modulation<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, modulation: *mut ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Modulation() {
                ::core::result::Result::Ok(ok__) => {
                    *modulation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetModulation<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, modulation: ModulationType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetModulation(::core::mem::transmute_copy(&modulation)).into()
        }
        unsafe extern "system" fn SymbolRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SymbolRate() {
                ::core::result::Result::Ok(ok__) => {
                    *rate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbolRate<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSymbolRate(::core::mem::transmute_copy(&rate)).into()
        }
        unsafe extern "system" fn Clone<Impl: ILocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newlocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newlocator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CarrierFrequency: CarrierFrequency::<Impl, IMPL_OFFSET>,
            SetCarrierFrequency: SetCarrierFrequency::<Impl, IMPL_OFFSET>,
            InnerFEC: InnerFEC::<Impl, IMPL_OFFSET>,
            SetInnerFEC: SetInnerFEC::<Impl, IMPL_OFFSET>,
            InnerFECRate: InnerFECRate::<Impl, IMPL_OFFSET>,
            SetInnerFECRate: SetInnerFECRate::<Impl, IMPL_OFFSET>,
            OuterFEC: OuterFEC::<Impl, IMPL_OFFSET>,
            SetOuterFEC: SetOuterFEC::<Impl, IMPL_OFFSET>,
            OuterFECRate: OuterFECRate::<Impl, IMPL_OFFSET>,
            SetOuterFECRate: SetOuterFECRate::<Impl, IMPL_OFFSET>,
            Modulation: Modulation::<Impl, IMPL_OFFSET>,
            SetModulation: SetModulation::<Impl, IMPL_OFFSET>,
            SymbolRate: SymbolRate::<Impl, IMPL_OFFSET>,
            SetSymbolRate: SetSymbolRate::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ILocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMPEG2Component_Impl: Sized + super::super::System::Com::IDispatch_Impl + IComponent_Impl {
    fn PID(&mut self) -> ::windows::core::Result<i32>;
    fn SetPID(&mut self, pid: i32) -> ::windows::core::Result<()>;
    fn PCRPID(&mut self) -> ::windows::core::Result<i32>;
    fn SetPCRPID(&mut self, pcrpid: i32) -> ::windows::core::Result<()>;
    fn ProgramNumber(&mut self) -> ::windows::core::Result<i32>;
    fn SetProgramNumber(&mut self, programnumber: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMPEG2Component_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2Component_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2Component_Vtbl {
        unsafe extern "system" fn PID<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PID() {
                ::core::result::Result::Ok(ok__) => {
                    *pid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPID<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPID(::core::mem::transmute_copy(&pid)).into()
        }
        unsafe extern "system" fn PCRPID<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcrpid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PCRPID() {
                ::core::result::Result::Ok(ok__) => {
                    *pcrpid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPCRPID<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcrpid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPCRPID(::core::mem::transmute_copy(&pcrpid)).into()
        }
        unsafe extern "system" fn ProgramNumber<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, programnumber: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProgramNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *programnumber = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgramNumber<Impl: IMPEG2Component_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, programnumber: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProgramNumber(::core::mem::transmute_copy(&programnumber)).into()
        }
        Self {
            base: IComponent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            PID: PID::<Impl, IMPL_OFFSET>,
            SetPID: SetPID::<Impl, IMPL_OFFSET>,
            PCRPID: PCRPID::<Impl, IMPL_OFFSET>,
            SetPCRPID: SetPCRPID::<Impl, IMPL_OFFSET>,
            ProgramNumber: ProgramNumber::<Impl, IMPL_OFFSET>,
            SetProgramNumber: SetProgramNumber::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2Component as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMPEG2ComponentType_Impl: Sized + super::super::System::Com::IDispatch_Impl + IComponentType_Impl + ILanguageComponentType_Impl {
    fn StreamType(&mut self) -> ::windows::core::Result<MPEG2StreamType>;
    fn SetStreamType(&mut self, mp2streamtype: MPEG2StreamType) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMPEG2ComponentType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2ComponentType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2ComponentType_Vtbl {
        unsafe extern "system" fn StreamType<Impl: IMPEG2ComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mp2streamtype: *mut MPEG2StreamType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StreamType() {
                ::core::result::Result::Ok(ok__) => {
                    *mp2streamtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamType<Impl: IMPEG2ComponentType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mp2streamtype: MPEG2StreamType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamType(::core::mem::transmute_copy(&mp2streamtype)).into()
        }
        Self {
            base: ILanguageComponentType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            StreamType: StreamType::<Impl, IMPL_OFFSET>,
            SetStreamType: SetStreamType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2ComponentType as ::windows::core::Interface>::IID
    }
}
pub trait IMPEG2PIDMap_Impl: Sized {
    fn MapPID(&mut self, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> ::windows::core::Result<()>;
    fn UnmapPID(&mut self, culpid: u32, pulpid: *const u32) -> ::windows::core::Result<()>;
    fn EnumPIDMap(&mut self) -> ::windows::core::Result<IEnumPIDMap>;
}
impl IMPEG2PIDMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2PIDMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2PIDMap_Vtbl {
        unsafe extern "system" fn MapPID<Impl: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MapPID(::core::mem::transmute_copy(&culpid), ::core::mem::transmute_copy(&pulpid), ::core::mem::transmute_copy(&mediasamplecontent)).into()
        }
        unsafe extern "system" fn UnmapPID<Impl: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, culpid: u32, pulpid: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnmapPID(::core::mem::transmute_copy(&culpid), ::core::mem::transmute_copy(&pulpid)).into()
        }
        unsafe extern "system" fn EnumPIDMap<Impl: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pienumpidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumPIDMap() {
                ::core::result::Result::Ok(ok__) => {
                    *pienumpidmap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            MapPID: MapPID::<Impl, IMPL_OFFSET>,
            UnmapPID: UnmapPID::<Impl, IMPL_OFFSET>,
            EnumPIDMap: EnumPIDMap::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2PIDMap as ::windows::core::Interface>::IID
    }
}
pub trait IMPEG2StreamIdMap_Impl: Sized {
    fn MapStreamId(&mut self, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> ::windows::core::Result<()>;
    fn UnmapStreamId(&mut self, culstreamid: u32, pulstreamid: *const u32) -> ::windows::core::Result<()>;
    fn EnumStreamIdMap(&mut self) -> ::windows::core::Result<IEnumStreamIdMap>;
}
impl IMPEG2StreamIdMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2StreamIdMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2StreamIdMap_Vtbl {
        unsafe extern "system" fn MapStreamId<Impl: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MapStreamId(::core::mem::transmute_copy(&ulstreamid), ::core::mem::transmute_copy(&mediasamplecontent), ::core::mem::transmute_copy(&ulsubstreamfiltervalue), ::core::mem::transmute_copy(&idataoffset)).into()
        }
        unsafe extern "system" fn UnmapStreamId<Impl: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, culstreamid: u32, pulstreamid: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnmapStreamId(::core::mem::transmute_copy(&culstreamid), ::core::mem::transmute_copy(&pulstreamid)).into()
        }
        unsafe extern "system" fn EnumStreamIdMap<Impl: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumstreamidmap: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumStreamIdMap() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumstreamidmap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            MapStreamId: MapStreamId::<Impl, IMPL_OFFSET>,
            UnmapStreamId: UnmapStreamId::<Impl, IMPL_OFFSET>,
            EnumStreamIdMap: EnumStreamIdMap::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2StreamIdMap as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMPEG2TuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl + ITuneRequest_Impl {
    fn TSID(&mut self) -> ::windows::core::Result<i32>;
    fn SetTSID(&mut self, tsid: i32) -> ::windows::core::Result<()>;
    fn ProgNo(&mut self) -> ::windows::core::Result<i32>;
    fn SetProgNo(&mut self, progno: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMPEG2TuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2TuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2TuneRequest_Vtbl {
        unsafe extern "system" fn TSID<Impl: IMPEG2TuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TSID() {
                ::core::result::Result::Ok(ok__) => {
                    *tsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTSID<Impl: IMPEG2TuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tsid: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTSID(::core::mem::transmute_copy(&tsid)).into()
        }
        unsafe extern "system" fn ProgNo<Impl: IMPEG2TuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, progno: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ProgNo() {
                ::core::result::Result::Ok(ok__) => {
                    *progno = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProgNo<Impl: IMPEG2TuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, progno: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProgNo(::core::mem::transmute_copy(&progno)).into()
        }
        Self {
            base: ITuneRequest_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            TSID: TSID::<Impl, IMPL_OFFSET>,
            SetTSID: SetTSID::<Impl, IMPL_OFFSET>,
            ProgNo: ProgNo::<Impl, IMPL_OFFSET>,
            SetProgNo: SetProgNo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2TuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMPEG2TuneRequestFactory_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn CreateTuneRequest(&mut self, tuningspace: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<IMPEG2TuneRequest>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMPEG2TuneRequestFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2TuneRequestFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2TuneRequestFactory_Vtbl {
        unsafe extern "system" fn CreateTuneRequest<Impl: IMPEG2TuneRequestFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequest(::core::mem::transmute(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateTuneRequest: CreateTuneRequest::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2TuneRequestFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMPEG2TuneRequestSupport_Impl: Sized {}
impl IMPEG2TuneRequestSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2TuneRequestSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2TuneRequestSupport_Vtbl {
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2TuneRequestSupport as ::windows::core::Interface>::IID
    }
}
pub trait IMPEG2_TIF_CONTROL_Impl: Sized {
    fn RegisterTIF(&mut self, punktif: &::core::option::Option<::windows::core::IUnknown>, ppvregistrationcontext: *mut u32) -> ::windows::core::Result<()>;
    fn UnregisterTIF(&mut self, pvregistrationcontext: u32) -> ::windows::core::Result<()>;
    fn AddPIDs(&mut self, ulcpids: u32, pulpids: *const u32) -> ::windows::core::Result<()>;
    fn DeletePIDs(&mut self, ulcpids: u32, pulpids: *const u32) -> ::windows::core::Result<()>;
    fn GetPIDCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetPIDs(&mut self, pulcpids: *mut u32, pulpids: *mut u32) -> ::windows::core::Result<()>;
}
impl IMPEG2_TIF_CONTROL_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMPEG2_TIF_CONTROL_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMPEG2_TIF_CONTROL_Vtbl {
        unsafe extern "system" fn RegisterTIF<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punktif: *mut ::core::ffi::c_void, ppvregistrationcontext: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterTIF(::core::mem::transmute(&punktif), ::core::mem::transmute_copy(&ppvregistrationcontext)).into()
        }
        unsafe extern "system" fn UnregisterTIF<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvregistrationcontext: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterTIF(::core::mem::transmute_copy(&pvregistrationcontext)).into()
        }
        unsafe extern "system" fn AddPIDs<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcpids: u32, pulpids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddPIDs(::core::mem::transmute_copy(&ulcpids), ::core::mem::transmute_copy(&pulpids)).into()
        }
        unsafe extern "system" fn DeletePIDs<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcpids: u32, pulpids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeletePIDs(::core::mem::transmute_copy(&ulcpids), ::core::mem::transmute_copy(&pulpids)).into()
        }
        unsafe extern "system" fn GetPIDCount<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcpids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPIDCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pulcpids = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPIDs<Impl: IMPEG2_TIF_CONTROL_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcpids: *mut u32, pulpids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPIDs(::core::mem::transmute_copy(&pulcpids), ::core::mem::transmute_copy(&pulpids)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterTIF: RegisterTIF::<Impl, IMPL_OFFSET>,
            UnregisterTIF: UnregisterTIF::<Impl, IMPL_OFFSET>,
            AddPIDs: AddPIDs::<Impl, IMPL_OFFSET>,
            DeletePIDs: DeletePIDs::<Impl, IMPL_OFFSET>,
            GetPIDCount: GetPIDCount::<Impl, IMPL_OFFSET>,
            GetPIDs: GetPIDs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMPEG2_TIF_CONTROL as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSEventBinder_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Bind(&mut self, peventobject: &::core::option::Option<super::super::System::Com::IDispatch>, eventname: &super::super::Foundation::BSTR, eventhandler: &super::super::Foundation::BSTR) -> ::windows::core::Result<i32>;
    fn Unbind(&mut self, cancelcookie: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSEventBinder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSEventBinder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSEventBinder_Vtbl {
        unsafe extern "system" fn Bind<Impl: IMSEventBinder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peventobject: ::windows::core::RawPtr, eventname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, eventhandler: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, cancelid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Bind(::core::mem::transmute(&peventobject), ::core::mem::transmute_copy(&eventname), ::core::mem::transmute_copy(&eventhandler)) {
                ::core::result::Result::Ok(ok__) => {
                    *cancelid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unbind<Impl: IMSEventBinder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cancelcookie: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unbind(::core::mem::transmute_copy(&cancelcookie)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Bind: Bind::<Impl, IMPL_OFFSET>,
            Unbind: Unbind::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSEventBinder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAnalogTuner_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidVideoInputDevice_Impl + IMSVidTuner_Impl {
    fn Channel(&mut self) -> ::windows::core::Result<i32>;
    fn SetChannel(&mut self, channel: i32) -> ::windows::core::Result<()>;
    fn VideoFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn AudioFrequency(&mut self) -> ::windows::core::Result<i32>;
    fn CountryCode(&mut self) -> ::windows::core::Result<i32>;
    fn SetCountryCode(&mut self, lcc: i32) -> ::windows::core::Result<()>;
    fn SAP(&mut self) -> ::windows::core::Result<i16>;
    fn SetSAP(&mut self, fsapon: i16) -> ::windows::core::Result<()>;
    fn ChannelAvailable(&mut self, nchannel: i32, signalstrength: *mut i32, fsignalpresent: *mut i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAnalogTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAnalogTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAnalogTuner_Vtbl {
        unsafe extern "system" fn Channel<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Channel() {
                ::core::result::Result::Ok(ok__) => {
                    *channel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannel<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channel: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChannel(::core::mem::transmute_copy(&channel)).into()
        }
        unsafe extern "system" fn VideoFrequency<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *lcc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioFrequency<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *lcc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CountryCode<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcc: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CountryCode() {
                ::core::result::Result::Ok(ok__) => {
                    *lcc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCountryCode<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcc: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCountryCode(::core::mem::transmute_copy(&lcc)).into()
        }
        unsafe extern "system" fn SAP<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfsapon: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SAP() {
                ::core::result::Result::Ok(ok__) => {
                    *pfsapon = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSAP<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fsapon: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSAP(::core::mem::transmute_copy(&fsapon)).into()
        }
        unsafe extern "system" fn ChannelAvailable<Impl: IMSVidAnalogTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, nchannel: i32, signalstrength: *mut i32, fsignalpresent: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChannelAvailable(::core::mem::transmute_copy(&nchannel), ::core::mem::transmute_copy(&signalstrength), ::core::mem::transmute_copy(&fsignalpresent)).into()
        }
        Self {
            base: IMSVidTuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Channel: Channel::<Impl, IMPL_OFFSET>,
            SetChannel: SetChannel::<Impl, IMPL_OFFSET>,
            VideoFrequency: VideoFrequency::<Impl, IMPL_OFFSET>,
            AudioFrequency: AudioFrequency::<Impl, IMPL_OFFSET>,
            CountryCode: CountryCode::<Impl, IMPL_OFFSET>,
            SetCountryCode: SetCountryCode::<Impl, IMPL_OFFSET>,
            SAP: SAP::<Impl, IMPL_OFFSET>,
            SetSAP: SetSAP::<Impl, IMPL_OFFSET>,
            ChannelAvailable: ChannelAvailable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAnalogTuner as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAnalogTuner2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidVideoInputDevice_Impl + IMSVidTuner_Impl + IMSVidAnalogTuner_Impl {
    fn TVFormats(&mut self) -> ::windows::core::Result<i32>;
    fn TunerModes(&mut self) -> ::windows::core::Result<i32>;
    fn NumAuxInputs(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAnalogTuner2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAnalogTuner2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAnalogTuner2_Vtbl {
        unsafe extern "system" fn TVFormats<Impl: IMSVidAnalogTuner2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, formats: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TVFormats() {
                ::core::result::Result::Ok(ok__) => {
                    *formats = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TunerModes<Impl: IMSVidAnalogTuner2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, modes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TunerModes() {
                ::core::result::Result::Ok(ok__) => {
                    *modes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumAuxInputs<Impl: IMSVidAnalogTuner2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumAuxInputs() {
                ::core::result::Result::Ok(ok__) => {
                    *inputs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidAnalogTuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            TVFormats: TVFormats::<Impl, IMPL_OFFSET>,
            TunerModes: TunerModes::<Impl, IMPL_OFFSET>,
            NumAuxInputs: NumAuxInputs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAnalogTuner2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAnalogTunerEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidTunerEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAnalogTunerEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAnalogTunerEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAnalogTunerEvent_Vtbl {
        Self { base: IMSVidTunerEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAnalogTunerEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAudioRenderer_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl {
    fn SetVolume(&mut self, lvol: i32) -> ::windows::core::Result<()>;
    fn Volume(&mut self) -> ::windows::core::Result<i32>;
    fn SetBalance(&mut self, lbal: i32) -> ::windows::core::Result<()>;
    fn Balance(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAudioRenderer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAudioRenderer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAudioRenderer_Vtbl {
        unsafe extern "system" fn SetVolume<Impl: IMSVidAudioRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvol: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(::core::mem::transmute_copy(&lvol)).into()
        }
        unsafe extern "system" fn Volume<Impl: IMSVidAudioRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lvol: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Volume() {
                ::core::result::Result::Ok(ok__) => {
                    *lvol = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMSVidAudioRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lbal: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(::core::mem::transmute_copy(&lbal)).into()
        }
        unsafe extern "system" fn Balance<Impl: IMSVidAudioRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lbal: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Balance() {
                ::core::result::Result::Ok(ok__) => {
                    *lbal = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidOutputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            Volume: Volume::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            Balance: Balance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAudioRenderer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAudioRendererDevices_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IMSVidAudioRenderer>;
    fn Add(&mut self, pdb: &::core::option::Option<IMSVidAudioRenderer>) -> ::windows::core::Result<()>;
    fn Remove(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAudioRendererDevices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAudioRendererDevices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAudioRendererDevices_Vtbl {
        unsafe extern "system" fn Count<Impl: IMSVidAudioRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *lcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidAudioRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *pd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidAudioRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidAudioRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Add(::core::mem::transmute(&pdb)).into()
        }
        unsafe extern "system" fn Remove<Impl: IMSVidAudioRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAudioRendererDevices as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAudioRendererEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAudioRendererEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAudioRendererEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAudioRendererEvent_Vtbl {
        Self { base: IMSVidOutputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAudioRendererEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidAudioRendererEvent2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl + IMSVidAudioRendererEvent_Impl {
    fn AVDecAudioDualMono(&mut self) -> ::windows::core::Result<()>;
    fn AVAudioSampleRate(&mut self) -> ::windows::core::Result<()>;
    fn AVAudioChannelConfig(&mut self) -> ::windows::core::Result<()>;
    fn AVAudioChannelCount(&mut self) -> ::windows::core::Result<()>;
    fn AVDecCommonMeanBitRate(&mut self) -> ::windows::core::Result<()>;
    fn AVDDSurroundMode(&mut self) -> ::windows::core::Result<()>;
    fn AVDecCommonInputFormat(&mut self) -> ::windows::core::Result<()>;
    fn AVDecCommonOutputFormat(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidAudioRendererEvent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidAudioRendererEvent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidAudioRendererEvent2_Vtbl {
        unsafe extern "system" fn AVDecAudioDualMono<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVDecAudioDualMono().into()
        }
        unsafe extern "system" fn AVAudioSampleRate<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVAudioSampleRate().into()
        }
        unsafe extern "system" fn AVAudioChannelConfig<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVAudioChannelConfig().into()
        }
        unsafe extern "system" fn AVAudioChannelCount<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVAudioChannelCount().into()
        }
        unsafe extern "system" fn AVDecCommonMeanBitRate<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVDecCommonMeanBitRate().into()
        }
        unsafe extern "system" fn AVDDSurroundMode<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVDDSurroundMode().into()
        }
        unsafe extern "system" fn AVDecCommonInputFormat<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVDecCommonInputFormat().into()
        }
        unsafe extern "system" fn AVDecCommonOutputFormat<Impl: IMSVidAudioRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AVDecCommonOutputFormat().into()
        }
        Self {
            base: IMSVidAudioRendererEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AVDecAudioDualMono: AVDecAudioDualMono::<Impl, IMPL_OFFSET>,
            AVAudioSampleRate: AVAudioSampleRate::<Impl, IMPL_OFFSET>,
            AVAudioChannelConfig: AVAudioChannelConfig::<Impl, IMPL_OFFSET>,
            AVAudioChannelCount: AVAudioChannelCount::<Impl, IMPL_OFFSET>,
            AVDecCommonMeanBitRate: AVDecCommonMeanBitRate::<Impl, IMPL_OFFSET>,
            AVDDSurroundMode: AVDDSurroundMode::<Impl, IMPL_OFFSET>,
            AVDecCommonInputFormat: AVDecCommonInputFormat::<Impl, IMPL_OFFSET>,
            AVDecCommonOutputFormat: AVDecCommonOutputFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidAudioRendererEvent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidClosedCaptioning_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl {
    fn Enable(&mut self) -> ::windows::core::Result<i16>;
    fn SetEnable(&mut self, on: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidClosedCaptioning_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidClosedCaptioning_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidClosedCaptioning_Vtbl {
        unsafe extern "system" fn Enable<Impl: IMSVidClosedCaptioning_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, on: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Enable() {
                ::core::result::Result::Ok(ok__) => {
                    *on = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnable<Impl: IMSVidClosedCaptioning_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, on: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnable(::core::mem::transmute_copy(&on)).into()
        }
        Self {
            base: IMSVidFeature_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Enable: Enable::<Impl, IMPL_OFFSET>,
            SetEnable: SetEnable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidClosedCaptioning as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidClosedCaptioning2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl + IMSVidClosedCaptioning_Impl {
    fn Service(&mut self) -> ::windows::core::Result<MSVidCCService>;
    fn SetService(&mut self, on: MSVidCCService) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidClosedCaptioning2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidClosedCaptioning2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidClosedCaptioning2_Vtbl {
        unsafe extern "system" fn Service<Impl: IMSVidClosedCaptioning2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, on: *mut MSVidCCService) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Service() {
                ::core::result::Result::Ok(ok__) => {
                    *on = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetService<Impl: IMSVidClosedCaptioning2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, on: MSVidCCService) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetService(::core::mem::transmute_copy(&on)).into()
        }
        Self {
            base: IMSVidClosedCaptioning_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Service: Service::<Impl, IMPL_OFFSET>,
            SetService: SetService::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidClosedCaptioning2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidClosedCaptioning3_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl + IMSVidClosedCaptioning_Impl + IMSVidClosedCaptioning2_Impl {
    fn TeleTextFilter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidClosedCaptioning3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidClosedCaptioning3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidClosedCaptioning3_Vtbl {
        unsafe extern "system" fn TeleTextFilter<Impl: IMSVidClosedCaptioning3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkttfilter: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TeleTextFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *punkttfilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IMSVidClosedCaptioning2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), TeleTextFilter: TeleTextFilter::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidClosedCaptioning3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidCompositionSegment_Impl: Sized + super::super::System::Com::IPersist_Impl + IMSVidGraphSegment_Impl {
    fn Compose(&mut self, upstream: &::core::option::Option<IMSVidGraphSegment>, downstream: &::core::option::Option<IMSVidGraphSegment>) -> ::windows::core::Result<()>;
    fn Up(&mut self) -> ::windows::core::Result<IMSVidGraphSegment>;
    fn Down(&mut self) -> ::windows::core::Result<IMSVidGraphSegment>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidCompositionSegment_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidCompositionSegment_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidCompositionSegment_Vtbl {
        unsafe extern "system" fn Compose<Impl: IMSVidCompositionSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, upstream: ::windows::core::RawPtr, downstream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Compose(::core::mem::transmute(&upstream), ::core::mem::transmute(&downstream)).into()
        }
        unsafe extern "system" fn Up<Impl: IMSVidCompositionSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, upstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Up() {
                ::core::result::Result::Ok(ok__) => {
                    *upstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Down<Impl: IMSVidCompositionSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, downstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Down() {
                ::core::result::Result::Ok(ok__) => {
                    *downstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidGraphSegment_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Compose: Compose::<Impl, IMPL_OFFSET>,
            Up: Up::<Impl, IMPL_OFFSET>,
            Down: Down::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidCompositionSegment as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidCtl_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn AutoSize(&mut self) -> ::windows::core::Result<i16>;
    fn SetAutoSize(&mut self, vbool: i16) -> ::windows::core::Result<()>;
    fn BackColor(&mut self) -> ::windows::core::Result<u32>;
    fn SetBackColor(&mut self, backcolor: u32) -> ::windows::core::Result<()>;
    fn Enabled(&mut self) -> ::windows::core::Result<i16>;
    fn SetEnabled(&mut self, vbool: i16) -> ::windows::core::Result<()>;
    fn TabStop(&mut self) -> ::windows::core::Result<i16>;
    fn SetTabStop(&mut self, vbool: i16) -> ::windows::core::Result<()>;
    fn Window(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn Refresh(&mut self) -> ::windows::core::Result<()>;
    fn DisplaySize(&mut self) -> ::windows::core::Result<DisplaySizeList>;
    fn SetDisplaySize(&mut self, newvalue: DisplaySizeList) -> ::windows::core::Result<()>;
    fn MaintainAspectRatio(&mut self) -> ::windows::core::Result<i16>;
    fn SetMaintainAspectRatio(&mut self, newvalue: i16) -> ::windows::core::Result<()>;
    fn ColorKey(&mut self) -> ::windows::core::Result<u32>;
    fn SetColorKey(&mut self, newvalue: u32) -> ::windows::core::Result<()>;
    fn InputsAvailable(&mut self, categoryguid: &super::super::Foundation::BSTR) -> ::windows::core::Result<IMSVidInputDevices>;
    fn OutputsAvailable(&mut self, categoryguid: &super::super::Foundation::BSTR) -> ::windows::core::Result<IMSVidOutputDevices>;
    fn _InputsAvailable(&mut self, categoryguid: *const ::windows::core::GUID) -> ::windows::core::Result<IMSVidInputDevices>;
    fn _OutputsAvailable(&mut self, categoryguid: *const ::windows::core::GUID) -> ::windows::core::Result<IMSVidOutputDevices>;
    fn VideoRenderersAvailable(&mut self) -> ::windows::core::Result<IMSVidVideoRendererDevices>;
    fn AudioRenderersAvailable(&mut self) -> ::windows::core::Result<IMSVidAudioRendererDevices>;
    fn FeaturesAvailable(&mut self) -> ::windows::core::Result<IMSVidFeatures>;
    fn InputActive(&mut self) -> ::windows::core::Result<IMSVidInputDevice>;
    fn SetInputActive(&mut self, pval: &::core::option::Option<IMSVidInputDevice>) -> ::windows::core::Result<()>;
    fn OutputsActive(&mut self) -> ::windows::core::Result<IMSVidOutputDevices>;
    fn SetOutputsActive(&mut self, pval: &::core::option::Option<IMSVidOutputDevices>) -> ::windows::core::Result<()>;
    fn VideoRendererActive(&mut self) -> ::windows::core::Result<IMSVidVideoRenderer>;
    fn SetVideoRendererActive(&mut self, pval: &::core::option::Option<IMSVidVideoRenderer>) -> ::windows::core::Result<()>;
    fn AudioRendererActive(&mut self) -> ::windows::core::Result<IMSVidAudioRenderer>;
    fn SetAudioRendererActive(&mut self, pval: &::core::option::Option<IMSVidAudioRenderer>) -> ::windows::core::Result<()>;
    fn FeaturesActive(&mut self) -> ::windows::core::Result<IMSVidFeatures>;
    fn SetFeaturesActive(&mut self, pval: &::core::option::Option<IMSVidFeatures>) -> ::windows::core::Result<()>;
    fn State(&mut self) -> ::windows::core::Result<MSVidCtlStateList>;
    fn View(&mut self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn Build(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Run(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Decompose(&mut self) -> ::windows::core::Result<()>;
    fn DisableVideo(&mut self) -> ::windows::core::Result<()>;
    fn DisableAudio(&mut self) -> ::windows::core::Result<()>;
    fn ViewNext(&mut self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidCtl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidCtl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidCtl_Vtbl {
        unsafe extern "system" fn AutoSize<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pbool = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoSize<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoSize(::core::mem::transmute_copy(&vbool)).into()
        }
        unsafe extern "system" fn BackColor<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, backcolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackColor() {
                ::core::result::Result::Ok(ok__) => {
                    *backcolor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackColor<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, backcolor: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackColor(::core::mem::transmute_copy(&backcolor)).into()
        }
        unsafe extern "system" fn Enabled<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Enabled() {
                ::core::result::Result::Ok(ok__) => {
                    *pbool = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnabled<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnabled(::core::mem::transmute_copy(&vbool)).into()
        }
        unsafe extern "system" fn TabStop<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbool: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TabStop() {
                ::core::result::Result::Ok(ok__) => {
                    *pbool = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabStop<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vbool: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTabStop(::core::mem::transmute_copy(&vbool)).into()
        }
        unsafe extern "system" fn Window<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Window() {
                ::core::result::Result::Ok(ok__) => {
                    *phwnd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Refresh<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Refresh().into()
        }
        unsafe extern "system" fn DisplaySize<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentvalue: *mut DisplaySizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DisplaySize() {
                ::core::result::Result::Ok(ok__) => {
                    *currentvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplaySize<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newvalue: DisplaySizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplaySize(::core::mem::transmute_copy(&newvalue)).into()
        }
        unsafe extern "system" fn MaintainAspectRatio<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentvalue: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaintainAspectRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *currentvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaintainAspectRatio<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newvalue: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaintainAspectRatio(::core::mem::transmute_copy(&newvalue)).into()
        }
        unsafe extern "system" fn ColorKey<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorKey() {
                ::core::result::Result::Ok(ok__) => {
                    *currentvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&newvalue)).into()
        }
        unsafe extern "system" fn InputsAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, categoryguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputsAvailable(::core::mem::transmute_copy(&categoryguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutputsAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, categoryguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutputsAvailable(::core::mem::transmute_copy(&categoryguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _InputsAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, categoryguid: *const ::windows::core::GUID, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._InputsAvailable(::core::mem::transmute_copy(&categoryguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _OutputsAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, categoryguid: *const ::windows::core::GUID, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._OutputsAvailable(::core::mem::transmute_copy(&categoryguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoRenderersAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoRenderersAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioRenderersAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioRenderersAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FeaturesAvailable<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FeaturesAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InputActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputActive(::core::mem::transmute(&pval)).into()
        }
        unsafe extern "system" fn OutputsActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OutputsActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputsActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputsActive(::core::mem::transmute(&pval)).into()
        }
        unsafe extern "system" fn VideoRendererActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoRendererActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoRendererActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoRendererActive(::core::mem::transmute(&pval)).into()
        }
        unsafe extern "system" fn AudioRendererActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioRendererActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioRendererActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioRendererActive(::core::mem::transmute(&pval)).into()
        }
        unsafe extern "system" fn FeaturesActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FeaturesActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFeaturesActive<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFeaturesActive(::core::mem::transmute(&pval)).into()
        }
        unsafe extern "system" fn State<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstate: *mut MSVidCtlStateList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *lstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn View<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).View(::core::mem::transmute_copy(&v)).into()
        }
        unsafe extern "system" fn Build<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Build().into()
        }
        unsafe extern "system" fn Pause<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Run<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Run().into()
        }
        unsafe extern "system" fn Stop<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Decompose().into()
        }
        unsafe extern "system" fn DisableVideo<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisableVideo().into()
        }
        unsafe extern "system" fn DisableAudio<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisableAudio().into()
        }
        unsafe extern "system" fn ViewNext<Impl: IMSVidCtl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ViewNext(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AutoSize: AutoSize::<Impl, IMPL_OFFSET>,
            SetAutoSize: SetAutoSize::<Impl, IMPL_OFFSET>,
            BackColor: BackColor::<Impl, IMPL_OFFSET>,
            SetBackColor: SetBackColor::<Impl, IMPL_OFFSET>,
            Enabled: Enabled::<Impl, IMPL_OFFSET>,
            SetEnabled: SetEnabled::<Impl, IMPL_OFFSET>,
            TabStop: TabStop::<Impl, IMPL_OFFSET>,
            SetTabStop: SetTabStop::<Impl, IMPL_OFFSET>,
            Window: Window::<Impl, IMPL_OFFSET>,
            Refresh: Refresh::<Impl, IMPL_OFFSET>,
            DisplaySize: DisplaySize::<Impl, IMPL_OFFSET>,
            SetDisplaySize: SetDisplaySize::<Impl, IMPL_OFFSET>,
            MaintainAspectRatio: MaintainAspectRatio::<Impl, IMPL_OFFSET>,
            SetMaintainAspectRatio: SetMaintainAspectRatio::<Impl, IMPL_OFFSET>,
            ColorKey: ColorKey::<Impl, IMPL_OFFSET>,
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            InputsAvailable: InputsAvailable::<Impl, IMPL_OFFSET>,
            OutputsAvailable: OutputsAvailable::<Impl, IMPL_OFFSET>,
            _InputsAvailable: _InputsAvailable::<Impl, IMPL_OFFSET>,
            _OutputsAvailable: _OutputsAvailable::<Impl, IMPL_OFFSET>,
            VideoRenderersAvailable: VideoRenderersAvailable::<Impl, IMPL_OFFSET>,
            AudioRenderersAvailable: AudioRenderersAvailable::<Impl, IMPL_OFFSET>,
            FeaturesAvailable: FeaturesAvailable::<Impl, IMPL_OFFSET>,
            InputActive: InputActive::<Impl, IMPL_OFFSET>,
            SetInputActive: SetInputActive::<Impl, IMPL_OFFSET>,
            OutputsActive: OutputsActive::<Impl, IMPL_OFFSET>,
            SetOutputsActive: SetOutputsActive::<Impl, IMPL_OFFSET>,
            VideoRendererActive: VideoRendererActive::<Impl, IMPL_OFFSET>,
            SetVideoRendererActive: SetVideoRendererActive::<Impl, IMPL_OFFSET>,
            AudioRendererActive: AudioRendererActive::<Impl, IMPL_OFFSET>,
            SetAudioRendererActive: SetAudioRendererActive::<Impl, IMPL_OFFSET>,
            FeaturesActive: FeaturesActive::<Impl, IMPL_OFFSET>,
            SetFeaturesActive: SetFeaturesActive::<Impl, IMPL_OFFSET>,
            State: State::<Impl, IMPL_OFFSET>,
            View: View::<Impl, IMPL_OFFSET>,
            Build: Build::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Run: Run::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Decompose: Decompose::<Impl, IMPL_OFFSET>,
            DisableVideo: DisableVideo::<Impl, IMPL_OFFSET>,
            DisableAudio: DisableAudio::<Impl, IMPL_OFFSET>,
            ViewNext: ViewNext::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidCtl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidDataServices_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidDataServices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidDataServices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidDataServices_Vtbl {
        Self { base: IMSVidFeature_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidDataServices as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidDataServicesEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidDataServicesEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidDataServicesEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidDataServicesEvent_Vtbl {
        Self { base: IMSVidDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidDataServicesEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidDevice_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Name(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Status(&mut self) -> ::windows::core::Result<i32>;
    fn SetPower(&mut self, power: i16) -> ::windows::core::Result<()>;
    fn Power(&mut self) -> ::windows::core::Result<i16>;
    fn Category(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn ClassID(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn _Category(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn _ClassID(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn IsEqualDevice(&mut self, device: &::core::option::Option<IMSVidDevice>) -> ::windows::core::Result<i16>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidDevice_Vtbl {
        unsafe extern "system" fn Name<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Name() {
                ::core::result::Result::Ok(ok__) => {
                    *name = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Status<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, status: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Status() {
                ::core::result::Result::Ok(ok__) => {
                    *status = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPower<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, power: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPower(::core::mem::transmute_copy(&power)).into()
        }
        unsafe extern "system" fn Power<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, power: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Power() {
                ::core::result::Result::Ok(ok__) => {
                    *power = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Category() {
                ::core::result::Result::Ok(ok__) => {
                    *guid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClassID<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClassID() {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _Category<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._Category() {
                ::core::result::Result::Ok(ok__) => {
                    *guid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _ClassID<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._ClassID() {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEqualDevice<Impl: IMSVidDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, device: ::windows::core::RawPtr, isequal: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEqualDevice(::core::mem::transmute(&device)) {
                ::core::result::Result::Ok(ok__) => {
                    *isequal = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Name: Name::<Impl, IMPL_OFFSET>,
            Status: Status::<Impl, IMPL_OFFSET>,
            SetPower: SetPower::<Impl, IMPL_OFFSET>,
            Power: Power::<Impl, IMPL_OFFSET>,
            Category: Category::<Impl, IMPL_OFFSET>,
            ClassID: ClassID::<Impl, IMPL_OFFSET>,
            _Category: _Category::<Impl, IMPL_OFFSET>,
            _ClassID: _ClassID::<Impl, IMPL_OFFSET>,
            IsEqualDevice: IsEqualDevice::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMSVidDevice2_Impl: Sized {
    fn DevicePath(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMSVidDevice2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidDevice2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidDevice2_Vtbl {
        unsafe extern "system" fn DevicePath<Impl: IMSVidDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devpath: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DevicePath() {
                ::core::result::Result::Ok(ok__) => {
                    *devpath = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), DevicePath: DevicePath::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidDevice2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidDeviceEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn StateChange(&mut self, lpd: &::core::option::Option<IMSVidDevice>, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidDeviceEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidDeviceEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidDeviceEvent_Vtbl {
        unsafe extern "system" fn StateChange<Impl: IMSVidDeviceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr, oldstate: i32, newstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StateChange(::core::mem::transmute(&lpd), ::core::mem::transmute_copy(&oldstate), ::core::mem::transmute_copy(&newstate)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            StateChange: StateChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidDeviceEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidEVR_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidVideoRenderer_Impl {
    fn Presenter(&mut self) -> ::windows::core::Result<super::MediaFoundation::IMFVideoPresenter>;
    fn SetPresenter(&mut self, pallocpresent: &::core::option::Option<super::MediaFoundation::IMFVideoPresenter>) -> ::windows::core::Result<()>;
    fn SetSuppressEffects(&mut self, bsuppress: i16) -> ::windows::core::Result<()>;
    fn SuppressEffects(&mut self) -> ::windows::core::Result<i16>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidEVR_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidEVR_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidEVR_Vtbl {
        unsafe extern "system" fn Presenter<Impl: IMSVidEVR_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppallocpresent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Presenter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppallocpresent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPresenter<Impl: IMSVidEVR_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pallocpresent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPresenter(::core::mem::transmute(&pallocpresent)).into()
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidEVR_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSuppressEffects(::core::mem::transmute_copy(&bsuppress)).into()
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidEVR_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuppressEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *bsuppress = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidVideoRenderer_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Presenter: Presenter::<Impl, IMPL_OFFSET>,
            SetPresenter: SetPresenter::<Impl, IMPL_OFFSET>,
            SetSuppressEffects: SetSuppressEffects::<Impl, IMPL_OFFSET>,
            SuppressEffects: SuppressEffects::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidEVR as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidEVREvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl {
    fn OnUserEvent(&mut self, leventcode: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidEVREvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidEVREvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidEVREvent_Vtbl {
        unsafe extern "system" fn OnUserEvent<Impl: IMSVidEVREvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leventcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUserEvent(::core::mem::transmute_copy(&leventcode)).into()
        }
        Self { base: IMSVidOutputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), OnUserEvent: OnUserEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidEVREvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidEncoder_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl {
    fn VideoEncoderInterface(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn AudioEncoderInterface(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidEncoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidEncoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidEncoder_Vtbl {
        unsafe extern "system" fn VideoEncoderInterface<Impl: IMSVidEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppencint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoEncoderInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *ppencint = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioEncoderInterface<Impl: IMSVidEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppencint: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioEncoderInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *ppencint = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidFeature_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            VideoEncoderInterface: VideoEncoderInterface::<Impl, IMPL_OFFSET>,
            AudioEncoderInterface: AudioEncoderInterface::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidEncoder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFeature_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFeature_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFeature_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFeature_Vtbl {
        Self { base: IMSVidDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFeature as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFeatureEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFeatureEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFeatureEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFeatureEvent_Vtbl {
        Self { base: IMSVidDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFeatureEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFeatures_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IMSVidFeature>;
    fn Add(&mut self, pdb: &::core::option::Option<IMSVidFeature>) -> ::windows::core::Result<()>;
    fn Remove(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFeatures_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFeatures_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFeatures_Vtbl {
        unsafe extern "system" fn Count<Impl: IMSVidFeatures_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *lcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidFeatures_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *pd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidFeatures_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidFeatures_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Add(::core::mem::transmute(&pdb)).into()
        }
        unsafe extern "system" fn Remove<Impl: IMSVidFeatures_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFeatures as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFilePlayback_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl {
    fn FileName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetFileName(&mut self, filename: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFilePlayback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFilePlayback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFilePlayback_Vtbl {
        unsafe extern "system" fn FileName<Impl: IMSVidFilePlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FileName() {
                ::core::result::Result::Ok(ok__) => {
                    *filename = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFileName<Impl: IMSVidFilePlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFileName(::core::mem::transmute_copy(&filename)).into()
        }
        Self {
            base: IMSVidPlayback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            FileName: FileName::<Impl, IMPL_OFFSET>,
            SetFileName: SetFileName::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFilePlayback as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFilePlayback2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl + IMSVidFilePlayback_Impl {
    fn Set_SourceFilter(&mut self, filename: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Set__SourceFilter(&mut self, filename: &::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFilePlayback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFilePlayback2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFilePlayback2_Vtbl {
        unsafe extern "system" fn Set_SourceFilter<Impl: IMSVidFilePlayback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_SourceFilter(::core::mem::transmute_copy(&filename)).into()
        }
        unsafe extern "system" fn Set__SourceFilter<Impl: IMSVidFilePlayback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set__SourceFilter(::core::mem::transmute_copy(&filename)).into()
        }
        Self {
            base: IMSVidFilePlayback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Set_SourceFilter: Set_SourceFilter::<Impl, IMPL_OFFSET>,
            Set__SourceFilter: Set__SourceFilter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFilePlayback2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidFilePlaybackEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidFilePlaybackEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidFilePlaybackEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidFilePlaybackEvent_Vtbl {
        Self { base: IMSVidPlaybackEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidFilePlaybackEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidGenericSink_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl {
    fn SetSinkFilter(&mut self, bstrname: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SinkStreams(&mut self) -> ::windows::core::Result<MSVidSinkStreams>;
    fn SetSinkStreams(&mut self, streams: MSVidSinkStreams) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidGenericSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidGenericSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidGenericSink_Vtbl {
        unsafe extern "system" fn SetSinkFilter<Impl: IMSVidGenericSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSinkFilter(::core::mem::transmute_copy(&bstrname)).into()
        }
        unsafe extern "system" fn SinkStreams<Impl: IMSVidGenericSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstreams: *mut MSVidSinkStreams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SinkStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *pstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSinkStreams<Impl: IMSVidGenericSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streams: MSVidSinkStreams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSinkStreams(::core::mem::transmute_copy(&streams)).into()
        }
        Self {
            base: IMSVidOutputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetSinkFilter: SetSinkFilter::<Impl, IMPL_OFFSET>,
            SinkStreams: SinkStreams::<Impl, IMPL_OFFSET>,
            SetSinkStreams: SetSinkStreams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidGenericSink as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidGenericSink2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidGenericSink_Impl {
    fn AddFilter(&mut self, bstrname: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ResetFilterList(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidGenericSink2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidGenericSink2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidGenericSink2_Vtbl {
        unsafe extern "system" fn AddFilter<Impl: IMSVidGenericSink2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrname: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddFilter(::core::mem::transmute_copy(&bstrname)).into()
        }
        unsafe extern "system" fn ResetFilterList<Impl: IMSVidGenericSink2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetFilterList().into()
        }
        Self {
            base: IMSVidGenericSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AddFilter: AddFilter::<Impl, IMPL_OFFSET>,
            ResetFilterList: ResetFilterList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidGenericSink2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidGraphSegment_Impl: Sized + super::super::System::Com::IPersist_Impl {
    fn Init(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn SetInit(&mut self, pinit: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EnumFilters(&mut self) -> ::windows::core::Result<IEnumFilters>;
    fn Container(&mut self) -> ::windows::core::Result<IMSVidGraphSegmentContainer>;
    fn SetContainer(&mut self, pctl: &::core::option::Option<IMSVidGraphSegmentContainer>) -> ::windows::core::Result<()>;
    fn Type(&mut self) -> ::windows::core::Result<MSVidSegmentType>;
    fn Category(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Build(&mut self) -> ::windows::core::Result<()>;
    fn PostBuild(&mut self) -> ::windows::core::Result<()>;
    fn PreRun(&mut self) -> ::windows::core::Result<()>;
    fn PostRun(&mut self) -> ::windows::core::Result<()>;
    fn PreStop(&mut self) -> ::windows::core::Result<()>;
    fn PostStop(&mut self) -> ::windows::core::Result<()>;
    fn OnEventNotify(&mut self, leventcode: i32, leventparm1: isize, leventparm2: isize) -> ::windows::core::Result<()>;
    fn Decompose(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGraphSegment_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidGraphSegment_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidGraphSegment_Vtbl {
        unsafe extern "system" fn Init<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinit: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Init() {
                ::core::result::Result::Ok(ok__) => {
                    *pinit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInit<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinit: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInit(::core::mem::transmute(&pinit)).into()
        }
        unsafe extern "system" fn EnumFilters<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnewenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumFilters() {
                ::core::result::Result::Ok(ok__) => {
                    *pnewenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Container<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppctl: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Container() {
                ::core::result::Result::Ok(ok__) => {
                    *ppctl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainer<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pctl: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainer(::core::mem::transmute(&pctl)).into()
        }
        unsafe extern "system" fn Type<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut MSVidSegmentType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Type() {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Category<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Category() {
                ::core::result::Result::Ok(ok__) => {
                    *pguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Build<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Build().into()
        }
        unsafe extern "system" fn PostBuild<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PostBuild().into()
        }
        unsafe extern "system" fn PreRun<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PreRun().into()
        }
        unsafe extern "system" fn PostRun<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PostRun().into()
        }
        unsafe extern "system" fn PreStop<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PreStop().into()
        }
        unsafe extern "system" fn PostStop<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PostStop().into()
        }
        unsafe extern "system" fn OnEventNotify<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leventcode: i32, leventparm1: isize, leventparm2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnEventNotify(::core::mem::transmute_copy(&leventcode), ::core::mem::transmute_copy(&leventparm1), ::core::mem::transmute_copy(&leventparm2)).into()
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Decompose().into()
        }
        Self {
            base: super::super::System::Com::IPersist_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Init: Init::<Impl, IMPL_OFFSET>,
            SetInit: SetInit::<Impl, IMPL_OFFSET>,
            EnumFilters: EnumFilters::<Impl, IMPL_OFFSET>,
            Container: Container::<Impl, IMPL_OFFSET>,
            SetContainer: SetContainer::<Impl, IMPL_OFFSET>,
            Type: Type::<Impl, IMPL_OFFSET>,
            Category: Category::<Impl, IMPL_OFFSET>,
            Build: Build::<Impl, IMPL_OFFSET>,
            PostBuild: PostBuild::<Impl, IMPL_OFFSET>,
            PreRun: PreRun::<Impl, IMPL_OFFSET>,
            PostRun: PostRun::<Impl, IMPL_OFFSET>,
            PreStop: PreStop::<Impl, IMPL_OFFSET>,
            PostStop: PostStop::<Impl, IMPL_OFFSET>,
            OnEventNotify: OnEventNotify::<Impl, IMPL_OFFSET>,
            Decompose: Decompose::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidGraphSegment as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMSVidGraphSegmentContainer_Impl: Sized {
    fn Graph(&mut self) -> ::windows::core::Result<IGraphBuilder>;
    fn Input(&mut self) -> ::windows::core::Result<IMSVidGraphSegment>;
    fn Outputs(&mut self) -> ::windows::core::Result<IEnumMSVidGraphSegment>;
    fn VideoRenderer(&mut self) -> ::windows::core::Result<IMSVidGraphSegment>;
    fn AudioRenderer(&mut self) -> ::windows::core::Result<IMSVidGraphSegment>;
    fn Features(&mut self) -> ::windows::core::Result<IEnumMSVidGraphSegment>;
    fn Composites(&mut self) -> ::windows::core::Result<IEnumMSVidGraphSegment>;
    fn ParentContainer(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Decompose(&mut self, psegment: &::core::option::Option<IMSVidGraphSegment>) -> ::windows::core::Result<()>;
    fn IsWindowless(&mut self) -> ::windows::core::Result<()>;
    fn GetFocus(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGraphSegmentContainer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidGraphSegmentContainer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidGraphSegmentContainer_Vtbl {
        unsafe extern "system" fn Graph<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppgraph: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Graph() {
                ::core::result::Result::Ok(ok__) => {
                    *ppgraph = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Input<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinput: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Input() {
                ::core::result::Result::Ok(ok__) => {
                    *ppinput = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Outputs<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppoutputs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Outputs() {
                ::core::result::Result::Ok(ok__) => {
                    *ppoutputs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoRenderer<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppvr: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoRenderer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppvr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioRenderer<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppar: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioRenderer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppar = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Features<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppfeatures: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Features() {
                ::core::result::Result::Ok(ok__) => {
                    *ppfeatures = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Composites<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppcomposites: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Composites() {
                ::core::result::Result::Ok(ok__) => {
                    *ppcomposites = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParentContainer<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppcontainer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ParentContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppcontainer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Decompose<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psegment: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Decompose(::core::mem::transmute(&psegment)).into()
        }
        unsafe extern "system" fn IsWindowless<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsWindowless().into()
        }
        unsafe extern "system" fn GetFocus<Impl: IMSVidGraphSegmentContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFocus().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Graph: Graph::<Impl, IMPL_OFFSET>,
            Input: Input::<Impl, IMPL_OFFSET>,
            Outputs: Outputs::<Impl, IMPL_OFFSET>,
            VideoRenderer: VideoRenderer::<Impl, IMPL_OFFSET>,
            AudioRenderer: AudioRenderer::<Impl, IMPL_OFFSET>,
            Features: Features::<Impl, IMPL_OFFSET>,
            Composites: Composites::<Impl, IMPL_OFFSET>,
            ParentContainer: ParentContainer::<Impl, IMPL_OFFSET>,
            Decompose: Decompose::<Impl, IMPL_OFFSET>,
            IsWindowless: IsWindowless::<Impl, IMPL_OFFSET>,
            GetFocus: GetFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidGraphSegmentContainer as ::windows::core::Interface>::IID
    }
}
pub trait IMSVidGraphSegmentUserInput_Impl: Sized {
    fn Click(&mut self) -> ::windows::core::Result<()>;
    fn DblClick(&mut self) -> ::windows::core::Result<()>;
    fn KeyDown(&mut self, keycode: *const i16, shiftstate: i16) -> ::windows::core::Result<()>;
    fn KeyPress(&mut self, keyascii: *const i16) -> ::windows::core::Result<()>;
    fn KeyUp(&mut self, keycode: *const i16, shiftstate: i16) -> ::windows::core::Result<()>;
    fn MouseDown(&mut self, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::Result<()>;
    fn MouseMove(&mut self, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::Result<()>;
    fn MouseUp(&mut self, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::Result<()>;
}
impl IMSVidGraphSegmentUserInput_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidGraphSegmentUserInput_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidGraphSegmentUserInput_Vtbl {
        unsafe extern "system" fn Click<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Click().into()
        }
        unsafe extern "system" fn DblClick<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DblClick().into()
        }
        unsafe extern "system" fn KeyDown<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keycode: *const i16, shiftstate: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyDown(::core::mem::transmute_copy(&keycode), ::core::mem::transmute_copy(&shiftstate)).into()
        }
        unsafe extern "system" fn KeyPress<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keyascii: *const i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyPress(::core::mem::transmute_copy(&keyascii)).into()
        }
        unsafe extern "system" fn KeyUp<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keycode: *const i16, shiftstate: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyUp(::core::mem::transmute_copy(&keycode), ::core::mem::transmute_copy(&shiftstate)).into()
        }
        unsafe extern "system" fn MouseDown<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseDown(::core::mem::transmute_copy(&buttonstate), ::core::mem::transmute_copy(&shiftstate), ::core::mem::transmute_copy(&x), ::core::mem::transmute_copy(&y)).into()
        }
        unsafe extern "system" fn MouseMove<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseMove(::core::mem::transmute_copy(&buttonstate), ::core::mem::transmute_copy(&shiftstate), ::core::mem::transmute_copy(&x), ::core::mem::transmute_copy(&y)).into()
        }
        unsafe extern "system" fn MouseUp<Impl: IMSVidGraphSegmentUserInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buttonstate: i16, shiftstate: i16, x: i32, y: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MouseUp(::core::mem::transmute_copy(&buttonstate), ::core::mem::transmute_copy(&shiftstate), ::core::mem::transmute_copy(&x), ::core::mem::transmute_copy(&y)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Click: Click::<Impl, IMPL_OFFSET>,
            DblClick: DblClick::<Impl, IMPL_OFFSET>,
            KeyDown: KeyDown::<Impl, IMPL_OFFSET>,
            KeyPress: KeyPress::<Impl, IMPL_OFFSET>,
            KeyUp: KeyUp::<Impl, IMPL_OFFSET>,
            MouseDown: MouseDown::<Impl, IMPL_OFFSET>,
            MouseMove: MouseMove::<Impl, IMPL_OFFSET>,
            MouseUp: MouseUp::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidGraphSegmentUserInput as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidInputDevice_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl {
    fn IsViewable(&mut self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<i16>;
    fn View(&mut self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidInputDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidInputDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidInputDevice_Vtbl {
        unsafe extern "system" fn IsViewable<Impl: IMSVidInputDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT, pfviewable: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsViewable(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfviewable = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn View<Impl: IMSVidInputDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).View(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: IMSVidDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            IsViewable: IsViewable::<Impl, IMPL_OFFSET>,
            View: View::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidInputDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidInputDeviceEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidInputDeviceEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidInputDeviceEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidInputDeviceEvent_Vtbl {
        Self { base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidInputDeviceEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidInputDevices_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IMSVidInputDevice>;
    fn Add(&mut self, pdb: &::core::option::Option<IMSVidInputDevice>) -> ::windows::core::Result<()>;
    fn Remove(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidInputDevices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidInputDevices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidInputDevices_Vtbl {
        unsafe extern "system" fn Count<Impl: IMSVidInputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *lcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidInputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *pd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidInputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidInputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Add(::core::mem::transmute(&pdb)).into()
        }
        unsafe extern "system" fn Remove<Impl: IMSVidInputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidInputDevices as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidOutputDevice_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidOutputDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidOutputDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidOutputDevice_Vtbl {
        Self { base: IMSVidDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidOutputDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidOutputDeviceEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidOutputDeviceEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidOutputDeviceEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidOutputDeviceEvent_Vtbl {
        Self { base: IMSVidDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidOutputDeviceEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidOutputDevices_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IMSVidOutputDevice>;
    fn Add(&mut self, pdb: &::core::option::Option<IMSVidOutputDevice>) -> ::windows::core::Result<()>;
    fn Remove(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidOutputDevices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidOutputDevices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidOutputDevices_Vtbl {
        unsafe extern "system" fn Count<Impl: IMSVidOutputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *lcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidOutputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *pd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidOutputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidOutputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Add(::core::mem::transmute(&pdb)).into()
        }
        unsafe extern "system" fn Remove<Impl: IMSVidOutputDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidOutputDevices as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidPlayback_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl {
    fn EnableResetOnStop(&mut self) -> ::windows::core::Result<i16>;
    fn SetEnableResetOnStop(&mut self, newval: i16) -> ::windows::core::Result<()>;
    fn Run(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn CanStep(&mut self, fbackwards: i16) -> ::windows::core::Result<i16>;
    fn Step(&mut self, lstep: i32) -> ::windows::core::Result<()>;
    fn SetRate(&mut self, plrate: f64) -> ::windows::core::Result<()>;
    fn Rate(&mut self) -> ::windows::core::Result<f64>;
    fn SetCurrentPosition(&mut self, lposition: i32) -> ::windows::core::Result<()>;
    fn CurrentPosition(&mut self) -> ::windows::core::Result<i32>;
    fn SetPositionMode(&mut self, lpositionmode: PositionModeList) -> ::windows::core::Result<()>;
    fn PositionMode(&mut self) -> ::windows::core::Result<PositionModeList>;
    fn Length(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidPlayback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidPlayback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidPlayback_Vtbl {
        unsafe extern "system" fn EnableResetOnStop<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnableResetOnStop() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEnableResetOnStop<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEnableResetOnStop(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn Run<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Run().into()
        }
        unsafe extern "system" fn Pause<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Stop<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn CanStep<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fbackwards: i16, pfcan: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanStep(::core::mem::transmute_copy(&fbackwards)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfcan = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Step<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstep: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Step(::core::mem::transmute_copy(&lstep)).into()
        }
        unsafe extern "system" fn SetRate<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&plrate)).into()
        }
        unsafe extern "system" fn Rate<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Rate() {
                ::core::result::Result::Ok(ok__) => {
                    *plrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lposition: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPosition(::core::mem::transmute_copy(&lposition)).into()
        }
        unsafe extern "system" fn CurrentPosition<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lposition: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *lposition = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPositionMode<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpositionmode: PositionModeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPositionMode(::core::mem::transmute_copy(&lpositionmode)).into()
        }
        unsafe extern "system" fn PositionMode<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpositionmode: *mut PositionModeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PositionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *lpositionmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: IMSVidPlayback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *llength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidInputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            EnableResetOnStop: EnableResetOnStop::<Impl, IMPL_OFFSET>,
            SetEnableResetOnStop: SetEnableResetOnStop::<Impl, IMPL_OFFSET>,
            Run: Run::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            CanStep: CanStep::<Impl, IMPL_OFFSET>,
            Step: Step::<Impl, IMPL_OFFSET>,
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            Rate: Rate::<Impl, IMPL_OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Impl, IMPL_OFFSET>,
            CurrentPosition: CurrentPosition::<Impl, IMPL_OFFSET>,
            SetPositionMode: SetPositionMode::<Impl, IMPL_OFFSET>,
            PositionMode: PositionMode::<Impl, IMPL_OFFSET>,
            Length: Length::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidPlayback as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidPlaybackEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl {
    fn EndOfMedia(&mut self, lpd: &::core::option::Option<IMSVidPlayback>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidPlaybackEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidPlaybackEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidPlaybackEvent_Vtbl {
        unsafe extern "system" fn EndOfMedia<Impl: IMSVidPlaybackEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndOfMedia(::core::mem::transmute(&lpd)).into()
        }
        Self { base: IMSVidInputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), EndOfMedia: EndOfMedia::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidPlaybackEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidRect_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Top(&mut self) -> ::windows::core::Result<i32>;
    fn SetTop(&mut self, topval: i32) -> ::windows::core::Result<()>;
    fn Left(&mut self) -> ::windows::core::Result<i32>;
    fn SetLeft(&mut self, leftval: i32) -> ::windows::core::Result<()>;
    fn Width(&mut self) -> ::windows::core::Result<i32>;
    fn SetWidth(&mut self, widthval: i32) -> ::windows::core::Result<()>;
    fn Height(&mut self) -> ::windows::core::Result<i32>;
    fn SetHeight(&mut self, heightval: i32) -> ::windows::core::Result<()>;
    fn HWnd(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn SetHWnd(&mut self, hwndval: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn SetRect(&mut self, rectval: &::core::option::Option<IMSVidRect>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidRect_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidRect_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidRect_Vtbl {
        unsafe extern "system" fn Top<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, topval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Top() {
                ::core::result::Result::Ok(ok__) => {
                    *topval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, topval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTop(::core::mem::transmute_copy(&topval)).into()
        }
        unsafe extern "system" fn Left<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leftval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Left() {
                ::core::result::Result::Ok(ok__) => {
                    *leftval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leftval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeft(::core::mem::transmute_copy(&leftval)).into()
        }
        unsafe extern "system" fn Width<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, widthval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Width() {
                ::core::result::Result::Ok(ok__) => {
                    *widthval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, widthval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWidth(::core::mem::transmute_copy(&widthval)).into()
        }
        unsafe extern "system" fn Height<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, heightval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Height() {
                ::core::result::Result::Ok(ok__) => {
                    *heightval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, heightval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeight(::core::mem::transmute_copy(&heightval)).into()
        }
        unsafe extern "system" fn HWnd<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwndval: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HWnd() {
                ::core::result::Result::Ok(ok__) => {
                    *hwndval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHWnd<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwndval: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHWnd(::core::mem::transmute_copy(&hwndval)).into()
        }
        unsafe extern "system" fn SetRect<Impl: IMSVidRect_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rectval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRect(::core::mem::transmute(&rectval)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Top: Top::<Impl, IMPL_OFFSET>,
            SetTop: SetTop::<Impl, IMPL_OFFSET>,
            Left: Left::<Impl, IMPL_OFFSET>,
            SetLeft: SetLeft::<Impl, IMPL_OFFSET>,
            Width: Width::<Impl, IMPL_OFFSET>,
            SetWidth: SetWidth::<Impl, IMPL_OFFSET>,
            Height: Height::<Impl, IMPL_OFFSET>,
            SetHeight: SetHeight::<Impl, IMPL_OFFSET>,
            HWnd: HWnd::<Impl, IMPL_OFFSET>,
            SetHWnd: SetHWnd::<Impl, IMPL_OFFSET>,
            SetRect: SetRect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidRect as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferRecordingControl_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn StartTime(&mut self) -> ::windows::core::Result<i32>;
    fn SetStartTime(&mut self, rtstart: i32) -> ::windows::core::Result<()>;
    fn StopTime(&mut self) -> ::windows::core::Result<i32>;
    fn SetStopTime(&mut self, rtstop: i32) -> ::windows::core::Result<()>;
    fn RecordingStopped(&mut self) -> ::windows::core::Result<i16>;
    fn RecordingStarted(&mut self) -> ::windows::core::Result<i16>;
    fn RecordingType(&mut self) -> ::windows::core::Result<RecordingType>;
    fn RecordingAttribute(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferRecordingControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferRecordingControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferRecordingControl_Vtbl {
        unsafe extern "system" fn StartTime<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtstart: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StartTime() {
                ::core::result::Result::Ok(ok__) => {
                    *rtstart = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStartTime<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtstart: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStartTime(::core::mem::transmute_copy(&rtstart)).into()
        }
        unsafe extern "system" fn StopTime<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtstop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StopTime() {
                ::core::result::Result::Ok(ok__) => {
                    *rtstop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopTime<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtstop: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStopTime(::core::mem::transmute_copy(&rtstop)).into()
        }
        unsafe extern "system" fn RecordingStopped<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phresult: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecordingStopped() {
                ::core::result::Result::Ok(ok__) => {
                    *phresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingStarted<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phresult: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecordingStarted() {
                ::core::result::Result::Ok(ok__) => {
                    *phresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingType<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtype: *mut RecordingType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecordingType() {
                ::core::result::Result::Ok(ok__) => {
                    *dwtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingAttribute<Impl: IMSVidStreamBufferRecordingControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, precordingattribute: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecordingAttribute() {
                ::core::result::Result::Ok(ok__) => {
                    *precordingattribute = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            StartTime: StartTime::<Impl, IMPL_OFFSET>,
            SetStartTime: SetStartTime::<Impl, IMPL_OFFSET>,
            StopTime: StopTime::<Impl, IMPL_OFFSET>,
            SetStopTime: SetStopTime::<Impl, IMPL_OFFSET>,
            RecordingStopped: RecordingStopped::<Impl, IMPL_OFFSET>,
            RecordingStarted: RecordingStarted::<Impl, IMPL_OFFSET>,
            RecordingType: RecordingType::<Impl, IMPL_OFFSET>,
            RecordingAttribute: RecordingAttribute::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferRecordingControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSink_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl {
    fn ContentRecorder(&mut self, pszfilename: &super::super::Foundation::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl>;
    fn ReferenceRecorder(&mut self, pszfilename: &super::super::Foundation::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl>;
    fn SinkName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetSinkName(&mut self, name: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn NameSetLock(&mut self) -> ::windows::core::Result<()>;
    fn SBESink(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSink_Vtbl {
        unsafe extern "system" fn ContentRecorder<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, precordingiunknown: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ContentRecorder(::core::mem::transmute_copy(&pszfilename)) {
                ::core::result::Result::Ok(ok__) => {
                    *precordingiunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReferenceRecorder<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, precordingiunknown: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReferenceRecorder(::core::mem::transmute_copy(&pszfilename)) {
                ::core::result::Result::Ok(ok__) => {
                    *precordingiunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SinkName<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SinkName() {
                ::core::result::Result::Ok(ok__) => {
                    *pname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSinkName<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSinkName(::core::mem::transmute_copy(&name)).into()
        }
        unsafe extern "system" fn NameSetLock<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NameSetLock().into()
        }
        unsafe extern "system" fn SBESink<Impl: IMSVidStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sbeconfig: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SBESink() {
                ::core::result::Result::Ok(ok__) => {
                    *sbeconfig = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidOutputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ContentRecorder: ContentRecorder::<Impl, IMPL_OFFSET>,
            ReferenceRecorder: ReferenceRecorder::<Impl, IMPL_OFFSET>,
            SinkName: SinkName::<Impl, IMPL_OFFSET>,
            SetSinkName: SetSinkName::<Impl, IMPL_OFFSET>,
            NameSetLock: NameSetLock::<Impl, IMPL_OFFSET>,
            SBESink: SBESink::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSink as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSink2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidStreamBufferSink_Impl {
    fn UnlockProfile(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSink2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSink2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSink2_Vtbl {
        unsafe extern "system" fn UnlockProfile<Impl: IMSVidStreamBufferSink2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockProfile().into()
        }
        Self { base: IMSVidStreamBufferSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), UnlockProfile: UnlockProfile::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSink2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSink3_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidStreamBufferSink_Impl + IMSVidStreamBufferSink2_Impl {
    fn SetMinSeek(&mut self) -> ::windows::core::Result<i32>;
    fn AudioCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn VideoCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn CCCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn WSTCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn SetAudioAnalysisFilter(&mut self, szclsid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn AudioAnalysisFilter(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Set_AudioAnalysisFilter(&mut self, guid: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn _AudioAnalysisFilter(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetVideoAnalysisFilter(&mut self, szclsid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn VideoAnalysisFilter(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Set_VideoAnalysisFilter(&mut self, guid: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn _VideoAnalysisFilter(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetDataAnalysisFilter(&mut self, szclsid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn DataAnalysisFilter(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Set_DataAnalysisFilter(&mut self, guid: &::windows::core::GUID) -> ::windows::core::Result<()>;
    fn _DataAnalysisFilter(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn LicenseErrorCode(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSink3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSink3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSink3_Vtbl {
        unsafe extern "system" fn SetMinSeek<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmin: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetMinSeek() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCounter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoCounter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCCounter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CCCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WSTCounter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WSTCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioAnalysisFilter(::core::mem::transmute_copy(&szclsid)).into()
        }
        unsafe extern "system" fn AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pszclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_AudioAnalysisFilter(::core::mem::transmute_copy(&guid)).into()
        }
        unsafe extern "system" fn _AudioAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._AudioAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoAnalysisFilter(::core::mem::transmute_copy(&szclsid)).into()
        }
        unsafe extern "system" fn VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pszclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_VideoAnalysisFilter(::core::mem::transmute_copy(&guid)).into()
        }
        unsafe extern "system" fn _VideoAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._VideoAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDataAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDataAnalysisFilter(::core::mem::transmute_copy(&szclsid)).into()
        }
        unsafe extern "system" fn DataAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DataAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pszclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_DataAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_DataAnalysisFilter(::core::mem::transmute_copy(&guid)).into()
        }
        unsafe extern "system" fn _DataAnalysisFilter<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._DataAnalysisFilter() {
                ::core::result::Result::Ok(ok__) => {
                    *pguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LicenseErrorCode<Impl: IMSVidStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hres: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LicenseErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *hres = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidStreamBufferSink2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetMinSeek: SetMinSeek::<Impl, IMPL_OFFSET>,
            AudioCounter: AudioCounter::<Impl, IMPL_OFFSET>,
            VideoCounter: VideoCounter::<Impl, IMPL_OFFSET>,
            CCCounter: CCCounter::<Impl, IMPL_OFFSET>,
            WSTCounter: WSTCounter::<Impl, IMPL_OFFSET>,
            SetAudioAnalysisFilter: SetAudioAnalysisFilter::<Impl, IMPL_OFFSET>,
            AudioAnalysisFilter: AudioAnalysisFilter::<Impl, IMPL_OFFSET>,
            Set_AudioAnalysisFilter: Set_AudioAnalysisFilter::<Impl, IMPL_OFFSET>,
            _AudioAnalysisFilter: _AudioAnalysisFilter::<Impl, IMPL_OFFSET>,
            SetVideoAnalysisFilter: SetVideoAnalysisFilter::<Impl, IMPL_OFFSET>,
            VideoAnalysisFilter: VideoAnalysisFilter::<Impl, IMPL_OFFSET>,
            Set_VideoAnalysisFilter: Set_VideoAnalysisFilter::<Impl, IMPL_OFFSET>,
            _VideoAnalysisFilter: _VideoAnalysisFilter::<Impl, IMPL_OFFSET>,
            SetDataAnalysisFilter: SetDataAnalysisFilter::<Impl, IMPL_OFFSET>,
            DataAnalysisFilter: DataAnalysisFilter::<Impl, IMPL_OFFSET>,
            Set_DataAnalysisFilter: Set_DataAnalysisFilter::<Impl, IMPL_OFFSET>,
            _DataAnalysisFilter: _DataAnalysisFilter::<Impl, IMPL_OFFSET>,
            LicenseErrorCode: LicenseErrorCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSink3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSinkEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl {
    fn CertificateFailure(&mut self) -> ::windows::core::Result<()>;
    fn CertificateSuccess(&mut self) -> ::windows::core::Result<()>;
    fn WriteFailure(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSinkEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSinkEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSinkEvent_Vtbl {
        unsafe extern "system" fn CertificateFailure<Impl: IMSVidStreamBufferSinkEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CertificateFailure().into()
        }
        unsafe extern "system" fn CertificateSuccess<Impl: IMSVidStreamBufferSinkEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CertificateSuccess().into()
        }
        unsafe extern "system" fn WriteFailure<Impl: IMSVidStreamBufferSinkEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteFailure().into()
        }
        Self {
            base: IMSVidOutputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CertificateFailure: CertificateFailure::<Impl, IMPL_OFFSET>,
            CertificateSuccess: CertificateSuccess::<Impl, IMPL_OFFSET>,
            WriteFailure: WriteFailure::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSinkEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSinkEvent2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl + IMSVidStreamBufferSinkEvent_Impl {
    fn EncryptionOn(&mut self) -> ::windows::core::Result<()>;
    fn EncryptionOff(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSinkEvent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSinkEvent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSinkEvent2_Vtbl {
        unsafe extern "system" fn EncryptionOn<Impl: IMSVidStreamBufferSinkEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EncryptionOn().into()
        }
        unsafe extern "system" fn EncryptionOff<Impl: IMSVidStreamBufferSinkEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EncryptionOff().into()
        }
        Self {
            base: IMSVidStreamBufferSinkEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            EncryptionOn: EncryptionOn::<Impl, IMPL_OFFSET>,
            EncryptionOff: EncryptionOff::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSinkEvent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSinkEvent3_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl + IMSVidStreamBufferSinkEvent_Impl + IMSVidStreamBufferSinkEvent2_Impl {
    fn LicenseChange(&mut self, dwprot: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSinkEvent3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSinkEvent3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSinkEvent3_Vtbl {
        unsafe extern "system" fn LicenseChange<Impl: IMSVidStreamBufferSinkEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwprot: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LicenseChange(::core::mem::transmute_copy(&dwprot)).into()
        }
        Self { base: IMSVidStreamBufferSinkEvent2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), LicenseChange: LicenseChange::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSinkEvent3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSinkEvent4_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl + IMSVidStreamBufferSinkEvent_Impl + IMSVidStreamBufferSinkEvent2_Impl + IMSVidStreamBufferSinkEvent3_Impl {
    fn WriteFailureClear(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSinkEvent4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSinkEvent4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSinkEvent4_Vtbl {
        unsafe extern "system" fn WriteFailureClear<Impl: IMSVidStreamBufferSinkEvent4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteFailureClear().into()
        }
        Self {
            base: IMSVidStreamBufferSinkEvent3_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            WriteFailureClear: WriteFailureClear::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSinkEvent4 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSource_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl + IMSVidFilePlayback_Impl {
    fn Start(&mut self) -> ::windows::core::Result<i32>;
    fn RecordingAttribute(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn CurrentRatings(&mut self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, pbfenattr: *mut i32) -> ::windows::core::Result<()>;
    fn MaxRatingsLevel(&mut self, ensystem: EnTvRat_System, enrating: EnTvRat_GenericLevel, lbfenattr: i32) -> ::windows::core::Result<()>;
    fn SetBlockUnrated(&mut self, bblock: i16) -> ::windows::core::Result<()>;
    fn SetUnratedDelay(&mut self, dwdelay: i32) -> ::windows::core::Result<()>;
    fn SBESource(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSource_Vtbl {
        unsafe extern "system" fn Start<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstart: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Start() {
                ::core::result::Result::Ok(ok__) => {
                    *lstart = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecordingAttribute<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, precordingattribute: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RecordingAttribute() {
                ::core::result::Result::Ok(ok__) => {
                    *precordingattribute = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentRatings<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, pbfenattr: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CurrentRatings(::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penrating), ::core::mem::transmute_copy(&pbfenattr)).into()
        }
        unsafe extern "system" fn MaxRatingsLevel<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ensystem: EnTvRat_System, enrating: EnTvRat_GenericLevel, lbfenattr: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MaxRatingsLevel(::core::mem::transmute_copy(&ensystem), ::core::mem::transmute_copy(&enrating), ::core::mem::transmute_copy(&lbfenattr)).into()
        }
        unsafe extern "system" fn SetBlockUnrated<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bblock: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlockUnrated(::core::mem::transmute_copy(&bblock)).into()
        }
        unsafe extern "system" fn SetUnratedDelay<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdelay: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnratedDelay(::core::mem::transmute_copy(&dwdelay)).into()
        }
        unsafe extern "system" fn SBESource<Impl: IMSVidStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sbefilter: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SBESource() {
                ::core::result::Result::Ok(ok__) => {
                    *sbefilter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidFilePlayback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Start: Start::<Impl, IMPL_OFFSET>,
            RecordingAttribute: RecordingAttribute::<Impl, IMPL_OFFSET>,
            CurrentRatings: CurrentRatings::<Impl, IMPL_OFFSET>,
            MaxRatingsLevel: MaxRatingsLevel::<Impl, IMPL_OFFSET>,
            SetBlockUnrated: SetBlockUnrated::<Impl, IMPL_OFFSET>,
            SetUnratedDelay: SetUnratedDelay::<Impl, IMPL_OFFSET>,
            SBESource: SBESource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSource as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSource2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl + IMSVidFilePlayback_Impl + IMSVidStreamBufferSource_Impl {
    fn SetRateEx(&mut self, dwrate: f64, dwframespersecond: u32) -> ::windows::core::Result<()>;
    fn AudioCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn VideoCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn CCCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn WSTCounter(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSource2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSource2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSource2_Vtbl {
        unsafe extern "system" fn SetRateEx<Impl: IMSVidStreamBufferSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrate: f64, dwframespersecond: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRateEx(::core::mem::transmute_copy(&dwrate), ::core::mem::transmute_copy(&dwframespersecond)).into()
        }
        unsafe extern "system" fn AudioCounter<Impl: IMSVidStreamBufferSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoCounter<Impl: IMSVidStreamBufferSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VideoCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CCCounter<Impl: IMSVidStreamBufferSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CCCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WSTCounter<Impl: IMSVidStreamBufferSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WSTCounter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidStreamBufferSource_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetRateEx: SetRateEx::<Impl, IMPL_OFFSET>,
            AudioCounter: AudioCounter::<Impl, IMPL_OFFSET>,
            VideoCounter: VideoCounter::<Impl, IMPL_OFFSET>,
            CCCounter: CCCounter::<Impl, IMPL_OFFSET>,
            WSTCounter: WSTCounter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSource2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSourceEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl + IMSVidFilePlaybackEvent_Impl {
    fn CertificateFailure(&mut self) -> ::windows::core::Result<()>;
    fn CertificateSuccess(&mut self) -> ::windows::core::Result<()>;
    fn RatingsBlocked(&mut self) -> ::windows::core::Result<()>;
    fn RatingsUnblocked(&mut self) -> ::windows::core::Result<()>;
    fn RatingsChanged(&mut self) -> ::windows::core::Result<()>;
    fn TimeHole(&mut self, streamoffsetms: i32, sizems: i32) -> ::windows::core::Result<()>;
    fn StaleDataRead(&mut self) -> ::windows::core::Result<()>;
    fn ContentBecomingStale(&mut self) -> ::windows::core::Result<()>;
    fn StaleFileDeleted(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSourceEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSourceEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSourceEvent_Vtbl {
        unsafe extern "system" fn CertificateFailure<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CertificateFailure().into()
        }
        unsafe extern "system" fn CertificateSuccess<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CertificateSuccess().into()
        }
        unsafe extern "system" fn RatingsBlocked<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RatingsBlocked().into()
        }
        unsafe extern "system" fn RatingsUnblocked<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RatingsUnblocked().into()
        }
        unsafe extern "system" fn RatingsChanged<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RatingsChanged().into()
        }
        unsafe extern "system" fn TimeHole<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamoffsetms: i32, sizems: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TimeHole(::core::mem::transmute_copy(&streamoffsetms), ::core::mem::transmute_copy(&sizems)).into()
        }
        unsafe extern "system" fn StaleDataRead<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StaleDataRead().into()
        }
        unsafe extern "system" fn ContentBecomingStale<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContentBecomingStale().into()
        }
        unsafe extern "system" fn StaleFileDeleted<Impl: IMSVidStreamBufferSourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StaleFileDeleted().into()
        }
        Self {
            base: IMSVidFilePlaybackEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CertificateFailure: CertificateFailure::<Impl, IMPL_OFFSET>,
            CertificateSuccess: CertificateSuccess::<Impl, IMPL_OFFSET>,
            RatingsBlocked: RatingsBlocked::<Impl, IMPL_OFFSET>,
            RatingsUnblocked: RatingsUnblocked::<Impl, IMPL_OFFSET>,
            RatingsChanged: RatingsChanged::<Impl, IMPL_OFFSET>,
            TimeHole: TimeHole::<Impl, IMPL_OFFSET>,
            StaleDataRead: StaleDataRead::<Impl, IMPL_OFFSET>,
            ContentBecomingStale: ContentBecomingStale::<Impl, IMPL_OFFSET>,
            StaleFileDeleted: StaleFileDeleted::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSourceEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSourceEvent2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl + IMSVidFilePlaybackEvent_Impl + IMSVidStreamBufferSourceEvent_Impl {
    fn RateChange(&mut self, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSourceEvent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSourceEvent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSourceEvent2_Vtbl {
        unsafe extern "system" fn RateChange<Impl: IMSVidStreamBufferSourceEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RateChange(::core::mem::transmute_copy(&qwnewrate), ::core::mem::transmute_copy(&qwoldrate)).into()
        }
        Self { base: IMSVidStreamBufferSourceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), RateChange: RateChange::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSourceEvent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferSourceEvent3_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl + IMSVidFilePlaybackEvent_Impl + IMSVidStreamBufferSourceEvent_Impl + IMSVidStreamBufferSourceEvent2_Impl {
    fn BroadcastEvent(&mut self, guid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn BroadcastEventEx(&mut self, guid: &super::super::Foundation::BSTR, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::Result<()>;
    fn COPPBlocked(&mut self) -> ::windows::core::Result<()>;
    fn COPPUnblocked(&mut self) -> ::windows::core::Result<()>;
    fn ContentPrimarilyAudio(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferSourceEvent3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferSourceEvent3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferSourceEvent3_Vtbl {
        unsafe extern "system" fn BroadcastEvent<Impl: IMSVidStreamBufferSourceEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BroadcastEvent(::core::mem::transmute_copy(&guid)).into()
        }
        unsafe extern "system" fn BroadcastEventEx<Impl: IMSVidStreamBufferSourceEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BroadcastEventEx(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2), ::core::mem::transmute_copy(&param3), ::core::mem::transmute_copy(&param4)).into()
        }
        unsafe extern "system" fn COPPBlocked<Impl: IMSVidStreamBufferSourceEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).COPPBlocked().into()
        }
        unsafe extern "system" fn COPPUnblocked<Impl: IMSVidStreamBufferSourceEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).COPPUnblocked().into()
        }
        unsafe extern "system" fn ContentPrimarilyAudio<Impl: IMSVidStreamBufferSourceEvent3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContentPrimarilyAudio().into()
        }
        Self {
            base: IMSVidStreamBufferSourceEvent2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            BroadcastEvent: BroadcastEvent::<Impl, IMPL_OFFSET>,
            BroadcastEventEx: BroadcastEventEx::<Impl, IMPL_OFFSET>,
            COPPBlocked: COPPBlocked::<Impl, IMPL_OFFSET>,
            COPPUnblocked: COPPUnblocked::<Impl, IMPL_OFFSET>,
            ContentPrimarilyAudio: ContentPrimarilyAudio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferSourceEvent3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidStreamBufferV2SourceEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl + IMSVidFilePlaybackEvent_Impl {
    fn RatingsChanged(&mut self) -> ::windows::core::Result<()>;
    fn TimeHole(&mut self, streamoffsetms: i32, sizems: i32) -> ::windows::core::Result<()>;
    fn StaleDataRead(&mut self) -> ::windows::core::Result<()>;
    fn ContentBecomingStale(&mut self) -> ::windows::core::Result<()>;
    fn StaleFileDeleted(&mut self) -> ::windows::core::Result<()>;
    fn RateChange(&mut self, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::Result<()>;
    fn BroadcastEvent(&mut self, guid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn BroadcastEventEx(&mut self, guid: &super::super::Foundation::BSTR, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::Result<()>;
    fn ContentPrimarilyAudio(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidStreamBufferV2SourceEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidStreamBufferV2SourceEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidStreamBufferV2SourceEvent_Vtbl {
        unsafe extern "system" fn RatingsChanged<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RatingsChanged().into()
        }
        unsafe extern "system" fn TimeHole<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamoffsetms: i32, sizems: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TimeHole(::core::mem::transmute_copy(&streamoffsetms), ::core::mem::transmute_copy(&sizems)).into()
        }
        unsafe extern "system" fn StaleDataRead<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StaleDataRead().into()
        }
        unsafe extern "system" fn ContentBecomingStale<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContentBecomingStale().into()
        }
        unsafe extern "system" fn StaleFileDeleted<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StaleFileDeleted().into()
        }
        unsafe extern "system" fn RateChange<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RateChange(::core::mem::transmute_copy(&qwnewrate), ::core::mem::transmute_copy(&qwoldrate)).into()
        }
        unsafe extern "system" fn BroadcastEvent<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BroadcastEvent(::core::mem::transmute_copy(&guid)).into()
        }
        unsafe extern "system" fn BroadcastEventEx<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, param1: u32, param2: u32, param3: u32, param4: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BroadcastEventEx(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2), ::core::mem::transmute_copy(&param3), ::core::mem::transmute_copy(&param4)).into()
        }
        unsafe extern "system" fn ContentPrimarilyAudio<Impl: IMSVidStreamBufferV2SourceEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContentPrimarilyAudio().into()
        }
        Self {
            base: IMSVidFilePlaybackEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            RatingsChanged: RatingsChanged::<Impl, IMPL_OFFSET>,
            TimeHole: TimeHole::<Impl, IMPL_OFFSET>,
            StaleDataRead: StaleDataRead::<Impl, IMPL_OFFSET>,
            ContentBecomingStale: ContentBecomingStale::<Impl, IMPL_OFFSET>,
            StaleFileDeleted: StaleFileDeleted::<Impl, IMPL_OFFSET>,
            RateChange: RateChange::<Impl, IMPL_OFFSET>,
            BroadcastEvent: BroadcastEvent::<Impl, IMPL_OFFSET>,
            BroadcastEventEx: BroadcastEventEx::<Impl, IMPL_OFFSET>,
            ContentPrimarilyAudio: ContentPrimarilyAudio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidStreamBufferV2SourceEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidTuner_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidVideoInputDevice_Impl {
    fn Tune(&mut self) -> ::windows::core::Result<ITuneRequest>;
    fn SetTune(&mut self, ptr: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn TuningSpace(&mut self) -> ::windows::core::Result<ITuningSpace>;
    fn SetTuningSpace(&mut self, plts: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidTuner_Vtbl {
        unsafe extern "system" fn Tune<Impl: IMSVidTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptr: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Tune() {
                ::core::result::Result::Ok(ok__) => {
                    *pptr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTune<Impl: IMSVidTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptr: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTune(::core::mem::transmute(&ptr)).into()
        }
        unsafe extern "system" fn TuningSpace<Impl: IMSVidTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plts: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpace() {
                ::core::result::Result::Ok(ok__) => {
                    *plts = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: IMSVidTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plts: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTuningSpace(::core::mem::transmute(&plts)).into()
        }
        Self {
            base: IMSVidVideoInputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Tune: Tune::<Impl, IMPL_OFFSET>,
            SetTune: SetTune::<Impl, IMPL_OFFSET>,
            TuningSpace: TuningSpace::<Impl, IMPL_OFFSET>,
            SetTuningSpace: SetTuningSpace::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidTuner as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidTunerEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl {
    fn TuneChanged(&mut self, lpd: &::core::option::Option<IMSVidTuner>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidTunerEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidTunerEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidTunerEvent_Vtbl {
        unsafe extern "system" fn TuneChanged<Impl: IMSVidTunerEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpd: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TuneChanged(::core::mem::transmute(&lpd)).into()
        }
        Self { base: IMSVidInputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), TuneChanged: TuneChanged::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidTunerEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVMR9_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidVideoRenderer_Impl {
    fn Allocator_ID(&mut self) -> ::windows::core::Result<i32>;
    fn SetAllocator(&mut self, allocpresent: &::core::option::Option<::windows::core::IUnknown>, id: i32) -> ::windows::core::Result<()>;
    fn SetSuppressEffects(&mut self, bsuppress: i16) -> ::windows::core::Result<()>;
    fn SuppressEffects(&mut self) -> ::windows::core::Result<i16>;
    fn Allocator(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVMR9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVMR9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVMR9_Vtbl {
        unsafe extern "system" fn Allocator_ID<Impl: IMSVidVMR9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Allocator_ID() {
                ::core::result::Result::Ok(ok__) => {
                    *id = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllocator<Impl: IMSVidVMR9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::core::ffi::c_void, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllocator(::core::mem::transmute(&allocpresent), ::core::mem::transmute_copy(&id)).into()
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidVMR9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSuppressEffects(::core::mem::transmute_copy(&bsuppress)).into()
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidVMR9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuppressEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *bsuppress = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allocator<Impl: IMSVidVMR9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Allocator() {
                ::core::result::Result::Ok(ok__) => {
                    *allocpresent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidVideoRenderer_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Allocator_ID: Allocator_ID::<Impl, IMPL_OFFSET>,
            SetAllocator: SetAllocator::<Impl, IMPL_OFFSET>,
            SetSuppressEffects: SetSuppressEffects::<Impl, IMPL_OFFSET>,
            SuppressEffects: SuppressEffects::<Impl, IMPL_OFFSET>,
            Allocator: Allocator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVMR9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com"))]
pub trait IMSVidVRGraphSegment_Impl: Sized + super::super::System::Com::IPersist_Impl + IMSVidGraphSegment_Impl {
    fn Set_VMRendererMode(&mut self, dwmode: i32) -> ::windows::core::Result<()>;
    fn SetOwner(&mut self, window: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn Owner(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn UseOverlay(&mut self) -> ::windows::core::Result<i16>;
    fn SetUseOverlay(&mut self, useoverlayval: i16) -> ::windows::core::Result<()>;
    fn Visible(&mut self) -> ::windows::core::Result<i16>;
    fn SetVisible(&mut self, visible: i16) -> ::windows::core::Result<()>;
    fn ColorKey(&mut self) -> ::windows::core::Result<u32>;
    fn SetColorKey(&mut self, colorkey: u32) -> ::windows::core::Result<()>;
    fn Source(&mut self) -> ::windows::core::Result<super::super::Foundation::RECT>;
    fn SetSource(&mut self, r: &super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn Destination(&mut self) -> ::windows::core::Result<super::super::Foundation::RECT>;
    fn SetDestination(&mut self, r: &super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn NativeSize(&mut self, sizeval: *mut super::super::Foundation::SIZE, aspectratio: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
    fn BorderColor(&mut self) -> ::windows::core::Result<u32>;
    fn SetBorderColor(&mut self, color: u32) -> ::windows::core::Result<()>;
    fn MaintainAspectRatio(&mut self) -> ::windows::core::Result<i16>;
    fn SetMaintainAspectRatio(&mut self, fmaintain: i16) -> ::windows::core::Result<()>;
    fn Refresh(&mut self) -> ::windows::core::Result<()>;
    fn DisplayChange(&mut self) -> ::windows::core::Result<()>;
    fn RePaint(&mut self, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com"))]
impl IMSVidVRGraphSegment_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVRGraphSegment_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVRGraphSegment_Vtbl {
        unsafe extern "system" fn Set_VMRendererMode<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_VMRendererMode(::core::mem::transmute_copy(&dwmode)).into()
        }
        unsafe extern "system" fn SetOwner<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, window: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOwner(::core::mem::transmute_copy(&window)).into()
        }
        unsafe extern "system" fn Owner<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, window: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Owner() {
                ::core::result::Result::Ok(ok__) => {
                    *window = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UseOverlay<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlayval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UseOverlay() {
                ::core::result::Result::Ok(ok__) => {
                    *useoverlayval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseOverlay<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlayval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseOverlay(::core::mem::transmute_copy(&useoverlayval)).into()
        }
        unsafe extern "system" fn Visible<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, visible: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Visible() {
                ::core::result::Result::Ok(ok__) => {
                    *visible = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisible<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, visible: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVisible(::core::mem::transmute_copy(&visible)).into()
        }
        unsafe extern "system" fn ColorKey<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, colorkey: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ColorKey() {
                ::core::result::Result::Ok(ok__) => {
                    *colorkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, colorkey: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&colorkey)).into()
        }
        unsafe extern "system" fn Source<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *r = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r: super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(::core::mem::transmute_copy(&r)).into()
        }
        unsafe extern "system" fn Destination<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Destination() {
                ::core::result::Result::Ok(ok__) => {
                    *r = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestination<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r: super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestination(::core::mem::transmute_copy(&r)).into()
        }
        unsafe extern "system" fn NativeSize<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sizeval: *mut super::super::Foundation::SIZE, aspectratio: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NativeSize(::core::mem::transmute_copy(&sizeval), ::core::mem::transmute_copy(&aspectratio)).into()
        }
        unsafe extern "system" fn BorderColor<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderColor() {
                ::core::result::Result::Ok(ok__) => {
                    *color = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&color)).into()
        }
        unsafe extern "system" fn MaintainAspectRatio<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmaintain: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaintainAspectRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *fmaintain = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaintainAspectRatio<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmaintain: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaintainAspectRatio(::core::mem::transmute_copy(&fmaintain)).into()
        }
        unsafe extern "system" fn Refresh<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Refresh().into()
        }
        unsafe extern "system" fn DisplayChange<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisplayChange().into()
        }
        unsafe extern "system" fn RePaint<Impl: IMSVidVRGraphSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RePaint(::core::mem::transmute_copy(&hdc)).into()
        }
        Self {
            base: IMSVidGraphSegment_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Set_VMRendererMode: Set_VMRendererMode::<Impl, IMPL_OFFSET>,
            SetOwner: SetOwner::<Impl, IMPL_OFFSET>,
            Owner: Owner::<Impl, IMPL_OFFSET>,
            UseOverlay: UseOverlay::<Impl, IMPL_OFFSET>,
            SetUseOverlay: SetUseOverlay::<Impl, IMPL_OFFSET>,
            Visible: Visible::<Impl, IMPL_OFFSET>,
            SetVisible: SetVisible::<Impl, IMPL_OFFSET>,
            ColorKey: ColorKey::<Impl, IMPL_OFFSET>,
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            Source: Source::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            Destination: Destination::<Impl, IMPL_OFFSET>,
            SetDestination: SetDestination::<Impl, IMPL_OFFSET>,
            NativeSize: NativeSize::<Impl, IMPL_OFFSET>,
            BorderColor: BorderColor::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            MaintainAspectRatio: MaintainAspectRatio::<Impl, IMPL_OFFSET>,
            SetMaintainAspectRatio: SetMaintainAspectRatio::<Impl, IMPL_OFFSET>,
            Refresh: Refresh::<Impl, IMPL_OFFSET>,
            DisplayChange: DisplayChange::<Impl, IMPL_OFFSET>,
            RePaint: RePaint::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVRGraphSegment as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoInputDevice_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoInputDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoInputDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoInputDevice_Vtbl {
        Self { base: IMSVidInputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoInputDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoRenderer_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl {
    fn CustomCompositorClass(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetCustomCompositorClass(&mut self, compositorclsid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn _CustomCompositorClass(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Set_CustomCompositorClass(&mut self, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn _CustomCompositor(&mut self) -> ::windows::core::Result<IVMRImageCompositor>;
    fn Set_CustomCompositor(&mut self, compositor: &::core::option::Option<IVMRImageCompositor>) -> ::windows::core::Result<()>;
    fn MixerBitmap(&mut self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp>;
    fn _MixerBitmap(&mut self) -> ::windows::core::Result<IVMRMixerBitmap>;
    fn SetMixerBitmap(&mut self, mixerpicturedisp: &::core::option::Option<super::super::System::Ole::IPictureDisp>) -> ::windows::core::Result<()>;
    fn Set_MixerBitmap(&mut self, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::Result<()>;
    fn MixerBitmapPositionRect(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn SetMixerBitmapPositionRect(&mut self, rdest: &::core::option::Option<IMSVidRect>) -> ::windows::core::Result<()>;
    fn MixerBitmapOpacity(&mut self) -> ::windows::core::Result<i32>;
    fn SetMixerBitmapOpacity(&mut self, opacity: i32) -> ::windows::core::Result<()>;
    fn SetupMixerBitmap(&mut self, mixerpicturedisp: &::core::option::Option<super::super::System::Ole::IPictureDisp>, opacity: i32, rdest: &::core::option::Option<IMSVidRect>) -> ::windows::core::Result<()>;
    fn SourceSize(&mut self) -> ::windows::core::Result<SourceSizeList>;
    fn SetSourceSize(&mut self, newsize: SourceSizeList) -> ::windows::core::Result<()>;
    fn OverScan(&mut self) -> ::windows::core::Result<i32>;
    fn SetOverScan(&mut self, lpercent: i32) -> ::windows::core::Result<()>;
    fn AvailableSourceRect(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn MaxVidRect(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn MinVidRect(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn ClippedSourceRect(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn SetClippedSourceRect(&mut self, prect: &::core::option::Option<IMSVidRect>) -> ::windows::core::Result<()>;
    fn UsingOverlay(&mut self) -> ::windows::core::Result<i16>;
    fn SetUsingOverlay(&mut self, useoverlayval: i16) -> ::windows::core::Result<()>;
    fn Capture(&mut self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp>;
    fn FramesPerSecond(&mut self) -> ::windows::core::Result<i32>;
    fn DecimateInput(&mut self) -> ::windows::core::Result<i16>;
    fn SetDecimateInput(&mut self, pdeci: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoRenderer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoRenderer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoRenderer_Vtbl {
        unsafe extern "system" fn CustomCompositorClass<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositorclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CustomCompositorClass() {
                ::core::result::Result::Ok(ok__) => {
                    *compositorclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomCompositorClass<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositorclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCustomCompositorClass(::core::mem::transmute_copy(&compositorclsid)).into()
        }
        unsafe extern "system" fn _CustomCompositorClass<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositorclsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._CustomCompositorClass() {
                ::core::result::Result::Ok(ok__) => {
                    *compositorclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_CustomCompositorClass<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_CustomCompositorClass(::core::mem::transmute_copy(&compositorclsid)).into()
        }
        unsafe extern "system" fn _CustomCompositor<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._CustomCompositor() {
                ::core::result::Result::Ok(ok__) => {
                    *compositor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_CustomCompositor<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_CustomCompositor(::core::mem::transmute(&compositor)).into()
        }
        unsafe extern "system" fn MixerBitmap<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MixerBitmap() {
                ::core::result::Result::Ok(ok__) => {
                    *mixerpicturedisp = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _MixerBitmap<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mixerpicture: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._MixerBitmap() {
                ::core::result::Result::Ok(ok__) => {
                    *mixerpicture = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmap<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixerBitmap(::core::mem::transmute(&mixerpicturedisp)).into()
        }
        unsafe extern "system" fn Set_MixerBitmap<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_MixerBitmap(::core::mem::transmute_copy(&mixerpicture)).into()
        }
        unsafe extern "system" fn MixerBitmapPositionRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rdest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MixerBitmapPositionRect() {
                ::core::result::Result::Ok(ok__) => {
                    *rdest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmapPositionRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixerBitmapPositionRect(::core::mem::transmute(&rdest)).into()
        }
        unsafe extern "system" fn MixerBitmapOpacity<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, opacity: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MixerBitmapOpacity() {
                ::core::result::Result::Ok(ok__) => {
                    *opacity = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMixerBitmapOpacity<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, opacity: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixerBitmapOpacity(::core::mem::transmute_copy(&opacity)).into()
        }
        unsafe extern "system" fn SetupMixerBitmap<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mixerpicturedisp: ::windows::core::RawPtr, opacity: i32, rdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetupMixerBitmap(::core::mem::transmute(&mixerpicturedisp), ::core::mem::transmute_copy(&opacity), ::core::mem::transmute(&rdest)).into()
        }
        unsafe extern "system" fn SourceSize<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentsize: *mut SourceSizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceSize() {
                ::core::result::Result::Ok(ok__) => {
                    *currentsize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceSize<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newsize: SourceSizeList) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceSize(::core::mem::transmute_copy(&newsize)).into()
        }
        unsafe extern "system" fn OverScan<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plpercent: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OverScan() {
                ::core::result::Result::Ok(ok__) => {
                    *plpercent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverScan<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpercent: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverScan(::core::mem::transmute_copy(&lpercent)).into()
        }
        unsafe extern "system" fn AvailableSourceRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvailableSourceRect() {
                ::core::result::Result::Ok(ok__) => {
                    *prect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxVidRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppvidrect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxVidRect() {
                ::core::result::Result::Ok(ok__) => {
                    *ppvidrect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinVidRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppvidrect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MinVidRect() {
                ::core::result::Result::Ok(ok__) => {
                    *ppvidrect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClippedSourceRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ClippedSourceRect() {
                ::core::result::Result::Ok(ok__) => {
                    *prect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClippedSourceRect<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prect: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClippedSourceRect(::core::mem::transmute(&prect)).into()
        }
        unsafe extern "system" fn UsingOverlay<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlayval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UsingOverlay() {
                ::core::result::Result::Ok(ok__) => {
                    *useoverlayval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUsingOverlay<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, useoverlayval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUsingOverlay(::core::mem::transmute_copy(&useoverlayval)).into()
        }
        unsafe extern "system" fn Capture<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentimage: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Capture() {
                ::core::result::Result::Ok(ok__) => {
                    *currentimage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FramesPerSecond<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FramesPerSecond() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DecimateInput<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeci: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DecimateInput() {
                ::core::result::Result::Ok(ok__) => {
                    *pdeci = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecimateInput<Impl: IMSVidVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeci: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDecimateInput(::core::mem::transmute_copy(&pdeci)).into()
        }
        Self {
            base: IMSVidOutputDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CustomCompositorClass: CustomCompositorClass::<Impl, IMPL_OFFSET>,
            SetCustomCompositorClass: SetCustomCompositorClass::<Impl, IMPL_OFFSET>,
            _CustomCompositorClass: _CustomCompositorClass::<Impl, IMPL_OFFSET>,
            Set_CustomCompositorClass: Set_CustomCompositorClass::<Impl, IMPL_OFFSET>,
            _CustomCompositor: _CustomCompositor::<Impl, IMPL_OFFSET>,
            Set_CustomCompositor: Set_CustomCompositor::<Impl, IMPL_OFFSET>,
            MixerBitmap: MixerBitmap::<Impl, IMPL_OFFSET>,
            _MixerBitmap: _MixerBitmap::<Impl, IMPL_OFFSET>,
            SetMixerBitmap: SetMixerBitmap::<Impl, IMPL_OFFSET>,
            Set_MixerBitmap: Set_MixerBitmap::<Impl, IMPL_OFFSET>,
            MixerBitmapPositionRect: MixerBitmapPositionRect::<Impl, IMPL_OFFSET>,
            SetMixerBitmapPositionRect: SetMixerBitmapPositionRect::<Impl, IMPL_OFFSET>,
            MixerBitmapOpacity: MixerBitmapOpacity::<Impl, IMPL_OFFSET>,
            SetMixerBitmapOpacity: SetMixerBitmapOpacity::<Impl, IMPL_OFFSET>,
            SetupMixerBitmap: SetupMixerBitmap::<Impl, IMPL_OFFSET>,
            SourceSize: SourceSize::<Impl, IMPL_OFFSET>,
            SetSourceSize: SetSourceSize::<Impl, IMPL_OFFSET>,
            OverScan: OverScan::<Impl, IMPL_OFFSET>,
            SetOverScan: SetOverScan::<Impl, IMPL_OFFSET>,
            AvailableSourceRect: AvailableSourceRect::<Impl, IMPL_OFFSET>,
            MaxVidRect: MaxVidRect::<Impl, IMPL_OFFSET>,
            MinVidRect: MinVidRect::<Impl, IMPL_OFFSET>,
            ClippedSourceRect: ClippedSourceRect::<Impl, IMPL_OFFSET>,
            SetClippedSourceRect: SetClippedSourceRect::<Impl, IMPL_OFFSET>,
            UsingOverlay: UsingOverlay::<Impl, IMPL_OFFSET>,
            SetUsingOverlay: SetUsingOverlay::<Impl, IMPL_OFFSET>,
            Capture: Capture::<Impl, IMPL_OFFSET>,
            FramesPerSecond: FramesPerSecond::<Impl, IMPL_OFFSET>,
            DecimateInput: DecimateInput::<Impl, IMPL_OFFSET>,
            SetDecimateInput: SetDecimateInput::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoRenderer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoRenderer2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidOutputDevice_Impl + IMSVidVideoRenderer_Impl {
    fn Allocator(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn _Allocator(&mut self) -> ::windows::core::Result<IVMRSurfaceAllocator>;
    fn Allocator_ID(&mut self) -> ::windows::core::Result<i32>;
    fn SetAllocator(&mut self, allocpresent: &::core::option::Option<::windows::core::IUnknown>, id: i32) -> ::windows::core::Result<()>;
    fn _SetAllocator2(&mut self, allocpresent: &::core::option::Option<IVMRSurfaceAllocator>, id: i32) -> ::windows::core::Result<()>;
    fn SetSuppressEffects(&mut self, bsuppress: i16) -> ::windows::core::Result<()>;
    fn SuppressEffects(&mut self) -> ::windows::core::Result<i16>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoRenderer2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoRenderer2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoRenderer2_Vtbl {
        unsafe extern "system" fn Allocator<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Allocator() {
                ::core::result::Result::Ok(ok__) => {
                    *allocpresent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _Allocator<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._Allocator() {
                ::core::result::Result::Ok(ok__) => {
                    *allocpresent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allocator_ID<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Allocator_ID() {
                ::core::result::Result::Ok(ok__) => {
                    *id = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllocator<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: *mut ::core::ffi::c_void, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllocator(::core::mem::transmute(&allocpresent), ::core::mem::transmute_copy(&id)).into()
        }
        unsafe extern "system" fn _SetAllocator2<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, allocpresent: ::windows::core::RawPtr, id: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this)._SetAllocator2(::core::mem::transmute(&allocpresent), ::core::mem::transmute_copy(&id)).into()
        }
        unsafe extern "system" fn SetSuppressEffects<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSuppressEffects(::core::mem::transmute_copy(&bsuppress)).into()
        }
        unsafe extern "system" fn SuppressEffects<Impl: IMSVidVideoRenderer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsuppress: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SuppressEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *bsuppress = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMSVidVideoRenderer_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Allocator: Allocator::<Impl, IMPL_OFFSET>,
            _Allocator: _Allocator::<Impl, IMPL_OFFSET>,
            Allocator_ID: Allocator_ID::<Impl, IMPL_OFFSET>,
            SetAllocator: SetAllocator::<Impl, IMPL_OFFSET>,
            _SetAllocator2: _SetAllocator2::<Impl, IMPL_OFFSET>,
            SetSuppressEffects: SetSuppressEffects::<Impl, IMPL_OFFSET>,
            SuppressEffects: SuppressEffects::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoRenderer2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoRendererDevices_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<IMSVidVideoRenderer>;
    fn Add(&mut self, pdb: &::core::option::Option<IMSVidVideoRenderer>) -> ::windows::core::Result<()>;
    fn Remove(&mut self, v: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoRendererDevices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoRendererDevices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoRendererDevices_Vtbl {
        unsafe extern "system" fn Count<Impl: IMSVidVideoRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *lcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: IMSVidVideoRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *pd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IMSVidVideoRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, pdb: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&v)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdb = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: IMSVidVideoRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdb: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Add(::core::mem::transmute(&pdb)).into()
        }
        unsafe extern "system" fn Remove<Impl: IMSVidVideoRendererDevices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, v: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&v)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoRendererDevices as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoRendererEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl {
    fn OverlayUnavailable(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoRendererEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoRendererEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoRendererEvent_Vtbl {
        unsafe extern "system" fn OverlayUnavailable<Impl: IMSVidVideoRendererEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OverlayUnavailable().into()
        }
        Self {
            base: IMSVidOutputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OverlayUnavailable: OverlayUnavailable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoRendererEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidVideoRendererEvent2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidOutputDeviceEvent_Impl {
    fn OverlayUnavailable(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidVideoRendererEvent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidVideoRendererEvent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidVideoRendererEvent2_Vtbl {
        unsafe extern "system" fn OverlayUnavailable<Impl: IMSVidVideoRendererEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OverlayUnavailable().into()
        }
        Self {
            base: IMSVidOutputDeviceEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OverlayUnavailable: OverlayUnavailable::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidVideoRendererEvent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidWebDVD_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl {
    fn OnDVDEvent(&mut self, levent: i32, lparam1: isize, lparam2: isize) -> ::windows::core::Result<()>;
    fn PlayTitle(&mut self, ltitle: i32) -> ::windows::core::Result<()>;
    fn PlayChapterInTitle(&mut self, ltitle: i32, lchapter: i32) -> ::windows::core::Result<()>;
    fn PlayChapter(&mut self, lchapter: i32) -> ::windows::core::Result<()>;
    fn PlayChaptersAutoStop(&mut self, ltitle: i32, lstrchapter: i32, lchaptercount: i32) -> ::windows::core::Result<()>;
    fn PlayAtTime(&mut self, strtime: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn PlayAtTimeInTitle(&mut self, ltitle: i32, strtime: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn PlayPeriodInTitleAutoStop(&mut self, ltitle: i32, strstarttime: &super::super::Foundation::BSTR, strendtime: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ReplayChapter(&mut self) -> ::windows::core::Result<()>;
    fn PlayPrevChapter(&mut self) -> ::windows::core::Result<()>;
    fn PlayNextChapter(&mut self) -> ::windows::core::Result<()>;
    fn StillOff(&mut self) -> ::windows::core::Result<()>;
    fn AudioLanguage(&mut self, lstream: i32, fformat: i16) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn ShowMenu(&mut self, menuid: DVDMenuIDConstants) -> ::windows::core::Result<()>;
    fn Resume(&mut self) -> ::windows::core::Result<()>;
    fn ReturnFromSubmenu(&mut self) -> ::windows::core::Result<()>;
    fn ButtonsAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentButton(&mut self) -> ::windows::core::Result<i32>;
    fn SelectAndActivateButton(&mut self, lbutton: i32) -> ::windows::core::Result<()>;
    fn ActivateButton(&mut self) -> ::windows::core::Result<()>;
    fn SelectRightButton(&mut self) -> ::windows::core::Result<()>;
    fn SelectLeftButton(&mut self) -> ::windows::core::Result<()>;
    fn SelectLowerButton(&mut self) -> ::windows::core::Result<()>;
    fn SelectUpperButton(&mut self) -> ::windows::core::Result<()>;
    fn ActivateAtPosition(&mut self, xpos: i32, ypos: i32) -> ::windows::core::Result<()>;
    fn SelectAtPosition(&mut self, xpos: i32, ypos: i32) -> ::windows::core::Result<()>;
    fn ButtonAtPosition(&mut self, xpos: i32, ypos: i32) -> ::windows::core::Result<i32>;
    fn NumberOfChapters(&mut self, ltitle: i32) -> ::windows::core::Result<i32>;
    fn TotalTitleTime(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn TitlesAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn VolumesAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentVolume(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentDiscSide(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentDomain(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentChapter(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentTitle(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentTime(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn DVDTimeCode2bstr(&mut self, timecode: i32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn DVDDirectory(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetDVDDirectory(&mut self, newval: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn IsSubpictureStreamEnabled(&mut self, lstream: i32) -> ::windows::core::Result<i16>;
    fn IsAudioStreamEnabled(&mut self, lstream: i32) -> ::windows::core::Result<i16>;
    fn CurrentSubpictureStream(&mut self) -> ::windows::core::Result<i32>;
    fn SetCurrentSubpictureStream(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn SubpictureLanguage(&mut self, lstream: i32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn CurrentAudioStream(&mut self) -> ::windows::core::Result<i32>;
    fn SetCurrentAudioStream(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn AudioStreamsAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn AnglesAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn CurrentAngle(&mut self) -> ::windows::core::Result<i32>;
    fn SetCurrentAngle(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn SubpictureStreamsAvailable(&mut self) -> ::windows::core::Result<i32>;
    fn SubpictureOn(&mut self) -> ::windows::core::Result<i16>;
    fn SetSubpictureOn(&mut self, newval: i16) -> ::windows::core::Result<()>;
    fn DVDUniqueID(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn AcceptParentalLevelChange(&mut self, faccept: i16, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn NotifyParentalLevelChange(&mut self, newval: i16) -> ::windows::core::Result<()>;
    fn SelectParentalCountry(&mut self, lcountry: i32, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SelectParentalLevel(&mut self, lparentallevel: i32, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn TitleParentalLevels(&mut self, ltitle: i32) -> ::windows::core::Result<i32>;
    fn PlayerParentalCountry(&mut self) -> ::windows::core::Result<i32>;
    fn PlayerParentalLevel(&mut self) -> ::windows::core::Result<i32>;
    fn Eject(&mut self) -> ::windows::core::Result<()>;
    fn UOPValid(&mut self, luop: i32) -> ::windows::core::Result<i16>;
    fn SPRM(&mut self, lindex: i32) -> ::windows::core::Result<i16>;
    fn GPRM(&mut self, lindex: i32) -> ::windows::core::Result<i16>;
    fn SetGPRM(&mut self, lindex: i32, svalue: i16) -> ::windows::core::Result<()>;
    fn DVDTextStringType(&mut self, llangindex: i32, lstringindex: i32) -> ::windows::core::Result<DVDTextStringType>;
    fn DVDTextString(&mut self, llangindex: i32, lstringindex: i32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn DVDTextNumberOfStrings(&mut self, llangindex: i32) -> ::windows::core::Result<i32>;
    fn DVDTextNumberOfLanguages(&mut self) -> ::windows::core::Result<i32>;
    fn DVDTextLanguageLCID(&mut self, llangindex: i32) -> ::windows::core::Result<i32>;
    fn RegionChange(&mut self) -> ::windows::core::Result<()>;
    fn DVDAdm(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn DeleteBookmark(&mut self) -> ::windows::core::Result<()>;
    fn RestoreBookmark(&mut self) -> ::windows::core::Result<()>;
    fn SaveBookmark(&mut self) -> ::windows::core::Result<()>;
    fn SelectDefaultAudioLanguage(&mut self, lang: i32, ext: i32) -> ::windows::core::Result<()>;
    fn SelectDefaultSubpictureLanguage(&mut self, lang: i32, ext: DVDSPExt) -> ::windows::core::Result<()>;
    fn PreferredSubpictureStream(&mut self) -> ::windows::core::Result<i32>;
    fn DefaultMenuLanguage(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultMenuLanguage(&mut self, lang: i32) -> ::windows::core::Result<()>;
    fn DefaultSubpictureLanguage(&mut self) -> ::windows::core::Result<i32>;
    fn DefaultAudioLanguage(&mut self) -> ::windows::core::Result<i32>;
    fn DefaultSubpictureLanguageExt(&mut self) -> ::windows::core::Result<DVDSPExt>;
    fn DefaultAudioLanguageExt(&mut self) -> ::windows::core::Result<i32>;
    fn LanguageFromLCID(&mut self, lcid: i32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn KaraokeAudioPresentationMode(&mut self) -> ::windows::core::Result<i32>;
    fn SetKaraokeAudioPresentationMode(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn KaraokeChannelContent(&mut self, lstream: i32, lchan: i32) -> ::windows::core::Result<i32>;
    fn KaraokeChannelAssignment(&mut self, lstream: i32) -> ::windows::core::Result<i32>;
    fn RestorePreferredSettings(&mut self) -> ::windows::core::Result<()>;
    fn ButtonRect(&mut self, lbutton: i32) -> ::windows::core::Result<IMSVidRect>;
    fn DVDScreenInMouseCoordinates(&mut self) -> ::windows::core::Result<IMSVidRect>;
    fn SetDVDScreenInMouseCoordinates(&mut self, prect: &::core::option::Option<IMSVidRect>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidWebDVD_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidWebDVD_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidWebDVD_Vtbl {
        unsafe extern "system" fn OnDVDEvent<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, levent: i32, lparam1: isize, lparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDVDEvent(::core::mem::transmute_copy(&levent), ::core::mem::transmute_copy(&lparam1), ::core::mem::transmute_copy(&lparam2)).into()
        }
        unsafe extern "system" fn PlayTitle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayTitle(::core::mem::transmute_copy(&ltitle)).into()
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, lchapter: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayChapterInTitle(::core::mem::transmute_copy(&ltitle), ::core::mem::transmute_copy(&lchapter)).into()
        }
        unsafe extern "system" fn PlayChapter<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lchapter: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayChapter(::core::mem::transmute_copy(&lchapter)).into()
        }
        unsafe extern "system" fn PlayChaptersAutoStop<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, lstrchapter: i32, lchaptercount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayChaptersAutoStop(::core::mem::transmute_copy(&ltitle), ::core::mem::transmute_copy(&lstrchapter), ::core::mem::transmute_copy(&lchaptercount)).into()
        }
        unsafe extern "system" fn PlayAtTime<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTime(::core::mem::transmute_copy(&strtime)).into()
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, strtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTimeInTitle(::core::mem::transmute_copy(&ltitle), ::core::mem::transmute_copy(&strtime)).into()
        }
        unsafe extern "system" fn PlayPeriodInTitleAutoStop<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, strstarttime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strendtime: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayPeriodInTitleAutoStop(::core::mem::transmute_copy(&ltitle), ::core::mem::transmute_copy(&strstarttime), ::core::mem::transmute_copy(&strendtime)).into()
        }
        unsafe extern "system" fn ReplayChapter<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReplayChapter().into()
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayPrevChapter().into()
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayNextChapter().into()
        }
        unsafe extern "system" fn StillOff<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StillOff().into()
        }
        unsafe extern "system" fn AudioLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, fformat: i16, straudiolang: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioLanguage(::core::mem::transmute_copy(&lstream), ::core::mem::transmute_copy(&fformat)) {
                ::core::result::Result::Ok(ok__) => {
                    *straudiolang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowMenu<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menuid: DVDMenuIDConstants) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowMenu(::core::mem::transmute_copy(&menuid)).into()
        }
        unsafe extern "system" fn Resume<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Resume().into()
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReturnFromSubmenu().into()
        }
        unsafe extern "system" fn ButtonsAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonsAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentButton() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectAndActivateButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lbutton: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAndActivateButton(::core::mem::transmute_copy(&lbutton)).into()
        }
        unsafe extern "system" fn ActivateButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateButton().into()
        }
        unsafe extern "system" fn SelectRightButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectRightButton().into()
        }
        unsafe extern "system" fn SelectLeftButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectLeftButton().into()
        }
        unsafe extern "system" fn SelectLowerButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectLowerButton().into()
        }
        unsafe extern "system" fn SelectUpperButton<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectUpperButton().into()
        }
        unsafe extern "system" fn ActivateAtPosition<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateAtPosition(::core::mem::transmute_copy(&xpos), ::core::mem::transmute_copy(&ypos)).into()
        }
        unsafe extern "system" fn SelectAtPosition<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectAtPosition(::core::mem::transmute_copy(&xpos), ::core::mem::transmute_copy(&ypos)).into()
        }
        unsafe extern "system" fn ButtonAtPosition<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, xpos: i32, ypos: i32, plbutton: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonAtPosition(::core::mem::transmute_copy(&xpos), ::core::mem::transmute_copy(&ypos)) {
                ::core::result::Result::Ok(ok__) => {
                    *plbutton = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfChapters<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumberOfChapters(::core::mem::transmute_copy(&ltitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TotalTitleTime<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TotalTitleTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitlesAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitlesAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VolumesAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).VolumesAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentVolume<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentVolume() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentDiscSide<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentDiscSide() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentDomain<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentDomain() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentChapter<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentChapter() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentTitle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentTime<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTimeCode2bstr<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, timecode: i32, ptimestr: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTimeCode2bstr(::core::mem::transmute_copy(&timecode)) {
                ::core::result::Result::Ok(ok__) => {
                    *ptimestr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDDirectory<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDDirectory() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDVDDirectory<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDVDDirectory(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn IsSubpictureStreamEnabled<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, fenabled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSubpictureStreamEnabled(::core::mem::transmute_copy(&lstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *fenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioStreamEnabled<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, fenabled: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAudioStreamEnabled(::core::mem::transmute_copy(&lstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *fenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSubpictureStream<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentSubpictureStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentSubpictureStream<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentSubpictureStream(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn SubpictureLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, strlanguage: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SubpictureLanguage(::core::mem::transmute_copy(&lstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *strlanguage = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentAudioStream<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentAudioStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentAudioStream<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentAudioStream(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn AudioStreamsAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioStreamsAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AnglesAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AnglesAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentAngle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentAngle() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentAngle<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentAngle(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn SubpictureStreamsAvailable<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SubpictureStreamsAvailable() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SubpictureOn<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SubpictureOn() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubpictureOn<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSubpictureOn(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn DVDUniqueID<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDUniqueID() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptParentalLevelChange<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, faccept: i16, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AcceptParentalLevelChange(::core::mem::transmute_copy(&faccept), ::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)).into()
        }
        unsafe extern "system" fn NotifyParentalLevelChange<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyParentalLevelChange(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn SelectParentalCountry<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcountry: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectParentalCountry(::core::mem::transmute_copy(&lcountry), ::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)).into()
        }
        unsafe extern "system" fn SelectParentalLevel<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lparentallevel: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectParentalLevel(::core::mem::transmute_copy(&lparentallevel), ::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)).into()
        }
        unsafe extern "system" fn TitleParentalLevels<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ltitle: i32, plparentallevels: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TitleParentalLevels(::core::mem::transmute_copy(&ltitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *plparentallevels = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayerParentalCountry<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plcountrycode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayerParentalCountry() {
                ::core::result::Result::Ok(ok__) => {
                    *plcountrycode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayerParentalLevel<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plparentallevel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PlayerParentalLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *plparentallevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Eject<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Eject().into()
        }
        unsafe extern "system" fn UOPValid<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, luop: i32, pfvalid: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UOPValid(::core::mem::transmute_copy(&luop)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfvalid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SPRM<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, pssprm: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SPRM(::core::mem::transmute_copy(&lindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pssprm = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GPRM<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, pssprm: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GPRM(::core::mem::transmute_copy(&lindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pssprm = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGPRM<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lindex: i32, svalue: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGPRM(::core::mem::transmute_copy(&lindex), ::core::mem::transmute_copy(&svalue)).into()
        }
        unsafe extern "system" fn DVDTextStringType<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llangindex: i32, lstringindex: i32, ptype: *mut DVDTextStringType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTextStringType(::core::mem::transmute_copy(&llangindex), ::core::mem::transmute_copy(&lstringindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextString<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llangindex: i32, lstringindex: i32, pstrtext: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTextString(::core::mem::transmute_copy(&llangindex), ::core::mem::transmute_copy(&lstringindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstrtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextNumberOfStrings<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llangindex: i32, plnumofstrings: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTextNumberOfStrings(::core::mem::transmute_copy(&llangindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *plnumofstrings = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextNumberOfLanguages<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plnumoflangs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTextNumberOfLanguages() {
                ::core::result::Result::Ok(ok__) => {
                    *plnumoflangs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDTextLanguageLCID<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llangindex: i32, lcid: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDTextLanguageLCID(::core::mem::transmute_copy(&llangindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *lcid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegionChange<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegionChange().into()
        }
        unsafe extern "system" fn DVDAdm<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDAdm() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteBookmark<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteBookmark().into()
        }
        unsafe extern "system" fn RestoreBookmark<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RestoreBookmark().into()
        }
        unsafe extern "system" fn SaveBookmark<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SaveBookmark().into()
        }
        unsafe extern "system" fn SelectDefaultAudioLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: i32, ext: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectDefaultAudioLanguage(::core::mem::transmute_copy(&lang), ::core::mem::transmute_copy(&ext)).into()
        }
        unsafe extern "system" fn SelectDefaultSubpictureLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: i32, ext: DVDSPExt) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectDefaultSubpictureLanguage(::core::mem::transmute_copy(&lang), ::core::mem::transmute_copy(&ext)).into()
        }
        unsafe extern "system" fn PreferredSubpictureStream<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferredSubpictureStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultMenuLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultMenuLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *lang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMenuLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultMenuLanguage(::core::mem::transmute_copy(&lang)).into()
        }
        unsafe extern "system" fn DefaultSubpictureLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *lang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLanguage<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lang: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *lang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSubpictureLanguageExt<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ext: *mut DVDSPExt) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLanguageExt() {
                ::core::result::Result::Ok(ok__) => {
                    *ext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLanguageExt<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ext: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLanguageExt() {
                ::core::result::Result::Ok(ok__) => {
                    *ext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LanguageFromLCID<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcid: i32, lang: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LanguageFromLCID(::core::mem::transmute_copy(&lcid)) {
                ::core::result::Result::Ok(ok__) => {
                    *lang = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeAudioPresentationMode<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KaraokeAudioPresentationMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKaraokeAudioPresentationMode<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKaraokeAudioPresentationMode(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn KaraokeChannelContent<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, lchan: i32, lcontent: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KaraokeChannelContent(::core::mem::transmute_copy(&lstream), ::core::mem::transmute_copy(&lchan)) {
                ::core::result::Result::Ok(ok__) => {
                    *lcontent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KaraokeChannelAssignment<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lstream: i32, lchannelassignment: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KaraokeChannelAssignment(::core::mem::transmute_copy(&lstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *lchannelassignment = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RestorePreferredSettings<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RestorePreferredSettings().into()
        }
        unsafe extern "system" fn ButtonRect<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lbutton: i32, prect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ButtonRect(::core::mem::transmute_copy(&lbutton)) {
                ::core::result::Result::Ok(ok__) => {
                    *prect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DVDScreenInMouseCoordinates<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprect: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DVDScreenInMouseCoordinates() {
                ::core::result::Result::Ok(ok__) => {
                    *pprect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDVDScreenInMouseCoordinates<Impl: IMSVidWebDVD_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prect: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDVDScreenInMouseCoordinates(::core::mem::transmute(&prect)).into()
        }
        Self {
            base: IMSVidPlayback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnDVDEvent: OnDVDEvent::<Impl, IMPL_OFFSET>,
            PlayTitle: PlayTitle::<Impl, IMPL_OFFSET>,
            PlayChapterInTitle: PlayChapterInTitle::<Impl, IMPL_OFFSET>,
            PlayChapter: PlayChapter::<Impl, IMPL_OFFSET>,
            PlayChaptersAutoStop: PlayChaptersAutoStop::<Impl, IMPL_OFFSET>,
            PlayAtTime: PlayAtTime::<Impl, IMPL_OFFSET>,
            PlayAtTimeInTitle: PlayAtTimeInTitle::<Impl, IMPL_OFFSET>,
            PlayPeriodInTitleAutoStop: PlayPeriodInTitleAutoStop::<Impl, IMPL_OFFSET>,
            ReplayChapter: ReplayChapter::<Impl, IMPL_OFFSET>,
            PlayPrevChapter: PlayPrevChapter::<Impl, IMPL_OFFSET>,
            PlayNextChapter: PlayNextChapter::<Impl, IMPL_OFFSET>,
            StillOff: StillOff::<Impl, IMPL_OFFSET>,
            AudioLanguage: AudioLanguage::<Impl, IMPL_OFFSET>,
            ShowMenu: ShowMenu::<Impl, IMPL_OFFSET>,
            Resume: Resume::<Impl, IMPL_OFFSET>,
            ReturnFromSubmenu: ReturnFromSubmenu::<Impl, IMPL_OFFSET>,
            ButtonsAvailable: ButtonsAvailable::<Impl, IMPL_OFFSET>,
            CurrentButton: CurrentButton::<Impl, IMPL_OFFSET>,
            SelectAndActivateButton: SelectAndActivateButton::<Impl, IMPL_OFFSET>,
            ActivateButton: ActivateButton::<Impl, IMPL_OFFSET>,
            SelectRightButton: SelectRightButton::<Impl, IMPL_OFFSET>,
            SelectLeftButton: SelectLeftButton::<Impl, IMPL_OFFSET>,
            SelectLowerButton: SelectLowerButton::<Impl, IMPL_OFFSET>,
            SelectUpperButton: SelectUpperButton::<Impl, IMPL_OFFSET>,
            ActivateAtPosition: ActivateAtPosition::<Impl, IMPL_OFFSET>,
            SelectAtPosition: SelectAtPosition::<Impl, IMPL_OFFSET>,
            ButtonAtPosition: ButtonAtPosition::<Impl, IMPL_OFFSET>,
            NumberOfChapters: NumberOfChapters::<Impl, IMPL_OFFSET>,
            TotalTitleTime: TotalTitleTime::<Impl, IMPL_OFFSET>,
            TitlesAvailable: TitlesAvailable::<Impl, IMPL_OFFSET>,
            VolumesAvailable: VolumesAvailable::<Impl, IMPL_OFFSET>,
            CurrentVolume: CurrentVolume::<Impl, IMPL_OFFSET>,
            CurrentDiscSide: CurrentDiscSide::<Impl, IMPL_OFFSET>,
            CurrentDomain: CurrentDomain::<Impl, IMPL_OFFSET>,
            CurrentChapter: CurrentChapter::<Impl, IMPL_OFFSET>,
            CurrentTitle: CurrentTitle::<Impl, IMPL_OFFSET>,
            CurrentTime: CurrentTime::<Impl, IMPL_OFFSET>,
            DVDTimeCode2bstr: DVDTimeCode2bstr::<Impl, IMPL_OFFSET>,
            DVDDirectory: DVDDirectory::<Impl, IMPL_OFFSET>,
            SetDVDDirectory: SetDVDDirectory::<Impl, IMPL_OFFSET>,
            IsSubpictureStreamEnabled: IsSubpictureStreamEnabled::<Impl, IMPL_OFFSET>,
            IsAudioStreamEnabled: IsAudioStreamEnabled::<Impl, IMPL_OFFSET>,
            CurrentSubpictureStream: CurrentSubpictureStream::<Impl, IMPL_OFFSET>,
            SetCurrentSubpictureStream: SetCurrentSubpictureStream::<Impl, IMPL_OFFSET>,
            SubpictureLanguage: SubpictureLanguage::<Impl, IMPL_OFFSET>,
            CurrentAudioStream: CurrentAudioStream::<Impl, IMPL_OFFSET>,
            SetCurrentAudioStream: SetCurrentAudioStream::<Impl, IMPL_OFFSET>,
            AudioStreamsAvailable: AudioStreamsAvailable::<Impl, IMPL_OFFSET>,
            AnglesAvailable: AnglesAvailable::<Impl, IMPL_OFFSET>,
            CurrentAngle: CurrentAngle::<Impl, IMPL_OFFSET>,
            SetCurrentAngle: SetCurrentAngle::<Impl, IMPL_OFFSET>,
            SubpictureStreamsAvailable: SubpictureStreamsAvailable::<Impl, IMPL_OFFSET>,
            SubpictureOn: SubpictureOn::<Impl, IMPL_OFFSET>,
            SetSubpictureOn: SetSubpictureOn::<Impl, IMPL_OFFSET>,
            DVDUniqueID: DVDUniqueID::<Impl, IMPL_OFFSET>,
            AcceptParentalLevelChange: AcceptParentalLevelChange::<Impl, IMPL_OFFSET>,
            NotifyParentalLevelChange: NotifyParentalLevelChange::<Impl, IMPL_OFFSET>,
            SelectParentalCountry: SelectParentalCountry::<Impl, IMPL_OFFSET>,
            SelectParentalLevel: SelectParentalLevel::<Impl, IMPL_OFFSET>,
            TitleParentalLevels: TitleParentalLevels::<Impl, IMPL_OFFSET>,
            PlayerParentalCountry: PlayerParentalCountry::<Impl, IMPL_OFFSET>,
            PlayerParentalLevel: PlayerParentalLevel::<Impl, IMPL_OFFSET>,
            Eject: Eject::<Impl, IMPL_OFFSET>,
            UOPValid: UOPValid::<Impl, IMPL_OFFSET>,
            SPRM: SPRM::<Impl, IMPL_OFFSET>,
            GPRM: GPRM::<Impl, IMPL_OFFSET>,
            SetGPRM: SetGPRM::<Impl, IMPL_OFFSET>,
            DVDTextStringType: DVDTextStringType::<Impl, IMPL_OFFSET>,
            DVDTextString: DVDTextString::<Impl, IMPL_OFFSET>,
            DVDTextNumberOfStrings: DVDTextNumberOfStrings::<Impl, IMPL_OFFSET>,
            DVDTextNumberOfLanguages: DVDTextNumberOfLanguages::<Impl, IMPL_OFFSET>,
            DVDTextLanguageLCID: DVDTextLanguageLCID::<Impl, IMPL_OFFSET>,
            RegionChange: RegionChange::<Impl, IMPL_OFFSET>,
            DVDAdm: DVDAdm::<Impl, IMPL_OFFSET>,
            DeleteBookmark: DeleteBookmark::<Impl, IMPL_OFFSET>,
            RestoreBookmark: RestoreBookmark::<Impl, IMPL_OFFSET>,
            SaveBookmark: SaveBookmark::<Impl, IMPL_OFFSET>,
            SelectDefaultAudioLanguage: SelectDefaultAudioLanguage::<Impl, IMPL_OFFSET>,
            SelectDefaultSubpictureLanguage: SelectDefaultSubpictureLanguage::<Impl, IMPL_OFFSET>,
            PreferredSubpictureStream: PreferredSubpictureStream::<Impl, IMPL_OFFSET>,
            DefaultMenuLanguage: DefaultMenuLanguage::<Impl, IMPL_OFFSET>,
            SetDefaultMenuLanguage: SetDefaultMenuLanguage::<Impl, IMPL_OFFSET>,
            DefaultSubpictureLanguage: DefaultSubpictureLanguage::<Impl, IMPL_OFFSET>,
            DefaultAudioLanguage: DefaultAudioLanguage::<Impl, IMPL_OFFSET>,
            DefaultSubpictureLanguageExt: DefaultSubpictureLanguageExt::<Impl, IMPL_OFFSET>,
            DefaultAudioLanguageExt: DefaultAudioLanguageExt::<Impl, IMPL_OFFSET>,
            LanguageFromLCID: LanguageFromLCID::<Impl, IMPL_OFFSET>,
            KaraokeAudioPresentationMode: KaraokeAudioPresentationMode::<Impl, IMPL_OFFSET>,
            SetKaraokeAudioPresentationMode: SetKaraokeAudioPresentationMode::<Impl, IMPL_OFFSET>,
            KaraokeChannelContent: KaraokeChannelContent::<Impl, IMPL_OFFSET>,
            KaraokeChannelAssignment: KaraokeChannelAssignment::<Impl, IMPL_OFFSET>,
            RestorePreferredSettings: RestorePreferredSettings::<Impl, IMPL_OFFSET>,
            ButtonRect: ButtonRect::<Impl, IMPL_OFFSET>,
            DVDScreenInMouseCoordinates: DVDScreenInMouseCoordinates::<Impl, IMPL_OFFSET>,
            SetDVDScreenInMouseCoordinates: SetDVDScreenInMouseCoordinates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidWebDVD as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidWebDVD2_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidInputDevice_Impl + IMSVidPlayback_Impl + IMSVidWebDVD_Impl {
    fn Bookmark(&mut self, ppdata: *mut *mut u8, pdatalength: *mut u32) -> ::windows::core::Result<()>;
    fn SetBookmark(&mut self, pdata: *const u8, dwdatalength: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidWebDVD2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidWebDVD2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidWebDVD2_Vtbl {
        unsafe extern "system" fn Bookmark<Impl: IMSVidWebDVD2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdata: *mut *mut u8, pdatalength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Bookmark(::core::mem::transmute_copy(&ppdata), ::core::mem::transmute_copy(&pdatalength)).into()
        }
        unsafe extern "system" fn SetBookmark<Impl: IMSVidWebDVD2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdata: *const u8, dwdatalength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBookmark(::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&dwdatalength)).into()
        }
        Self {
            base: IMSVidWebDVD_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Bookmark: Bookmark::<Impl, IMPL_OFFSET>,
            SetBookmark: SetBookmark::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidWebDVD2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidWebDVDAdm_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn ChangePassword(&mut self, strusername: &super::super::Foundation::BSTR, strold: &super::super::Foundation::BSTR, strnew: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SaveParentalLevel(&mut self, level: i32, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn SaveParentalCountry(&mut self, country: i32, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn ConfirmPassword(&mut self, strusername: &super::super::Foundation::BSTR, strpassword: &super::super::Foundation::BSTR) -> ::windows::core::Result<i16>;
    fn GetParentalLevel(&mut self) -> ::windows::core::Result<i32>;
    fn GetParentalCountry(&mut self) -> ::windows::core::Result<i32>;
    fn DefaultAudioLCID(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultAudioLCID(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn DefaultSubpictureLCID(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultSubpictureLCID(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn DefaultMenuLCID(&mut self) -> ::windows::core::Result<i32>;
    fn SetDefaultMenuLCID(&mut self, newval: i32) -> ::windows::core::Result<()>;
    fn BookmarkOnStop(&mut self) -> ::windows::core::Result<i16>;
    fn SetBookmarkOnStop(&mut self, newval: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidWebDVDAdm_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidWebDVDAdm_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidWebDVDAdm_Vtbl {
        unsafe extern "system" fn ChangePassword<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strold: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strnew: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangePassword(::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strold), ::core::mem::transmute_copy(&strnew)).into()
        }
        unsafe extern "system" fn SaveParentalLevel<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, level: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SaveParentalLevel(::core::mem::transmute_copy(&level), ::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)).into()
        }
        unsafe extern "system" fn SaveParentalCountry<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, country: i32, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SaveParentalCountry(::core::mem::transmute_copy(&country), ::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)).into()
        }
        unsafe extern "system" fn ConfirmPassword<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strusername: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, strpassword: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConfirmPassword(::core::mem::transmute_copy(&strusername), ::core::mem::transmute_copy(&strpassword)) {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalLevel<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llevel: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParentalLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *llevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParentalCountry<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcountry: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParentalCountry() {
                ::core::result::Result::Ok(ok__) => {
                    *lcountry = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultAudioLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultAudioLCID() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultAudioLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultAudioLCID(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn DefaultSubpictureLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultSubpictureLCID() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSubpictureLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSubpictureLCID(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn DefaultMenuLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultMenuLCID() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMenuLCID<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultMenuLCID(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn BookmarkOnStop<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pval: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BookmarkOnStop() {
                ::core::result::Result::Ok(ok__) => {
                    *pval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBookmarkOnStop<Impl: IMSVidWebDVDAdm_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBookmarkOnStop(::core::mem::transmute_copy(&newval)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ChangePassword: ChangePassword::<Impl, IMPL_OFFSET>,
            SaveParentalLevel: SaveParentalLevel::<Impl, IMPL_OFFSET>,
            SaveParentalCountry: SaveParentalCountry::<Impl, IMPL_OFFSET>,
            ConfirmPassword: ConfirmPassword::<Impl, IMPL_OFFSET>,
            GetParentalLevel: GetParentalLevel::<Impl, IMPL_OFFSET>,
            GetParentalCountry: GetParentalCountry::<Impl, IMPL_OFFSET>,
            DefaultAudioLCID: DefaultAudioLCID::<Impl, IMPL_OFFSET>,
            SetDefaultAudioLCID: SetDefaultAudioLCID::<Impl, IMPL_OFFSET>,
            DefaultSubpictureLCID: DefaultSubpictureLCID::<Impl, IMPL_OFFSET>,
            SetDefaultSubpictureLCID: SetDefaultSubpictureLCID::<Impl, IMPL_OFFSET>,
            DefaultMenuLCID: DefaultMenuLCID::<Impl, IMPL_OFFSET>,
            SetDefaultMenuLCID: SetDefaultMenuLCID::<Impl, IMPL_OFFSET>,
            BookmarkOnStop: BookmarkOnStop::<Impl, IMPL_OFFSET>,
            SetBookmarkOnStop: SetBookmarkOnStop::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidWebDVDAdm as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidWebDVDEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidInputDeviceEvent_Impl + IMSVidPlaybackEvent_Impl {
    fn DVDNotify(&mut self, leventcode: i32, lparam1: &super::super::System::Com::VARIANT, lparam2: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn PlayForwards(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayBackwards(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ShowMenu(&mut self, menuid: DVDMenuIDConstants, benabled: i16) -> ::windows::core::Result<()>;
    fn Resume(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn SelectOrActivateButton(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn StillOff(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PauseOn(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ChangeCurrentAudioStream(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ChangeCurrentSubpictureStream(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ChangeCurrentAngle(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayAtTimeInTitle(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayAtTime(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayChapterInTitle(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayChapter(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ReplayChapter(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayNextChapter(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn Stop(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ReturnFromSubmenu(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayTitle(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn PlayPrevChapter(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ChangeKaraokePresMode(&mut self, benabled: i16) -> ::windows::core::Result<()>;
    fn ChangeVideoPresMode(&mut self, benabled: i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidWebDVDEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidWebDVDEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidWebDVDEvent_Vtbl {
        unsafe extern "system" fn DVDNotify<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leventcode: i32, lparam1: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, lparam2: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DVDNotify(::core::mem::transmute_copy(&leventcode), ::core::mem::transmute_copy(&lparam1), ::core::mem::transmute_copy(&lparam2)).into()
        }
        unsafe extern "system" fn PlayForwards<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayForwards(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayBackwards<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayBackwards(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ShowMenu<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, menuid: DVDMenuIDConstants, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShowMenu(::core::mem::transmute_copy(&menuid), ::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn Resume<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Resume(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn SelectOrActivateButton<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectOrActivateButton(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn StillOff<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StillOff(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PauseOn<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PauseOn(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ChangeCurrentAudioStream<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeCurrentAudioStream(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ChangeCurrentSubpictureStream<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeCurrentSubpictureStream(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ChangeCurrentAngle<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeCurrentAngle(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTimeInTitle(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayAtTime<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayAtTime(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayChapterInTitle<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayChapterInTitle(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayChapter<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayChapter(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ReplayChapter<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReplayChapter(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayNextChapter<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayNextChapter(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ReturnFromSubmenu<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReturnFromSubmenu(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayTitle<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayTitle(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn PlayPrevChapter<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlayPrevChapter(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ChangeKaraokePresMode<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeKaraokePresMode(::core::mem::transmute_copy(&benabled)).into()
        }
        unsafe extern "system" fn ChangeVideoPresMode<Impl: IMSVidWebDVDEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, benabled: i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeVideoPresMode(::core::mem::transmute_copy(&benabled)).into()
        }
        Self {
            base: IMSVidPlaybackEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            DVDNotify: DVDNotify::<Impl, IMPL_OFFSET>,
            PlayForwards: PlayForwards::<Impl, IMPL_OFFSET>,
            PlayBackwards: PlayBackwards::<Impl, IMPL_OFFSET>,
            ShowMenu: ShowMenu::<Impl, IMPL_OFFSET>,
            Resume: Resume::<Impl, IMPL_OFFSET>,
            SelectOrActivateButton: SelectOrActivateButton::<Impl, IMPL_OFFSET>,
            StillOff: StillOff::<Impl, IMPL_OFFSET>,
            PauseOn: PauseOn::<Impl, IMPL_OFFSET>,
            ChangeCurrentAudioStream: ChangeCurrentAudioStream::<Impl, IMPL_OFFSET>,
            ChangeCurrentSubpictureStream: ChangeCurrentSubpictureStream::<Impl, IMPL_OFFSET>,
            ChangeCurrentAngle: ChangeCurrentAngle::<Impl, IMPL_OFFSET>,
            PlayAtTimeInTitle: PlayAtTimeInTitle::<Impl, IMPL_OFFSET>,
            PlayAtTime: PlayAtTime::<Impl, IMPL_OFFSET>,
            PlayChapterInTitle: PlayChapterInTitle::<Impl, IMPL_OFFSET>,
            PlayChapter: PlayChapter::<Impl, IMPL_OFFSET>,
            ReplayChapter: ReplayChapter::<Impl, IMPL_OFFSET>,
            PlayNextChapter: PlayNextChapter::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            ReturnFromSubmenu: ReturnFromSubmenu::<Impl, IMPL_OFFSET>,
            PlayTitle: PlayTitle::<Impl, IMPL_OFFSET>,
            PlayPrevChapter: PlayPrevChapter::<Impl, IMPL_OFFSET>,
            ChangeKaraokePresMode: ChangeKaraokePresMode::<Impl, IMPL_OFFSET>,
            ChangeVideoPresMode: ChangeVideoPresMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidWebDVDEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidXDS_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDevice_Impl + IMSVidFeature_Impl {
    fn ChannelChangeInterface(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidXDS_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidXDS_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidXDS_Vtbl {
        unsafe extern "system" fn ChannelChangeInterface<Impl: IMSVidXDS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkcc: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ChannelChangeInterface() {
                ::core::result::Result::Ok(ok__) => {
                    *punkcc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IMSVidFeature_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), ChannelChangeInterface: ChannelChangeInterface::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidXDS as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMSVidXDSEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMSVidDeviceEvent_Impl + IMSVidFeatureEvent_Impl {
    fn RatingChange(&mut self, prevratingsystem: EnTvRat_System, prevlevel: EnTvRat_GenericLevel, prevattributes: BfEnTvRat_GenericAttributes, newratingsystem: EnTvRat_System, newlevel: EnTvRat_GenericLevel, newattributes: BfEnTvRat_GenericAttributes) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMSVidXDSEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMSVidXDSEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMSVidXDSEvent_Vtbl {
        unsafe extern "system" fn RatingChange<Impl: IMSVidXDSEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prevratingsystem: EnTvRat_System, prevlevel: EnTvRat_GenericLevel, prevattributes: BfEnTvRat_GenericAttributes, newratingsystem: EnTvRat_System, newlevel: EnTvRat_GenericLevel, newattributes: BfEnTvRat_GenericAttributes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RatingChange(::core::mem::transmute_copy(&prevratingsystem), ::core::mem::transmute_copy(&prevlevel), ::core::mem::transmute_copy(&prevattributes), ::core::mem::transmute_copy(&newratingsystem), ::core::mem::transmute_copy(&newlevel), ::core::mem::transmute_copy(&newattributes)).into()
        }
        Self { base: IMSVidFeatureEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), RatingChange: RatingChange::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMSVidXDSEvent as ::windows::core::Interface>::IID
    }
}
pub trait IMceBurnerControl_Impl: Sized {
    fn GetBurnerNoDecryption(&mut self) -> ::windows::core::Result<()>;
}
impl IMceBurnerControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMceBurnerControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMceBurnerControl_Vtbl {
        unsafe extern "system" fn GetBurnerNoDecryption<Impl: IMceBurnerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBurnerNoDecryption().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetBurnerNoDecryption: GetBurnerNoDecryption::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMceBurnerControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMediaControl_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Run(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn GetState(&mut self, mstimeout: i32) -> ::windows::core::Result<i32>;
    fn RenderFile(&mut self, strfilename: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn AddSourceFilter(&mut self, strfilename: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn FilterCollection(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn RegFilterCollection(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn StopWhenReady(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMediaControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaControl_Vtbl {
        unsafe extern "system" fn Run<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Run().into()
        }
        unsafe extern "system" fn Pause<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Stop<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn GetState<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mstimeout: i32, pfs: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&mstimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RenderFile<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenderFile(::core::mem::transmute_copy(&strfilename)).into()
        }
        unsafe extern "system" fn AddSourceFilter<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strfilename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddSourceFilter(::core::mem::transmute_copy(&strfilename)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FilterCollection<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FilterCollection() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegFilterCollection<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RegFilterCollection() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopWhenReady<Impl: IMediaControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopWhenReady().into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Run: Run::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            RenderFile: RenderFile::<Impl, IMPL_OFFSET>,
            AddSourceFilter: AddSourceFilter::<Impl, IMPL_OFFSET>,
            FilterCollection: FilterCollection::<Impl, IMPL_OFFSET>,
            RegFilterCollection: RegFilterCollection::<Impl, IMPL_OFFSET>,
            StopWhenReady: StopWhenReady::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMediaEvent_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn GetEventHandle(&mut self) -> ::windows::core::Result<isize>;
    fn GetEvent(&mut self, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> ::windows::core::Result<()>;
    fn WaitForCompletion(&mut self, mstimeout: i32) -> ::windows::core::Result<i32>;
    fn CancelDefaultHandling(&mut self, levcode: i32) -> ::windows::core::Result<()>;
    fn RestoreDefaultHandling(&mut self, levcode: i32) -> ::windows::core::Result<()>;
    fn FreeEventParams(&mut self, levcode: i32, lparam1: isize, lparam2: isize) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMediaEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaEvent_Vtbl {
        unsafe extern "system" fn GetEventHandle<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hevent: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEventHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *hevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEvent<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEvent(::core::mem::transmute_copy(&leventcode), ::core::mem::transmute_copy(&lparam1), ::core::mem::transmute_copy(&lparam2), ::core::mem::transmute_copy(&mstimeout)).into()
        }
        unsafe extern "system" fn WaitForCompletion<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mstimeout: i32, pevcode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WaitForCompletion(::core::mem::transmute_copy(&mstimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *pevcode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelDefaultHandling<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, levcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelDefaultHandling(::core::mem::transmute_copy(&levcode)).into()
        }
        unsafe extern "system" fn RestoreDefaultHandling<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, levcode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RestoreDefaultHandling(::core::mem::transmute_copy(&levcode)).into()
        }
        unsafe extern "system" fn FreeEventParams<Impl: IMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, levcode: i32, lparam1: isize, lparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FreeEventParams(::core::mem::transmute_copy(&levcode), ::core::mem::transmute_copy(&lparam1), ::core::mem::transmute_copy(&lparam2)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetEventHandle: GetEventHandle::<Impl, IMPL_OFFSET>,
            GetEvent: GetEvent::<Impl, IMPL_OFFSET>,
            WaitForCompletion: WaitForCompletion::<Impl, IMPL_OFFSET>,
            CancelDefaultHandling: CancelDefaultHandling::<Impl, IMPL_OFFSET>,
            RestoreDefaultHandling: RestoreDefaultHandling::<Impl, IMPL_OFFSET>,
            FreeEventParams: FreeEventParams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMediaEventEx_Impl: Sized + super::super::System::Com::IDispatch_Impl + IMediaEvent_Impl {
    fn SetNotifyWindow(&mut self, hwnd: isize, lmsg: i32, linstancedata: isize) -> ::windows::core::Result<()>;
    fn SetNotifyFlags(&mut self, lnonotifyflags: i32) -> ::windows::core::Result<()>;
    fn GetNotifyFlags(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMediaEventEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaEventEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaEventEx_Vtbl {
        unsafe extern "system" fn SetNotifyWindow<Impl: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: isize, lmsg: i32, linstancedata: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNotifyWindow(::core::mem::transmute_copy(&hwnd), ::core::mem::transmute_copy(&lmsg), ::core::mem::transmute_copy(&linstancedata)).into()
        }
        unsafe extern "system" fn SetNotifyFlags<Impl: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lnonotifyflags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNotifyFlags(::core::mem::transmute_copy(&lnonotifyflags)).into()
        }
        unsafe extern "system" fn GetNotifyFlags<Impl: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplnonotifyflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNotifyFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *lplnonotifyflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMediaEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetNotifyWindow: SetNotifyWindow::<Impl, IMPL_OFFSET>,
            SetNotifyFlags: SetNotifyFlags::<Impl, IMPL_OFFSET>,
            GetNotifyFlags: GetNotifyFlags::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaEventEx as ::windows::core::Interface>::IID
    }
}
pub trait IMediaEventSink_Impl: Sized {
    fn Notify(&mut self, eventcode: i32, eventparam1: isize, eventparam2: isize) -> ::windows::core::Result<()>;
}
impl IMediaEventSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaEventSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaEventSink_Vtbl {
        unsafe extern "system" fn Notify<Impl: IMediaEventSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eventcode: i32, eventparam1: isize, eventparam2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Notify(::core::mem::transmute_copy(&eventcode), ::core::mem::transmute_copy(&eventparam1), ::core::mem::transmute_copy(&eventparam2)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Notify: Notify::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaEventSink as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaFilter_Impl: Sized + super::super::System::Com::IPersist_Impl {
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Run(&mut self, tstart: i64) -> ::windows::core::Result<()>;
    fn GetState(&mut self, dwmillisecstimeout: u32) -> ::windows::core::Result<FILTER_STATE>;
    fn SetSyncSource(&mut self, pclock: &::core::option::Option<super::IReferenceClock>) -> ::windows::core::Result<()>;
    fn GetSyncSource(&mut self) -> ::windows::core::Result<super::IReferenceClock>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaFilter_Vtbl {
        unsafe extern "system" fn Stop<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Pause<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Run<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tstart: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Run(::core::mem::transmute_copy(&tstart)).into()
        }
        unsafe extern "system" fn GetState<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmillisecstimeout: u32, state: *mut FILTER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&dwmillisecstimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *state = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncSource<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncSource(::core::mem::transmute(&pclock)).into()
        }
        unsafe extern "system" fn GetSyncSource<Impl: IMediaFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSyncSource() {
                ::core::result::Result::Ok(ok__) => {
                    *pclock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IPersist_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Run: Run::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            SetSyncSource: SetSyncSource::<Impl, IMPL_OFFSET>,
            GetSyncSource: GetSyncSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaFilter as ::windows::core::Interface>::IID
    }
}
pub trait IMediaParamInfo_Impl: Sized {
    fn GetParamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetParamInfo(&mut self, dwparamindex: u32) -> ::windows::core::Result<MP_PARAMINFO>;
    fn GetParamText(&mut self, dwparamindex: u32) -> ::windows::core::Result<*mut u16>;
    fn GetNumTimeFormats(&mut self) -> ::windows::core::Result<u32>;
    fn GetSupportedTimeFormat(&mut self, dwformatindex: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetCurrentTimeFormat(&mut self, pguidtimeformat: *mut ::windows::core::GUID, ptimedata: *mut u32) -> ::windows::core::Result<()>;
}
impl IMediaParamInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaParamInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaParamInfo_Vtbl {
        unsafe extern "system" fn GetParamCount<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwparams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwparams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParamInfo<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, pinfo: *mut MP_PARAMINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParamInfo(::core::mem::transmute_copy(&dwparamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParamText<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, ppwchtext: *mut *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParamText(::core::mem::transmute_copy(&dwparamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppwchtext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumTimeFormats<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumtimeformats: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumTimeFormats() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumtimeformats = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedTimeFormat<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwformatindex: u32, pguidtimeformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSupportedTimeFormat(::core::mem::transmute_copy(&dwformatindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pguidtimeformat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentTimeFormat<Impl: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *mut ::windows::core::GUID, ptimedata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentTimeFormat(::core::mem::transmute_copy(&pguidtimeformat), ::core::mem::transmute_copy(&ptimedata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetParamCount: GetParamCount::<Impl, IMPL_OFFSET>,
            GetParamInfo: GetParamInfo::<Impl, IMPL_OFFSET>,
            GetParamText: GetParamText::<Impl, IMPL_OFFSET>,
            GetNumTimeFormats: GetNumTimeFormats::<Impl, IMPL_OFFSET>,
            GetSupportedTimeFormat: GetSupportedTimeFormat::<Impl, IMPL_OFFSET>,
            GetCurrentTimeFormat: GetCurrentTimeFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaParamInfo as ::windows::core::Interface>::IID
    }
}
pub trait IMediaParams_Impl: Sized {
    fn GetParam(&mut self, dwparamindex: u32) -> ::windows::core::Result<f32>;
    fn SetParam(&mut self, dwparamindex: u32, value: f32) -> ::windows::core::Result<()>;
    fn AddEnvelope(&mut self, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> ::windows::core::Result<()>;
    fn FlushEnvelope(&mut self, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> ::windows::core::Result<()>;
    fn SetTimeFormat(&mut self, guidtimeformat: &::windows::core::GUID, mptimedata: u32) -> ::windows::core::Result<()>;
}
impl IMediaParams_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaParams_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaParams_Vtbl {
        unsafe extern "system" fn GetParam<Impl: IMediaParams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, pvalue: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetParam(::core::mem::transmute_copy(&dwparamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetParam<Impl: IMediaParams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetParam(::core::mem::transmute_copy(&dwparamindex), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn AddEnvelope<Impl: IMediaParams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEnvelope(::core::mem::transmute_copy(&dwparamindex), ::core::mem::transmute_copy(&csegments), ::core::mem::transmute_copy(&penvelopesegments)).into()
        }
        unsafe extern "system" fn FlushEnvelope<Impl: IMediaParams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FlushEnvelope(::core::mem::transmute_copy(&dwparamindex), ::core::mem::transmute_copy(&reftimestart), ::core::mem::transmute_copy(&reftimeend)).into()
        }
        unsafe extern "system" fn SetTimeFormat<Impl: IMediaParams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidtimeformat: ::windows::core::GUID, mptimedata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimeFormat(::core::mem::transmute_copy(&guidtimeformat), ::core::mem::transmute_copy(&mptimedata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetParam: GetParam::<Impl, IMPL_OFFSET>,
            SetParam: SetParam::<Impl, IMPL_OFFSET>,
            AddEnvelope: AddEnvelope::<Impl, IMPL_OFFSET>,
            FlushEnvelope: FlushEnvelope::<Impl, IMPL_OFFSET>,
            SetTimeFormat: SetTimeFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaParams as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMediaPosition_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Duration(&mut self) -> ::windows::core::Result<f64>;
    fn SetCurrentPosition(&mut self, lltime: f64) -> ::windows::core::Result<()>;
    fn CurrentPosition(&mut self) -> ::windows::core::Result<f64>;
    fn StopTime(&mut self) -> ::windows::core::Result<f64>;
    fn SetStopTime(&mut self, lltime: f64) -> ::windows::core::Result<()>;
    fn PrerollTime(&mut self) -> ::windows::core::Result<f64>;
    fn SetPrerollTime(&mut self, lltime: f64) -> ::windows::core::Result<()>;
    fn SetRate(&mut self, drate: f64) -> ::windows::core::Result<()>;
    fn Rate(&mut self) -> ::windows::core::Result<f64>;
    fn CanSeekForward(&mut self) -> ::windows::core::Result<i32>;
    fn CanSeekBackward(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMediaPosition_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPosition_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPosition_Vtbl {
        unsafe extern "system" fn Duration<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plength: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Duration() {
                ::core::result::Result::Ok(ok__) => {
                    *plength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPosition(::core::mem::transmute_copy(&lltime)).into()
        }
        unsafe extern "system" fn CurrentPosition<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CurrentPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *plltime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopTime<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).StopTime() {
                ::core::result::Result::Ok(ok__) => {
                    *plltime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopTime<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStopTime(::core::mem::transmute_copy(&lltime)).into()
        }
        unsafe extern "system" fn PrerollTime<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plltime: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PrerollTime() {
                ::core::result::Result::Ok(ok__) => {
                    *plltime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrerollTime<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lltime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPrerollTime(::core::mem::transmute_copy(&lltime)).into()
        }
        unsafe extern "system" fn SetRate<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&drate)).into()
        }
        unsafe extern "system" fn Rate<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Rate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekForward<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcanseekforward: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeekForward() {
                ::core::result::Result::Ok(ok__) => {
                    *pcanseekforward = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekBackward<Impl: IMediaPosition_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcanseekbackward: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanSeekBackward() {
                ::core::result::Result::Ok(ok__) => {
                    *pcanseekbackward = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Duration: Duration::<Impl, IMPL_OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Impl, IMPL_OFFSET>,
            CurrentPosition: CurrentPosition::<Impl, IMPL_OFFSET>,
            StopTime: StopTime::<Impl, IMPL_OFFSET>,
            SetStopTime: SetStopTime::<Impl, IMPL_OFFSET>,
            PrerollTime: PrerollTime::<Impl, IMPL_OFFSET>,
            SetPrerollTime: SetPrerollTime::<Impl, IMPL_OFFSET>,
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            Rate: Rate::<Impl, IMPL_OFFSET>,
            CanSeekForward: CanSeekForward::<Impl, IMPL_OFFSET>,
            CanSeekBackward: CanSeekBackward::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPosition as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
pub trait IMediaPropertyBag_Impl: Sized + super::super::System::Com::StructuredStorage::IPropertyBag_Impl {
    fn EnumProperty(&mut self, iproperty: u32, pvarpropertyname: *mut super::super::System::Com::VARIANT, pvarpropertyvalue: *mut super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
impl IMediaPropertyBag_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaPropertyBag_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaPropertyBag_Vtbl {
        unsafe extern "system" fn EnumProperty<Impl: IMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, iproperty: u32, pvarpropertyname: *mut super::super::System::Com::VARIANT, pvarpropertyvalue: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnumProperty(::core::mem::transmute_copy(&iproperty), ::core::mem::transmute_copy(&pvarpropertyname), ::core::mem::transmute_copy(&pvarpropertyvalue)).into()
        }
        Self {
            base: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            EnumProperty: EnumProperty::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaPropertyBag as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMediaSample_Impl: Sized {
    fn GetPointer(&mut self) -> ::windows::core::Result<*mut u8>;
    fn GetSize(&mut self) -> i32;
    fn GetTime(&mut self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn SetTime(&mut self, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::Result<()>;
    fn IsSyncPoint(&mut self) -> ::windows::core::Result<()>;
    fn SetSyncPoint(&mut self, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn IsPreroll(&mut self) -> ::windows::core::Result<()>;
    fn SetPreroll(&mut self, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetActualDataLength(&mut self) -> i32;
    fn SetActualDataLength(&mut self, __midl__imediasample0000: i32) -> ::windows::core::Result<()>;
    fn GetMediaType(&mut self) -> ::windows::core::Result<*mut AM_MEDIA_TYPE>;
    fn SetMediaType(&mut self, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn IsDiscontinuity(&mut self) -> ::windows::core::Result<()>;
    fn SetDiscontinuity(&mut self, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetMediaTime(&mut self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn SetMediaTime(&mut self, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMediaSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaSample_Vtbl {
        unsafe extern "system" fn GetPointer<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSize<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSize()
        }
        unsafe extern "system" fn GetTime<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn SetTime<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn IsSyncPoint<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSyncPoint().into()
        }
        unsafe extern "system" fn SetSyncPoint<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bissyncpoint: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncPoint(::core::mem::transmute_copy(&bissyncpoint)).into()
        }
        unsafe extern "system" fn IsPreroll<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsPreroll().into()
        }
        unsafe extern "system" fn SetPreroll<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bispreroll: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreroll(::core::mem::transmute_copy(&bispreroll)).into()
        }
        unsafe extern "system" fn GetActualDataLength<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> i32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetActualDataLength()
        }
        unsafe extern "system" fn SetActualDataLength<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__imediasample0000: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetActualDataLength(::core::mem::transmute_copy(&__midl__imediasample0000)).into()
        }
        unsafe extern "system" fn GetMediaType<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute_copy(&pmediatype)).into()
        }
        unsafe extern "system" fn IsDiscontinuity<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsDiscontinuity().into()
        }
        unsafe extern "system" fn SetDiscontinuity<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bdiscontinuity: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDiscontinuity(::core::mem::transmute_copy(&bdiscontinuity)).into()
        }
        unsafe extern "system" fn GetMediaTime<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn SetMediaTime<Impl: IMediaSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaTime(::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPointer: GetPointer::<Impl, IMPL_OFFSET>,
            GetSize: GetSize::<Impl, IMPL_OFFSET>,
            GetTime: GetTime::<Impl, IMPL_OFFSET>,
            SetTime: SetTime::<Impl, IMPL_OFFSET>,
            IsSyncPoint: IsSyncPoint::<Impl, IMPL_OFFSET>,
            SetSyncPoint: SetSyncPoint::<Impl, IMPL_OFFSET>,
            IsPreroll: IsPreroll::<Impl, IMPL_OFFSET>,
            SetPreroll: SetPreroll::<Impl, IMPL_OFFSET>,
            GetActualDataLength: GetActualDataLength::<Impl, IMPL_OFFSET>,
            SetActualDataLength: SetActualDataLength::<Impl, IMPL_OFFSET>,
            GetMediaType: GetMediaType::<Impl, IMPL_OFFSET>,
            SetMediaType: SetMediaType::<Impl, IMPL_OFFSET>,
            IsDiscontinuity: IsDiscontinuity::<Impl, IMPL_OFFSET>,
            SetDiscontinuity: SetDiscontinuity::<Impl, IMPL_OFFSET>,
            GetMediaTime: GetMediaTime::<Impl, IMPL_OFFSET>,
            SetMediaTime: SetMediaTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaSample as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMediaSample2_Impl: Sized + IMediaSample_Impl {
    fn GetProperties(&mut self, cbproperties: u32) -> ::windows::core::Result<u8>;
    fn SetProperties(&mut self, cbproperties: u32, pbproperties: *const u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMediaSample2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaSample2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaSample2_Vtbl {
        unsafe extern "system" fn GetProperties<Impl: IMediaSample2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbproperties: u32, pbproperties: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProperties(::core::mem::transmute_copy(&cbproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbproperties = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProperties<Impl: IMediaSample2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbproperties: u32, pbproperties: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProperties(::core::mem::transmute_copy(&cbproperties), ::core::mem::transmute_copy(&pbproperties)).into()
        }
        Self {
            base: IMediaSample_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetProperties: GetProperties::<Impl, IMPL_OFFSET>,
            SetProperties: SetProperties::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaSample2 as ::windows::core::Interface>::IID
    }
}
pub trait IMediaSample2Config_Impl: Sized {
    fn GetSurface(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IMediaSample2Config_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaSample2Config_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaSample2Config_Vtbl {
        unsafe extern "system" fn GetSurface<Impl: IMediaSample2Config_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirect3dsurface9: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdirect3dsurface9 = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetSurface: GetSurface::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaSample2Config as ::windows::core::Interface>::IID
    }
}
pub trait IMediaSeeking_Impl: Sized {
    fn GetCapabilities(&mut self) -> ::windows::core::Result<u32>;
    fn CheckCapabilities(&mut self, pcapabilities: *mut u32) -> ::windows::core::Result<()>;
    fn IsFormatSupported(&mut self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn QueryPreferredFormat(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetTimeFormat(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn IsUsingTimeFormat(&mut self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetTimeFormat(&mut self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDuration(&mut self) -> ::windows::core::Result<i64>;
    fn GetStopPosition(&mut self) -> ::windows::core::Result<i64>;
    fn GetCurrentPosition(&mut self) -> ::windows::core::Result<i64>;
    fn ConvertTimeFormat(&mut self, ptarget: *mut i64, ptargetformat: *const ::windows::core::GUID, source: i64, psourceformat: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetPositions(&mut self, pcurrent: *mut i64, dwcurrentflags: u32, pstop: *mut i64, dwstopflags: u32) -> ::windows::core::Result<()>;
    fn GetPositions(&mut self, pcurrent: *mut i64, pstop: *mut i64) -> ::windows::core::Result<()>;
    fn GetAvailable(&mut self, pearliest: *mut i64, platest: *mut i64) -> ::windows::core::Result<()>;
    fn SetRate(&mut self, drate: f64) -> ::windows::core::Result<()>;
    fn GetRate(&mut self) -> ::windows::core::Result<f64>;
    fn GetPreroll(&mut self) -> ::windows::core::Result<i64>;
}
impl IMediaSeeking_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaSeeking_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaSeeking_Vtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *pcapabilities = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CheckCapabilities<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CheckCapabilities(::core::mem::transmute_copy(&pcapabilities)).into()
        }
        unsafe extern "system" fn IsFormatSupported<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsFormatSupported(::core::mem::transmute_copy(&pformat)).into()
        }
        unsafe extern "system" fn QueryPreferredFormat<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryPreferredFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pformat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeFormat<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pformat: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimeFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pformat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsUsingTimeFormat<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsUsingTimeFormat(::core::mem::transmute_copy(&pformat)).into()
        }
        unsafe extern "system" fn SetTimeFormat<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimeFormat(::core::mem::transmute_copy(&pformat)).into()
        }
        unsafe extern "system" fn GetDuration<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *pduration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStopPosition<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstop: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStopPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *pstop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *pcurrent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertTimeFormat<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptarget: *mut i64, ptargetformat: *const ::windows::core::GUID, source: i64, psourceformat: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertTimeFormat(::core::mem::transmute_copy(&ptarget), ::core::mem::transmute_copy(&ptargetformat), ::core::mem::transmute_copy(&source), ::core::mem::transmute_copy(&psourceformat)).into()
        }
        unsafe extern "system" fn SetPositions<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64, dwcurrentflags: u32, pstop: *mut i64, dwstopflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPositions(::core::mem::transmute_copy(&pcurrent), ::core::mem::transmute_copy(&dwcurrentflags), ::core::mem::transmute_copy(&pstop), ::core::mem::transmute_copy(&dwstopflags)).into()
        }
        unsafe extern "system" fn GetPositions<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrent: *mut i64, pstop: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPositions(::core::mem::transmute_copy(&pcurrent), ::core::mem::transmute_copy(&pstop)).into()
        }
        unsafe extern "system" fn GetAvailable<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pearliest: *mut i64, platest: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAvailable(::core::mem::transmute_copy(&pearliest), ::core::mem::transmute_copy(&platest)).into()
        }
        unsafe extern "system" fn SetRate<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&drate)).into()
        }
        unsafe extern "system" fn GetRate<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdrate: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pdrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreroll<Impl: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pllpreroll: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPreroll() {
                ::core::result::Result::Ok(ok__) => {
                    *pllpreroll = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCapabilities: GetCapabilities::<Impl, IMPL_OFFSET>,
            CheckCapabilities: CheckCapabilities::<Impl, IMPL_OFFSET>,
            IsFormatSupported: IsFormatSupported::<Impl, IMPL_OFFSET>,
            QueryPreferredFormat: QueryPreferredFormat::<Impl, IMPL_OFFSET>,
            GetTimeFormat: GetTimeFormat::<Impl, IMPL_OFFSET>,
            IsUsingTimeFormat: IsUsingTimeFormat::<Impl, IMPL_OFFSET>,
            SetTimeFormat: SetTimeFormat::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            GetStopPosition: GetStopPosition::<Impl, IMPL_OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Impl, IMPL_OFFSET>,
            ConvertTimeFormat: ConvertTimeFormat::<Impl, IMPL_OFFSET>,
            SetPositions: SetPositions::<Impl, IMPL_OFFSET>,
            GetPositions: GetPositions::<Impl, IMPL_OFFSET>,
            GetAvailable: GetAvailable::<Impl, IMPL_OFFSET>,
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            GetRate: GetRate::<Impl, IMPL_OFFSET>,
            GetPreroll: GetPreroll::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaSeeking as ::windows::core::Interface>::IID
    }
}
pub trait IMediaStream_Impl: Sized {
    fn GetMultiMediaStream(&mut self) -> ::windows::core::Result<IMultiMediaStream>;
    fn GetInformation(&mut self, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::Result<()>;
    fn SetSameFormat(&mut self, pstreamthathasdesiredformat: &::core::option::Option<IMediaStream>, dwflags: u32) -> ::windows::core::Result<()>;
    fn AllocateSample(&mut self, dwflags: u32) -> ::windows::core::Result<IStreamSample>;
    fn CreateSharedSample(&mut self, pexistingsample: &::core::option::Option<IStreamSample>, dwflags: u32) -> ::windows::core::Result<IStreamSample>;
    fn SendEndOfStream(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
}
impl IMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaStream_Vtbl {
        unsafe extern "system" fn GetMultiMediaStream<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmultimediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMultiMediaStream() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmultimediastream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInformation<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInformation(::core::mem::transmute_copy(&ppurposeid), ::core::mem::transmute_copy(&ptype)).into()
        }
        unsafe extern "system" fn SetSameFormat<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstreamthathasdesiredformat: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSameFormat(::core::mem::transmute(&pstreamthathasdesiredformat), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn AllocateSample<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllocateSample(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSharedSample<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pexistingsample: ::windows::core::RawPtr, dwflags: u32, ppnewsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSharedSample(::core::mem::transmute(&pexistingsample), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnewsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendEndOfStream<Impl: IMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SendEndOfStream(::core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMultiMediaStream: GetMultiMediaStream::<Impl, IMPL_OFFSET>,
            GetInformation: GetInformation::<Impl, IMPL_OFFSET>,
            SetSameFormat: SetSameFormat::<Impl, IMPL_OFFSET>,
            AllocateSample: AllocateSample::<Impl, IMPL_OFFSET>,
            CreateSharedSample: CreateSharedSample::<Impl, IMPL_OFFSET>,
            SendEndOfStream: SendEndOfStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IMediaStreamFilter_Impl: Sized + super::super::System::Com::IPersist_Impl + IMediaFilter_Impl + IBaseFilter_Impl {
    fn AddMediaStream(&mut self, pammediastream: &::core::option::Option<IAMMediaStream>) -> ::windows::core::Result<()>;
    fn GetMediaStream(&mut self, idpurpose: *const ::windows::core::GUID) -> ::windows::core::Result<IMediaStream>;
    fn EnumMediaStreams(&mut self, index: i32) -> ::windows::core::Result<IMediaStream>;
    fn SupportSeeking(&mut self, brenderer: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn ReferenceTimeToStreamTime(&mut self) -> ::windows::core::Result<i64>;
    fn GetCurrentStreamTime(&mut self) -> ::windows::core::Result<i64>;
    fn WaitUntil(&mut self, waitstreamtime: i64) -> ::windows::core::Result<()>;
    fn Flush(&mut self, bcanceleos: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn EndOfStream(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IMediaStreamFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaStreamFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaStreamFilter_Vtbl {
        unsafe extern "system" fn AddMediaStream<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pammediastream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddMediaStream(::core::mem::transmute(&pammediastream)).into()
        }
        unsafe extern "system" fn GetMediaStream<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idpurpose: *const ::windows::core::GUID, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaStream(::core::mem::transmute_copy(&idpurpose)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediastream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumMediaStreams(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediastream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportSeeking<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brenderer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupportSeeking(::core::mem::transmute_copy(&brenderer)).into()
        }
        unsafe extern "system" fn ReferenceTimeToStreamTime<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReferenceTimeToStreamTime() {
                ::core::result::Result::Ok(ok__) => {
                    *ptime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentStreamTime<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrentstreamtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentStreamTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pcurrentstreamtime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WaitUntil<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, waitstreamtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitUntil(::core::mem::transmute_copy(&waitstreamtime)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bcanceleos: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush(::core::mem::transmute_copy(&bcanceleos)).into()
        }
        unsafe extern "system" fn EndOfStream<Impl: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndOfStream().into()
        }
        Self {
            base: IBaseFilter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AddMediaStream: AddMediaStream::<Impl, IMPL_OFFSET>,
            GetMediaStream: GetMediaStream::<Impl, IMPL_OFFSET>,
            EnumMediaStreams: EnumMediaStreams::<Impl, IMPL_OFFSET>,
            SupportSeeking: SupportSeeking::<Impl, IMPL_OFFSET>,
            ReferenceTimeToStreamTime: ReferenceTimeToStreamTime::<Impl, IMPL_OFFSET>,
            GetCurrentStreamTime: GetCurrentStreamTime::<Impl, IMPL_OFFSET>,
            WaitUntil: WaitUntil::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            EndOfStream: EndOfStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaStreamFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IMediaTypeInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Type(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Subtype(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IMediaTypeInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMediaTypeInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMediaTypeInfo_Vtbl {
        unsafe extern "system" fn Type<Impl: IMediaTypeInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Type() {
                ::core::result::Result::Ok(ok__) => {
                    *strtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Subtype<Impl: IMediaTypeInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strtype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Subtype() {
                ::core::result::Result::Ok(ok__) => {
                    *strtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Type: Type::<Impl, IMPL_OFFSET>,
            Subtype: Subtype::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMediaTypeInfo as ::windows::core::Interface>::IID
    }
}
pub trait IMemAllocator_Impl: Sized {
    fn SetProperties(&mut self, prequest: *const ALLOCATOR_PROPERTIES) -> ::windows::core::Result<ALLOCATOR_PROPERTIES>;
    fn GetProperties(&mut self) -> ::windows::core::Result<ALLOCATOR_PROPERTIES>;
    fn Commit(&mut self) -> ::windows::core::Result<()>;
    fn Decommit(&mut self) -> ::windows::core::Result<()>;
    fn GetBuffer(&mut self, ppbuffer: *mut ::core::option::Option<IMediaSample>, pstarttime: *const i64, pendtime: *const i64, dwflags: u32) -> ::windows::core::Result<()>;
    fn ReleaseBuffer(&mut self, pbuffer: &::core::option::Option<IMediaSample>) -> ::windows::core::Result<()>;
}
impl IMemAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMemAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMemAllocator_Vtbl {
        unsafe extern "system" fn SetProperties<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prequest: *const ALLOCATOR_PROPERTIES, pactual: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetProperties(::core::mem::transmute_copy(&prequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *pactual = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperties<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProperties() {
                ::core::result::Result::Ok(ok__) => {
                    *pprops = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Commit<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Commit().into()
        }
        unsafe extern "system" fn Decommit<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Decommit().into()
        }
        unsafe extern "system" fn GetBuffer<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut ::windows::core::RawPtr, pstarttime: *const i64, pendtime: *const i64, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBuffer(::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&pendtime), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IMemAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseBuffer(::core::mem::transmute(&pbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetProperties: SetProperties::<Impl, IMPL_OFFSET>,
            GetProperties: GetProperties::<Impl, IMPL_OFFSET>,
            Commit: Commit::<Impl, IMPL_OFFSET>,
            Decommit: Decommit::<Impl, IMPL_OFFSET>,
            GetBuffer: GetBuffer::<Impl, IMPL_OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMemAllocator as ::windows::core::Interface>::IID
    }
}
pub trait IMemAllocatorCallbackTemp_Impl: Sized + IMemAllocator_Impl {
    fn SetNotify(&mut self, pnotify: &::core::option::Option<IMemAllocatorNotifyCallbackTemp>) -> ::windows::core::Result<()>;
    fn GetFreeCount(&mut self) -> ::windows::core::Result<i32>;
}
impl IMemAllocatorCallbackTemp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMemAllocatorCallbackTemp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMemAllocatorCallbackTemp_Vtbl {
        unsafe extern "system" fn SetNotify<Impl: IMemAllocatorCallbackTemp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNotify(::core::mem::transmute(&pnotify)).into()
        }
        unsafe extern "system" fn GetFreeCount<Impl: IMemAllocatorCallbackTemp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plbuffersfree: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFreeCount() {
                ::core::result::Result::Ok(ok__) => {
                    *plbuffersfree = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMemAllocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetNotify: SetNotify::<Impl, IMPL_OFFSET>,
            GetFreeCount: GetFreeCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMemAllocatorCallbackTemp as ::windows::core::Interface>::IID
    }
}
pub trait IMemAllocatorNotifyCallbackTemp_Impl: Sized {
    fn NotifyRelease(&mut self) -> ::windows::core::Result<()>;
}
impl IMemAllocatorNotifyCallbackTemp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMemAllocatorNotifyCallbackTemp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMemAllocatorNotifyCallbackTemp_Vtbl {
        unsafe extern "system" fn NotifyRelease<Impl: IMemAllocatorNotifyCallbackTemp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyRelease().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), NotifyRelease: NotifyRelease::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMemAllocatorNotifyCallbackTemp as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMemInputPin_Impl: Sized {
    fn GetAllocator(&mut self) -> ::windows::core::Result<IMemAllocator>;
    fn NotifyAllocator(&mut self, pallocator: &::core::option::Option<IMemAllocator>, breadonly: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetAllocatorRequirements(&mut self) -> ::windows::core::Result<ALLOCATOR_PROPERTIES>;
    fn Receive(&mut self, psample: &::core::option::Option<IMediaSample>) -> ::windows::core::Result<()>;
    fn ReceiveMultiple(&mut self, psamples: *const ::core::option::Option<IMediaSample>, nsamples: i32) -> ::windows::core::Result<i32>;
    fn ReceiveCanBlock(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMemInputPin_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMemInputPin_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMemInputPin_Vtbl {
        unsafe extern "system" fn GetAllocator<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppallocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllocator() {
                ::core::result::Result::Ok(ok__) => {
                    *ppallocator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyAllocator<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr, breadonly: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyAllocator(::core::mem::transmute(&pallocator), ::core::mem::transmute_copy(&breadonly)).into()
        }
        unsafe extern "system" fn GetAllocatorRequirements<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllocatorRequirements() {
                ::core::result::Result::Ok(ok__) => {
                    *pprops = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Receive<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Receive(::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn ReceiveMultiple<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psamples: *const ::windows::core::RawPtr, nsamples: i32, nsamplesprocessed: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ReceiveMultiple(::core::mem::transmute_copy(&psamples), ::core::mem::transmute_copy(&nsamples)) {
                ::core::result::Result::Ok(ok__) => {
                    *nsamplesprocessed = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReceiveCanBlock<Impl: IMemInputPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReceiveCanBlock().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAllocator: GetAllocator::<Impl, IMPL_OFFSET>,
            NotifyAllocator: NotifyAllocator::<Impl, IMPL_OFFSET>,
            GetAllocatorRequirements: GetAllocatorRequirements::<Impl, IMPL_OFFSET>,
            Receive: Receive::<Impl, IMPL_OFFSET>,
            ReceiveMultiple: ReceiveMultiple::<Impl, IMPL_OFFSET>,
            ReceiveCanBlock: ReceiveCanBlock::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMemInputPin as ::windows::core::Interface>::IID
    }
}
pub trait IMemoryData_Impl: Sized {
    fn SetBuffer(&mut self, cbsize: u32, pbdata: *const u8, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetInfo(&mut self, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> ::windows::core::Result<()>;
    fn SetActual(&mut self, cbdatavalid: u32) -> ::windows::core::Result<()>;
}
impl IMemoryData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMemoryData_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMemoryData_Vtbl {
        unsafe extern "system" fn SetBuffer<Impl: IMemoryData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbsize: u32, pbdata: *const u8, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBuffer(::core::mem::transmute_copy(&cbsize), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetInfo<Impl: IMemoryData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInfo(::core::mem::transmute_copy(&pdwlength), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbactualdata)).into()
        }
        unsafe extern "system" fn SetActual<Impl: IMemoryData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdatavalid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetActual(::core::mem::transmute_copy(&cbdatavalid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetBuffer: SetBuffer::<Impl, IMPL_OFFSET>,
            GetInfo: GetInfo::<Impl, IMPL_OFFSET>,
            SetActual: SetActual::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMemoryData as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IMixerOCX_Impl: Sized {
    fn OnDisplayChange(&mut self, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> ::windows::core::Result<()>;
    fn GetAspectRatio(&mut self, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::Result<()>;
    fn GetVideoSize(&mut self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> ::windows::core::Result<()>;
    fn GetStatus(&mut self) -> ::windows::core::Result<*mut u32>;
    fn OnDraw(&mut self, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn SetDrawRegion(&mut self, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn Advise(&mut self, pmdns: &::core::option::Option<IMixerOCXNotify>) -> ::windows::core::Result<()>;
    fn UnAdvise(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IMixerOCX_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMixerOCX_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMixerOCX_Vtbl {
        unsafe extern "system" fn OnDisplayChange<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDisplayChange(::core::mem::transmute_copy(&ulbitsperpixel), ::core::mem::transmute_copy(&ulscreenwidth), ::core::mem::transmute_copy(&ulscreenheight)).into()
        }
        unsafe extern "system" fn GetAspectRatio<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAspectRatio(::core::mem::transmute_copy(&pdwpictaspectratiox), ::core::mem::transmute_copy(&pdwpictaspectratioy)).into()
        }
        unsafe extern "system" fn GetVideoSize<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoSize(::core::mem::transmute_copy(&pdwvideowidth), ::core::mem::transmute_copy(&pdwvideoheight)).into()
        }
        unsafe extern "system" fn GetStatus<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstatus: *mut *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnDraw<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDraw(::core::mem::transmute_copy(&hdcdraw), ::core::mem::transmute_copy(&prcdraw)).into()
        }
        unsafe extern "system" fn SetDrawRegion<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDrawRegion(::core::mem::transmute_copy(&lppttopleftsc), ::core::mem::transmute_copy(&prcdrawcc), ::core::mem::transmute_copy(&lprcclip)).into()
        }
        unsafe extern "system" fn Advise<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmdns: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Advise(::core::mem::transmute(&pmdns)).into()
        }
        unsafe extern "system" fn UnAdvise<Impl: IMixerOCX_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnAdvise().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnDisplayChange: OnDisplayChange::<Impl, IMPL_OFFSET>,
            GetAspectRatio: GetAspectRatio::<Impl, IMPL_OFFSET>,
            GetVideoSize: GetVideoSize::<Impl, IMPL_OFFSET>,
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            OnDraw: OnDraw::<Impl, IMPL_OFFSET>,
            SetDrawRegion: SetDrawRegion::<Impl, IMPL_OFFSET>,
            Advise: Advise::<Impl, IMPL_OFFSET>,
            UnAdvise: UnAdvise::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMixerOCX as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMixerOCXNotify_Impl: Sized {
    fn OnInvalidateRect(&mut self, lpcrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn OnStatusChange(&mut self, ulstatusflags: u32) -> ::windows::core::Result<()>;
    fn OnDataChange(&mut self, uldataflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMixerOCXNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMixerOCXNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMixerOCXNotify_Vtbl {
        unsafe extern "system" fn OnInvalidateRect<Impl: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpcrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnInvalidateRect(::core::mem::transmute_copy(&lpcrect)).into()
        }
        unsafe extern "system" fn OnStatusChange<Impl: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulstatusflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnStatusChange(::core::mem::transmute_copy(&ulstatusflags)).into()
        }
        unsafe extern "system" fn OnDataChange<Impl: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uldataflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDataChange(::core::mem::transmute_copy(&uldataflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnInvalidateRect: OnInvalidateRect::<Impl, IMPL_OFFSET>,
            OnStatusChange: OnStatusChange::<Impl, IMPL_OFFSET>,
            OnDataChange: OnDataChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMixerOCXNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMixerPinConfig_Impl: Sized {
    fn SetRelativePosition(&mut self, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> ::windows::core::Result<()>;
    fn GetRelativePosition(&mut self, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> ::windows::core::Result<()>;
    fn SetZOrder(&mut self, dwzorder: u32) -> ::windows::core::Result<()>;
    fn GetZOrder(&mut self, pdwzorder: *mut u32) -> ::windows::core::Result<()>;
    fn SetColorKey(&mut self, pcolorkey: *mut COLORKEY) -> ::windows::core::Result<()>;
    fn GetColorKey(&mut self, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> ::windows::core::Result<()>;
    fn SetBlendingParameter(&mut self, dwblendingparameter: u32) -> ::windows::core::Result<()>;
    fn GetBlendingParameter(&mut self, pdwblendingparameter: *mut u32) -> ::windows::core::Result<()>;
    fn SetAspectRatioMode(&mut self, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> ::windows::core::Result<()>;
    fn GetAspectRatioMode(&mut self, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> ::windows::core::Result<()>;
    fn SetStreamTransparent(&mut self, bstreamtransparent: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamTransparent(&mut self, pbstreamtransparent: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMixerPinConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMixerPinConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMixerPinConfig_Vtbl {
        unsafe extern "system" fn SetRelativePosition<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRelativePosition(::core::mem::transmute_copy(&dwleft), ::core::mem::transmute_copy(&dwtop), ::core::mem::transmute_copy(&dwright), ::core::mem::transmute_copy(&dwbottom)).into()
        }
        unsafe extern "system" fn GetRelativePosition<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRelativePosition(::core::mem::transmute_copy(&pdwleft), ::core::mem::transmute_copy(&pdwtop), ::core::mem::transmute_copy(&pdwright), ::core::mem::transmute_copy(&pdwbottom)).into()
        }
        unsafe extern "system" fn SetZOrder<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwzorder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZOrder(::core::mem::transmute_copy(&dwzorder)).into()
        }
        unsafe extern "system" fn GetZOrder<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwzorder: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetZOrder(::core::mem::transmute_copy(&pdwzorder)).into()
        }
        unsafe extern "system" fn SetColorKey<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&pcolorkey)).into()
        }
        unsafe extern "system" fn GetColorKey<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetColorKey(::core::mem::transmute_copy(&pcolorkey), ::core::mem::transmute_copy(&pcolor)).into()
        }
        unsafe extern "system" fn SetBlendingParameter<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwblendingparameter: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlendingParameter(::core::mem::transmute_copy(&dwblendingparameter)).into()
        }
        unsafe extern "system" fn GetBlendingParameter<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwblendingparameter: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBlendingParameter(::core::mem::transmute_copy(&pdwblendingparameter)).into()
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&amaspectratiomode)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAspectRatioMode(::core::mem::transmute_copy(&pamaspectratiomode)).into()
        }
        unsafe extern "system" fn SetStreamTransparent<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstreamtransparent: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamTransparent(::core::mem::transmute_copy(&bstreamtransparent)).into()
        }
        unsafe extern "system" fn GetStreamTransparent<Impl: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbstreamtransparent: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamTransparent(::core::mem::transmute_copy(&pbstreamtransparent)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetRelativePosition: SetRelativePosition::<Impl, IMPL_OFFSET>,
            GetRelativePosition: GetRelativePosition::<Impl, IMPL_OFFSET>,
            SetZOrder: SetZOrder::<Impl, IMPL_OFFSET>,
            GetZOrder: GetZOrder::<Impl, IMPL_OFFSET>,
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            GetColorKey: GetColorKey::<Impl, IMPL_OFFSET>,
            SetBlendingParameter: SetBlendingParameter::<Impl, IMPL_OFFSET>,
            GetBlendingParameter: GetBlendingParameter::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetStreamTransparent: SetStreamTransparent::<Impl, IMPL_OFFSET>,
            GetStreamTransparent: GetStreamTransparent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMixerPinConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IMixerPinConfig2_Impl: Sized + IMixerPinConfig_Impl {
    fn SetOverlaySurfaceColorControls(&mut self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::Result<()>;
    fn GetOverlaySurfaceColorControls(&mut self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IMixerPinConfig2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMixerPinConfig2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMixerPinConfig2_Vtbl {
        unsafe extern "system" fn SetOverlaySurfaceColorControls<Impl: IMixerPinConfig2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOverlaySurfaceColorControls(::core::mem::transmute_copy(&pcolorcontrol)).into()
        }
        unsafe extern "system" fn GetOverlaySurfaceColorControls<Impl: IMixerPinConfig2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOverlaySurfaceColorControls(::core::mem::transmute_copy(&pcolorcontrol)).into()
        }
        Self {
            base: IMixerPinConfig_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetOverlaySurfaceColorControls: SetOverlaySurfaceColorControls::<Impl, IMPL_OFFSET>,
            GetOverlaySurfaceColorControls: GetOverlaySurfaceColorControls::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMixerPinConfig2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMpeg2Data_Impl: Sized {
    fn GetSection(&mut self, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32) -> ::windows::core::Result<ISectionList>;
    fn GetTable(&mut self, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32) -> ::windows::core::Result<ISectionList>;
    fn GetStreamOfSections(&mut self, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<IMpeg2Stream>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMpeg2Data_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMpeg2Data_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMpeg2Data_Vtbl {
        unsafe extern "system" fn GetSection<Impl: IMpeg2Data_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32, ppsectionlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSection(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&tid), ::core::mem::transmute_copy(&pfilter), ::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsectionlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTable<Impl: IMpeg2Data_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, dwtimeout: u32, ppsectionlist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTable(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&tid), ::core::mem::transmute_copy(&pfilter), ::core::mem::transmute_copy(&dwtimeout)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsectionlist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamOfSections<Impl: IMpeg2Data_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE, ppmpegstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamOfSections(::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&tid), ::core::mem::transmute_copy(&pfilter), ::core::mem::transmute_copy(&hdatareadyevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmpegstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSection: GetSection::<Impl, IMPL_OFFSET>,
            GetTable: GetTable::<Impl, IMPL_OFFSET>,
            GetStreamOfSections: GetStreamOfSections::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMpeg2Data as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMpeg2Demultiplexer_Impl: Sized {
    fn CreateOutputPin(&mut self, pmediatype: *mut AM_MEDIA_TYPE, pszpinname: super::super::Foundation::PWSTR, ppipin: *mut ::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn SetOutputPinMediaType(&mut self, pszpinname: super::super::Foundation::PWSTR, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn DeleteOutputPin(&mut self, pszpinname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMpeg2Demultiplexer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMpeg2Demultiplexer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMpeg2Demultiplexer_Vtbl {
        unsafe extern "system" fn CreateOutputPin<Impl: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *mut AM_MEDIA_TYPE, pszpinname: super::super::Foundation::PWSTR, ppipin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateOutputPin(::core::mem::transmute_copy(&pmediatype), ::core::mem::transmute_copy(&pszpinname), ::core::mem::transmute_copy(&ppipin)).into()
        }
        unsafe extern "system" fn SetOutputPinMediaType<Impl: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszpinname: super::super::Foundation::PWSTR, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputPinMediaType(::core::mem::transmute_copy(&pszpinname), ::core::mem::transmute_copy(&pmediatype)).into()
        }
        unsafe extern "system" fn DeleteOutputPin<Impl: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszpinname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteOutputPin(::core::mem::transmute_copy(&pszpinname)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateOutputPin: CreateOutputPin::<Impl, IMPL_OFFSET>,
            SetOutputPinMediaType: SetOutputPinMediaType::<Impl, IMPL_OFFSET>,
            DeleteOutputPin: DeleteOutputPin::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMpeg2Demultiplexer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMpeg2Stream_Impl: Sized {
    fn Initialize(&mut self, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: &::core::option::Option<IMpeg2Data>, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn SupplyDataBuffer(&mut self, pstreambuffer: *const MPEG_STREAM_BUFFER) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMpeg2Stream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMpeg2Stream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMpeg2Stream_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IMpeg2Stream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: ::windows::core::RawPtr, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, hdatareadyevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&requesttype), ::core::mem::transmute(&pmpeg2data), ::core::mem::transmute_copy(&pcontext), ::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&tid), ::core::mem::transmute_copy(&pfilter), ::core::mem::transmute_copy(&hdatareadyevent)).into()
        }
        unsafe extern "system" fn SupplyDataBuffer<Impl: IMpeg2Stream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstreambuffer: *const MPEG_STREAM_BUFFER) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupplyDataBuffer(::core::mem::transmute_copy(&pstreambuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            SupplyDataBuffer: SupplyDataBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMpeg2Stream as ::windows::core::Interface>::IID
    }
}
pub trait IMpeg2TableFilter_Impl: Sized {
    fn AddPID(&mut self, p: u16) -> ::windows::core::Result<()>;
    fn AddTable(&mut self, p: u16, t: u8) -> ::windows::core::Result<()>;
    fn AddExtension(&mut self, p: u16, t: u8, e: u16) -> ::windows::core::Result<()>;
    fn RemovePID(&mut self, p: u16) -> ::windows::core::Result<()>;
    fn RemoveTable(&mut self, p: u16, t: u8) -> ::windows::core::Result<()>;
    fn RemoveExtension(&mut self, p: u16, t: u8, e: u16) -> ::windows::core::Result<()>;
}
impl IMpeg2TableFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMpeg2TableFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMpeg2TableFilter_Vtbl {
        unsafe extern "system" fn AddPID<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddPID(::core::mem::transmute_copy(&p)).into()
        }
        unsafe extern "system" fn AddTable<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16, t: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddTable(::core::mem::transmute_copy(&p), ::core::mem::transmute_copy(&t)).into()
        }
        unsafe extern "system" fn AddExtension<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16, t: u8, e: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddExtension(::core::mem::transmute_copy(&p), ::core::mem::transmute_copy(&t), ::core::mem::transmute_copy(&e)).into()
        }
        unsafe extern "system" fn RemovePID<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemovePID(::core::mem::transmute_copy(&p)).into()
        }
        unsafe extern "system" fn RemoveTable<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16, t: u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTable(::core::mem::transmute_copy(&p), ::core::mem::transmute_copy(&t)).into()
        }
        unsafe extern "system" fn RemoveExtension<Impl: IMpeg2TableFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, p: u16, t: u8, e: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveExtension(::core::mem::transmute_copy(&p), ::core::mem::transmute_copy(&t), ::core::mem::transmute_copy(&e)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AddPID: AddPID::<Impl, IMPL_OFFSET>,
            AddTable: AddTable::<Impl, IMPL_OFFSET>,
            AddExtension: AddExtension::<Impl, IMPL_OFFSET>,
            RemovePID: RemovePID::<Impl, IMPL_OFFSET>,
            RemoveTable: RemoveTable::<Impl, IMPL_OFFSET>,
            RemoveExtension: RemoveExtension::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMpeg2TableFilter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IMpegAudioDecoder_Impl: Sized {
    fn FrequencyDivider(&mut self) -> ::windows::core::Result<u32>;
    fn SetFrequencyDivider(&mut self, divider: u32) -> ::windows::core::Result<()>;
    fn DecoderAccuracy(&mut self) -> ::windows::core::Result<u32>;
    fn SetDecoderAccuracy(&mut self, accuracy: u32) -> ::windows::core::Result<()>;
    fn Stereo(&mut self) -> ::windows::core::Result<u32>;
    fn SetStereo(&mut self, stereo: u32) -> ::windows::core::Result<()>;
    fn DecoderWordSize(&mut self) -> ::windows::core::Result<u32>;
    fn SetDecoderWordSize(&mut self, wordsize: u32) -> ::windows::core::Result<()>;
    fn IntegerDecode(&mut self) -> ::windows::core::Result<u32>;
    fn SetIntegerDecode(&mut self, intdecode: u32) -> ::windows::core::Result<()>;
    fn DualMode(&mut self, pintdecode: *mut u32) -> ::windows::core::Result<()>;
    fn SetDualMode(&mut self, intdecode: u32) -> ::windows::core::Result<()>;
    fn AudioFormat(&mut self) -> ::windows::core::Result<MPEG1WAVEFORMAT>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IMpegAudioDecoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMpegAudioDecoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMpegAudioDecoder_Vtbl {
        unsafe extern "system" fn FrequencyDivider<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdivider: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrequencyDivider() {
                ::core::result::Result::Ok(ok__) => {
                    *pdivider = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyDivider<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, divider: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrequencyDivider(::core::mem::transmute_copy(&divider)).into()
        }
        unsafe extern "system" fn DecoderAccuracy<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, paccuracy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DecoderAccuracy() {
                ::core::result::Result::Ok(ok__) => {
                    *paccuracy = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecoderAccuracy<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, accuracy: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDecoderAccuracy(::core::mem::transmute_copy(&accuracy)).into()
        }
        unsafe extern "system" fn Stereo<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstereo: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Stereo() {
                ::core::result::Result::Ok(ok__) => {
                    *pstereo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stereo: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo(::core::mem::transmute_copy(&stereo)).into()
        }
        unsafe extern "system" fn DecoderWordSize<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwordsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DecoderWordSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pwordsize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDecoderWordSize<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wordsize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDecoderWordSize(::core::mem::transmute_copy(&wordsize)).into()
        }
        unsafe extern "system" fn IntegerDecode<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pintdecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IntegerDecode() {
                ::core::result::Result::Ok(ok__) => {
                    *pintdecode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIntegerDecode<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, intdecode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIntegerDecode(::core::mem::transmute_copy(&intdecode)).into()
        }
        unsafe extern "system" fn DualMode<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pintdecode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DualMode(::core::mem::transmute_copy(&pintdecode)).into()
        }
        unsafe extern "system" fn SetDualMode<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, intdecode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDualMode(::core::mem::transmute_copy(&intdecode)).into()
        }
        unsafe extern "system" fn AudioFormat<Impl: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpfmt: *mut MPEG1WAVEFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AudioFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *lpfmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            FrequencyDivider: FrequencyDivider::<Impl, IMPL_OFFSET>,
            SetFrequencyDivider: SetFrequencyDivider::<Impl, IMPL_OFFSET>,
            DecoderAccuracy: DecoderAccuracy::<Impl, IMPL_OFFSET>,
            SetDecoderAccuracy: SetDecoderAccuracy::<Impl, IMPL_OFFSET>,
            Stereo: Stereo::<Impl, IMPL_OFFSET>,
            SetStereo: SetStereo::<Impl, IMPL_OFFSET>,
            DecoderWordSize: DecoderWordSize::<Impl, IMPL_OFFSET>,
            SetDecoderWordSize: SetDecoderWordSize::<Impl, IMPL_OFFSET>,
            IntegerDecode: IntegerDecode::<Impl, IMPL_OFFSET>,
            SetIntegerDecode: SetIntegerDecode::<Impl, IMPL_OFFSET>,
            DualMode: DualMode::<Impl, IMPL_OFFSET>,
            SetDualMode: SetDualMode::<Impl, IMPL_OFFSET>,
            AudioFormat: AudioFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMpegAudioDecoder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMultiMediaStream_Impl: Sized {
    fn GetInformation(&mut self, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> ::windows::core::Result<()>;
    fn GetMediaStream(&mut self, idpurpose: *const ::windows::core::GUID) -> ::windows::core::Result<IMediaStream>;
    fn EnumMediaStreams(&mut self, index: i32) -> ::windows::core::Result<IMediaStream>;
    fn GetState(&mut self) -> ::windows::core::Result<STREAM_STATE>;
    fn SetState(&mut self, newstate: STREAM_STATE) -> ::windows::core::Result<()>;
    fn GetTime(&mut self) -> ::windows::core::Result<i64>;
    fn GetDuration(&mut self) -> ::windows::core::Result<i64>;
    fn Seek(&mut self, seektime: i64) -> ::windows::core::Result<()>;
    fn GetEndOfStreamEventHandle(&mut self) -> ::windows::core::Result<super::super::Foundation::HANDLE>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMultiMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMultiMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMultiMediaStream_Vtbl {
        unsafe extern "system" fn GetInformation<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInformation(::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&pstreamtype)).into()
        }
        unsafe extern "system" fn GetMediaStream<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idpurpose: *const ::windows::core::GUID, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaStream(::core::mem::transmute_copy(&idpurpose)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediastream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: i32, ppmediastream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumMediaStreams(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediastream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrentstate: *mut STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState() {
                ::core::result::Result::Ok(ok__) => {
                    *pcurrentstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetState<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newstate: STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetState(::core::mem::transmute_copy(&newstate)).into()
        }
        unsafe extern "system" fn GetTime<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrenttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pcurrenttime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *pduration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, seektime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Seek(::core::mem::transmute_copy(&seektime)).into()
        }
        unsafe extern "system" fn GetEndOfStreamEventHandle<Impl: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pheos: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEndOfStreamEventHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *pheos = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetInformation: GetInformation::<Impl, IMPL_OFFSET>,
            GetMediaStream: GetMediaStream::<Impl, IMPL_OFFSET>,
            EnumMediaStreams: EnumMediaStreams::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            SetState: SetState::<Impl, IMPL_OFFSET>,
            GetTime: GetTime::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            Seek: Seek::<Impl, IMPL_OFFSET>,
            GetEndOfStreamEventHandle: GetEndOfStreamEventHandle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMultiMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IOverlay_Impl: Sized {
    fn GetPalette(&mut self, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::Result<()>;
    fn SetPalette(&mut self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::Result<()>;
    fn GetDefaultColorKey(&mut self) -> ::windows::core::Result<COLORKEY>;
    fn GetColorKey(&mut self) -> ::windows::core::Result<COLORKEY>;
    fn SetColorKey(&mut self, pcolorkey: *mut COLORKEY) -> ::windows::core::Result<()>;
    fn GetWindowHandle(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn GetClipList(&mut self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::Result<()>;
    fn GetVideoPosition(&mut self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn Advise(&mut self, poverlaynotify: &::core::option::Option<IOverlayNotify>, dwinterests: u32) -> ::windows::core::Result<()>;
    fn Unadvise(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IOverlay_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IOverlay_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IOverlay_Vtbl {
        unsafe extern "system" fn GetPalette<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPalette(::core::mem::transmute_copy(&pdwcolors), ::core::mem::transmute_copy(&pppalette)).into()
        }
        unsafe extern "system" fn SetPalette<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPalette(::core::mem::transmute_copy(&dwcolors), ::core::mem::transmute_copy(&ppalette)).into()
        }
        unsafe extern "system" fn GetDefaultColorKey<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultColorKey() {
                ::core::result::Result::Ok(ok__) => {
                    *pcolorkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColorKey<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColorKey() {
                ::core::result::Result::Ok(ok__) => {
                    *pcolorkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorKey<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *mut COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&pcolorkey)).into()
        }
        unsafe extern "system" fn GetWindowHandle<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetWindowHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *phwnd = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClipList<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetClipList(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect), ::core::mem::transmute_copy(&pprgndata)).into()
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPosition(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect)).into()
        }
        unsafe extern "system" fn Advise<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poverlaynotify: ::windows::core::RawPtr, dwinterests: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Advise(::core::mem::transmute(&poverlaynotify), ::core::mem::transmute_copy(&dwinterests)).into()
        }
        unsafe extern "system" fn Unadvise<Impl: IOverlay_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unadvise().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPalette: GetPalette::<Impl, IMPL_OFFSET>,
            SetPalette: SetPalette::<Impl, IMPL_OFFSET>,
            GetDefaultColorKey: GetDefaultColorKey::<Impl, IMPL_OFFSET>,
            GetColorKey: GetColorKey::<Impl, IMPL_OFFSET>,
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            GetWindowHandle: GetWindowHandle::<Impl, IMPL_OFFSET>,
            GetClipList: GetClipList::<Impl, IMPL_OFFSET>,
            GetVideoPosition: GetVideoPosition::<Impl, IMPL_OFFSET>,
            Advise: Advise::<Impl, IMPL_OFFSET>,
            Unadvise: Unadvise::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IOverlay as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IOverlayNotify_Impl: Sized {
    fn OnPaletteChange(&mut self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::Result<()>;
    fn OnClipChange(&mut self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::Result<()>;
    fn OnColorKeyChange(&mut self, pcolorkey: *const COLORKEY) -> ::windows::core::Result<()>;
    fn OnPositionChange(&mut self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IOverlayNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IOverlayNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IOverlayNotify_Vtbl {
        unsafe extern "system" fn OnPaletteChange<Impl: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPaletteChange(::core::mem::transmute_copy(&dwcolors), ::core::mem::transmute_copy(&ppalette)).into()
        }
        unsafe extern "system" fn OnClipChange<Impl: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClipChange(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect), ::core::mem::transmute_copy(&prgndata)).into()
        }
        unsafe extern "system" fn OnColorKeyChange<Impl: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcolorkey: *const COLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnColorKeyChange(::core::mem::transmute_copy(&pcolorkey)).into()
        }
        unsafe extern "system" fn OnPositionChange<Impl: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnPositionChange(::core::mem::transmute_copy(&psourcerect), ::core::mem::transmute_copy(&pdestinationrect)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnPaletteChange: OnPaletteChange::<Impl, IMPL_OFFSET>,
            OnClipChange: OnClipChange::<Impl, IMPL_OFFSET>,
            OnColorKeyChange: OnColorKeyChange::<Impl, IMPL_OFFSET>,
            OnPositionChange: OnPositionChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IOverlayNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IOverlayNotify2_Impl: Sized + IOverlayNotify_Impl {
    fn OnDisplayChange(&mut self, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IOverlayNotify2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IOverlayNotify2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IOverlayNotify2_Vtbl {
        unsafe extern "system" fn OnDisplayChange<Impl: IOverlayNotify2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnDisplayChange(::core::mem::transmute_copy(&hmonitor)).into()
        }
        Self { base: IOverlayNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), OnDisplayChange: OnDisplayChange::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IOverlayNotify2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IPAT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetTransportStreamId(&mut self) -> ::windows::core::Result<u16>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordProgramNumber(&mut self, dwindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordProgramMapPid(&mut self, dwindex: u32) -> ::windows::core::Result<u16>;
    fn FindRecordProgramMapPid(&mut self, wprogramnumber: u16) -> ::windows::core::Result<u16>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IPAT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IPAT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPAT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPAT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetTransportStreamId<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransportStreamId() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramNumber<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramNumber(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordProgramMapPid<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordProgramMapPid(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindRecordProgramMapPid<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wprogramnumber: u16, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindRecordProgramMapPid(::core::mem::transmute_copy(&wprogramnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppat: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *pppat = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IPAT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetTransportStreamId: GetTransportStreamId::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordProgramNumber: GetRecordProgramNumber::<Impl, IMPL_OFFSET>,
            GetRecordProgramMapPid: GetRecordProgramMapPid::<Impl, IMPL_OFFSET>,
            FindRecordProgramMapPid: FindRecordProgramMapPid::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPAT as ::windows::core::Interface>::IID
    }
}
pub trait IPBDAAttributesDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u16>;
    fn GetAttributePayload(&mut self, ppbattributebuffer: *mut *mut u8, pdwattributelength: *mut u32) -> ::windows::core::Result<()>;
}
impl IPBDAAttributesDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPBDAAttributesDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPBDAAttributesDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IPBDAAttributesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IPBDAAttributesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributePayload<Impl: IPBDAAttributesDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbattributebuffer: *mut *mut u8, pdwattributelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAttributePayload(::core::mem::transmute_copy(&ppbattributebuffer), ::core::mem::transmute_copy(&pdwattributelength)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetAttributePayload: GetAttributePayload::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPBDAAttributesDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IPBDAEntitlementDescriptor_Impl: Sized {
    fn GetTag(&mut self) -> ::windows::core::Result<u8>;
    fn GetLength(&mut self) -> ::windows::core::Result<u16>;
    fn GetToken(&mut self, ppbtokenbuffer: *mut *mut u8, pdwtokenlength: *mut u32) -> ::windows::core::Result<()>;
}
impl IPBDAEntitlementDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPBDAEntitlementDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPBDAEntitlementDescriptor_Vtbl {
        unsafe extern "system" fn GetTag<Impl: IPBDAEntitlementDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTag() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IPBDAEntitlementDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToken<Impl: IPBDAEntitlementDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbtokenbuffer: *mut *mut u8, pdwtokenlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetToken(::core::mem::transmute_copy(&ppbtokenbuffer), ::core::mem::transmute_copy(&pdwtokenlength)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetTag: GetTag::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetToken: GetToken::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPBDAEntitlementDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IPBDASiParser_Impl: Sized {
    fn Initialize(&mut self, punk: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetEIT(&mut self, dwsize: u32, pbuffer: *const u8) -> ::windows::core::Result<IPBDA_EIT>;
    fn GetServices(&mut self, dwsize: u32, pbuffer: *const u8) -> ::windows::core::Result<IPBDA_Services>;
}
impl IPBDASiParser_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPBDASiParser_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPBDASiParser_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDASiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&punk)).into()
        }
        unsafe extern "system" fn GetEIT<Impl: IPBDASiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsize: u32, pbuffer: *const u8, ppeit: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEIT(::core::mem::transmute_copy(&dwsize), ::core::mem::transmute_copy(&pbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppeit = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServices<Impl: IPBDASiParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsize: u32, pbuffer: *const u8, ppservices: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServices(::core::mem::transmute_copy(&dwsize), ::core::mem::transmute_copy(&pbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppservices = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetEIT: GetEIT::<Impl, IMPL_OFFSET>,
            GetServices: GetServices::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPBDASiParser as ::windows::core::Interface>::IID
    }
}
pub trait IPBDA_EIT_Impl: Sized {
    fn Initialize(&mut self, size: u32, pbuffer: *const u8) -> ::windows::core::Result<()>;
    fn GetTableId(&mut self) -> ::windows::core::Result<u8>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u16>;
    fn GetServiceIdx(&mut self) -> ::windows::core::Result<u64>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordEventId(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u64>;
    fn GetRecordStartTime(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_DATE_AND_TIME>;
    fn GetRecordDuration(&mut self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_TIME>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
impl IPBDA_EIT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPBDA_EIT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPBDA_EIT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, size: u32, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&size), ::core::mem::transmute_copy(&pbuffer)).into()
        }
        unsafe extern "system" fn GetTableId<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableId() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceIdx<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plwval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetServiceIdx() {
                ::core::result::Result::Ok(ok__) => {
                    *plwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordEventId<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, plwval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordEventId(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *plwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStartTime<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdtval: *mut MPEG_DATE_AND_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordStartTime(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdtval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDuration<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pmdval: *mut MPEG_TIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDuration(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmdval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IPBDA_EIT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetTableId: GetTableId::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetServiceIdx: GetServiceIdx::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordEventId: GetRecordEventId::<Impl, IMPL_OFFSET>,
            GetRecordStartTime: GetRecordStartTime::<Impl, IMPL_OFFSET>,
            GetRecordDuration: GetRecordDuration::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPBDA_EIT as ::windows::core::Interface>::IID
    }
}
pub trait IPBDA_Services_Impl: Sized {
    fn Initialize(&mut self, size: u32, pbuffer: *const u8) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u32>;
    fn GetRecordByIndex(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u64>;
}
impl IPBDA_Services_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPBDA_Services_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPBDA_Services_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IPBDA_Services_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, size: u32, pbuffer: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&size), ::core::mem::transmute_copy(&pbuffer)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPBDA_Services_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordByIndex<Impl: IPBDA_Services_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pul64serviceidx: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordByIndex(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pul64serviceidx = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordByIndex: GetRecordByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPBDA_Services as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IPMT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetProgramNumber(&mut self) -> ::windows::core::Result<u16>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetPcrPid(&mut self) -> ::windows::core::Result<u16>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn GetCountOfRecords(&mut self) -> ::windows::core::Result<u16>;
    fn GetRecordStreamType(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u8>;
    fn GetRecordElementaryPid(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u16>;
    fn GetRecordCountOfDescriptors(&mut self, dwrecordindex: u32) -> ::windows::core::Result<u32>;
    fn GetRecordDescriptorByIndex(&mut self, dwrecordindex: u32, dwdescindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetRecordDescriptorByTag(&mut self, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn QueryServiceGatewayInfo(&mut self, ppdsmcclist: *mut *mut DSMCC_ELEMENT, puicount: *mut u32) -> ::windows::core::Result<()>;
    fn QueryMPEInfo(&mut self, ppmpelist: *mut *mut MPE_ELEMENT, puicount: *mut u32) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<IPMT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IPMT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPMT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPMT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetProgramNumber<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProgramNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVersionNumber<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPcrPid<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPcrPid() {
                ::core::result::Result::Ok(ok__) => {
                    *ppidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn GetCountOfRecords<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfRecords() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordStreamType<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordStreamType(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordElementaryPid<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, ppidval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordElementaryPid(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppidval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCountOfDescriptors<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCountOfDescriptors(::core::mem::transmute_copy(&dwrecordindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByIndex<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, dwdescindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordDescriptorByIndex(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&dwdescindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordDescriptorByTag<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordindex: u32, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordDescriptorByTag(::core::mem::transmute_copy(&dwrecordindex), ::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn QueryServiceGatewayInfo<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdsmcclist: *mut *mut DSMCC_ELEMENT, puicount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryServiceGatewayInfo(::core::mem::transmute_copy(&ppdsmcclist), ::core::mem::transmute_copy(&puicount)).into()
        }
        unsafe extern "system" fn QueryMPEInfo<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmpelist: *mut *mut MPE_ELEMENT, puicount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryMPEInfo(::core::mem::transmute_copy(&ppmpelist), ::core::mem::transmute_copy(&puicount)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppmt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *pppmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: IPMT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetProgramNumber: GetProgramNumber::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetPcrPid: GetPcrPid::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            GetCountOfRecords: GetCountOfRecords::<Impl, IMPL_OFFSET>,
            GetRecordStreamType: GetRecordStreamType::<Impl, IMPL_OFFSET>,
            GetRecordElementaryPid: GetRecordElementaryPid::<Impl, IMPL_OFFSET>,
            GetRecordCountOfDescriptors: GetRecordCountOfDescriptors::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByIndex: GetRecordDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetRecordDescriptorByTag: GetRecordDescriptorByTag::<Impl, IMPL_OFFSET>,
            QueryServiceGatewayInfo: QueryServiceGatewayInfo::<Impl, IMPL_OFFSET>,
            QueryMPEInfo: QueryMPEInfo::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPMT as ::windows::core::Interface>::IID
    }
}
pub trait IPSITables_Impl: Sized {
    fn GetTable(&mut self, dwtsid: u32, dwtid_pid: u32, dwhashedver: u32, dwpara4: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IPSITables_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPSITables_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPSITables_Vtbl {
        unsafe extern "system" fn GetTable<Impl: IPSITables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtsid: u32, dwtid_pid: u32, dwhashedver: u32, dwpara4: u32, ppiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTable(::core::mem::transmute_copy(&dwtsid), ::core::mem::transmute_copy(&dwtid_pid), ::core::mem::transmute_copy(&dwhashedver), ::core::mem::transmute_copy(&dwpara4)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppiunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetTable: GetTable::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPSITables as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IPTFilterLicenseRenewal_Impl: Sized {
    fn RenewLicenses(&mut self, wszfilename: super::super::Foundation::PWSTR, wszexpiredkid: super::super::Foundation::PWSTR, dwcallersid: u32, bhighpriority: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn CancelLicenseRenewal(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IPTFilterLicenseRenewal_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPTFilterLicenseRenewal_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPTFilterLicenseRenewal_Vtbl {
        unsafe extern "system" fn RenewLicenses<Impl: IPTFilterLicenseRenewal_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wszfilename: super::super::Foundation::PWSTR, wszexpiredkid: super::super::Foundation::PWSTR, dwcallersid: u32, bhighpriority: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenewLicenses(::core::mem::transmute_copy(&wszfilename), ::core::mem::transmute_copy(&wszexpiredkid), ::core::mem::transmute_copy(&dwcallersid), ::core::mem::transmute_copy(&bhighpriority)).into()
        }
        unsafe extern "system" fn CancelLicenseRenewal<Impl: IPTFilterLicenseRenewal_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelLicenseRenewal().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RenewLicenses: RenewLicenses::<Impl, IMPL_OFFSET>,
            CancelLicenseRenewal: CancelLicenseRenewal::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPTFilterLicenseRenewal as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IPersistMediaPropertyBag_Impl: Sized + super::super::System::Com::IPersist_Impl {
    fn InitNew(&mut self) -> ::windows::core::Result<()>;
    fn Load(&mut self, ppropbag: &::core::option::Option<IMediaPropertyBag>, perrorlog: &::core::option::Option<super::super::System::Com::IErrorLog>) -> ::windows::core::Result<()>;
    fn Save(&mut self, ppropbag: &::core::option::Option<IMediaPropertyBag>, fcleardirty: super::super::Foundation::BOOL, fsaveallproperties: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IPersistMediaPropertyBag_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersistMediaPropertyBag_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersistMediaPropertyBag_Vtbl {
        unsafe extern "system" fn InitNew<Impl: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitNew().into()
        }
        unsafe extern "system" fn Load<Impl: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppropbag: ::windows::core::RawPtr, perrorlog: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Load(::core::mem::transmute(&ppropbag), ::core::mem::transmute(&perrorlog)).into()
        }
        unsafe extern "system" fn Save<Impl: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppropbag: ::windows::core::RawPtr, fcleardirty: super::super::Foundation::BOOL, fsaveallproperties: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Save(::core::mem::transmute(&ppropbag), ::core::mem::transmute_copy(&fcleardirty), ::core::mem::transmute_copy(&fsaveallproperties)).into()
        }
        Self {
            base: super::super::System::Com::IPersist_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            InitNew: InitNew::<Impl, IMPL_OFFSET>,
            Load: Load::<Impl, IMPL_OFFSET>,
            Save: Save::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersistMediaPropertyBag as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IPersistTuneXml_Impl: Sized + super::super::System::Com::IPersist_Impl {
    fn InitNew(&mut self) -> ::windows::core::Result<()>;
    fn Load(&mut self, varvalue: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn Save(&mut self) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IPersistTuneXml_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersistTuneXml_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersistTuneXml_Vtbl {
        unsafe extern "system" fn InitNew<Impl: IPersistTuneXml_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitNew().into()
        }
        unsafe extern "system" fn Load<Impl: IPersistTuneXml_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varvalue: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Load(::core::mem::transmute_copy(&varvalue)).into()
        }
        unsafe extern "system" fn Save<Impl: IPersistTuneXml_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvarfragment: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Save() {
                ::core::result::Result::Ok(ok__) => {
                    *pvarfragment = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IPersist_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            InitNew: InitNew::<Impl, IMPL_OFFSET>,
            Load: Load::<Impl, IMPL_OFFSET>,
            Save: Save::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersistTuneXml as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IPersistTuneXmlUtility_Impl: Sized {
    fn Deserialize(&mut self, varvalue: &super::super::System::Com::VARIANT) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IPersistTuneXmlUtility_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersistTuneXmlUtility_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersistTuneXmlUtility_Vtbl {
        unsafe extern "system" fn Deserialize<Impl: IPersistTuneXmlUtility_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varvalue: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Deserialize(::core::mem::transmute_copy(&varvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Deserialize: Deserialize::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersistTuneXmlUtility as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IPersistTuneXmlUtility2_Impl: Sized + IPersistTuneXmlUtility_Impl {
    fn Serialize(&mut self, pitunerequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IPersistTuneXmlUtility2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPersistTuneXmlUtility2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPersistTuneXmlUtility2_Vtbl {
        unsafe extern "system" fn Serialize<Impl: IPersistTuneXmlUtility2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pitunerequest: ::windows::core::RawPtr, pstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Serialize(::core::mem::transmute(&pitunerequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstring = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IPersistTuneXmlUtility_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), Serialize: Serialize::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPersistTuneXmlUtility2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IPin_Impl: Sized {
    fn Connect(&mut self, preceivepin: &::core::option::Option<IPin>, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn ReceiveConnection(&mut self, pconnector: &::core::option::Option<IPin>, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn Disconnect(&mut self) -> ::windows::core::Result<()>;
    fn ConnectedTo(&mut self) -> ::windows::core::Result<IPin>;
    fn ConnectionMediaType(&mut self) -> ::windows::core::Result<AM_MEDIA_TYPE>;
    fn QueryPinInfo(&mut self) -> ::windows::core::Result<PIN_INFO>;
    fn QueryDirection(&mut self) -> ::windows::core::Result<PIN_DIRECTION>;
    fn QueryId(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn QueryAccept(&mut self, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn EnumMediaTypes(&mut self) -> ::windows::core::Result<IEnumMediaTypes>;
    fn QueryInternalConnections(&mut self, appin: *mut ::core::option::Option<IPin>, npin: *mut u32) -> ::windows::core::Result<()>;
    fn EndOfStream(&mut self) -> ::windows::core::Result<()>;
    fn BeginFlush(&mut self) -> ::windows::core::Result<()>;
    fn EndFlush(&mut self) -> ::windows::core::Result<()>;
    fn NewSegment(&mut self, tstart: i64, tstop: i64, drate: f64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IPin_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPin_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPin_Vtbl {
        unsafe extern "system" fn Connect<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, preceivepin: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Connect(::core::mem::transmute(&preceivepin), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn ReceiveConnection<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pconnector: ::windows::core::RawPtr, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReceiveConnection(::core::mem::transmute(&pconnector), ::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn Disconnect<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Disconnect().into()
        }
        unsafe extern "system" fn ConnectedTo<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectedTo() {
                ::core::result::Result::Ok(ok__) => {
                    *ppin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectionMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *pmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryPinInfo<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinfo: *mut PIN_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryPinInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *pinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryDirection<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppindir: *mut PIN_DIRECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *ppindir = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryId<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryId() {
                ::core::result::Result::Ok(ok__) => {
                    *id = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryAccept<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryAccept(::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn EnumMediaTypes<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumMediaTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryInternalConnections<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, appin: *mut ::windows::core::RawPtr, npin: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueryInternalConnections(::core::mem::transmute_copy(&appin), ::core::mem::transmute_copy(&npin)).into()
        }
        unsafe extern "system" fn EndOfStream<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndOfStream().into()
        }
        unsafe extern "system" fn BeginFlush<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginFlush().into()
        }
        unsafe extern "system" fn EndFlush<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndFlush().into()
        }
        unsafe extern "system" fn NewSegment<Impl: IPin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tstart: i64, tstop: i64, drate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NewSegment(::core::mem::transmute_copy(&tstart), ::core::mem::transmute_copy(&tstop), ::core::mem::transmute_copy(&drate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Connect: Connect::<Impl, IMPL_OFFSET>,
            ReceiveConnection: ReceiveConnection::<Impl, IMPL_OFFSET>,
            Disconnect: Disconnect::<Impl, IMPL_OFFSET>,
            ConnectedTo: ConnectedTo::<Impl, IMPL_OFFSET>,
            ConnectionMediaType: ConnectionMediaType::<Impl, IMPL_OFFSET>,
            QueryPinInfo: QueryPinInfo::<Impl, IMPL_OFFSET>,
            QueryDirection: QueryDirection::<Impl, IMPL_OFFSET>,
            QueryId: QueryId::<Impl, IMPL_OFFSET>,
            QueryAccept: QueryAccept::<Impl, IMPL_OFFSET>,
            EnumMediaTypes: EnumMediaTypes::<Impl, IMPL_OFFSET>,
            QueryInternalConnections: QueryInternalConnections::<Impl, IMPL_OFFSET>,
            EndOfStream: EndOfStream::<Impl, IMPL_OFFSET>,
            BeginFlush: BeginFlush::<Impl, IMPL_OFFSET>,
            EndFlush: EndFlush::<Impl, IMPL_OFFSET>,
            NewSegment: NewSegment::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPin as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IPinConnection_Impl: Sized {
    fn DynamicQueryAccept(&mut self, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn NotifyEndOfStream(&mut self, hnotifyevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn IsEndPin(&mut self) -> ::windows::core::Result<()>;
    fn DynamicDisconnect(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IPinConnection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPinConnection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPinConnection_Vtbl {
        unsafe extern "system" fn DynamicQueryAccept<Impl: IPinConnection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DynamicQueryAccept(::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn NotifyEndOfStream<Impl: IPinConnection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnotifyevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyEndOfStream(::core::mem::transmute_copy(&hnotifyevent)).into()
        }
        unsafe extern "system" fn IsEndPin<Impl: IPinConnection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsEndPin().into()
        }
        unsafe extern "system" fn DynamicDisconnect<Impl: IPinConnection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DynamicDisconnect().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            DynamicQueryAccept: DynamicQueryAccept::<Impl, IMPL_OFFSET>,
            NotifyEndOfStream: NotifyEndOfStream::<Impl, IMPL_OFFSET>,
            IsEndPin: IsEndPin::<Impl, IMPL_OFFSET>,
            DynamicDisconnect: DynamicDisconnect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPinConnection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IPinFlowControl_Impl: Sized {
    fn Block(&mut self, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IPinFlowControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPinFlowControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPinFlowControl_Vtbl {
        unsafe extern "system" fn Block<Impl: IPinFlowControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Block(::core::mem::transmute_copy(&dwblockflags), ::core::mem::transmute_copy(&hevent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Block: Block::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPinFlowControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IPinInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Pin(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn ConnectedTo(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn ConnectionMediaType(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn FilterInfo(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn Name(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Direction(&mut self) -> ::windows::core::Result<i32>;
    fn PinID(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn MediaTypes(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
    fn Connect(&mut self, ppin: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn ConnectDirect(&mut self, ppin: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn ConnectWithType(&mut self, ppin: &::core::option::Option<::windows::core::IUnknown>, pmediatype: &::core::option::Option<super::super::System::Com::IDispatch>) -> ::windows::core::Result<()>;
    fn Disconnect(&mut self) -> ::windows::core::Result<()>;
    fn Render(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IPinInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPinInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPinInfo_Vtbl {
        unsafe extern "system" fn Pin<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Pin() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectedTo<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectedTo() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectionMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FilterInfo<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FilterInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Name<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Name() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Direction<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppdirection: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Direction() {
                ::core::result::Result::Ok(ok__) => {
                    *ppdirection = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PinID<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strpinid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PinID() {
                ::core::result::Result::Ok(ok__) => {
                    *strpinid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaTypes<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MediaTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Connect<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Connect(::core::mem::transmute(&ppin)).into()
        }
        unsafe extern "system" fn ConnectDirect<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConnectDirect(::core::mem::transmute(&ppin)).into()
        }
        unsafe extern "system" fn ConnectWithType<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppin: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConnectWithType(::core::mem::transmute(&ppin), ::core::mem::transmute(&pmediatype)).into()
        }
        unsafe extern "system" fn Disconnect<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Disconnect().into()
        }
        unsafe extern "system" fn Render<Impl: IPinInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Render().into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Pin: Pin::<Impl, IMPL_OFFSET>,
            ConnectedTo: ConnectedTo::<Impl, IMPL_OFFSET>,
            ConnectionMediaType: ConnectionMediaType::<Impl, IMPL_OFFSET>,
            FilterInfo: FilterInfo::<Impl, IMPL_OFFSET>,
            Name: Name::<Impl, IMPL_OFFSET>,
            Direction: Direction::<Impl, IMPL_OFFSET>,
            PinID: PinID::<Impl, IMPL_OFFSET>,
            MediaTypes: MediaTypes::<Impl, IMPL_OFFSET>,
            Connect: Connect::<Impl, IMPL_OFFSET>,
            ConnectDirect: ConnectDirect::<Impl, IMPL_OFFSET>,
            ConnectWithType: ConnectWithType::<Impl, IMPL_OFFSET>,
            Disconnect: Disconnect::<Impl, IMPL_OFFSET>,
            Render: Render::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPinInfo as ::windows::core::Interface>::IID
    }
}
pub trait IQualProp_Impl: Sized {
    fn FramesDroppedInRenderer(&mut self) -> ::windows::core::Result<i32>;
    fn FramesDrawn(&mut self) -> ::windows::core::Result<i32>;
    fn AvgFrameRate(&mut self) -> ::windows::core::Result<i32>;
    fn Jitter(&mut self) -> ::windows::core::Result<i32>;
    fn AvgSyncOffset(&mut self) -> ::windows::core::Result<i32>;
    fn DevSyncOffset(&mut self) -> ::windows::core::Result<i32>;
}
impl IQualProp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IQualProp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IQualProp_Vtbl {
        unsafe extern "system" fn FramesDroppedInRenderer<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcframes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FramesDroppedInRenderer() {
                ::core::result::Result::Ok(ok__) => {
                    *pcframes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FramesDrawn<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcframesdrawn: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FramesDrawn() {
                ::core::result::Result::Ok(ok__) => {
                    *pcframesdrawn = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AvgFrameRate<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piavgframerate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvgFrameRate() {
                ::core::result::Result::Ok(ok__) => {
                    *piavgframerate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Jitter<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ijitter: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Jitter() {
                ::core::result::Result::Ok(ok__) => {
                    *ijitter = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AvgSyncOffset<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piavg: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AvgSyncOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *piavg = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DevSyncOffset<Impl: IQualProp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pidev: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DevSyncOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *pidev = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            FramesDroppedInRenderer: FramesDroppedInRenderer::<Impl, IMPL_OFFSET>,
            FramesDrawn: FramesDrawn::<Impl, IMPL_OFFSET>,
            AvgFrameRate: AvgFrameRate::<Impl, IMPL_OFFSET>,
            Jitter: Jitter::<Impl, IMPL_OFFSET>,
            AvgSyncOffset: AvgSyncOffset::<Impl, IMPL_OFFSET>,
            DevSyncOffset: DevSyncOffset::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IQualProp as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IQualityControl_Impl: Sized {
    fn Notify(&mut self, pself: &::core::option::Option<IBaseFilter>, q: &Quality) -> ::windows::core::Result<()>;
    fn SetSink(&mut self, piqc: &::core::option::Option<IQualityControl>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IQualityControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IQualityControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IQualityControl_Vtbl {
        unsafe extern "system" fn Notify<Impl: IQualityControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pself: ::windows::core::RawPtr, q: Quality) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Notify(::core::mem::transmute(&pself), ::core::mem::transmute_copy(&q)).into()
        }
        unsafe extern "system" fn SetSink<Impl: IQualityControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piqc: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSink(::core::mem::transmute(&piqc)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Notify: Notify::<Impl, IMPL_OFFSET>, SetSink: SetSink::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IQualityControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IQueueCommand_Impl: Sized {
    fn InvokeAtStreamTime(&mut self, pcmd: *mut ::core::option::Option<IDeferredCommand>, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::Result<()>;
    fn InvokeAtPresentationTime(&mut self, pcmd: *mut ::core::option::Option<IDeferredCommand>, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IQueueCommand_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IQueueCommand_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IQueueCommand_Vtbl {
        unsafe extern "system" fn InvokeAtStreamTime<Impl: IQueueCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcmd: *mut ::windows::core::RawPtr, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InvokeAtStreamTime(::core::mem::transmute_copy(&pcmd), ::core::mem::transmute_copy(&time), ::core::mem::transmute_copy(&iid), ::core::mem::transmute_copy(&dispidmethod), ::core::mem::transmute_copy(&wflags), ::core::mem::transmute_copy(&cargs), ::core::mem::transmute_copy(&pdispparams), ::core::mem::transmute_copy(&pvarresult), ::core::mem::transmute_copy(&puargerr)).into()
        }
        unsafe extern "system" fn InvokeAtPresentationTime<Impl: IQueueCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcmd: *mut ::windows::core::RawPtr, time: f64, iid: *const ::windows::core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Com::VARIANT, pvarresult: *mut super::super::System::Com::VARIANT, puargerr: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InvokeAtPresentationTime(::core::mem::transmute_copy(&pcmd), ::core::mem::transmute_copy(&time), ::core::mem::transmute_copy(&iid), ::core::mem::transmute_copy(&dispidmethod), ::core::mem::transmute_copy(&wflags), ::core::mem::transmute_copy(&cargs), ::core::mem::transmute_copy(&pdispparams), ::core::mem::transmute_copy(&pvarresult), ::core::mem::transmute_copy(&puargerr)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InvokeAtStreamTime: InvokeAtStreamTime::<Impl, IMPL_OFFSET>,
            InvokeAtPresentationTime: InvokeAtPresentationTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IQueueCommand as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IRegFilterInfo_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Name(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Filter(&mut self) -> ::windows::core::Result<super::super::System::Com::IDispatch>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IRegFilterInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRegFilterInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRegFilterInfo_Vtbl {
        unsafe extern "system" fn Name<Impl: IRegFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strname: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Name() {
                ::core::result::Result::Ok(ok__) => {
                    *strname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Filter<Impl: IRegFilterInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunk: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Filter() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunk = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Name: Name::<Impl, IMPL_OFFSET>,
            Filter: Filter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRegFilterInfo as ::windows::core::Interface>::IID
    }
}
pub trait IRegisterServiceProvider_Impl: Sized {
    fn RegisterService(&mut self, guidservice: *const ::windows::core::GUID, punkobject: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IRegisterServiceProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRegisterServiceProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRegisterServiceProvider_Vtbl {
        unsafe extern "system" fn RegisterService<Impl: IRegisterServiceProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidservice: *const ::windows::core::GUID, punkobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterService(::core::mem::transmute_copy(&guidservice), ::core::mem::transmute(&punkobject)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), RegisterService: RegisterService::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRegisterServiceProvider as ::windows::core::Interface>::IID
    }
}
pub trait IRegisterTuner_Impl: Sized {
    fn Register(&mut self, ptuner: &::core::option::Option<ITuner>, pgraph: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
    fn Unregister(&mut self) -> ::windows::core::Result<()>;
}
impl IRegisterTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IRegisterTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IRegisterTuner_Vtbl {
        unsafe extern "system" fn Register<Impl: IRegisterTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptuner: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Register(::core::mem::transmute(&ptuner), ::core::mem::transmute(&pgraph)).into()
        }
        unsafe extern "system" fn Unregister<Impl: IRegisterTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unregister().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Register: Register::<Impl, IMPL_OFFSET>,
            Unregister: Unregister::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IRegisterTuner as ::windows::core::Interface>::IID
    }
}
pub trait IResourceConsumer_Impl: Sized {
    fn AcquireResource(&mut self, idresource: i32) -> ::windows::core::Result<()>;
    fn ReleaseResource(&mut self, idresource: i32) -> ::windows::core::Result<()>;
}
impl IResourceConsumer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IResourceConsumer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IResourceConsumer_Vtbl {
        unsafe extern "system" fn AcquireResource<Impl: IResourceConsumer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AcquireResource(::core::mem::transmute_copy(&idresource)).into()
        }
        unsafe extern "system" fn ReleaseResource<Impl: IResourceConsumer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseResource(::core::mem::transmute_copy(&idresource)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AcquireResource: AcquireResource::<Impl, IMPL_OFFSET>,
            ReleaseResource: ReleaseResource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IResourceConsumer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IResourceManager_Impl: Sized {
    fn Register(&mut self, pname: super::super::Foundation::PWSTR, cresource: i32) -> ::windows::core::Result<i32>;
    fn RegisterGroup(&mut self, pname: super::super::Foundation::PWSTR, cresource: i32, paltokens: *const i32) -> ::windows::core::Result<i32>;
    fn RequestResource(&mut self, idresource: i32, pfocusobject: &::core::option::Option<::windows::core::IUnknown>, pconsumer: &::core::option::Option<IResourceConsumer>) -> ::windows::core::Result<()>;
    fn NotifyAcquire(&mut self, idresource: i32, pconsumer: &::core::option::Option<IResourceConsumer>, hr: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn NotifyRelease(&mut self, idresource: i32, pconsumer: &::core::option::Option<IResourceConsumer>, bstillwant: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn CancelRequest(&mut self, idresource: i32, pconsumer: &::core::option::Option<IResourceConsumer>) -> ::windows::core::Result<()>;
    fn SetFocus(&mut self, pfocusobject: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn ReleaseFocus(&mut self, pfocusobject: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IResourceManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IResourceManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IResourceManager_Vtbl {
        unsafe extern "system" fn Register<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, cresource: i32, pltoken: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Register(::core::mem::transmute_copy(&pname), ::core::mem::transmute_copy(&cresource)) {
                ::core::result::Result::Ok(ok__) => {
                    *pltoken = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterGroup<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pname: super::super::Foundation::PWSTR, cresource: i32, paltokens: *const i32, pltoken: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RegisterGroup(::core::mem::transmute_copy(&pname), ::core::mem::transmute_copy(&cresource), ::core::mem::transmute_copy(&paltokens)) {
                ::core::result::Result::Ok(ok__) => {
                    *pltoken = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestResource<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32, pfocusobject: *mut ::core::ffi::c_void, pconsumer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestResource(::core::mem::transmute_copy(&idresource), ::core::mem::transmute(&pfocusobject), ::core::mem::transmute(&pconsumer)).into()
        }
        unsafe extern "system" fn NotifyAcquire<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr, hr: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyAcquire(::core::mem::transmute_copy(&idresource), ::core::mem::transmute(&pconsumer), ::core::mem::transmute_copy(&hr)).into()
        }
        unsafe extern "system" fn NotifyRelease<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr, bstillwant: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyRelease(::core::mem::transmute_copy(&idresource), ::core::mem::transmute(&pconsumer), ::core::mem::transmute_copy(&bstillwant)).into()
        }
        unsafe extern "system" fn CancelRequest<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idresource: i32, pconsumer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelRequest(::core::mem::transmute_copy(&idresource), ::core::mem::transmute(&pconsumer)).into()
        }
        unsafe extern "system" fn SetFocus<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfocusobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFocus(::core::mem::transmute(&pfocusobject)).into()
        }
        unsafe extern "system" fn ReleaseFocus<Impl: IResourceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfocusobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseFocus(::core::mem::transmute(&pfocusobject)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Register: Register::<Impl, IMPL_OFFSET>,
            RegisterGroup: RegisterGroup::<Impl, IMPL_OFFSET>,
            RequestResource: RequestResource::<Impl, IMPL_OFFSET>,
            NotifyAcquire: NotifyAcquire::<Impl, IMPL_OFFSET>,
            NotifyRelease: NotifyRelease::<Impl, IMPL_OFFSET>,
            CancelRequest: CancelRequest::<Impl, IMPL_OFFSET>,
            SetFocus: SetFocus::<Impl, IMPL_OFFSET>,
            ReleaseFocus: ReleaseFocus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IResourceManager as ::windows::core::Interface>::IID
    }
}
pub trait ISBE2Crossbar_Impl: Sized {
    fn EnableDefaultMode(&mut self, defaultflags: u32) -> ::windows::core::Result<()>;
    fn GetInitialProfile(&mut self) -> ::windows::core::Result<ISBE2MediaTypeProfile>;
    fn SetOutputProfile(&mut self, pprofile: &::core::option::Option<ISBE2MediaTypeProfile>, pcoutputpins: *mut u32, ppoutputpins: *mut ::core::option::Option<IPin>) -> ::windows::core::Result<()>;
    fn EnumStreams(&mut self) -> ::windows::core::Result<ISBE2EnumStream>;
}
impl ISBE2Crossbar_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2Crossbar_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2Crossbar_Vtbl {
        unsafe extern "system" fn EnableDefaultMode<Impl: ISBE2Crossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, defaultflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableDefaultMode(::core::mem::transmute_copy(&defaultflags)).into()
        }
        unsafe extern "system" fn GetInitialProfile<Impl: ISBE2Crossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInitialProfile() {
                ::core::result::Result::Ok(ok__) => {
                    *ppprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputProfile<Impl: ISBE2Crossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr, pcoutputpins: *mut u32, ppoutputpins: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputProfile(::core::mem::transmute(&pprofile), ::core::mem::transmute_copy(&pcoutputpins), ::core::mem::transmute_copy(&ppoutputpins)).into()
        }
        unsafe extern "system" fn EnumStreams<Impl: ISBE2Crossbar_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppstreams: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            EnableDefaultMode: EnableDefaultMode::<Impl, IMPL_OFFSET>,
            GetInitialProfile: GetInitialProfile::<Impl, IMPL_OFFSET>,
            SetOutputProfile: SetOutputProfile::<Impl, IMPL_OFFSET>,
            EnumStreams: EnumStreams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2Crossbar as ::windows::core::Interface>::IID
    }
}
pub trait ISBE2EnumStream_Impl: Sized {
    fn Next(&mut self, crequest: u32, pstreamdesc: *mut SBE2_STREAM_DESC, pcreceived: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&mut self, crecords: u32) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<ISBE2EnumStream>;
}
impl ISBE2EnumStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2EnumStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2EnumStream_Vtbl {
        unsafe extern "system" fn Next<Impl: ISBE2EnumStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crequest: u32, pstreamdesc: *mut SBE2_STREAM_DESC, pcreceived: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Next(::core::mem::transmute_copy(&crequest), ::core::mem::transmute_copy(&pstreamdesc), ::core::mem::transmute_copy(&pcreceived)).into()
        }
        unsafe extern "system" fn Skip<Impl: ISBE2EnumStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crecords: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Skip(::core::mem::transmute_copy(&crecords)).into()
        }
        unsafe extern "system" fn Reset<Impl: ISBE2EnumStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        unsafe extern "system" fn Clone<Impl: ISBE2EnumStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Next: Next::<Impl, IMPL_OFFSET>,
            Skip: Skip::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2EnumStream as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISBE2FileScan_Impl: Sized {
    fn RepairFile(&mut self, filename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISBE2FileScan_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2FileScan_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2FileScan_Vtbl {
        unsafe extern "system" fn RepairFile<Impl: ISBE2FileScan_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RepairFile(::core::mem::transmute_copy(&filename)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), RepairFile: RepairFile::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2FileScan as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISBE2GlobalEvent_Impl: Sized {
    fn GetEvent(&mut self, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISBE2GlobalEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2GlobalEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2GlobalEvent_Vtbl {
        unsafe extern "system" fn GetEvent<Impl: ISBE2GlobalEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEvent(::core::mem::transmute_copy(&idevt), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2), ::core::mem::transmute_copy(&param3), ::core::mem::transmute_copy(&param4), ::core::mem::transmute_copy(&pspanning), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetEvent: GetEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2GlobalEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISBE2GlobalEvent2_Impl: Sized + ISBE2GlobalEvent_Impl {
    fn GetEventEx(&mut self, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8, pstreamtime: *mut i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISBE2GlobalEvent2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2GlobalEvent2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2GlobalEvent2_Vtbl {
        unsafe extern "system" fn GetEventEx<Impl: ISBE2GlobalEvent2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8, pstreamtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEventEx(::core::mem::transmute_copy(&idevt), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2), ::core::mem::transmute_copy(&param3), ::core::mem::transmute_copy(&param4), ::core::mem::transmute_copy(&pspanning), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&pstreamtime)).into()
        }
        Self { base: ISBE2GlobalEvent_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetEventEx: GetEventEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2GlobalEvent2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISBE2MediaTypeProfile_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStream(&mut self, index: u32) -> ::windows::core::Result<*mut AM_MEDIA_TYPE>;
    fn AddStream(&mut self, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn DeleteStream(&mut self, index: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISBE2MediaTypeProfile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2MediaTypeProfile_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2MediaTypeProfile_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: ISBE2MediaTypeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: ISBE2MediaTypeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ppmediatype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStream(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStream<Impl: ISBE2MediaTypeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: *const AM_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddStream(::core::mem::transmute_copy(&pmediatype)).into()
        }
        unsafe extern "system" fn DeleteStream<Impl: ISBE2MediaTypeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteStream(::core::mem::transmute_copy(&index)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetStream: GetStream::<Impl, IMPL_OFFSET>,
            AddStream: AddStream::<Impl, IMPL_OFFSET>,
            DeleteStream: DeleteStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2MediaTypeProfile as ::windows::core::Interface>::IID
    }
}
pub trait ISBE2SpanningEvent_Impl: Sized {
    fn GetEvent(&mut self, idevt: *const ::windows::core::GUID, streamid: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()>;
}
impl ISBE2SpanningEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2SpanningEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2SpanningEvent_Vtbl {
        unsafe extern "system" fn GetEvent<Impl: ISBE2SpanningEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, idevt: *const ::windows::core::GUID, streamid: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEvent(::core::mem::transmute_copy(&idevt), ::core::mem::transmute_copy(&streamid), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetEvent: GetEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2SpanningEvent as ::windows::core::Interface>::IID
    }
}
pub trait ISBE2StreamMap_Impl: Sized {
    fn MapStream(&mut self, stream: u32) -> ::windows::core::Result<()>;
    fn UnmapStream(&mut self, stream: u32) -> ::windows::core::Result<()>;
    fn EnumMappedStreams(&mut self) -> ::windows::core::Result<ISBE2EnumStream>;
}
impl ISBE2StreamMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISBE2StreamMap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISBE2StreamMap_Vtbl {
        unsafe extern "system" fn MapStream<Impl: ISBE2StreamMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MapStream(::core::mem::transmute_copy(&stream)).into()
        }
        unsafe extern "system" fn UnmapStream<Impl: ISBE2StreamMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stream: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnmapStream(::core::mem::transmute_copy(&stream)).into()
        }
        unsafe extern "system" fn EnumMappedStreams<Impl: ISBE2StreamMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppstreams: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumMappedStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            MapStream: MapStream::<Impl, IMPL_OFFSET>,
            UnmapStream: UnmapStream::<Impl, IMPL_OFFSET>,
            EnumMappedStreams: EnumMappedStreams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISBE2StreamMap as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISCTE_EAS_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetSequencyNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetProtocolVersion(&mut self) -> ::windows::core::Result<u8>;
    fn GetEASEventID(&mut self) -> ::windows::core::Result<u16>;
    fn GetOriginatorCode(&mut self) -> ::windows::core::Result<u8>;
    fn GetEASEventCodeLen(&mut self) -> ::windows::core::Result<u8>;
    fn GetEASEventCode(&mut self) -> ::windows::core::Result<u8>;
    fn GetRawNatureOfActivationTextLen(&mut self) -> ::windows::core::Result<u8>;
    fn GetRawNatureOfActivationText(&mut self) -> ::windows::core::Result<u8>;
    fn GetNatureOfActivationText(&mut self, bstris0639code: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetTimeRemaining(&mut self) -> ::windows::core::Result<u8>;
    fn GetStartTime(&mut self) -> ::windows::core::Result<u32>;
    fn GetDuration(&mut self) -> ::windows::core::Result<u16>;
    fn GetAlertPriority(&mut self) -> ::windows::core::Result<u8>;
    fn GetDetailsOOBSourceID(&mut self) -> ::windows::core::Result<u16>;
    fn GetDetailsMajor(&mut self) -> ::windows::core::Result<u16>;
    fn GetDetailsMinor(&mut self) -> ::windows::core::Result<u16>;
    fn GetDetailsAudioOOBSourceID(&mut self) -> ::windows::core::Result<u16>;
    fn GetAlertText(&mut self, bstris0639code: &super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetRawAlertTextLen(&mut self) -> ::windows::core::Result<u16>;
    fn GetRawAlertText(&mut self) -> ::windows::core::Result<u8>;
    fn GetLocationCount(&mut self) -> ::windows::core::Result<u8>;
    fn GetLocationCodes(&mut self, bindex: u8, pbstate: *mut u8, pbcountysubdivision: *mut u8, pwcounty: *mut u16) -> ::windows::core::Result<()>;
    fn GetExceptionCount(&mut self) -> ::windows::core::Result<u8>;
    fn GetExceptionService(&mut self, bindex: u8, pbibref: *mut u8, pwfirst: *mut u16, pwsecond: *mut u16) -> ::windows::core::Result<()>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISCTE_EAS_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISCTE_EAS_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISCTE_EAS_Vtbl {
        unsafe extern "system" fn Initialize<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSequencyNumber<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSequencyNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtocolVersion<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProtocolVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventID<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEASEventID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorCode<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginatorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventCodeLen<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEASEventCodeLen() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEASEventCode<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEASEventCode() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawNatureOfActivationTextLen<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRawNatureOfActivationTextLen() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawNatureOfActivationText<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRawNatureOfActivationText() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNatureOfActivationText<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstris0639code: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNatureOfActivationText(::core::mem::transmute_copy(&bstris0639code)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrstring = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeRemaining<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimeRemaining() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartTime<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStartTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlertPriority<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlertPriority() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsOOBSourceID<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDetailsOOBSourceID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsMajor<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDetailsMajor() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsMinor<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDetailsMinor() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDetailsAudioOOBSourceID<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDetailsAudioOOBSourceID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlertText<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstris0639code: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbstrstring: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlertText(::core::mem::transmute_copy(&bstris0639code)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbstrstring = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawAlertTextLen<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRawAlertTextLen() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRawAlertText<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRawAlertText() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLocationCount<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLocationCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLocationCodes<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbstate: *mut u8, pbcountysubdivision: *mut u8, pwcounty: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLocationCodes(::core::mem::transmute_copy(&bindex), ::core::mem::transmute_copy(&pbstate), ::core::mem::transmute_copy(&pbcountysubdivision), ::core::mem::transmute_copy(&pwcounty)).into()
        }
        unsafe extern "system" fn GetExceptionCount<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExceptionCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExceptionService<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbibref: *mut u8, pwfirst: *mut u16, pwsecond: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExceptionService(::core::mem::transmute_copy(&bindex), ::core::mem::transmute_copy(&pbibref), ::core::mem::transmute_copy(&pwfirst), ::core::mem::transmute_copy(&pwsecond)).into()
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ISCTE_EAS_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetSequencyNumber: GetSequencyNumber::<Impl, IMPL_OFFSET>,
            GetProtocolVersion: GetProtocolVersion::<Impl, IMPL_OFFSET>,
            GetEASEventID: GetEASEventID::<Impl, IMPL_OFFSET>,
            GetOriginatorCode: GetOriginatorCode::<Impl, IMPL_OFFSET>,
            GetEASEventCodeLen: GetEASEventCodeLen::<Impl, IMPL_OFFSET>,
            GetEASEventCode: GetEASEventCode::<Impl, IMPL_OFFSET>,
            GetRawNatureOfActivationTextLen: GetRawNatureOfActivationTextLen::<Impl, IMPL_OFFSET>,
            GetRawNatureOfActivationText: GetRawNatureOfActivationText::<Impl, IMPL_OFFSET>,
            GetNatureOfActivationText: GetNatureOfActivationText::<Impl, IMPL_OFFSET>,
            GetTimeRemaining: GetTimeRemaining::<Impl, IMPL_OFFSET>,
            GetStartTime: GetStartTime::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            GetAlertPriority: GetAlertPriority::<Impl, IMPL_OFFSET>,
            GetDetailsOOBSourceID: GetDetailsOOBSourceID::<Impl, IMPL_OFFSET>,
            GetDetailsMajor: GetDetailsMajor::<Impl, IMPL_OFFSET>,
            GetDetailsMinor: GetDetailsMinor::<Impl, IMPL_OFFSET>,
            GetDetailsAudioOOBSourceID: GetDetailsAudioOOBSourceID::<Impl, IMPL_OFFSET>,
            GetAlertText: GetAlertText::<Impl, IMPL_OFFSET>,
            GetRawAlertTextLen: GetRawAlertTextLen::<Impl, IMPL_OFFSET>,
            GetRawAlertText: GetRawAlertText::<Impl, IMPL_OFFSET>,
            GetLocationCount: GetLocationCount::<Impl, IMPL_OFFSET>,
            GetLocationCodes: GetLocationCodes::<Impl, IMPL_OFFSET>,
            GetExceptionCount: GetExceptionCount::<Impl, IMPL_OFFSET>,
            GetExceptionService: GetExceptionService::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISCTE_EAS as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISIInbandEPG_Impl: Sized {
    fn StartSIEPGScan(&mut self) -> ::windows::core::Result<()>;
    fn StopSIEPGScan(&mut self) -> ::windows::core::Result<()>;
    fn IsSIEPGScanRunning(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISIInbandEPG_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISIInbandEPG_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISIInbandEPG_Vtbl {
        unsafe extern "system" fn StartSIEPGScan<Impl: ISIInbandEPG_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartSIEPGScan().into()
        }
        unsafe extern "system" fn StopSIEPGScan<Impl: ISIInbandEPG_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopSIEPGScan().into()
        }
        unsafe extern "system" fn IsSIEPGScanRunning<Impl: ISIInbandEPG_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, brunning: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSIEPGScanRunning() {
                ::core::result::Result::Ok(ok__) => {
                    *brunning = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartSIEPGScan: StartSIEPGScan::<Impl, IMPL_OFFSET>,
            StopSIEPGScan: StopSIEPGScan::<Impl, IMPL_OFFSET>,
            IsSIEPGScanRunning: IsSIEPGScanRunning::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISIInbandEPG as ::windows::core::Interface>::IID
    }
}
pub trait ISIInbandEPGEvent_Impl: Sized {
    fn SIObjectEvent(&mut self, pidvb_eit: &::core::option::Option<IDVB_EIT2>, dwtable_id: u32, dwservice_id: u32) -> ::windows::core::Result<()>;
}
impl ISIInbandEPGEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISIInbandEPGEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISIInbandEPGEvent_Vtbl {
        unsafe extern "system" fn SIObjectEvent<Impl: ISIInbandEPGEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pidvb_eit: ::windows::core::RawPtr, dwtable_id: u32, dwservice_id: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SIObjectEvent(::core::mem::transmute(&pidvb_eit), ::core::mem::transmute_copy(&dwtable_id), ::core::mem::transmute_copy(&dwservice_id)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SIObjectEvent: SIObjectEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISIInbandEPGEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IScanningTuner_Impl: Sized + ITuner_Impl {
    fn SeekUp(&mut self) -> ::windows::core::Result<()>;
    fn SeekDown(&mut self) -> ::windows::core::Result<()>;
    fn ScanUp(&mut self, millisecondspause: i32) -> ::windows::core::Result<()>;
    fn ScanDown(&mut self, millisecondspause: i32) -> ::windows::core::Result<()>;
    fn AutoProgram(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IScanningTuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScanningTuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScanningTuner_Vtbl {
        unsafe extern "system" fn SeekUp<Impl: IScanningTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SeekUp().into()
        }
        unsafe extern "system" fn SeekDown<Impl: IScanningTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SeekDown().into()
        }
        unsafe extern "system" fn ScanUp<Impl: IScanningTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, millisecondspause: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScanUp(::core::mem::transmute_copy(&millisecondspause)).into()
        }
        unsafe extern "system" fn ScanDown<Impl: IScanningTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, millisecondspause: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ScanDown(::core::mem::transmute_copy(&millisecondspause)).into()
        }
        unsafe extern "system" fn AutoProgram<Impl: IScanningTuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AutoProgram().into()
        }
        Self {
            base: ITuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SeekUp: SeekUp::<Impl, IMPL_OFFSET>,
            SeekDown: SeekDown::<Impl, IMPL_OFFSET>,
            ScanUp: ScanUp::<Impl, IMPL_OFFSET>,
            ScanDown: ScanDown::<Impl, IMPL_OFFSET>,
            AutoProgram: AutoProgram::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScanningTuner as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IScanningTunerEx_Impl: Sized + ITuner_Impl + IScanningTuner_Impl {
    fn GetCurrentLocator(&mut self, pilocator: *const ::core::option::Option<ILocator>) -> ::windows::core::Result<()>;
    fn PerformExhaustiveScan(&mut self, dwlowerfreq: i32, dwhigherfreq: i32, bfinetune: i16, hevent: usize) -> ::windows::core::Result<()>;
    fn TerminateCurrentScan(&mut self) -> ::windows::core::Result<i32>;
    fn ResumeCurrentScan(&mut self, hevent: usize) -> ::windows::core::Result<()>;
    fn GetTunerScanningCapability(&mut self, hardwareassistedscanning: *mut i32, numstandardssupported: *mut i32, broadcaststandards: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetTunerStatus(&mut self, secondsleft: *mut i32, currentlocktype: *mut i32, autodetect: *mut i32, currentfreq: *mut i32) -> ::windows::core::Result<()>;
    fn GetCurrentTunerStandardCapability(&mut self, currentbroadcaststandard: &::windows::core::GUID, settlingtime: *mut i32, tvstandardssupported: *mut i32) -> ::windows::core::Result<()>;
    fn SetScanSignalTypeFilter(&mut self, scanmodulationtypes: i32, analogvideostandard: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IScanningTunerEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IScanningTunerEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IScanningTunerEx_Vtbl {
        unsafe extern "system" fn GetCurrentLocator<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pilocator: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentLocator(::core::mem::transmute_copy(&pilocator)).into()
        }
        unsafe extern "system" fn PerformExhaustiveScan<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwlowerfreq: i32, dwhigherfreq: i32, bfinetune: i16, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PerformExhaustiveScan(::core::mem::transmute_copy(&dwlowerfreq), ::core::mem::transmute_copy(&dwhigherfreq), ::core::mem::transmute_copy(&bfinetune), ::core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn TerminateCurrentScan<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcurrentfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TerminateCurrentScan() {
                ::core::result::Result::Ok(ok__) => {
                    *pcurrentfreq = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResumeCurrentScan<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hevent: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResumeCurrentScan(::core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn GetTunerScanningCapability<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hardwareassistedscanning: *mut i32, numstandardssupported: *mut i32, broadcaststandards: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTunerScanningCapability(::core::mem::transmute_copy(&hardwareassistedscanning), ::core::mem::transmute_copy(&numstandardssupported), ::core::mem::transmute_copy(&broadcaststandards)).into()
        }
        unsafe extern "system" fn GetTunerStatus<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, secondsleft: *mut i32, currentlocktype: *mut i32, autodetect: *mut i32, currentfreq: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTunerStatus(::core::mem::transmute_copy(&secondsleft), ::core::mem::transmute_copy(&currentlocktype), ::core::mem::transmute_copy(&autodetect), ::core::mem::transmute_copy(&currentfreq)).into()
        }
        unsafe extern "system" fn GetCurrentTunerStandardCapability<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentbroadcaststandard: ::windows::core::GUID, settlingtime: *mut i32, tvstandardssupported: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentTunerStandardCapability(::core::mem::transmute_copy(&currentbroadcaststandard), ::core::mem::transmute_copy(&settlingtime), ::core::mem::transmute_copy(&tvstandardssupported)).into()
        }
        unsafe extern "system" fn SetScanSignalTypeFilter<Impl: IScanningTunerEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scanmodulationtypes: i32, analogvideostandard: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetScanSignalTypeFilter(::core::mem::transmute_copy(&scanmodulationtypes), ::core::mem::transmute_copy(&analogvideostandard)).into()
        }
        Self {
            base: IScanningTuner_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetCurrentLocator: GetCurrentLocator::<Impl, IMPL_OFFSET>,
            PerformExhaustiveScan: PerformExhaustiveScan::<Impl, IMPL_OFFSET>,
            TerminateCurrentScan: TerminateCurrentScan::<Impl, IMPL_OFFSET>,
            ResumeCurrentScan: ResumeCurrentScan::<Impl, IMPL_OFFSET>,
            GetTunerScanningCapability: GetTunerScanningCapability::<Impl, IMPL_OFFSET>,
            GetTunerStatus: GetTunerStatus::<Impl, IMPL_OFFSET>,
            GetCurrentTunerStandardCapability: GetCurrentTunerStandardCapability::<Impl, IMPL_OFFSET>,
            SetScanSignalTypeFilter: SetScanSignalTypeFilter::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IScanningTunerEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISectionList_Impl: Sized {
    fn Initialize(&mut self, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: &::core::option::Option<IMpeg2Data>, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, timeout: u32, hdoneevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn InitializeWithRawSections(&mut self, pmplsections: *const MPEG_PACKET_LIST) -> ::windows::core::Result<()>;
    fn CancelPendingRequest(&mut self) -> ::windows::core::Result<()>;
    fn GetNumberOfSections(&mut self) -> ::windows::core::Result<u16>;
    fn GetSectionData(&mut self, sectionnumber: u16, pdwrawpacketlength: *mut u32, ppsection: *mut *mut SECTION) -> ::windows::core::Result<()>;
    fn GetProgramIdentifier(&mut self, ppid: *const u16) -> ::windows::core::Result<()>;
    fn GetTableIdentifier(&mut self, ptableid: *const u8) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISectionList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISectionList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISectionList_Vtbl {
        unsafe extern "system" fn Initialize<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, requesttype: MPEG_REQUEST_TYPE, pmpeg2data: ::windows::core::RawPtr, pcontext: *const MPEG_CONTEXT, pid: u16, tid: u8, pfilter: *const MPEG2_FILTER, timeout: u32, hdoneevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&requesttype), ::core::mem::transmute(&pmpeg2data), ::core::mem::transmute_copy(&pcontext), ::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&tid), ::core::mem::transmute_copy(&pfilter), ::core::mem::transmute_copy(&timeout), ::core::mem::transmute_copy(&hdoneevent)).into()
        }
        unsafe extern "system" fn InitializeWithRawSections<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmplsections: *const MPEG_PACKET_LIST) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeWithRawSections(::core::mem::transmute_copy(&pmplsections)).into()
        }
        unsafe extern "system" fn CancelPendingRequest<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelPendingRequest().into()
        }
        unsafe extern "system" fn GetNumberOfSections<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcount: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfSections() {
                ::core::result::Result::Ok(ok__) => {
                    *pcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSectionData<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sectionnumber: u16, pdwrawpacketlength: *mut u32, ppsection: *mut *mut SECTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSectionData(::core::mem::transmute_copy(&sectionnumber), ::core::mem::transmute_copy(&pdwrawpacketlength), ::core::mem::transmute_copy(&ppsection)).into()
        }
        unsafe extern "system" fn GetProgramIdentifier<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppid: *const u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProgramIdentifier(::core::mem::transmute_copy(&ppid)).into()
        }
        unsafe extern "system" fn GetTableIdentifier<Impl: ISectionList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptableid: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableIdentifier(::core::mem::transmute_copy(&ptableid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            InitializeWithRawSections: InitializeWithRawSections::<Impl, IMPL_OFFSET>,
            CancelPendingRequest: CancelPendingRequest::<Impl, IMPL_OFFSET>,
            GetNumberOfSections: GetNumberOfSections::<Impl, IMPL_OFFSET>,
            GetSectionData: GetSectionData::<Impl, IMPL_OFFSET>,
            GetProgramIdentifier: GetProgramIdentifier::<Impl, IMPL_OFFSET>,
            GetTableIdentifier: GetTableIdentifier::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISectionList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ISeekingPassThru_Impl: Sized {
    fn Init(&mut self, bsupportrendering: super::super::Foundation::BOOL, ppin: &::core::option::Option<IPin>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ISeekingPassThru_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISeekingPassThru_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISeekingPassThru_Vtbl {
        unsafe extern "system" fn Init<Impl: ISeekingPassThru_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bsupportrendering: super::super::Foundation::BOOL, ppin: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Init(::core::mem::transmute_copy(&bsupportrendering), ::core::mem::transmute(&ppin)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Init: Init::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISeekingPassThru as ::windows::core::Interface>::IID
    }
}
pub trait ISelector_Impl: Sized {
    fn NumSources(&mut self) -> ::windows::core::Result<u32>;
    fn SourceNodeId(&mut self) -> ::windows::core::Result<u32>;
    fn SetSourceNodeId(&mut self, dwpinid: u32) -> ::windows::core::Result<()>;
}
impl ISelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISelector_Vtbl {
        unsafe extern "system" fn NumSources<Impl: ISelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumsources: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NumSources() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwnumsources = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceNodeId<Impl: ISelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwpinid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SourceNodeId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwpinid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceNodeId<Impl: ISelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwpinid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceNodeId(::core::mem::transmute_copy(&dwpinid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            NumSources: NumSources::<Impl, IMPL_OFFSET>,
            SourceNodeId: SourceNodeId::<Impl, IMPL_OFFSET>,
            SetSourceNodeId: SetSourceNodeId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISelector as ::windows::core::Interface>::IID
    }
}
pub trait IServiceLocationDescriptor_Impl: Sized {
    fn GetPCR_PID(&mut self) -> ::windows::core::Result<u16>;
    fn GetNumberOfElements(&mut self) -> ::windows::core::Result<u8>;
    fn GetElementStreamType(&mut self, bindex: u8) -> ::windows::core::Result<u8>;
    fn GetElementPID(&mut self, bindex: u8) -> ::windows::core::Result<u16>;
    fn GetElementLanguageCode(&mut self, bindex: u8, langcode: *mut u8) -> ::windows::core::Result<()>;
}
impl IServiceLocationDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IServiceLocationDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IServiceLocationDescriptor_Vtbl {
        unsafe extern "system" fn GetPCR_PID<Impl: IServiceLocationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPCR_PID() {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfElements<Impl: IServiceLocationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfElements() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementStreamType<Impl: IServiceLocationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetElementStreamType(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementPID<Impl: IServiceLocationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, pwval: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetElementPID(::core::mem::transmute_copy(&bindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElementLanguageCode<Impl: IServiceLocationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bindex: u8, langcode: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetElementLanguageCode(::core::mem::transmute_copy(&bindex), ::core::mem::transmute_copy(&langcode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPCR_PID: GetPCR_PID::<Impl, IMPL_OFFSET>,
            GetNumberOfElements: GetNumberOfElements::<Impl, IMPL_OFFSET>,
            GetElementStreamType: GetElementStreamType::<Impl, IMPL_OFFSET>,
            GetElementPID: GetElementPID::<Impl, IMPL_OFFSET>,
            GetElementLanguageCode: GetElementLanguageCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IServiceLocationDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Ole")]
pub trait ISpecifyParticularPages_Impl: Sized {
    fn GetPages(&mut self, guidwhatpages: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Ole::CAUUID>;
}
#[cfg(feature = "Win32_System_Ole")]
impl ISpecifyParticularPages_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ISpecifyParticularPages_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ISpecifyParticularPages_Vtbl {
        unsafe extern "system" fn GetPages<Impl: ISpecifyParticularPages_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidwhatpages: *const ::windows::core::GUID, ppages: *mut super::super::System::Ole::CAUUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPages(::core::mem::transmute_copy(&guidwhatpages)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppages = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetPages: GetPages::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ISpecifyParticularPages as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferConfigure_Impl: Sized {
    fn SetDirectory(&mut self, pszdirectoryname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetDirectory(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn SetBackingFileCount(&mut self, dwmin: u32, dwmax: u32) -> ::windows::core::Result<()>;
    fn GetBackingFileCount(&mut self, pdwmin: *mut u32, pdwmax: *mut u32) -> ::windows::core::Result<()>;
    fn SetBackingFileDuration(&mut self, dwseconds: u32) -> ::windows::core::Result<()>;
    fn GetBackingFileDuration(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferConfigure_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferConfigure_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferConfigure_Vtbl {
        unsafe extern "system" fn SetDirectory<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszdirectoryname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectory(::core::mem::transmute_copy(&pszdirectoryname)).into()
        }
        unsafe extern "system" fn GetDirectory<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszdirectoryname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectory() {
                ::core::result::Result::Ok(ok__) => {
                    *ppszdirectoryname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackingFileCount<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmin: u32, dwmax: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackingFileCount(::core::mem::transmute_copy(&dwmin), ::core::mem::transmute_copy(&dwmax)).into()
        }
        unsafe extern "system" fn GetBackingFileCount<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmin: *mut u32, pdwmax: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBackingFileCount(::core::mem::transmute_copy(&pdwmin), ::core::mem::transmute_copy(&pdwmax)).into()
        }
        unsafe extern "system" fn SetBackingFileDuration<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackingFileDuration(::core::mem::transmute_copy(&dwseconds)).into()
        }
        unsafe extern "system" fn GetBackingFileDuration<Impl: IStreamBufferConfigure_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBackingFileDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwseconds = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDirectory: SetDirectory::<Impl, IMPL_OFFSET>,
            GetDirectory: GetDirectory::<Impl, IMPL_OFFSET>,
            SetBackingFileCount: SetBackingFileCount::<Impl, IMPL_OFFSET>,
            GetBackingFileCount: GetBackingFileCount::<Impl, IMPL_OFFSET>,
            SetBackingFileDuration: SetBackingFileDuration::<Impl, IMPL_OFFSET>,
            GetBackingFileDuration: GetBackingFileDuration::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferConfigure as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferConfigure2_Impl: Sized + IStreamBufferConfigure_Impl {
    fn SetMultiplexedPacketSize(&mut self, cbbytesperpacket: u32) -> ::windows::core::Result<()>;
    fn GetMultiplexedPacketSize(&mut self) -> ::windows::core::Result<u32>;
    fn SetFFTransitionRates(&mut self, dwmaxfullframerate: u32, dwmaxnonskippingrate: u32) -> ::windows::core::Result<()>;
    fn GetFFTransitionRates(&mut self, pdwmaxfullframerate: *mut u32, pdwmaxnonskippingrate: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferConfigure2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferConfigure2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferConfigure2_Vtbl {
        unsafe extern "system" fn SetMultiplexedPacketSize<Impl: IStreamBufferConfigure2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbbytesperpacket: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMultiplexedPacketSize(::core::mem::transmute_copy(&cbbytesperpacket)).into()
        }
        unsafe extern "system" fn GetMultiplexedPacketSize<Impl: IStreamBufferConfigure2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbbytesperpacket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMultiplexedPacketSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbbytesperpacket = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFFTransitionRates<Impl: IStreamBufferConfigure2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxfullframerate: u32, dwmaxnonskippingrate: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFFTransitionRates(::core::mem::transmute_copy(&dwmaxfullframerate), ::core::mem::transmute_copy(&dwmaxnonskippingrate)).into()
        }
        unsafe extern "system" fn GetFFTransitionRates<Impl: IStreamBufferConfigure2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmaxfullframerate: *mut u32, pdwmaxnonskippingrate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFFTransitionRates(::core::mem::transmute_copy(&pdwmaxfullframerate), ::core::mem::transmute_copy(&pdwmaxnonskippingrate)).into()
        }
        Self {
            base: IStreamBufferConfigure_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetMultiplexedPacketSize: SetMultiplexedPacketSize::<Impl, IMPL_OFFSET>,
            GetMultiplexedPacketSize: GetMultiplexedPacketSize::<Impl, IMPL_OFFSET>,
            SetFFTransitionRates: SetFFTransitionRates::<Impl, IMPL_OFFSET>,
            GetFFTransitionRates: GetFFTransitionRates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferConfigure2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferConfigure3_Impl: Sized + IStreamBufferConfigure_Impl + IStreamBufferConfigure2_Impl {
    fn SetStartRecConfig(&mut self, fstartstopscur: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStartRecConfig(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetNamespace(&mut self, psznamespace: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetNamespace(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferConfigure3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferConfigure3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferConfigure3_Vtbl {
        unsafe extern "system" fn SetStartRecConfig<Impl: IStreamBufferConfigure3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fstartstopscur: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStartRecConfig(::core::mem::transmute_copy(&fstartstopscur)).into()
        }
        unsafe extern "system" fn GetStartRecConfig<Impl: IStreamBufferConfigure3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfstartstopscur: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStartRecConfig() {
                ::core::result::Result::Ok(ok__) => {
                    *pfstartstopscur = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNamespace<Impl: IStreamBufferConfigure3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psznamespace: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNamespace(::core::mem::transmute_copy(&psznamespace)).into()
        }
        unsafe extern "system" fn GetNamespace<Impl: IStreamBufferConfigure3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsznamespace: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNamespace() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsznamespace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IStreamBufferConfigure2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetStartRecConfig: SetStartRecConfig::<Impl, IMPL_OFFSET>,
            GetStartRecConfig: GetStartRecConfig::<Impl, IMPL_OFFSET>,
            SetNamespace: SetNamespace::<Impl, IMPL_OFFSET>,
            GetNamespace: GetNamespace::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferConfigure3 as ::windows::core::Interface>::IID
    }
}
pub trait IStreamBufferDataCounters_Impl: Sized {
    fn GetData(&mut self) -> ::windows::core::Result<SBE_PIN_DATA>;
    fn ResetData(&mut self) -> ::windows::core::Result<()>;
}
impl IStreamBufferDataCounters_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferDataCounters_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferDataCounters_Vtbl {
        unsafe extern "system" fn GetData<Impl: IStreamBufferDataCounters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppindata: *mut SBE_PIN_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetData() {
                ::core::result::Result::Ok(ok__) => {
                    *ppindata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetData<Impl: IStreamBufferDataCounters_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetData().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetData: GetData::<Impl, IMPL_OFFSET>,
            ResetData: ResetData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferDataCounters as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Registry"))]
pub trait IStreamBufferInitialize_Impl: Sized {
    fn SetHKEY(&mut self, hkeyroot: super::super::System::Registry::HKEY) -> ::windows::core::Result<()>;
    fn SetSIDs(&mut self, csids: u32, ppsid: *mut super::super::Foundation::PSID) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Registry"))]
impl IStreamBufferInitialize_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferInitialize_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferInitialize_Vtbl {
        unsafe extern "system" fn SetHKEY<Impl: IStreamBufferInitialize_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hkeyroot: super::super::System::Registry::HKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHKEY(::core::mem::transmute_copy(&hkeyroot)).into()
        }
        unsafe extern "system" fn SetSIDs<Impl: IStreamBufferInitialize_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, csids: u32, ppsid: *mut super::super::Foundation::PSID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSIDs(::core::mem::transmute_copy(&csids), ::core::mem::transmute_copy(&ppsid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetHKEY: SetHKEY::<Impl, IMPL_OFFSET>,
            SetSIDs: SetSIDs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferInitialize as ::windows::core::Interface>::IID
    }
}
pub trait IStreamBufferMediaSeeking_Impl: Sized + IMediaSeeking_Impl {}
impl IStreamBufferMediaSeeking_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferMediaSeeking_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferMediaSeeking_Vtbl {
        Self { base: IMediaSeeking_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferMediaSeeking as ::windows::core::Interface>::IID
    }
}
pub trait IStreamBufferMediaSeeking2_Impl: Sized + IMediaSeeking_Impl + IStreamBufferMediaSeeking_Impl {
    fn SetRateEx(&mut self, drate: f64, dwframespersec: u32) -> ::windows::core::Result<()>;
}
impl IStreamBufferMediaSeeking2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferMediaSeeking2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferMediaSeeking2_Vtbl {
        unsafe extern "system" fn SetRateEx<Impl: IStreamBufferMediaSeeking2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, drate: f64, dwframespersec: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRateEx(::core::mem::transmute_copy(&drate), ::core::mem::transmute_copy(&dwframespersec)).into()
        }
        Self { base: IStreamBufferMediaSeeking_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetRateEx: SetRateEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferMediaSeeking2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferRecComp_Impl: Sized {
    fn Initialize(&mut self, psztargetfilename: super::super::Foundation::PWSTR, pszsbrecprofileref: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn Append(&mut self, pszsbrecording: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn AppendEx(&mut self, pszsbrecording: super::super::Foundation::PWSTR, rtstart: i64, rtstop: i64) -> ::windows::core::Result<()>;
    fn GetCurrentLength(&mut self) -> ::windows::core::Result<u32>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Cancel(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferRecComp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferRecComp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferRecComp_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psztargetfilename: super::super::Foundation::PWSTR, pszsbrecprofileref: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&psztargetfilename), ::core::mem::transmute_copy(&pszsbrecprofileref)).into()
        }
        unsafe extern "system" fn Append<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszsbrecording: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Append(::core::mem::transmute_copy(&pszsbrecording)).into()
        }
        unsafe extern "system" fn AppendEx<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszsbrecording: super::super::Foundation::PWSTR, rtstart: i64, rtstop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AppendEx(::core::mem::transmute_copy(&pszsbrecording), ::core::mem::transmute_copy(&rtstart), ::core::mem::transmute_copy(&rtstop)).into()
        }
        unsafe extern "system" fn GetCurrentLength<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcseconds: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pcseconds = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Cancel<Impl: IStreamBufferRecComp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Cancel().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            Append: Append::<Impl, IMPL_OFFSET>,
            AppendEx: AppendEx::<Impl, IMPL_OFFSET>,
            GetCurrentLength: GetCurrentLength::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferRecComp as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferRecordControl_Impl: Sized {
    fn Start(&mut self, prtstart: *mut i64) -> ::windows::core::Result<()>;
    fn Stop(&mut self, rtstop: i64) -> ::windows::core::Result<()>;
    fn GetRecordingStatus(&mut self, phresult: *mut ::windows::core::HRESULT, pbstarted: *mut super::super::Foundation::BOOL, pbstopped: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferRecordControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferRecordControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferRecordControl_Vtbl {
        unsafe extern "system" fn Start<Impl: IStreamBufferRecordControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtstart: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start(::core::mem::transmute_copy(&prtstart)).into()
        }
        unsafe extern "system" fn Stop<Impl: IStreamBufferRecordControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rtstop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop(::core::mem::transmute_copy(&rtstop)).into()
        }
        unsafe extern "system" fn GetRecordingStatus<Impl: IStreamBufferRecordControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phresult: *mut ::windows::core::HRESULT, pbstarted: *mut super::super::Foundation::BOOL, pbstopped: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRecordingStatus(::core::mem::transmute_copy(&phresult), ::core::mem::transmute_copy(&pbstarted), ::core::mem::transmute_copy(&pbstopped)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Start: Start::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            GetRecordingStatus: GetRecordingStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferRecordControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferRecordingAttribute_Impl: Sized {
    fn SetAttribute(&mut self, ulreserved: u32, pszattributename: super::super::Foundation::PWSTR, streambufferattributetype: STREAMBUFFER_ATTR_DATATYPE, pbattribute: *const u8, cbattributelength: u16) -> ::windows::core::Result<()>;
    fn GetAttributeCount(&mut self, ulreserved: u32) -> ::windows::core::Result<u16>;
    fn GetAttributeByName(&mut self, pszattributename: super::super::Foundation::PWSTR, pulreserved: *const u32, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::Result<()>;
    fn GetAttributeByIndex(&mut self, windex: u16, pulreserved: *const u32, pszattributename: super::super::Foundation::PWSTR, pcchnamelength: *mut u16, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::Result<()>;
    fn EnumAttributes(&mut self) -> ::windows::core::Result<IEnumStreamBufferRecordingAttrib>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferRecordingAttribute_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferRecordingAttribute_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferRecordingAttribute_Vtbl {
        unsafe extern "system" fn SetAttribute<Impl: IStreamBufferRecordingAttribute_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulreserved: u32, pszattributename: super::super::Foundation::PWSTR, streambufferattributetype: STREAMBUFFER_ATTR_DATATYPE, pbattribute: *const u8, cbattributelength: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAttribute(::core::mem::transmute_copy(&ulreserved), ::core::mem::transmute_copy(&pszattributename), ::core::mem::transmute_copy(&streambufferattributetype), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&cbattributelength)).into()
        }
        unsafe extern "system" fn GetAttributeCount<Impl: IStreamBufferRecordingAttribute_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulreserved: u32, pcattributes: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAttributeCount(::core::mem::transmute_copy(&ulreserved)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributeByName<Impl: IStreamBufferRecordingAttribute_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszattributename: super::super::Foundation::PWSTR, pulreserved: *const u32, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAttributeByName(::core::mem::transmute_copy(&pszattributename), ::core::mem::transmute_copy(&pulreserved), ::core::mem::transmute_copy(&pstreambufferattributetype), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&pcblength)).into()
        }
        unsafe extern "system" fn GetAttributeByIndex<Impl: IStreamBufferRecordingAttribute_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windex: u16, pulreserved: *const u32, pszattributename: super::super::Foundation::PWSTR, pcchnamelength: *mut u16, pstreambufferattributetype: *mut STREAMBUFFER_ATTR_DATATYPE, pbattribute: *mut u8, pcblength: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAttributeByIndex(::core::mem::transmute_copy(&windex), ::core::mem::transmute_copy(&pulreserved), ::core::mem::transmute_copy(&pszattributename), ::core::mem::transmute_copy(&pcchnamelength), ::core::mem::transmute_copy(&pstreambufferattributetype), ::core::mem::transmute_copy(&pbattribute), ::core::mem::transmute_copy(&pcblength)).into()
        }
        unsafe extern "system" fn EnumAttributes<Impl: IStreamBufferRecordingAttribute_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppienumstreambufferattrib: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppienumstreambufferattrib = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAttribute: SetAttribute::<Impl, IMPL_OFFSET>,
            GetAttributeCount: GetAttributeCount::<Impl, IMPL_OFFSET>,
            GetAttributeByName: GetAttributeByName::<Impl, IMPL_OFFSET>,
            GetAttributeByIndex: GetAttributeByIndex::<Impl, IMPL_OFFSET>,
            EnumAttributes: EnumAttributes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferRecordingAttribute as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferSink_Impl: Sized {
    fn LockProfile(&mut self, pszstreambufferfilename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn CreateRecorder(&mut self, pszfilename: super::super::Foundation::PWSTR, dwrecordtype: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn IsProfileLocked(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferSink_Vtbl {
        unsafe extern "system" fn LockProfile<Impl: IStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszstreambufferfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockProfile(::core::mem::transmute_copy(&pszstreambufferfilename)).into()
        }
        unsafe extern "system" fn CreateRecorder<Impl: IStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszfilename: super::super::Foundation::PWSTR, dwrecordtype: u32, precordingiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateRecorder(::core::mem::transmute_copy(&pszfilename), ::core::mem::transmute_copy(&dwrecordtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *precordingiunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProfileLocked<Impl: IStreamBufferSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsProfileLocked().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            LockProfile: LockProfile::<Impl, IMPL_OFFSET>,
            CreateRecorder: CreateRecorder::<Impl, IMPL_OFFSET>,
            IsProfileLocked: IsProfileLocked::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferSink as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferSink2_Impl: Sized + IStreamBufferSink_Impl {
    fn UnlockProfile(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferSink2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferSink2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferSink2_Vtbl {
        unsafe extern "system" fn UnlockProfile<Impl: IStreamBufferSink2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockProfile().into()
        }
        Self { base: IStreamBufferSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), UnlockProfile: UnlockProfile::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferSink2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamBufferSink3_Impl: Sized + IStreamBufferSink_Impl + IStreamBufferSink2_Impl {
    fn SetAvailableFilter(&mut self, prtmin: *mut i64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamBufferSink3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferSink3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferSink3_Vtbl {
        unsafe extern "system" fn SetAvailableFilter<Impl: IStreamBufferSink3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prtmin: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAvailableFilter(::core::mem::transmute_copy(&prtmin)).into()
        }
        Self { base: IStreamBufferSink2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetAvailableFilter: SetAvailableFilter::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferSink3 as ::windows::core::Interface>::IID
    }
}
pub trait IStreamBufferSource_Impl: Sized {
    fn SetStreamSink(&mut self, pistreambuffersink: &::core::option::Option<IStreamBufferSink>) -> ::windows::core::Result<()>;
}
impl IStreamBufferSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBufferSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBufferSource_Vtbl {
        unsafe extern "system" fn SetStreamSink<Impl: IStreamBufferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pistreambuffersink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSink(::core::mem::transmute(&pistreambuffersink)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetStreamSink: SetStreamSink::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBufferSource as ::windows::core::Interface>::IID
    }
}
pub trait IStreamBuilder_Impl: Sized {
    fn Render(&mut self, ppinout: &::core::option::Option<IPin>, pgraph: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
    fn Backout(&mut self, ppinout: &::core::option::Option<IPin>, pgraph: &::core::option::Option<IGraphBuilder>) -> ::windows::core::Result<()>;
}
impl IStreamBuilder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamBuilder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamBuilder_Vtbl {
        unsafe extern "system" fn Render<Impl: IStreamBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Render(::core::mem::transmute(&ppinout), ::core::mem::transmute(&pgraph)).into()
        }
        unsafe extern "system" fn Backout<Impl: IStreamBuilder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppinout: ::windows::core::RawPtr, pgraph: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Backout(::core::mem::transmute(&ppinout), ::core::mem::transmute(&pgraph)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Render: Render::<Impl, IMPL_OFFSET>, Backout: Backout::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamBuilder as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IStreamSample_Impl: Sized {
    fn GetMediaStream(&mut self, ppmediastream: *const ::core::option::Option<IMediaStream>) -> ::windows::core::Result<()>;
    fn GetSampleTimes(&mut self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::Result<()>;
    fn SetSampleTimes(&mut self, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::Result<()>;
    fn Update(&mut self, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: &super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> ::windows::core::Result<()>;
    fn CompletionStatus(&mut self, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IStreamSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IStreamSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IStreamSample_Vtbl {
        unsafe extern "system" fn GetMediaStream<Impl: IStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediastream: *const ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMediaStream(::core::mem::transmute_copy(&ppmediastream)).into()
        }
        unsafe extern "system" fn GetSampleTimes<Impl: IStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSampleTimes(::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&pendtime), ::core::mem::transmute_copy(&pcurrenttime)).into()
        }
        unsafe extern "system" fn SetSampleTimes<Impl: IStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleTimes(::core::mem::transmute_copy(&pstarttime), ::core::mem::transmute_copy(&pendtime)).into()
        }
        unsafe extern "system" fn Update<Impl: IStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: ::windows::core::RawPtr, dwapcdata: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Update(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&hevent), ::core::mem::transmute_copy(&pfnapc), ::core::mem::transmute_copy(&dwapcdata)).into()
        }
        unsafe extern "system" fn CompletionStatus<Impl: IStreamSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompletionStatus(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&dwmilliseconds)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMediaStream: GetMediaStream::<Impl, IMPL_OFFSET>,
            GetSampleTimes: GetSampleTimes::<Impl, IMPL_OFFSET>,
            SetSampleTimes: SetSampleTimes::<Impl, IMPL_OFFSET>,
            Update: Update::<Impl, IMPL_OFFSET>,
            CompletionStatus: CompletionStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IStreamSample as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ITSDT_Impl: Sized {
    fn Initialize(&mut self, psectionlist: &::core::option::Option<ISectionList>, pmpegdata: &::core::option::Option<IMpeg2Data>) -> ::windows::core::Result<()>;
    fn GetVersionNumber(&mut self) -> ::windows::core::Result<u8>;
    fn GetCountOfTableDescriptors(&mut self) -> ::windows::core::Result<u32>;
    fn GetTableDescriptorByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor>;
    fn GetTableDescriptorByTag(&mut self, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()>;
    fn RegisterForNextTable(&mut self, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetNextTable(&mut self) -> ::windows::core::Result<ITSDT>;
    fn RegisterForWhenCurrent(&mut self, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn ConvertNextToCurrent(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ITSDT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITSDT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITSDT_Vtbl {
        unsafe extern "system" fn Initialize<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psectionlist: ::windows::core::RawPtr, pmpegdata: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&psectionlist), ::core::mem::transmute(&pmpegdata)).into()
        }
        unsafe extern "system" fn GetVersionNumber<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbval: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVersionNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *pbval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCountOfTableDescriptors<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCountOfTableDescriptors() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByIndex<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTableDescriptorByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTableDescriptorByTag<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, btag: u8, pdwcookie: *mut u32, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTableDescriptorByTag(::core::mem::transmute_copy(&btag), ::core::mem::transmute_copy(&pdwcookie), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn RegisterForNextTable<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableavailable: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForNextTable(::core::mem::transmute_copy(&hnexttableavailable)).into()
        }
        unsafe extern "system" fn GetNextTable<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptsdt: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextTable() {
                ::core::result::Result::Ok(ok__) => {
                    *pptsdt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForWhenCurrent<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnexttableiscurrent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForWhenCurrent(::core::mem::transmute_copy(&hnexttableiscurrent)).into()
        }
        unsafe extern "system" fn ConvertNextToCurrent<Impl: ITSDT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConvertNextToCurrent().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetVersionNumber: GetVersionNumber::<Impl, IMPL_OFFSET>,
            GetCountOfTableDescriptors: GetCountOfTableDescriptors::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByIndex: GetTableDescriptorByIndex::<Impl, IMPL_OFFSET>,
            GetTableDescriptorByTag: GetTableDescriptorByTag::<Impl, IMPL_OFFSET>,
            RegisterForNextTable: RegisterForNextTable::<Impl, IMPL_OFFSET>,
            GetNextTable: GetNextTable::<Impl, IMPL_OFFSET>,
            RegisterForWhenCurrent: RegisterForWhenCurrent::<Impl, IMPL_OFFSET>,
            ConvertNextToCurrent: ConvertNextToCurrent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITSDT as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ITuneRequest_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn TuningSpace(&mut self) -> ::windows::core::Result<ITuningSpace>;
    fn Components(&mut self) -> ::windows::core::Result<IComponents>;
    fn Clone(&mut self) -> ::windows::core::Result<ITuneRequest>;
    fn Locator(&mut self) -> ::windows::core::Result<ILocator>;
    fn SetLocator(&mut self, locator: &::core::option::Option<ILocator>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ITuneRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuneRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuneRequest_Vtbl {
        unsafe extern "system" fn TuningSpace<Impl: ITuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpace() {
                ::core::result::Result::Ok(ok__) => {
                    *tuningspace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Components<Impl: ITuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, components: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Components() {
                ::core::result::Result::Ok(ok__) => {
                    *components = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: ITuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newtunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newtunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Locator<Impl: ITuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Locator() {
                ::core::result::Result::Ok(ok__) => {
                    *locator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLocator<Impl: ITuneRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLocator(::core::mem::transmute(&locator)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            TuningSpace: TuningSpace::<Impl, IMPL_OFFSET>,
            Components: Components::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
            Locator: Locator::<Impl, IMPL_OFFSET>,
            SetLocator: SetLocator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuneRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuneRequestInfo_Impl: Sized {
    fn GetLocatorData(&mut self, request: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn GetComponentData(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn CreateComponentList(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn GetNextProgram(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<ITuneRequest>;
    fn GetPreviousProgram(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<ITuneRequest>;
    fn GetNextLocator(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<ITuneRequest>;
    fn GetPreviousLocator(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<ITuneRequest>;
}
#[cfg(feature = "Win32_System_Com")]
impl ITuneRequestInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuneRequestInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuneRequestInfo_Vtbl {
        unsafe extern "system" fn GetLocatorData<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, request: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLocatorData(::core::mem::transmute(&request)).into()
        }
        unsafe extern "system" fn GetComponentData<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetComponentData(::core::mem::transmute(&currentrequest)).into()
        }
        unsafe extern "system" fn CreateComponentList<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateComponentList(::core::mem::transmute(&currentrequest)).into()
        }
        unsafe extern "system" fn GetNextProgram<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextProgram(::core::mem::transmute(&currentrequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreviousProgram<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPreviousProgram(::core::mem::transmute(&currentrequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextLocator<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNextLocator(::core::mem::transmute(&currentrequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreviousLocator<Impl: ITuneRequestInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPreviousLocator(::core::mem::transmute(&currentrequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLocatorData: GetLocatorData::<Impl, IMPL_OFFSET>,
            GetComponentData: GetComponentData::<Impl, IMPL_OFFSET>,
            CreateComponentList: CreateComponentList::<Impl, IMPL_OFFSET>,
            GetNextProgram: GetNextProgram::<Impl, IMPL_OFFSET>,
            GetPreviousProgram: GetPreviousProgram::<Impl, IMPL_OFFSET>,
            GetNextLocator: GetNextLocator::<Impl, IMPL_OFFSET>,
            GetPreviousLocator: GetPreviousLocator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuneRequestInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuneRequestInfoEx_Impl: Sized + ITuneRequestInfo_Impl {
    fn CreateComponentListEx(&mut self, currentrequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(feature = "Win32_System_Com")]
impl ITuneRequestInfoEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuneRequestInfoEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuneRequestInfoEx_Vtbl {
        unsafe extern "system" fn CreateComponentListEx<Impl: ITuneRequestInfoEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, currentrequest: ::windows::core::RawPtr, ppcurpmt: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateComponentListEx(::core::mem::transmute(&currentrequest)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcurpmt = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ITuneRequestInfo_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateComponentListEx: CreateComponentListEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuneRequestInfoEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait ITuner_Impl: Sized {
    fn TuningSpace(&mut self) -> ::windows::core::Result<ITuningSpace>;
    fn SetTuningSpace(&mut self, tuningspace: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<()>;
    fn EnumTuningSpaces(&mut self) -> ::windows::core::Result<IEnumTuningSpaces>;
    fn TuneRequest(&mut self) -> ::windows::core::Result<ITuneRequest>;
    fn SetTuneRequest(&mut self, tunerequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn Validate(&mut self, tunerequest: &::core::option::Option<ITuneRequest>) -> ::windows::core::Result<()>;
    fn PreferredComponentTypes(&mut self) -> ::windows::core::Result<IComponentTypes>;
    fn SetPreferredComponentTypes(&mut self, componenttypes: &::core::option::Option<IComponentTypes>) -> ::windows::core::Result<()>;
    fn SignalStrength(&mut self) -> ::windows::core::Result<i32>;
    fn TriggerSignalEvents(&mut self, interval: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl ITuner_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuner_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuner_Vtbl {
        unsafe extern "system" fn TuningSpace<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpace() {
                ::core::result::Result::Ok(ok__) => {
                    *tuningspace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuningSpace<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTuningSpace(::core::mem::transmute(&tuningspace)).into()
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuneRequest<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuneRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTuneRequest<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tunerequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTuneRequest(::core::mem::transmute(&tunerequest)).into()
        }
        unsafe extern "system" fn Validate<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tunerequest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Validate(::core::mem::transmute(&tunerequest)).into()
        }
        unsafe extern "system" fn PreferredComponentTypes<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, componenttypes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).PreferredComponentTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *componenttypes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferredComponentTypes<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, componenttypes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreferredComponentTypes(::core::mem::transmute(&componenttypes)).into()
        }
        unsafe extern "system" fn SignalStrength<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strength: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SignalStrength() {
                ::core::result::Result::Ok(ok__) => {
                    *strength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TriggerSignalEvents<Impl: ITuner_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, interval: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TriggerSignalEvents(::core::mem::transmute_copy(&interval)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            TuningSpace: TuningSpace::<Impl, IMPL_OFFSET>,
            SetTuningSpace: SetTuningSpace::<Impl, IMPL_OFFSET>,
            EnumTuningSpaces: EnumTuningSpaces::<Impl, IMPL_OFFSET>,
            TuneRequest: TuneRequest::<Impl, IMPL_OFFSET>,
            SetTuneRequest: SetTuneRequest::<Impl, IMPL_OFFSET>,
            Validate: Validate::<Impl, IMPL_OFFSET>,
            PreferredComponentTypes: PreferredComponentTypes::<Impl, IMPL_OFFSET>,
            SetPreferredComponentTypes: SetPreferredComponentTypes::<Impl, IMPL_OFFSET>,
            SignalStrength: SignalStrength::<Impl, IMPL_OFFSET>,
            TriggerSignalEvents: TriggerSignalEvents::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuner as ::windows::core::Interface>::IID
    }
}
pub trait ITunerCap_Impl: Sized {
    fn SupportedNetworkTypes(&mut self, ulcnetworktypesmax: u32, pulcnetworktypes: *mut u32, pguidnetworktypes: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SupportedVideoFormats(&mut self, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::Result<()>;
    fn AuxInputCount(&mut self, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::Result<()>;
}
impl ITunerCap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITunerCap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITunerCap_Vtbl {
        unsafe extern "system" fn SupportedNetworkTypes<Impl: ITunerCap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulcnetworktypesmax: u32, pulcnetworktypes: *mut u32, pguidnetworktypes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupportedNetworkTypes(::core::mem::transmute_copy(&ulcnetworktypesmax), ::core::mem::transmute_copy(&pulcnetworktypes), ::core::mem::transmute_copy(&pguidnetworktypes)).into()
        }
        unsafe extern "system" fn SupportedVideoFormats<Impl: ITunerCap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SupportedVideoFormats(::core::mem::transmute_copy(&pulamtunermodetype), ::core::mem::transmute_copy(&pulanalogvideostandard)).into()
        }
        unsafe extern "system" fn AuxInputCount<Impl: ITunerCap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AuxInputCount(::core::mem::transmute_copy(&pulcompositecount), ::core::mem::transmute_copy(&pulsvideocount)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SupportedNetworkTypes: SupportedNetworkTypes::<Impl, IMPL_OFFSET>,
            SupportedVideoFormats: SupportedVideoFormats::<Impl, IMPL_OFFSET>,
            AuxInputCount: AuxInputCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITunerCap as ::windows::core::Interface>::IID
    }
}
pub trait ITunerCapEx_Impl: Sized {
    fn Has608_708Caption(&mut self) -> ::windows::core::Result<i16>;
}
impl ITunerCapEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITunerCapEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITunerCapEx_Vtbl {
        unsafe extern "system" fn Has608_708Caption<Impl: ITunerCapEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbhascaption: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Has608_708Caption() {
                ::core::result::Result::Ok(ok__) => {
                    *pbhascaption = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Has608_708Caption: Has608_708Caption::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITunerCapEx as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ITuningSpace_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn UniqueName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetUniqueName(&mut self, name: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn FriendlyName(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetFriendlyName(&mut self, name: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn CLSID(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn NetworkType(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetNetworkType(&mut self, networktypeguid: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn _NetworkType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn Set_NetworkType(&mut self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn CreateTuneRequest(&mut self) -> ::windows::core::Result<ITuneRequest>;
    fn EnumCategoryGUIDs(&mut self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID>;
    fn EnumDeviceMonikers(&mut self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker>;
    fn DefaultPreferredComponentTypes(&mut self) -> ::windows::core::Result<IComponentTypes>;
    fn SetDefaultPreferredComponentTypes(&mut self, newcomponenttypes: &::core::option::Option<IComponentTypes>) -> ::windows::core::Result<()>;
    fn FrequencyMapping(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetFrequencyMapping(&mut self, mapping: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn DefaultLocator(&mut self) -> ::windows::core::Result<ILocator>;
    fn SetDefaultLocator(&mut self, locatorval: &::core::option::Option<ILocator>) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<ITuningSpace>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ITuningSpace_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuningSpace_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuningSpace_Vtbl {
        unsafe extern "system" fn UniqueName<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).UniqueName() {
                ::core::result::Result::Ok(ok__) => {
                    *name = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUniqueName<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUniqueName(::core::mem::transmute_copy(&name)).into()
        }
        unsafe extern "system" fn FriendlyName<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FriendlyName() {
                ::core::result::Result::Ok(ok__) => {
                    *name = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFriendlyName<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFriendlyName(::core::mem::transmute_copy(&name)).into()
        }
        unsafe extern "system" fn CLSID<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, spaceclsid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CLSID() {
                ::core::result::Result::Ok(ok__) => {
                    *spaceclsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NetworkType<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networktypeguid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NetworkType() {
                ::core::result::Result::Ok(ok__) => {
                    *networktypeguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNetworkType<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networktypeguid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNetworkType(::core::mem::transmute_copy(&networktypeguid)).into()
        }
        unsafe extern "system" fn _NetworkType<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networktypeguid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NetworkType() {
                ::core::result::Result::Ok(ok__) => {
                    *networktypeguid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set_NetworkType<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set_NetworkType(::core::mem::transmute_copy(&networktypeguid)).into()
        }
        unsafe extern "system" fn CreateTuneRequest<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tunerequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTuneRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *tunerequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumCategoryGUIDs<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumCategoryGUIDs() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumDeviceMonikers<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumDeviceMonikers() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPreferredComponentTypes<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, componenttypes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultPreferredComponentTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *componenttypes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPreferredComponentTypes<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newcomponenttypes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultPreferredComponentTypes(::core::mem::transmute(&newcomponenttypes)).into()
        }
        unsafe extern "system" fn FrequencyMapping<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmapping: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FrequencyMapping() {
                ::core::result::Result::Ok(ok__) => {
                    *pmapping = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrequencyMapping<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mapping: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrequencyMapping(::core::mem::transmute_copy(&mapping)).into()
        }
        unsafe extern "system" fn DefaultLocator<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locatorval: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).DefaultLocator() {
                ::core::result::Result::Ok(ok__) => {
                    *locatorval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultLocator<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, locatorval: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultLocator(::core::mem::transmute(&locatorval)).into()
        }
        unsafe extern "system" fn Clone<Impl: ITuningSpace_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newts: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *newts = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            UniqueName: UniqueName::<Impl, IMPL_OFFSET>,
            SetUniqueName: SetUniqueName::<Impl, IMPL_OFFSET>,
            FriendlyName: FriendlyName::<Impl, IMPL_OFFSET>,
            SetFriendlyName: SetFriendlyName::<Impl, IMPL_OFFSET>,
            CLSID: CLSID::<Impl, IMPL_OFFSET>,
            NetworkType: NetworkType::<Impl, IMPL_OFFSET>,
            SetNetworkType: SetNetworkType::<Impl, IMPL_OFFSET>,
            _NetworkType: _NetworkType::<Impl, IMPL_OFFSET>,
            Set_NetworkType: Set_NetworkType::<Impl, IMPL_OFFSET>,
            CreateTuneRequest: CreateTuneRequest::<Impl, IMPL_OFFSET>,
            EnumCategoryGUIDs: EnumCategoryGUIDs::<Impl, IMPL_OFFSET>,
            EnumDeviceMonikers: EnumDeviceMonikers::<Impl, IMPL_OFFSET>,
            DefaultPreferredComponentTypes: DefaultPreferredComponentTypes::<Impl, IMPL_OFFSET>,
            SetDefaultPreferredComponentTypes: SetDefaultPreferredComponentTypes::<Impl, IMPL_OFFSET>,
            FrequencyMapping: FrequencyMapping::<Impl, IMPL_OFFSET>,
            SetFrequencyMapping: SetFrequencyMapping::<Impl, IMPL_OFFSET>,
            DefaultLocator: DefaultLocator::<Impl, IMPL_OFFSET>,
            SetDefaultLocator: SetDefaultLocator::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuningSpace as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ITuningSpaceContainer_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, varindex: &super::super::System::Com::VARIANT) -> ::windows::core::Result<ITuningSpace>;
    fn SetItem(&mut self, varindex: &super::super::System::Com::VARIANT, tuningspace: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<()>;
    fn TuningSpacesForCLSID(&mut self, spaceclsid: &super::super::Foundation::BSTR) -> ::windows::core::Result<ITuningSpaces>;
    fn _TuningSpacesForCLSID2(&mut self, spaceclsid: *const ::windows::core::GUID) -> ::windows::core::Result<ITuningSpaces>;
    fn TuningSpacesForName(&mut self, name: &super::super::Foundation::BSTR) -> ::windows::core::Result<ITuningSpaces>;
    fn FindID(&mut self, tuningspace: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<i32>;
    fn Add(&mut self, tuningspace: &::core::option::Option<ITuningSpace>) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn EnumTuningSpaces(&mut self) -> ::windows::core::Result<IEnumTuningSpaces>;
    fn Remove(&mut self, index: &super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn MaxCount(&mut self) -> ::windows::core::Result<i32>;
    fn SetMaxCount(&mut self, maxcount: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ITuningSpaceContainer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuningSpaceContainer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuningSpaceContainer_Vtbl {
        unsafe extern "system" fn Count<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *count = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *newenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&varindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *tuningspace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(::core::mem::transmute_copy(&varindex), ::core::mem::transmute(&tuningspace)).into()
        }
        unsafe extern "system" fn TuningSpacesForCLSID<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, spaceclsid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpacesForCLSID(::core::mem::transmute_copy(&spaceclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *newcoll = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _TuningSpacesForCLSID2<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, spaceclsid: *const ::windows::core::GUID, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._TuningSpacesForCLSID2(::core::mem::transmute_copy(&spaceclsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *newcoll = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TuningSpacesForName<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, newcoll: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TuningSpacesForName(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *newcoll = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindID<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, id: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindID(::core::mem::transmute(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *id = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Add<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tuningspace: ::windows::core::RawPtr, newindex: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Add(::core::mem::transmute(&tuningspace)) {
                ::core::result::Result::Ok(ok__) => {
                    *newindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces() {
                ::core::result::Result::Ok(ok__) => {
                    *ppenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&index)).into()
        }
        unsafe extern "system" fn MaxCount<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxcount: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MaxCount() {
                ::core::result::Result::Ok(ok__) => {
                    *maxcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxCount<Impl: ITuningSpaceContainer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, maxcount: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMaxCount(::core::mem::transmute_copy(&maxcount)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
            TuningSpacesForCLSID: TuningSpacesForCLSID::<Impl, IMPL_OFFSET>,
            _TuningSpacesForCLSID2: _TuningSpacesForCLSID2::<Impl, IMPL_OFFSET>,
            TuningSpacesForName: TuningSpacesForName::<Impl, IMPL_OFFSET>,
            FindID: FindID::<Impl, IMPL_OFFSET>,
            Add: Add::<Impl, IMPL_OFFSET>,
            EnumTuningSpaces: EnumTuningSpaces::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            MaxCount: MaxCount::<Impl, IMPL_OFFSET>,
            SetMaxCount: SetMaxCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuningSpaceContainer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ITuningSpaces_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Count(&mut self) -> ::windows::core::Result<i32>;
    fn _NewEnum(&mut self) -> ::windows::core::Result<super::super::System::Ole::IEnumVARIANT>;
    fn Item(&mut self, varindex: &super::super::System::Com::VARIANT) -> ::windows::core::Result<ITuningSpace>;
    fn EnumTuningSpaces(&mut self) -> ::windows::core::Result<IEnumTuningSpaces>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ITuningSpaces_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITuningSpaces_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITuningSpaces_Vtbl {
        unsafe extern "system" fn Count<Impl: ITuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Count() {
                ::core::result::Result::Ok(ok__) => {
                    *count = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Impl: ITuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this)._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    *newenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ITuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, varindex: ::core::mem::ManuallyDrop<super::super::System::Com::VARIANT>, tuningspace: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Item(::core::mem::transmute_copy(&varindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *tuningspace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnumTuningSpaces<Impl: ITuningSpaces_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newenum: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EnumTuningSpaces() {
                ::core::result::Result::Ok(ok__) => {
                    *newenum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Count: Count::<Impl, IMPL_OFFSET>,
            _NewEnum: _NewEnum::<Impl, IMPL_OFFSET>,
            Item: Item::<Impl, IMPL_OFFSET>,
            EnumTuningSpaces: EnumTuningSpaces::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITuningSpaces as ::windows::core::Interface>::IID
    }
}
pub trait IVMRAspectRatioControl_Impl: Sized {
    fn GetAspectRatioMode(&mut self, lpdwarmode: *mut u32) -> ::windows::core::Result<()>;
    fn SetAspectRatioMode(&mut self, dwarmode: u32) -> ::windows::core::Result<()>;
}
impl IVMRAspectRatioControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRAspectRatioControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRAspectRatioControl_Vtbl {
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRAspectRatioControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwarmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAspectRatioMode(::core::mem::transmute_copy(&lpdwarmode)).into()
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRAspectRatioControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwarmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&dwarmode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRAspectRatioControl as ::windows::core::Interface>::IID
    }
}
pub trait IVMRAspectRatioControl9_Impl: Sized {
    fn GetAspectRatioMode(&mut self) -> ::windows::core::Result<u32>;
    fn SetAspectRatioMode(&mut self, dwarmode: u32) -> ::windows::core::Result<()>;
}
impl IVMRAspectRatioControl9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRAspectRatioControl9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRAspectRatioControl9_Vtbl {
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRAspectRatioControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwarmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *lpdwarmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRAspectRatioControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwarmode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&dwarmode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRAspectRatioControl9 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IVMRDeinterlaceControl_Impl: Sized {
    fn GetNumberOfDeinterlaceModes(&mut self, lpvideodescription: *mut VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDeinterlaceModeCaps(&mut self, lpdeinterlacemode: *mut ::windows::core::GUID, lpvideodescription: *mut VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> ::windows::core::Result<()>;
    fn GetDeinterlaceMode(&mut self, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetDeinterlaceMode(&mut self, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDeinterlacePrefs(&mut self, lpdwdeinterlaceprefs: *mut u32) -> ::windows::core::Result<()>;
    fn SetDeinterlacePrefs(&mut self, dwdeinterlaceprefs: u32) -> ::windows::core::Result<()>;
    fn GetActualDeinterlaceMode(&mut self, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IVMRDeinterlaceControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRDeinterlaceControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRDeinterlaceControl_Vtbl {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpvideodescription: *mut VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNumberOfDeinterlaceModes(::core::mem::transmute_copy(&lpvideodescription), ::core::mem::transmute_copy(&lpdwnumdeinterlacemodes), ::core::mem::transmute_copy(&lpdeinterlacemodes)).into()
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdeinterlacemode: *mut ::windows::core::GUID, lpvideodescription: *mut VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDeinterlaceModeCaps(::core::mem::transmute_copy(&lpdeinterlacemode), ::core::mem::transmute_copy(&lpvideodescription), ::core::mem::transmute_copy(&lpdeinterlacecaps)).into()
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpdeinterlacemode)).into()
        }
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpdeinterlacemode)).into()
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDeinterlacePrefs(::core::mem::transmute_copy(&lpdwdeinterlaceprefs)).into()
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdeinterlaceprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDeinterlacePrefs(::core::mem::transmute_copy(&dwdeinterlaceprefs)).into()
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Impl: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetActualDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpdeinterlacemode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNumberOfDeinterlaceModes: GetNumberOfDeinterlaceModes::<Impl, IMPL_OFFSET>,
            GetDeinterlaceModeCaps: GetDeinterlaceModeCaps::<Impl, IMPL_OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Impl, IMPL_OFFSET>,
            SetDeinterlaceMode: SetDeinterlaceMode::<Impl, IMPL_OFFSET>,
            GetDeinterlacePrefs: GetDeinterlacePrefs::<Impl, IMPL_OFFSET>,
            SetDeinterlacePrefs: SetDeinterlacePrefs::<Impl, IMPL_OFFSET>,
            GetActualDeinterlaceMode: GetActualDeinterlaceMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRDeinterlaceControl as ::windows::core::Interface>::IID
    }
}
pub trait IVMRDeinterlaceControl9_Impl: Sized {
    fn GetNumberOfDeinterlaceModes(&mut self, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDeinterlaceModeCaps(&mut self, lpdeinterlacemode: *const ::windows::core::GUID, lpvideodescription: *const VMR9VideoDesc) -> ::windows::core::Result<VMR9DeinterlaceCaps>;
    fn GetDeinterlaceMode(&mut self, dwstreamid: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetDeinterlaceMode(&mut self, dwstreamid: u32, lpdeinterlacemode: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDeinterlacePrefs(&mut self) -> ::windows::core::Result<u32>;
    fn SetDeinterlacePrefs(&mut self, dwdeinterlaceprefs: u32) -> ::windows::core::Result<()>;
    fn GetActualDeinterlaceMode(&mut self, dwstreamid: u32) -> ::windows::core::Result<::windows::core::GUID>;
}
impl IVMRDeinterlaceControl9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRDeinterlaceControl9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRDeinterlaceControl9_Vtbl {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNumberOfDeinterlaceModes(::core::mem::transmute_copy(&lpvideodescription), ::core::mem::transmute_copy(&lpdwnumdeinterlacemodes), ::core::mem::transmute_copy(&lpdeinterlacemodes)).into()
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdeinterlacemode: *const ::windows::core::GUID, lpvideodescription: *const VMR9VideoDesc, lpdeinterlacecaps: *mut VMR9DeinterlaceCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceModeCaps(::core::mem::transmute_copy(&lpdeinterlacemode), ::core::mem::transmute_copy(&lpvideodescription)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdeinterlacecaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdeinterlacemode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpdeinterlacemode)).into()
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeinterlacePrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *lpdwdeinterlaceprefs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdeinterlaceprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDeinterlacePrefs(::core::mem::transmute_copy(&dwdeinterlaceprefs)).into()
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Impl: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetActualDeinterlaceMode(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdeinterlacemode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNumberOfDeinterlaceModes: GetNumberOfDeinterlaceModes::<Impl, IMPL_OFFSET>,
            GetDeinterlaceModeCaps: GetDeinterlaceModeCaps::<Impl, IMPL_OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Impl, IMPL_OFFSET>,
            SetDeinterlaceMode: SetDeinterlaceMode::<Impl, IMPL_OFFSET>,
            GetDeinterlacePrefs: GetDeinterlacePrefs::<Impl, IMPL_OFFSET>,
            SetDeinterlacePrefs: SetDeinterlacePrefs::<Impl, IMPL_OFFSET>,
            GetActualDeinterlaceMode: GetActualDeinterlaceMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRDeinterlaceControl9 as ::windows::core::Interface>::IID
    }
}
pub trait IVMRFilterConfig_Impl: Sized {
    fn SetImageCompositor(&mut self, lpvmrimgcompositor: &::core::option::Option<IVMRImageCompositor>) -> ::windows::core::Result<()>;
    fn SetNumberOfStreams(&mut self, dwmaxstreams: u32) -> ::windows::core::Result<()>;
    fn GetNumberOfStreams(&mut self, pdwmaxstreams: *mut u32) -> ::windows::core::Result<()>;
    fn SetRenderingPrefs(&mut self, dwrenderflags: u32) -> ::windows::core::Result<()>;
    fn GetRenderingPrefs(&mut self, pdwrenderflags: *mut u32) -> ::windows::core::Result<()>;
    fn SetRenderingMode(&mut self, mode: u32) -> ::windows::core::Result<()>;
    fn GetRenderingMode(&mut self, pmode: *mut u32) -> ::windows::core::Result<()>;
}
impl IVMRFilterConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRFilterConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRFilterConfig_Vtbl {
        unsafe extern "system" fn SetImageCompositor<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpvmrimgcompositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetImageCompositor(::core::mem::transmute(&lpvmrimgcompositor)).into()
        }
        unsafe extern "system" fn SetNumberOfStreams<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNumberOfStreams(::core::mem::transmute_copy(&dwmaxstreams)).into()
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNumberOfStreams(::core::mem::transmute_copy(&pdwmaxstreams)).into()
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRenderingPrefs(::core::mem::transmute_copy(&pdwrenderflags)).into()
        }
        unsafe extern "system" fn SetRenderingMode<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn GetRenderingMode<Impl: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRenderingMode(::core::mem::transmute_copy(&pmode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetImageCompositor: SetImageCompositor::<Impl, IMPL_OFFSET>,
            SetNumberOfStreams: SetNumberOfStreams::<Impl, IMPL_OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Impl, IMPL_OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Impl, IMPL_OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Impl, IMPL_OFFSET>,
            SetRenderingMode: SetRenderingMode::<Impl, IMPL_OFFSET>,
            GetRenderingMode: GetRenderingMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRFilterConfig as ::windows::core::Interface>::IID
    }
}
pub trait IVMRFilterConfig9_Impl: Sized {
    fn SetImageCompositor(&mut self, lpvmrimgcompositor: &::core::option::Option<IVMRImageCompositor9>) -> ::windows::core::Result<()>;
    fn SetNumberOfStreams(&mut self, dwmaxstreams: u32) -> ::windows::core::Result<()>;
    fn GetNumberOfStreams(&mut self) -> ::windows::core::Result<u32>;
    fn SetRenderingPrefs(&mut self, dwrenderflags: u32) -> ::windows::core::Result<()>;
    fn GetRenderingPrefs(&mut self) -> ::windows::core::Result<u32>;
    fn SetRenderingMode(&mut self, mode: u32) -> ::windows::core::Result<()>;
    fn GetRenderingMode(&mut self) -> ::windows::core::Result<u32>;
}
impl IVMRFilterConfig9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRFilterConfig9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRFilterConfig9_Vtbl {
        unsafe extern "system" fn SetImageCompositor<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpvmrimgcompositor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetImageCompositor(::core::mem::transmute(&lpvmrimgcompositor)).into()
        }
        unsafe extern "system" fn SetNumberOfStreams<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNumberOfStreams(::core::mem::transmute_copy(&dwmaxstreams)).into()
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmaxstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrenderflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingMode<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn GetRenderingMode<Impl: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenderingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetImageCompositor: SetImageCompositor::<Impl, IMPL_OFFSET>,
            SetNumberOfStreams: SetNumberOfStreams::<Impl, IMPL_OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Impl, IMPL_OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Impl, IMPL_OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Impl, IMPL_OFFSET>,
            SetRenderingMode: SetRenderingMode::<Impl, IMPL_OFFSET>,
            GetRenderingMode: GetRenderingMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRFilterConfig9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVMRImageCompositor_Impl: Sized {
    fn InitCompositionTarget(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>, pddsrendertarget: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> ::windows::core::Result<()>;
    fn TermCompositionTarget(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>, pddsrendertarget: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> ::windows::core::Result<()>;
    fn SetStreamMediaType(&mut self, dwstrmid: u32, pmt: *mut AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn CompositeImage(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>, pddsrendertarget: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>, pmtrendertarget: *mut AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *mut VMRVIDEOSTREAMINFO, cstreams: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVMRImageCompositor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImageCompositor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImageCompositor_Vtbl {
        unsafe extern "system" fn InitCompositionTarget<Impl: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitCompositionTarget(::core::mem::transmute(&pd3ddevice), ::core::mem::transmute(&pddsrendertarget)).into()
        }
        unsafe extern "system" fn TermCompositionTarget<Impl: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TermCompositionTarget(::core::mem::transmute(&pd3ddevice), ::core::mem::transmute(&pddsrendertarget)).into()
        }
        unsafe extern "system" fn SetStreamMediaType<Impl: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstrmid: u32, pmt: *mut AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamMediaType(::core::mem::transmute_copy(&dwstrmid), ::core::mem::transmute_copy(&pmt), ::core::mem::transmute_copy(&ftexture)).into()
        }
        unsafe extern "system" fn CompositeImage<Impl: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr, pmtrendertarget: *mut AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *mut VMRVIDEOSTREAMINFO, cstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompositeImage(::core::mem::transmute(&pd3ddevice), ::core::mem::transmute(&pddsrendertarget), ::core::mem::transmute_copy(&pmtrendertarget), ::core::mem::transmute_copy(&rtstart), ::core::mem::transmute_copy(&rtend), ::core::mem::transmute_copy(&dwclrbkgnd), ::core::mem::transmute_copy(&pvideostreaminfo), ::core::mem::transmute_copy(&cstreams)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitCompositionTarget: InitCompositionTarget::<Impl, IMPL_OFFSET>,
            TermCompositionTarget: TermCompositionTarget::<Impl, IMPL_OFFSET>,
            SetStreamMediaType: SetStreamMediaType::<Impl, IMPL_OFFSET>,
            CompositeImage: CompositeImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImageCompositor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IVMRImageCompositor9_Impl: Sized {
    fn InitCompositionDevice(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn TermCompositionDevice(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn SetStreamMediaType(&mut self, dwstrmid: u32, pmt: *const AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn CompositeImage(&mut self, pd3ddevice: &::core::option::Option<::windows::core::IUnknown>, pddsrendertarget: &::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pmtrendertarget: *const AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IVMRImageCompositor9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImageCompositor9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImageCompositor9_Vtbl {
        unsafe extern "system" fn InitCompositionDevice<Impl: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitCompositionDevice(::core::mem::transmute(&pd3ddevice)).into()
        }
        unsafe extern "system" fn TermCompositionDevice<Impl: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TermCompositionDevice(::core::mem::transmute(&pd3ddevice)).into()
        }
        unsafe extern "system" fn SetStreamMediaType<Impl: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstrmid: u32, pmt: *const AM_MEDIA_TYPE, ftexture: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamMediaType(::core::mem::transmute_copy(&dwstrmid), ::core::mem::transmute_copy(&pmt), ::core::mem::transmute_copy(&ftexture)).into()
        }
        unsafe extern "system" fn CompositeImage<Impl: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pd3ddevice: *mut ::core::ffi::c_void, pddsrendertarget: ::windows::core::RawPtr, pmtrendertarget: *const AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CompositeImage(::core::mem::transmute(&pd3ddevice), ::core::mem::transmute(&pddsrendertarget), ::core::mem::transmute_copy(&pmtrendertarget), ::core::mem::transmute_copy(&rtstart), ::core::mem::transmute_copy(&rtend), ::core::mem::transmute_copy(&dwclrbkgnd), ::core::mem::transmute_copy(&pvideostreaminfo), ::core::mem::transmute_copy(&cstreams)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitCompositionDevice: InitCompositionDevice::<Impl, IMPL_OFFSET>,
            TermCompositionDevice: TermCompositionDevice::<Impl, IMPL_OFFSET>,
            SetStreamMediaType: SetStreamMediaType::<Impl, IMPL_OFFSET>,
            CompositeImage: CompositeImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImageCompositor9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVMRImagePresenter_Impl: Sized {
    fn StartPresenting(&mut self, dwuserid: usize) -> ::windows::core::Result<()>;
    fn StopPresenting(&mut self, dwuserid: usize) -> ::windows::core::Result<()>;
    fn PresentImage(&mut self, dwuserid: usize, lppresinfo: *mut VMRPRESENTATIONINFO) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVMRImagePresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImagePresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImagePresenter_Vtbl {
        unsafe extern "system" fn StartPresenting<Impl: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartPresenting(::core::mem::transmute_copy(&dwuserid)).into()
        }
        unsafe extern "system" fn StopPresenting<Impl: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopPresenting(::core::mem::transmute_copy(&dwuserid)).into()
        }
        unsafe extern "system" fn PresentImage<Impl: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lppresinfo: *mut VMRPRESENTATIONINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PresentImage(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&lppresinfo)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartPresenting: StartPresenting::<Impl, IMPL_OFFSET>,
            StopPresenting: StopPresenting::<Impl, IMPL_OFFSET>,
            PresentImage: PresentImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImagePresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IVMRImagePresenter9_Impl: Sized {
    fn StartPresenting(&mut self, dwuserid: usize) -> ::windows::core::Result<()>;
    fn StopPresenting(&mut self, dwuserid: usize) -> ::windows::core::Result<()>;
    fn PresentImage(&mut self, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IVMRImagePresenter9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImagePresenter9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImagePresenter9_Vtbl {
        unsafe extern "system" fn StartPresenting<Impl: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartPresenting(::core::mem::transmute_copy(&dwuserid)).into()
        }
        unsafe extern "system" fn StopPresenting<Impl: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopPresenting(::core::mem::transmute_copy(&dwuserid)).into()
        }
        unsafe extern "system" fn PresentImage<Impl: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PresentImage(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&lppresinfo)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartPresenting: StartPresenting::<Impl, IMPL_OFFSET>,
            StopPresenting: StopPresenting::<Impl, IMPL_OFFSET>,
            PresentImage: PresentImage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImagePresenter9 as ::windows::core::Interface>::IID
    }
}
pub trait IVMRImagePresenterConfig_Impl: Sized {
    fn SetRenderingPrefs(&mut self, dwrenderflags: u32) -> ::windows::core::Result<()>;
    fn GetRenderingPrefs(&mut self, dwrenderflags: *mut u32) -> ::windows::core::Result<()>;
}
impl IVMRImagePresenterConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImagePresenterConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImagePresenterConfig_Vtbl {
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRImagePresenterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRImagePresenterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetRenderingPrefs: SetRenderingPrefs::<Impl, IMPL_OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImagePresenterConfig as ::windows::core::Interface>::IID
    }
}
pub trait IVMRImagePresenterConfig9_Impl: Sized {
    fn SetRenderingPrefs(&mut self, dwrenderflags: u32) -> ::windows::core::Result<()>;
    fn GetRenderingPrefs(&mut self) -> ::windows::core::Result<u32>;
}
impl IVMRImagePresenterConfig9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImagePresenterConfig9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImagePresenterConfig9_Vtbl {
        unsafe extern "system" fn SetRenderingPrefs<Impl: IVMRImagePresenterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IVMRImagePresenterConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *dwrenderflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetRenderingPrefs: SetRenderingPrefs::<Impl, IMPL_OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImagePresenterConfig9 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRImagePresenterExclModeConfig_Impl: Sized + IVMRImagePresenterConfig_Impl {
    fn SetXlcModeDDObjAndPrimarySurface(&mut self, lpddobj: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw7>, lpprimarysurf: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> ::windows::core::Result<()>;
    fn GetXlcModeDDObjAndPrimarySurface(&mut self, lpddobj: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw7>, lpprimarysurf: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRImagePresenterExclModeConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRImagePresenterExclModeConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRImagePresenterExclModeConfig_Vtbl {
        unsafe extern "system" fn SetXlcModeDDObjAndPrimarySurface<Impl: IVMRImagePresenterExclModeConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpddobj: ::windows::core::RawPtr, lpprimarysurf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetXlcModeDDObjAndPrimarySurface(::core::mem::transmute(&lpddobj), ::core::mem::transmute(&lpprimarysurf)).into()
        }
        unsafe extern "system" fn GetXlcModeDDObjAndPrimarySurface<Impl: IVMRImagePresenterExclModeConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpddobj: *mut ::windows::core::RawPtr, lpprimarysurf: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetXlcModeDDObjAndPrimarySurface(::core::mem::transmute_copy(&lpddobj), ::core::mem::transmute_copy(&lpprimarysurf)).into()
        }
        Self {
            base: IVMRImagePresenterConfig_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetXlcModeDDObjAndPrimarySurface: SetXlcModeDDObjAndPrimarySurface::<Impl, IMPL_OFFSET>,
            GetXlcModeDDObjAndPrimarySurface: GetXlcModeDDObjAndPrimarySurface::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRImagePresenterExclModeConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMixerBitmap_Impl: Sized {
    fn SetAlphaBitmap(&mut self, pbmpparms: *const VMRALPHABITMAP) -> ::windows::core::Result<()>;
    fn UpdateAlphaBitmapParameters(&mut self, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::Result<()>;
    fn GetAlphaBitmapParameters(&mut self, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRMixerBitmap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMixerBitmap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMixerBitmap_Vtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlphaBitmap(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMRALPHABITMAP) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Impl, IMPL_OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMixerBitmap as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMixerBitmap9_Impl: Sized {
    fn SetAlphaBitmap(&mut self, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::Result<()>;
    fn UpdateAlphaBitmapParameters(&mut self, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::Result<()>;
    fn GetAlphaBitmapParameters(&mut self) -> ::windows::core::Result<VMR9AlphaBitmap>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IVMRMixerBitmap9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMixerBitmap9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMixerBitmap9_Vtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlphaBitmap(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut VMR9AlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaBitmapParameters() {
                ::core::result::Result::Ok(ok__) => {
                    *pbmpparms = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Impl, IMPL_OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMixerBitmap9 as ::windows::core::Interface>::IID
    }
}
pub trait IVMRMixerControl_Impl: Sized {
    fn SetAlpha(&mut self, dwstreamid: u32, alpha: f32) -> ::windows::core::Result<()>;
    fn GetAlpha(&mut self, dwstreamid: u32, palpha: *mut f32) -> ::windows::core::Result<()>;
    fn SetZOrder(&mut self, dwstreamid: u32, dwz: u32) -> ::windows::core::Result<()>;
    fn GetZOrder(&mut self, dwstreamid: u32, pz: *mut u32) -> ::windows::core::Result<()>;
    fn SetOutputRect(&mut self, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> ::windows::core::Result<()>;
    fn GetOutputRect(&mut self, dwstreamid: u32, prect: *mut NORMALIZEDRECT) -> ::windows::core::Result<()>;
    fn SetBackgroundClr(&mut self, clrbkg: u32) -> ::windows::core::Result<()>;
    fn GetBackgroundClr(&mut self, lpclrbkg: *mut u32) -> ::windows::core::Result<()>;
    fn SetMixingPrefs(&mut self, dwmixerprefs: u32) -> ::windows::core::Result<()>;
    fn GetMixingPrefs(&mut self, pdwmixerprefs: *mut u32) -> ::windows::core::Result<()>;
}
impl IVMRMixerControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMixerControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMixerControl_Vtbl {
        unsafe extern "system" fn SetAlpha<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, alpha: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlpha(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&alpha)).into()
        }
        unsafe extern "system" fn GetAlpha<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAlpha(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&palpha)).into()
        }
        unsafe extern "system" fn SetZOrder<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZOrder(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&dwz)).into()
        }
        unsafe extern "system" fn GetZOrder<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetZOrder(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&pz)).into()
        }
        unsafe extern "system" fn SetOutputRect<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputRect(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&prect)).into()
        }
        unsafe extern "system" fn GetOutputRect<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *mut NORMALIZEDRECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOutputRect(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&prect)).into()
        }
        unsafe extern "system" fn SetBackgroundClr<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundClr(::core::mem::transmute_copy(&clrbkg)).into()
        }
        unsafe extern "system" fn GetBackgroundClr<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclrbkg: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBackgroundClr(::core::mem::transmute_copy(&lpclrbkg)).into()
        }
        unsafe extern "system" fn SetMixingPrefs<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmixerprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixingPrefs(::core::mem::transmute_copy(&dwmixerprefs)).into()
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmixerprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMixingPrefs(::core::mem::transmute_copy(&pdwmixerprefs)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAlpha: SetAlpha::<Impl, IMPL_OFFSET>,
            GetAlpha: GetAlpha::<Impl, IMPL_OFFSET>,
            SetZOrder: SetZOrder::<Impl, IMPL_OFFSET>,
            GetZOrder: GetZOrder::<Impl, IMPL_OFFSET>,
            SetOutputRect: SetOutputRect::<Impl, IMPL_OFFSET>,
            GetOutputRect: GetOutputRect::<Impl, IMPL_OFFSET>,
            SetBackgroundClr: SetBackgroundClr::<Impl, IMPL_OFFSET>,
            GetBackgroundClr: GetBackgroundClr::<Impl, IMPL_OFFSET>,
            SetMixingPrefs: SetMixingPrefs::<Impl, IMPL_OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMixerControl as ::windows::core::Interface>::IID
    }
}
pub trait IVMRMixerControl9_Impl: Sized {
    fn SetAlpha(&mut self, dwstreamid: u32, alpha: f32) -> ::windows::core::Result<()>;
    fn GetAlpha(&mut self, dwstreamid: u32) -> ::windows::core::Result<f32>;
    fn SetZOrder(&mut self, dwstreamid: u32, dwz: u32) -> ::windows::core::Result<()>;
    fn GetZOrder(&mut self, dwstreamid: u32) -> ::windows::core::Result<u32>;
    fn SetOutputRect(&mut self, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> ::windows::core::Result<()>;
    fn GetOutputRect(&mut self, dwstreamid: u32) -> ::windows::core::Result<VMR9NormalizedRect>;
    fn SetBackgroundClr(&mut self, clrbkg: u32) -> ::windows::core::Result<()>;
    fn GetBackgroundClr(&mut self, lpclrbkg: *const u32) -> ::windows::core::Result<()>;
    fn SetMixingPrefs(&mut self, dwmixerprefs: u32) -> ::windows::core::Result<()>;
    fn GetMixingPrefs(&mut self) -> ::windows::core::Result<u32>;
    fn SetProcAmpControl(&mut self, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> ::windows::core::Result<()>;
    fn GetProcAmpControl(&mut self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> ::windows::core::Result<()>;
    fn GetProcAmpControlRange(&mut self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> ::windows::core::Result<()>;
}
impl IVMRMixerControl9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMixerControl9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMixerControl9_Vtbl {
        unsafe extern "system" fn SetAlpha<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, alpha: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlpha(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&alpha)).into()
        }
        unsafe extern "system" fn GetAlpha<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlpha(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *palpha = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZOrder<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetZOrder(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&dwz)).into()
        }
        unsafe extern "system" fn GetZOrder<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZOrder(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pz = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputRect<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputRect(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&prect)).into()
        }
        unsafe extern "system" fn GetOutputRect<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, prect: *mut VMR9NormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputRect(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *prect = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundClr<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundClr(::core::mem::transmute_copy(&clrbkg)).into()
        }
        unsafe extern "system" fn GetBackgroundClr<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclrbkg: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBackgroundClr(::core::mem::transmute_copy(&lpclrbkg)).into()
        }
        unsafe extern "system" fn SetMixingPrefs<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmixerprefs: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixingPrefs(::core::mem::transmute_copy(&dwmixerprefs)).into()
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmixerprefs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMixingPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmixerprefs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProcAmpControl<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProcAmpControl(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpclrcontrol)).into()
        }
        unsafe extern "system" fn GetProcAmpControl<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProcAmpControl(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpclrcontrol)).into()
        }
        unsafe extern "system" fn GetProcAmpControlRange<Impl: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProcAmpControlRange(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&lpclrcontrol)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAlpha: SetAlpha::<Impl, IMPL_OFFSET>,
            GetAlpha: GetAlpha::<Impl, IMPL_OFFSET>,
            SetZOrder: SetZOrder::<Impl, IMPL_OFFSET>,
            GetZOrder: GetZOrder::<Impl, IMPL_OFFSET>,
            SetOutputRect: SetOutputRect::<Impl, IMPL_OFFSET>,
            GetOutputRect: GetOutputRect::<Impl, IMPL_OFFSET>,
            SetBackgroundClr: SetBackgroundClr::<Impl, IMPL_OFFSET>,
            GetBackgroundClr: GetBackgroundClr::<Impl, IMPL_OFFSET>,
            SetMixingPrefs: SetMixingPrefs::<Impl, IMPL_OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Impl, IMPL_OFFSET>,
            SetProcAmpControl: SetProcAmpControl::<Impl, IMPL_OFFSET>,
            GetProcAmpControl: GetProcAmpControl::<Impl, IMPL_OFFSET>,
            GetProcAmpControlRange: GetProcAmpControlRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMixerControl9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMonitorConfig_Impl: Sized {
    fn SetMonitor(&mut self, pguid: *const VMRGUID) -> ::windows::core::Result<()>;
    fn GetMonitor(&mut self, pguid: *mut VMRGUID) -> ::windows::core::Result<()>;
    fn SetDefaultMonitor(&mut self, pguid: *const VMRGUID) -> ::windows::core::Result<()>;
    fn GetDefaultMonitor(&mut self, pguid: *mut VMRGUID) -> ::windows::core::Result<()>;
    fn GetAvailableMonitors(&mut self, pinfo: *mut VMRMONITORINFO, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IVMRMonitorConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMonitorConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMonitorConfig_Vtbl {
        unsafe extern "system" fn SetMonitor<Impl: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonitor(::core::mem::transmute_copy(&pguid)).into()
        }
        unsafe extern "system" fn GetMonitor<Impl: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMonitor(::core::mem::transmute_copy(&pguid)).into()
        }
        unsafe extern "system" fn SetDefaultMonitor<Impl: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *const VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultMonitor(::core::mem::transmute_copy(&pguid)).into()
        }
        unsafe extern "system" fn GetDefaultMonitor<Impl: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguid: *mut VMRGUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDefaultMonitor(::core::mem::transmute_copy(&pguid)).into()
        }
        unsafe extern "system" fn GetAvailableMonitors<Impl: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinfo: *mut VMRMONITORINFO, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAvailableMonitors(::core::mem::transmute_copy(&pinfo), ::core::mem::transmute_copy(&dwmaxinfoarraysize), ::core::mem::transmute_copy(&pdwnumdevices)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMonitor: SetMonitor::<Impl, IMPL_OFFSET>,
            GetMonitor: GetMonitor::<Impl, IMPL_OFFSET>,
            SetDefaultMonitor: SetDefaultMonitor::<Impl, IMPL_OFFSET>,
            GetDefaultMonitor: GetDefaultMonitor::<Impl, IMPL_OFFSET>,
            GetAvailableMonitors: GetAvailableMonitors::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMonitorConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMonitorConfig9_Impl: Sized {
    fn SetMonitor(&mut self, udev: u32) -> ::windows::core::Result<()>;
    fn GetMonitor(&mut self) -> ::windows::core::Result<u32>;
    fn SetDefaultMonitor(&mut self, udev: u32) -> ::windows::core::Result<()>;
    fn GetDefaultMonitor(&mut self) -> ::windows::core::Result<u32>;
    fn GetAvailableMonitors(&mut self, pinfo: *mut VMR9MonitorInfo, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IVMRMonitorConfig9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRMonitorConfig9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRMonitorConfig9_Vtbl {
        unsafe extern "system" fn SetMonitor<Impl: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, udev: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMonitor(::core::mem::transmute_copy(&udev)).into()
        }
        unsafe extern "system" fn GetMonitor<Impl: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pudev: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMonitor() {
                ::core::result::Result::Ok(ok__) => {
                    *pudev = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultMonitor<Impl: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, udev: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultMonitor(::core::mem::transmute_copy(&udev)).into()
        }
        unsafe extern "system" fn GetDefaultMonitor<Impl: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pudev: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultMonitor() {
                ::core::result::Result::Ok(ok__) => {
                    *pudev = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableMonitors<Impl: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinfo: *mut VMR9MonitorInfo, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAvailableMonitors(::core::mem::transmute_copy(&pinfo), ::core::mem::transmute_copy(&dwmaxinfoarraysize), ::core::mem::transmute_copy(&pdwnumdevices)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMonitor: SetMonitor::<Impl, IMPL_OFFSET>,
            GetMonitor: GetMonitor::<Impl, IMPL_OFFSET>,
            SetDefaultMonitor: SetDefaultMonitor::<Impl, IMPL_OFFSET>,
            GetDefaultMonitor: GetDefaultMonitor::<Impl, IMPL_OFFSET>,
            GetAvailableMonitors: GetAvailableMonitors::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRMonitorConfig9 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRSurface_Impl: Sized {
    fn IsSurfaceLocked(&mut self) -> ::windows::core::Result<()>;
    fn LockSurface(&mut self, lpsurface: *mut *mut u8) -> ::windows::core::Result<()>;
    fn UnlockSurface(&mut self) -> ::windows::core::Result<()>;
    fn GetSurface(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface7>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRSurface_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurface_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurface_Vtbl {
        unsafe extern "system" fn IsSurfaceLocked<Impl: IVMRSurface_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSurfaceLocked().into()
        }
        unsafe extern "system" fn LockSurface<Impl: IVMRSurface_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsurface: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockSurface(::core::mem::transmute_copy(&lpsurface)).into()
        }
        unsafe extern "system" fn UnlockSurface<Impl: IVMRSurface_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockSurface().into()
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurface_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *lplpsurface = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsSurfaceLocked: IsSurfaceLocked::<Impl, IMPL_OFFSET>,
            LockSurface: LockSurface::<Impl, IMPL_OFFSET>,
            UnlockSurface: UnlockSurface::<Impl, IMPL_OFFSET>,
            GetSurface: GetSurface::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurface as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IVMRSurface9_Impl: Sized {
    fn IsSurfaceLocked(&mut self) -> ::windows::core::Result<()>;
    fn LockSurface(&mut self) -> ::windows::core::Result<*mut u8>;
    fn UnlockSurface(&mut self) -> ::windows::core::Result<()>;
    fn GetSurface(&mut self) -> ::windows::core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IVMRSurface9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurface9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurface9_Vtbl {
        unsafe extern "system" fn IsSurfaceLocked<Impl: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSurfaceLocked().into()
        }
        unsafe extern "system" fn LockSurface<Impl: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsurface: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LockSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *lpsurface = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockSurface<Impl: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockSurface().into()
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSurface() {
                ::core::result::Result::Ok(ok__) => {
                    *lplpsurface = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsSurfaceLocked: IsSurfaceLocked::<Impl, IMPL_OFFSET>,
            LockSurface: LockSurface::<Impl, IMPL_OFFSET>,
            UnlockSurface: UnlockSurface::<Impl, IMPL_OFFSET>,
            GetSurface: GetSurface::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurface9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocator_Impl: Sized {
    fn AllocateSurface(&mut self, dwuserid: usize, lpallocinfo: *mut VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: *mut ::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> ::windows::core::Result<()>;
    fn FreeSurface(&mut self, dwid: usize) -> ::windows::core::Result<()>;
    fn PrepareSurface(&mut self, dwuserid: usize, lpsurface: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>, dwsurfaceflags: u32) -> ::windows::core::Result<()>;
    fn AdviseNotify(&mut self, lpivmrsurfallocnotify: &::core::option::Option<IVMRSurfaceAllocatorNotify>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurfaceAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurfaceAllocator_Vtbl {
        unsafe extern "system" fn AllocateSurface<Impl: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpallocinfo: *mut VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AllocateSurface(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&lpallocinfo), ::core::mem::transmute_copy(&lpdwactualbuffers), ::core::mem::transmute_copy(&lplpsurface)).into()
        }
        unsafe extern "system" fn FreeSurface<Impl: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FreeSurface(::core::mem::transmute_copy(&dwid)).into()
        }
        unsafe extern "system" fn PrepareSurface<Impl: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpsurface: ::windows::core::RawPtr, dwsurfaceflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PrepareSurface(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute(&lpsurface), ::core::mem::transmute_copy(&dwsurfaceflags)).into()
        }
        unsafe extern "system" fn AdviseNotify<Impl: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpivmrsurfallocnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AdviseNotify(::core::mem::transmute(&lpivmrsurfallocnotify)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AllocateSurface: AllocateSurface::<Impl, IMPL_OFFSET>,
            FreeSurface: FreeSurface::<Impl, IMPL_OFFSET>,
            PrepareSurface: PrepareSurface::<Impl, IMPL_OFFSET>,
            AdviseNotify: AdviseNotify::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IVMRSurfaceAllocator9_Impl: Sized {
    fn InitializeDevice(&mut self, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> ::windows::core::Result<()>;
    fn TerminateDevice(&mut self, dwid: usize) -> ::windows::core::Result<()>;
    fn GetSurface(&mut self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32) -> ::windows::core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9>;
    fn AdviseNotify(&mut self, lpivmrsurfallocnotify: &::core::option::Option<IVMRSurfaceAllocatorNotify9>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IVMRSurfaceAllocator9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurfaceAllocator9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurfaceAllocator9_Vtbl {
        unsafe extern "system" fn InitializeDevice<Impl: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeDevice(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&lpallocinfo), ::core::mem::transmute_copy(&lpnumbuffers)).into()
        }
        unsafe extern "system" fn TerminateDevice<Impl: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwid: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TerminateDevice(::core::mem::transmute_copy(&dwid)).into()
        }
        unsafe extern "system" fn GetSurface<Impl: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSurface(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&surfaceindex), ::core::mem::transmute_copy(&surfaceflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *lplpsurface = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AdviseNotify<Impl: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpivmrsurfallocnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AdviseNotify(::core::mem::transmute(&lpivmrsurfallocnotify)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitializeDevice: InitializeDevice::<Impl, IMPL_OFFSET>,
            TerminateDevice: TerminateDevice::<Impl, IMPL_OFFSET>,
            GetSurface: GetSurface::<Impl, IMPL_OFFSET>,
            AdviseNotify: AdviseNotify::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocator9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IVMRSurfaceAllocatorEx9_Impl: Sized + IVMRSurfaceAllocator9_Impl {
    fn GetSurfaceEx(&mut self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, lprcdst: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IVMRSurfaceAllocatorEx9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurfaceAllocatorEx9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurfaceAllocatorEx9_Vtbl {
        unsafe extern "system" fn GetSurfaceEx<Impl: IVMRSurfaceAllocatorEx9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut ::windows::core::RawPtr, lprcdst: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSurfaceEx(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute_copy(&surfaceindex), ::core::mem::transmute_copy(&surfaceflags), ::core::mem::transmute_copy(&lplpsurface), ::core::mem::transmute_copy(&lprcdst)).into()
        }
        Self { base: IVMRSurfaceAllocator9_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetSurfaceEx: GetSurfaceEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorEx9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocatorNotify_Impl: Sized {
    fn AdviseSurfaceAllocator(&mut self, dwuserid: usize, lpivrmsurfaceallocator: &::core::option::Option<IVMRSurfaceAllocator>) -> ::windows::core::Result<()>;
    fn SetDDrawDevice(&mut self, lpddrawdevice: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw7>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::Result<()>;
    fn ChangeDDrawDevice(&mut self, lpddrawdevice: &::core::option::Option<super::super::Graphics::DirectDraw::IDirectDraw7>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::Result<()>;
    fn RestoreDDrawSurfaces(&mut self) -> ::windows::core::Result<()>;
    fn NotifyEvent(&mut self, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::Result<()>;
    fn SetBorderColor(&mut self, clrborder: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocatorNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurfaceAllocatorNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurfaceAllocatorNotify_Vtbl {
        unsafe extern "system" fn AdviseSurfaceAllocator<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AdviseSurfaceAllocator(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute(&lpivrmsurfaceallocator)).into()
        }
        unsafe extern "system" fn SetDDrawDevice<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpddrawdevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDDrawDevice(::core::mem::transmute(&lpddrawdevice), ::core::mem::transmute_copy(&hmonitor)).into()
        }
        unsafe extern "system" fn ChangeDDrawDevice<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpddrawdevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeDDrawDevice(::core::mem::transmute(&lpddrawdevice), ::core::mem::transmute_copy(&hmonitor)).into()
        }
        unsafe extern "system" fn RestoreDDrawSurfaces<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RestoreDDrawSurfaces().into()
        }
        unsafe extern "system" fn NotifyEvent<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyEvent(::core::mem::transmute_copy(&eventcode), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2)).into()
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clrborder: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&clrborder)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AdviseSurfaceAllocator: AdviseSurfaceAllocator::<Impl, IMPL_OFFSET>,
            SetDDrawDevice: SetDDrawDevice::<Impl, IMPL_OFFSET>,
            ChangeDDrawDevice: ChangeDDrawDevice::<Impl, IMPL_OFFSET>,
            RestoreDDrawSurfaces: RestoreDDrawSurfaces::<Impl, IMPL_OFFSET>,
            NotifyEvent: NotifyEvent::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocatorNotify9_Impl: Sized {
    fn AdviseSurfaceAllocator(&mut self, dwuserid: usize, lpivrmsurfaceallocator: &::core::option::Option<IVMRSurfaceAllocator9>) -> ::windows::core::Result<()>;
    fn SetD3DDevice(&mut self, lpd3ddevice: &::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::Result<()>;
    fn ChangeD3DDevice(&mut self, lpd3ddevice: &::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::Result<()>;
    fn AllocateSurfaceHelper(&mut self, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>) -> ::windows::core::Result<()>;
    fn NotifyEvent(&mut self, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocatorNotify9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRSurfaceAllocatorNotify9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRSurfaceAllocatorNotify9_Vtbl {
        unsafe extern "system" fn AdviseSurfaceAllocator<Impl: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AdviseSurfaceAllocator(::core::mem::transmute_copy(&dwuserid), ::core::mem::transmute(&lpivrmsurfaceallocator)).into()
        }
        unsafe extern "system" fn SetD3DDevice<Impl: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpd3ddevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetD3DDevice(::core::mem::transmute(&lpd3ddevice), ::core::mem::transmute_copy(&hmonitor)).into()
        }
        unsafe extern "system" fn ChangeD3DDevice<Impl: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpd3ddevice: ::windows::core::RawPtr, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ChangeD3DDevice(::core::mem::transmute(&lpd3ddevice), ::core::mem::transmute_copy(&hmonitor)).into()
        }
        unsafe extern "system" fn AllocateSurfaceHelper<Impl: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AllocateSurfaceHelper(::core::mem::transmute_copy(&lpallocinfo), ::core::mem::transmute_copy(&lpnumbuffers), ::core::mem::transmute_copy(&lplpsurface)).into()
        }
        unsafe extern "system" fn NotifyEvent<Impl: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyEvent(::core::mem::transmute_copy(&eventcode), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AdviseSurfaceAllocator: AdviseSurfaceAllocator::<Impl, IMPL_OFFSET>,
            SetD3DDevice: SetD3DDevice::<Impl, IMPL_OFFSET>,
            ChangeD3DDevice: ChangeD3DDevice::<Impl, IMPL_OFFSET>,
            AllocateSurfaceHelper: AllocateSurfaceHelper::<Impl, IMPL_OFFSET>,
            NotifyEvent: NotifyEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorNotify9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVMRVideoStreamControl_Impl: Sized {
    fn SetColorKey(&mut self, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::Result<()>;
    fn GetColorKey(&mut self, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::Result<()>;
    fn SetStreamActiveState(&mut self, factive: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamActiveState(&mut self, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVMRVideoStreamControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRVideoStreamControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRVideoStreamControl_Vtbl {
        unsafe extern "system" fn SetColorKey<Impl: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&lpclrkey)).into()
        }
        unsafe extern "system" fn GetColorKey<Impl: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetColorKey(::core::mem::transmute_copy(&lpclrkey)).into()
        }
        unsafe extern "system" fn SetStreamActiveState<Impl: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamActiveState(::core::mem::transmute_copy(&factive)).into()
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamActiveState(::core::mem::transmute_copy(&lpfactive)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            GetColorKey: GetColorKey::<Impl, IMPL_OFFSET>,
            SetStreamActiveState: SetStreamActiveState::<Impl, IMPL_OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRVideoStreamControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IVMRVideoStreamControl9_Impl: Sized {
    fn SetStreamActiveState(&mut self, factive: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamActiveState(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IVMRVideoStreamControl9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRVideoStreamControl9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRVideoStreamControl9_Vtbl {
        unsafe extern "system" fn SetStreamActiveState<Impl: IVMRVideoStreamControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamActiveState(::core::mem::transmute_copy(&factive)).into()
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IVMRVideoStreamControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamActiveState() {
                ::core::result::Result::Ok(ok__) => {
                    *lpfactive = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetStreamActiveState: SetStreamActiveState::<Impl, IMPL_OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRVideoStreamControl9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRWindowlessControl_Impl: Sized {
    fn GetNativeVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMinIdealVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMaxIdealVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::Result<()>;
    fn SetVideoPosition(&mut self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetVideoPosition(&mut self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetAspectRatioMode(&mut self, lpaspectratiomode: *mut u32) -> ::windows::core::Result<()>;
    fn SetAspectRatioMode(&mut self, aspectratiomode: u32) -> ::windows::core::Result<()>;
    fn SetVideoClippingWindow(&mut self, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn RepaintVideo(&mut self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::Result<()>;
    fn DisplayModeChanged(&mut self) -> ::windows::core::Result<()>;
    fn GetCurrentImage(&mut self, lpdib: *mut *mut u8) -> ::windows::core::Result<()>;
    fn SetBorderColor(&mut self, clr: u32) -> ::windows::core::Result<()>;
    fn GetBorderColor(&mut self, lpclr: *mut u32) -> ::windows::core::Result<()>;
    fn SetColorKey(&mut self, clr: u32) -> ::windows::core::Result<()>;
    fn GetColorKey(&mut self, lpclr: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IVMRWindowlessControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRWindowlessControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRWindowlessControl_Vtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight), ::core::mem::transmute_copy(&lparwidth), ::core::mem::transmute_copy(&lparheight)).into()
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMinIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)).into()
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMaxIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)).into()
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoPosition(::core::mem::transmute_copy(&lpsrcrect), ::core::mem::transmute_copy(&lpdstrect)).into()
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPosition(::core::mem::transmute_copy(&lpsrcrect), ::core::mem::transmute_copy(&lpdstrect)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAspectRatioMode(::core::mem::transmute_copy(&lpaspectratiomode)).into()
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, aspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&aspectratiomode)).into()
        }
        unsafe extern "system" fn SetVideoClippingWindow<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoClippingWindow(::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn RepaintVideo<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RepaintVideo(::core::mem::transmute_copy(&hwnd), ::core::mem::transmute_copy(&hdc)).into()
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisplayModeChanged().into()
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdib: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentImage(::core::mem::transmute_copy(&lpdib)).into()
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBorderColor(::core::mem::transmute_copy(&lpclr)).into()
        }
        unsafe extern "system" fn SetColorKey<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorKey(::core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetColorKey<Impl: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetColorKey(::core::mem::transmute_copy(&lpclr)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Impl, IMPL_OFFSET>,
            GetMinIdealVideoSize: GetMinIdealVideoSize::<Impl, IMPL_OFFSET>,
            GetMaxIdealVideoSize: GetMaxIdealVideoSize::<Impl, IMPL_OFFSET>,
            SetVideoPosition: SetVideoPosition::<Impl, IMPL_OFFSET>,
            GetVideoPosition: GetVideoPosition::<Impl, IMPL_OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetVideoClippingWindow: SetVideoClippingWindow::<Impl, IMPL_OFFSET>,
            RepaintVideo: RepaintVideo::<Impl, IMPL_OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Impl, IMPL_OFFSET>,
            GetCurrentImage: GetCurrentImage::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            GetBorderColor: GetBorderColor::<Impl, IMPL_OFFSET>,
            SetColorKey: SetColorKey::<Impl, IMPL_OFFSET>,
            GetColorKey: GetColorKey::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRWindowlessControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRWindowlessControl9_Impl: Sized {
    fn GetNativeVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMinIdealVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMaxIdealVideoSize(&mut self, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::Result<()>;
    fn SetVideoPosition(&mut self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetVideoPosition(&mut self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetAspectRatioMode(&mut self) -> ::windows::core::Result<u32>;
    fn SetAspectRatioMode(&mut self, aspectratiomode: u32) -> ::windows::core::Result<()>;
    fn SetVideoClippingWindow(&mut self, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn RepaintVideo(&mut self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::Result<()>;
    fn DisplayModeChanged(&mut self) -> ::windows::core::Result<()>;
    fn GetCurrentImage(&mut self) -> ::windows::core::Result<*mut u8>;
    fn SetBorderColor(&mut self, clr: u32) -> ::windows::core::Result<()>;
    fn GetBorderColor(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IVMRWindowlessControl9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVMRWindowlessControl9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVMRWindowlessControl9_Vtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight), ::core::mem::transmute_copy(&lparwidth), ::core::mem::transmute_copy(&lparheight)).into()
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMinIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)).into()
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMaxIdealVideoSize(::core::mem::transmute_copy(&lpwidth), ::core::mem::transmute_copy(&lpheight)).into()
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoPosition(::core::mem::transmute_copy(&lpsrcrect), ::core::mem::transmute_copy(&lpdstrect)).into()
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPosition(::core::mem::transmute_copy(&lpsrcrect), ::core::mem::transmute_copy(&lpdstrect)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *lpaspectratiomode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, aspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&aspectratiomode)).into()
        }
        unsafe extern "system" fn SetVideoClippingWindow<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoClippingWindow(::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn RepaintVideo<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RepaintVideo(::core::mem::transmute_copy(&hwnd), ::core::mem::transmute_copy(&hdc)).into()
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisplayModeChanged().into()
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdib: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentImage() {
                ::core::result::Result::Ok(ok__) => {
                    *lpdib = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Impl: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBorderColor() {
                ::core::result::Result::Ok(ok__) => {
                    *lpclr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Impl, IMPL_OFFSET>,
            GetMinIdealVideoSize: GetMinIdealVideoSize::<Impl, IMPL_OFFSET>,
            GetMaxIdealVideoSize: GetMaxIdealVideoSize::<Impl, IMPL_OFFSET>,
            SetVideoPosition: SetVideoPosition::<Impl, IMPL_OFFSET>,
            GetVideoPosition: GetVideoPosition::<Impl, IMPL_OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetVideoClippingWindow: SetVideoClippingWindow::<Impl, IMPL_OFFSET>,
            RepaintVideo: RepaintVideo::<Impl, IMPL_OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Impl, IMPL_OFFSET>,
            GetCurrentImage: GetCurrentImage::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            GetBorderColor: GetBorderColor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVMRWindowlessControl9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVPBaseConfig_Impl: Sized {
    fn GetConnectInfo(&mut self, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> ::windows::core::Result<()>;
    fn SetConnectInfo(&mut self, dwchosenentry: u32) -> ::windows::core::Result<()>;
    fn GetVPDataInfo(&mut self, pamvpdatainfo: *mut AMVPDATAINFO) -> ::windows::core::Result<()>;
    fn GetMaxPixelRate(&mut self, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> ::windows::core::Result<()>;
    fn InformVPInputFormats(&mut self, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::Result<()>;
    fn GetVideoFormats(&mut self, pdwnumformats: *mut u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::Result<()>;
    fn SetVideoFormat(&mut self, dwchosenentry: u32) -> ::windows::core::Result<()>;
    fn SetInvertPolarity(&mut self) -> ::windows::core::Result<()>;
    fn GetOverlaySurface(&mut self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface>;
    fn SetDirectDrawKernelHandle(&mut self, dwddkernelhandle: usize) -> ::windows::core::Result<()>;
    fn SetVideoPortID(&mut self, dwvideoportid: u32) -> ::windows::core::Result<()>;
    fn SetDDSurfaceKernelHandles(&mut self, chandles: u32, rgddkernelhandles: *mut usize) -> ::windows::core::Result<()>;
    fn SetSurfaceParameters(&mut self, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVPBaseConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPBaseConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPBaseConfig_Vtbl {
        unsafe extern "system" fn GetConnectInfo<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetConnectInfo(::core::mem::transmute_copy(&pdwnumconnectinfo), ::core::mem::transmute_copy(&pddvpconnectinfo)).into()
        }
        unsafe extern "system" fn SetConnectInfo<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwchosenentry: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConnectInfo(::core::mem::transmute_copy(&dwchosenentry)).into()
        }
        unsafe extern "system" fn GetVPDataInfo<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pamvpdatainfo: *mut AMVPDATAINFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVPDataInfo(::core::mem::transmute_copy(&pamvpdatainfo)).into()
        }
        unsafe extern "system" fn GetMaxPixelRate<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMaxPixelRate(::core::mem::transmute_copy(&pamvpsize), ::core::mem::transmute_copy(&pdwmaxpixelspersecond)).into()
        }
        unsafe extern "system" fn InformVPInputFormats<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InformVPInputFormats(::core::mem::transmute_copy(&dwnumformats), ::core::mem::transmute_copy(&pddpixelformats)).into()
        }
        unsafe extern "system" fn GetVideoFormats<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumformats: *mut u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoFormats(::core::mem::transmute_copy(&pdwnumformats), ::core::mem::transmute_copy(&pddpixelformats)).into()
        }
        unsafe extern "system" fn SetVideoFormat<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwchosenentry: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoFormat(::core::mem::transmute_copy(&dwchosenentry)).into()
        }
        unsafe extern "system" fn SetInvertPolarity<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInvertPolarity().into()
        }
        unsafe extern "system" fn GetOverlaySurface<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppddoverlaysurface: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOverlaySurface() {
                ::core::result::Result::Ok(ok__) => {
                    *ppddoverlaysurface = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDirectDrawKernelHandle<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwddkernelhandle: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectDrawKernelHandle(::core::mem::transmute_copy(&dwddkernelhandle)).into()
        }
        unsafe extern "system" fn SetVideoPortID<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwvideoportid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoPortID(::core::mem::transmute_copy(&dwvideoportid)).into()
        }
        unsafe extern "system" fn SetDDSurfaceKernelHandles<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, chandles: u32, rgddkernelhandles: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDDSurfaceKernelHandles(::core::mem::transmute_copy(&chandles), ::core::mem::transmute_copy(&rgddkernelhandles)).into()
        }
        unsafe extern "system" fn SetSurfaceParameters<Impl: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSurfaceParameters(::core::mem::transmute_copy(&dwpitch), ::core::mem::transmute_copy(&dwxorigin), ::core::mem::transmute_copy(&dwyorigin)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetConnectInfo: GetConnectInfo::<Impl, IMPL_OFFSET>,
            SetConnectInfo: SetConnectInfo::<Impl, IMPL_OFFSET>,
            GetVPDataInfo: GetVPDataInfo::<Impl, IMPL_OFFSET>,
            GetMaxPixelRate: GetMaxPixelRate::<Impl, IMPL_OFFSET>,
            InformVPInputFormats: InformVPInputFormats::<Impl, IMPL_OFFSET>,
            GetVideoFormats: GetVideoFormats::<Impl, IMPL_OFFSET>,
            SetVideoFormat: SetVideoFormat::<Impl, IMPL_OFFSET>,
            SetInvertPolarity: SetInvertPolarity::<Impl, IMPL_OFFSET>,
            GetOverlaySurface: GetOverlaySurface::<Impl, IMPL_OFFSET>,
            SetDirectDrawKernelHandle: SetDirectDrawKernelHandle::<Impl, IMPL_OFFSET>,
            SetVideoPortID: SetVideoPortID::<Impl, IMPL_OFFSET>,
            SetDDSurfaceKernelHandles: SetDDSurfaceKernelHandles::<Impl, IMPL_OFFSET>,
            SetSurfaceParameters: SetSurfaceParameters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPBaseConfig as ::windows::core::Interface>::IID
    }
}
pub trait IVPBaseNotify_Impl: Sized {
    fn RenegotiateVPParameters(&mut self) -> ::windows::core::Result<()>;
}
impl IVPBaseNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPBaseNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPBaseNotify_Vtbl {
        unsafe extern "system" fn RenegotiateVPParameters<Impl: IVPBaseNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RenegotiateVPParameters().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), RenegotiateVPParameters: RenegotiateVPParameters::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPBaseNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVPConfig_Impl: Sized + IVPBaseConfig_Impl {
    fn IsVPDecimationAllowed(&mut self, pbisdecimationallowed: *mut i32) -> ::windows::core::Result<()>;
    fn SetScalingFactors(&mut self, pamvpsize: *mut AMVPSIZE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVPConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPConfig_Vtbl {
        unsafe extern "system" fn IsVPDecimationAllowed<Impl: IVPConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbisdecimationallowed: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsVPDecimationAllowed(::core::mem::transmute_copy(&pbisdecimationallowed)).into()
        }
        unsafe extern "system" fn SetScalingFactors<Impl: IVPConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pamvpsize: *mut AMVPSIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetScalingFactors(::core::mem::transmute_copy(&pamvpsize)).into()
        }
        Self {
            base: IVPBaseConfig_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            IsVPDecimationAllowed: IsVPDecimationAllowed::<Impl, IMPL_OFFSET>,
            SetScalingFactors: SetScalingFactors::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPConfig as ::windows::core::Interface>::IID
    }
}
pub trait IVPManager_Impl: Sized {
    fn SetVideoPortIndex(&mut self, dwvideoportindex: u32) -> ::windows::core::Result<()>;
    fn GetVideoPortIndex(&mut self, pdwvideoportindex: *mut u32) -> ::windows::core::Result<()>;
}
impl IVPManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPManager_Vtbl {
        unsafe extern "system" fn SetVideoPortIndex<Impl: IVPManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwvideoportindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoPortIndex(::core::mem::transmute_copy(&dwvideoportindex)).into()
        }
        unsafe extern "system" fn GetVideoPortIndex<Impl: IVPManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwvideoportindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPortIndex(::core::mem::transmute_copy(&pdwvideoportindex)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetVideoPortIndex: SetVideoPortIndex::<Impl, IMPL_OFFSET>,
            GetVideoPortIndex: GetVideoPortIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPManager as ::windows::core::Interface>::IID
    }
}
pub trait IVPNotify_Impl: Sized + IVPBaseNotify_Impl {
    fn SetDeinterlaceMode(&mut self, mode: AMVP_MODE) -> ::windows::core::Result<()>;
    fn GetDeinterlaceMode(&mut self, pmode: *mut AMVP_MODE) -> ::windows::core::Result<()>;
}
impl IVPNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPNotify_Vtbl {
        unsafe extern "system" fn SetDeinterlaceMode<Impl: IVPNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: AMVP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDeinterlaceMode(::core::mem::transmute_copy(&mode)).into()
        }
        unsafe extern "system" fn GetDeinterlaceMode<Impl: IVPNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut AMVP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDeinterlaceMode(::core::mem::transmute_copy(&pmode)).into()
        }
        Self {
            base: IVPBaseNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetDeinterlaceMode: SetDeinterlaceMode::<Impl, IMPL_OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IVPNotify2_Impl: Sized + IVPBaseNotify_Impl + IVPNotify_Impl {
    fn SetVPSyncMaster(&mut self, bvpsyncmaster: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetVPSyncMaster(&mut self, pbvpsyncmaster: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IVPNotify2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPNotify2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPNotify2_Vtbl {
        unsafe extern "system" fn SetVPSyncMaster<Impl: IVPNotify2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bvpsyncmaster: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVPSyncMaster(::core::mem::transmute_copy(&bvpsyncmaster)).into()
        }
        unsafe extern "system" fn GetVPSyncMaster<Impl: IVPNotify2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbvpsyncmaster: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVPSyncMaster(::core::mem::transmute_copy(&pbvpsyncmaster)).into()
        }
        Self {
            base: IVPNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetVPSyncMaster: SetVPSyncMaster::<Impl, IMPL_OFFSET>,
            GetVPSyncMaster: GetVPSyncMaster::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPNotify2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub trait IVPVBIConfig_Impl: Sized + IVPBaseConfig_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl IVPVBIConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPVBIConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPVBIConfig_Vtbl {
        Self { base: IVPBaseConfig_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPVBIConfig as ::windows::core::Interface>::IID
    }
}
pub trait IVPVBINotify_Impl: Sized + IVPBaseNotify_Impl {}
impl IVPVBINotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVPVBINotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVPVBINotify_Vtbl {
        Self { base: IVPBaseNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVPVBINotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IVideoEncoder_Impl: Sized + IEncoderAPI_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IVideoEncoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVideoEncoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVideoEncoder_Vtbl {
        Self { base: IEncoderAPI_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVideoEncoder as ::windows::core::Interface>::IID
    }
}
pub trait IVideoFrameStep_Impl: Sized {
    fn Step(&mut self, dwframes: u32, pstepobject: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CanStep(&mut self, bmultiple: i32, pstepobject: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CancelStep(&mut self) -> ::windows::core::Result<()>;
}
impl IVideoFrameStep_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVideoFrameStep_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVideoFrameStep_Vtbl {
        unsafe extern "system" fn Step<Impl: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwframes: u32, pstepobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Step(::core::mem::transmute_copy(&dwframes), ::core::mem::transmute(&pstepobject)).into()
        }
        unsafe extern "system" fn CanStep<Impl: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bmultiple: i32, pstepobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CanStep(::core::mem::transmute_copy(&bmultiple), ::core::mem::transmute(&pstepobject)).into()
        }
        unsafe extern "system" fn CancelStep<Impl: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelStep().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Step: Step::<Impl, IMPL_OFFSET>,
            CanStep: CanStep::<Impl, IMPL_OFFSET>,
            CancelStep: CancelStep::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVideoFrameStep as ::windows::core::Interface>::IID
    }
}
pub trait IVideoProcAmp_Impl: Sized {
    fn BacklightCompensation(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetBacklightCompensation(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_BacklightCompensation(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Brightness(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetBrightness(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Brightness(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn ColorEnable(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetColorEnable(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_ColorEnable(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Contrast(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetContrast(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Contrast(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Gamma(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetGamma(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Gamma(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Saturation(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetSaturation(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Saturation(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Sharpness(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetSharpness(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Sharpness(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn WhiteBalance(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetWhiteBalance(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_WhiteBalance(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Gain(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetGain(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Gain(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn Hue(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetHue(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_Hue(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn DigitalMultiplier(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetDigitalMultiplier(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_DigitalMultiplier(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn PowerlineFrequency(&mut self, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetPowerlineFrequency(&mut self, value: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_PowerlineFrequency(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
    fn WhiteBalanceComponent(&mut self, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> ::windows::core::Result<()>;
    fn SetWhiteBalanceComponent(&mut self, value1: i32, value2: i32, flags: i32) -> ::windows::core::Result<()>;
    fn getRange_WhiteBalanceComponent(&mut self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::Result<()>;
}
impl IVideoProcAmp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVideoProcAmp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVideoProcAmp_Vtbl {
        unsafe extern "system" fn BacklightCompensation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BacklightCompensation(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetBacklightCompensation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBacklightCompensation(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_BacklightCompensation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_BacklightCompensation(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Brightness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Brightness(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetBrightness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBrightness(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Brightness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Brightness(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn ColorEnable<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ColorEnable(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetColorEnable<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorEnable(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_ColorEnable<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_ColorEnable(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Contrast<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Contrast(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetContrast<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContrast(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Contrast<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Contrast(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Gamma<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Gamma(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetGamma<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGamma(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Gamma<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Gamma(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Saturation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Saturation(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetSaturation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSaturation(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Saturation<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Saturation(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Sharpness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Sharpness(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetSharpness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSharpness(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Sharpness<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Sharpness(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn WhiteBalance<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WhiteBalance(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetWhiteBalance<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWhiteBalance(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_WhiteBalance<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_WhiteBalance(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Gain<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Gain(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetGain<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGain(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Gain<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Gain(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn Hue<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Hue(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetHue<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHue(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_Hue<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_Hue(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn DigitalMultiplier<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DigitalMultiplier(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetDigitalMultiplier<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDigitalMultiplier(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_DigitalMultiplier<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_DigitalMultiplier(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn PowerlineFrequency<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PowerlineFrequency(::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetPowerlineFrequency<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPowerlineFrequency(::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_PowerlineFrequency<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_PowerlineFrequency(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        unsafe extern "system" fn WhiteBalanceComponent<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WhiteBalanceComponent(::core::mem::transmute_copy(&pvalue1), ::core::mem::transmute_copy(&pvalue2), ::core::mem::transmute_copy(&pflags)).into()
        }
        unsafe extern "system" fn SetWhiteBalanceComponent<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value1: i32, value2: i32, flags: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWhiteBalanceComponent(::core::mem::transmute_copy(&value1), ::core::mem::transmute_copy(&value2), ::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn getRange_WhiteBalanceComponent<Impl: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).getRange_WhiteBalanceComponent(::core::mem::transmute_copy(&pmin), ::core::mem::transmute_copy(&pmax), ::core::mem::transmute_copy(&psteppingdelta), ::core::mem::transmute_copy(&pdefault), ::core::mem::transmute_copy(&pcapsflag)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BacklightCompensation: BacklightCompensation::<Impl, IMPL_OFFSET>,
            SetBacklightCompensation: SetBacklightCompensation::<Impl, IMPL_OFFSET>,
            getRange_BacklightCompensation: getRange_BacklightCompensation::<Impl, IMPL_OFFSET>,
            Brightness: Brightness::<Impl, IMPL_OFFSET>,
            SetBrightness: SetBrightness::<Impl, IMPL_OFFSET>,
            getRange_Brightness: getRange_Brightness::<Impl, IMPL_OFFSET>,
            ColorEnable: ColorEnable::<Impl, IMPL_OFFSET>,
            SetColorEnable: SetColorEnable::<Impl, IMPL_OFFSET>,
            getRange_ColorEnable: getRange_ColorEnable::<Impl, IMPL_OFFSET>,
            Contrast: Contrast::<Impl, IMPL_OFFSET>,
            SetContrast: SetContrast::<Impl, IMPL_OFFSET>,
            getRange_Contrast: getRange_Contrast::<Impl, IMPL_OFFSET>,
            Gamma: Gamma::<Impl, IMPL_OFFSET>,
            SetGamma: SetGamma::<Impl, IMPL_OFFSET>,
            getRange_Gamma: getRange_Gamma::<Impl, IMPL_OFFSET>,
            Saturation: Saturation::<Impl, IMPL_OFFSET>,
            SetSaturation: SetSaturation::<Impl, IMPL_OFFSET>,
            getRange_Saturation: getRange_Saturation::<Impl, IMPL_OFFSET>,
            Sharpness: Sharpness::<Impl, IMPL_OFFSET>,
            SetSharpness: SetSharpness::<Impl, IMPL_OFFSET>,
            getRange_Sharpness: getRange_Sharpness::<Impl, IMPL_OFFSET>,
            WhiteBalance: WhiteBalance::<Impl, IMPL_OFFSET>,
            SetWhiteBalance: SetWhiteBalance::<Impl, IMPL_OFFSET>,
            getRange_WhiteBalance: getRange_WhiteBalance::<Impl, IMPL_OFFSET>,
            Gain: Gain::<Impl, IMPL_OFFSET>,
            SetGain: SetGain::<Impl, IMPL_OFFSET>,
            getRange_Gain: getRange_Gain::<Impl, IMPL_OFFSET>,
            Hue: Hue::<Impl, IMPL_OFFSET>,
            SetHue: SetHue::<Impl, IMPL_OFFSET>,
            getRange_Hue: getRange_Hue::<Impl, IMPL_OFFSET>,
            DigitalMultiplier: DigitalMultiplier::<Impl, IMPL_OFFSET>,
            SetDigitalMultiplier: SetDigitalMultiplier::<Impl, IMPL_OFFSET>,
            getRange_DigitalMultiplier: getRange_DigitalMultiplier::<Impl, IMPL_OFFSET>,
            PowerlineFrequency: PowerlineFrequency::<Impl, IMPL_OFFSET>,
            SetPowerlineFrequency: SetPowerlineFrequency::<Impl, IMPL_OFFSET>,
            getRange_PowerlineFrequency: getRange_PowerlineFrequency::<Impl, IMPL_OFFSET>,
            WhiteBalanceComponent: WhiteBalanceComponent::<Impl, IMPL_OFFSET>,
            SetWhiteBalanceComponent: SetWhiteBalanceComponent::<Impl, IMPL_OFFSET>,
            getRange_WhiteBalanceComponent: getRange_WhiteBalanceComponent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVideoProcAmp as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IVideoWindow_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn SetCaption(&mut self, strcaption: &super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn Caption(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SetWindowStyle(&mut self, windowstyle: i32) -> ::windows::core::Result<()>;
    fn WindowStyle(&mut self) -> ::windows::core::Result<i32>;
    fn SetWindowStyleEx(&mut self, windowstyleex: i32) -> ::windows::core::Result<()>;
    fn WindowStyleEx(&mut self) -> ::windows::core::Result<i32>;
    fn SetAutoShow(&mut self, autoshow: i32) -> ::windows::core::Result<()>;
    fn AutoShow(&mut self) -> ::windows::core::Result<i32>;
    fn SetWindowState(&mut self, windowstate: i32) -> ::windows::core::Result<()>;
    fn WindowState(&mut self) -> ::windows::core::Result<i32>;
    fn SetBackgroundPalette(&mut self, backgroundpalette: i32) -> ::windows::core::Result<()>;
    fn BackgroundPalette(&mut self) -> ::windows::core::Result<i32>;
    fn SetVisible(&mut self, visible: i32) -> ::windows::core::Result<()>;
    fn Visible(&mut self) -> ::windows::core::Result<i32>;
    fn SetLeft(&mut self, left: i32) -> ::windows::core::Result<()>;
    fn Left(&mut self) -> ::windows::core::Result<i32>;
    fn SetWidth(&mut self, width: i32) -> ::windows::core::Result<()>;
    fn Width(&mut self) -> ::windows::core::Result<i32>;
    fn SetTop(&mut self, top: i32) -> ::windows::core::Result<()>;
    fn Top(&mut self) -> ::windows::core::Result<i32>;
    fn SetHeight(&mut self, height: i32) -> ::windows::core::Result<()>;
    fn Height(&mut self) -> ::windows::core::Result<i32>;
    fn SetOwner(&mut self, owner: isize) -> ::windows::core::Result<()>;
    fn Owner(&mut self) -> ::windows::core::Result<isize>;
    fn SetMessageDrain(&mut self, drain: isize) -> ::windows::core::Result<()>;
    fn MessageDrain(&mut self) -> ::windows::core::Result<isize>;
    fn BorderColor(&mut self) -> ::windows::core::Result<i32>;
    fn SetBorderColor(&mut self, color: i32) -> ::windows::core::Result<()>;
    fn FullScreenMode(&mut self) -> ::windows::core::Result<i32>;
    fn SetFullScreenMode(&mut self, fullscreenmode: i32) -> ::windows::core::Result<()>;
    fn SetWindowForeground(&mut self, focus: i32) -> ::windows::core::Result<()>;
    fn NotifyOwnerMessage(&mut self, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> ::windows::core::Result<()>;
    fn SetWindowPosition(&mut self, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::Result<()>;
    fn GetWindowPosition(&mut self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMinIdealImageSize(&mut self, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetMaxIdealImageSize(&mut self, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn GetRestorePosition(&mut self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()>;
    fn HideCursor(&mut self, hidecursor: OA_BOOL) -> ::windows::core::Result<()>;
    fn IsCursorHidden(&mut self) -> ::windows::core::Result<i32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IVideoWindow_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IVideoWindow_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IVideoWindow_Vtbl {
        unsafe extern "system" fn SetCaption<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strcaption: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCaption(::core::mem::transmute_copy(&strcaption)).into()
        }
        unsafe extern "system" fn Caption<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, strcaption: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Caption() {
                ::core::result::Result::Ok(ok__) => {
                    *strcaption = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowStyle<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstyle: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowStyle(::core::mem::transmute_copy(&windowstyle)).into()
        }
        unsafe extern "system" fn WindowStyle<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstyle: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WindowStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *windowstyle = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowStyleEx<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstyleex: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowStyleEx(::core::mem::transmute_copy(&windowstyleex)).into()
        }
        unsafe extern "system" fn WindowStyleEx<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstyleex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WindowStyleEx() {
                ::core::result::Result::Ok(ok__) => {
                    *windowstyleex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoShow<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, autoshow: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoShow(::core::mem::transmute_copy(&autoshow)).into()
        }
        unsafe extern "system" fn AutoShow<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, autoshow: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AutoShow() {
                ::core::result::Result::Ok(ok__) => {
                    *autoshow = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWindowState<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstate: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowState(::core::mem::transmute_copy(&windowstate)).into()
        }
        unsafe extern "system" fn WindowState<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windowstate: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).WindowState() {
                ::core::result::Result::Ok(ok__) => {
                    *windowstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundPalette<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, backgroundpalette: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundPalette(::core::mem::transmute_copy(&backgroundpalette)).into()
        }
        unsafe extern "system" fn BackgroundPalette<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbackgroundpalette: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BackgroundPalette() {
                ::core::result::Result::Ok(ok__) => {
                    *pbackgroundpalette = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisible<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, visible: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVisible(::core::mem::transmute_copy(&visible)).into()
        }
        unsafe extern "system" fn Visible<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvisible: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Visible() {
                ::core::result::Result::Ok(ok__) => {
                    *pvisible = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, left: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLeft(::core::mem::transmute_copy(&left)).into()
        }
        unsafe extern "system" fn Left<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pleft: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Left() {
                ::core::result::Result::Ok(ok__) => {
                    *pleft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, width: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWidth(::core::mem::transmute_copy(&width)).into()
        }
        unsafe extern "system" fn Width<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Width() {
                ::core::result::Result::Ok(ok__) => {
                    *pwidth = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, top: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTop(::core::mem::transmute_copy(&top)).into()
        }
        unsafe extern "system" fn Top<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptop: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Top() {
                ::core::result::Result::Ok(ok__) => {
                    *ptop = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHeight(::core::mem::transmute_copy(&height)).into()
        }
        unsafe extern "system" fn Height<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Height() {
                ::core::result::Result::Ok(ok__) => {
                    *pheight = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOwner<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOwner(::core::mem::transmute_copy(&owner)).into()
        }
        unsafe extern "system" fn Owner<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, owner: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Owner() {
                ::core::result::Result::Ok(ok__) => {
                    *owner = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMessageDrain<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, drain: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMessageDrain(::core::mem::transmute_copy(&drain)).into()
        }
        unsafe extern "system" fn MessageDrain<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, drain: *mut isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).MessageDrain() {
                ::core::result::Result::Ok(ok__) => {
                    *drain = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderColor<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BorderColor() {
                ::core::result::Result::Ok(ok__) => {
                    *color = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&color)).into()
        }
        unsafe extern "system" fn FullScreenMode<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fullscreenmode: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FullScreenMode() {
                ::core::result::Result::Ok(ok__) => {
                    *fullscreenmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullScreenMode<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fullscreenmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullScreenMode(::core::mem::transmute_copy(&fullscreenmode)).into()
        }
        unsafe extern "system" fn SetWindowForeground<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, focus: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowForeground(::core::mem::transmute_copy(&focus)).into()
        }
        unsafe extern "system" fn NotifyOwnerMessage<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyOwnerMessage(::core::mem::transmute_copy(&hwnd), ::core::mem::transmute_copy(&umsg), ::core::mem::transmute_copy(&wparam), ::core::mem::transmute_copy(&lparam)).into()
        }
        unsafe extern "system" fn SetWindowPosition<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWindowPosition(::core::mem::transmute_copy(&left), ::core::mem::transmute_copy(&top), ::core::mem::transmute_copy(&width), ::core::mem::transmute_copy(&height)).into()
        }
        unsafe extern "system" fn GetWindowPosition<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetWindowPosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn GetMinIdealImageSize<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMinIdealImageSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn GetMaxIdealImageSize<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMaxIdealImageSize(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn GetRestorePosition<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRestorePosition(::core::mem::transmute_copy(&pleft), ::core::mem::transmute_copy(&ptop), ::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight)).into()
        }
        unsafe extern "system" fn HideCursor<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hidecursor: OA_BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HideCursor(::core::mem::transmute_copy(&hidecursor)).into()
        }
        unsafe extern "system" fn IsCursorHidden<Impl: IVideoWindow_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cursorhidden: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCursorHidden() {
                ::core::result::Result::Ok(ok__) => {
                    *cursorhidden = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetCaption: SetCaption::<Impl, IMPL_OFFSET>,
            Caption: Caption::<Impl, IMPL_OFFSET>,
            SetWindowStyle: SetWindowStyle::<Impl, IMPL_OFFSET>,
            WindowStyle: WindowStyle::<Impl, IMPL_OFFSET>,
            SetWindowStyleEx: SetWindowStyleEx::<Impl, IMPL_OFFSET>,
            WindowStyleEx: WindowStyleEx::<Impl, IMPL_OFFSET>,
            SetAutoShow: SetAutoShow::<Impl, IMPL_OFFSET>,
            AutoShow: AutoShow::<Impl, IMPL_OFFSET>,
            SetWindowState: SetWindowState::<Impl, IMPL_OFFSET>,
            WindowState: WindowState::<Impl, IMPL_OFFSET>,
            SetBackgroundPalette: SetBackgroundPalette::<Impl, IMPL_OFFSET>,
            BackgroundPalette: BackgroundPalette::<Impl, IMPL_OFFSET>,
            SetVisible: SetVisible::<Impl, IMPL_OFFSET>,
            Visible: Visible::<Impl, IMPL_OFFSET>,
            SetLeft: SetLeft::<Impl, IMPL_OFFSET>,
            Left: Left::<Impl, IMPL_OFFSET>,
            SetWidth: SetWidth::<Impl, IMPL_OFFSET>,
            Width: Width::<Impl, IMPL_OFFSET>,
            SetTop: SetTop::<Impl, IMPL_OFFSET>,
            Top: Top::<Impl, IMPL_OFFSET>,
            SetHeight: SetHeight::<Impl, IMPL_OFFSET>,
            Height: Height::<Impl, IMPL_OFFSET>,
            SetOwner: SetOwner::<Impl, IMPL_OFFSET>,
            Owner: Owner::<Impl, IMPL_OFFSET>,
            SetMessageDrain: SetMessageDrain::<Impl, IMPL_OFFSET>,
            MessageDrain: MessageDrain::<Impl, IMPL_OFFSET>,
            BorderColor: BorderColor::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            FullScreenMode: FullScreenMode::<Impl, IMPL_OFFSET>,
            SetFullScreenMode: SetFullScreenMode::<Impl, IMPL_OFFSET>,
            SetWindowForeground: SetWindowForeground::<Impl, IMPL_OFFSET>,
            NotifyOwnerMessage: NotifyOwnerMessage::<Impl, IMPL_OFFSET>,
            SetWindowPosition: SetWindowPosition::<Impl, IMPL_OFFSET>,
            GetWindowPosition: GetWindowPosition::<Impl, IMPL_OFFSET>,
            GetMinIdealImageSize: GetMinIdealImageSize::<Impl, IMPL_OFFSET>,
            GetMaxIdealImageSize: GetMaxIdealImageSize::<Impl, IMPL_OFFSET>,
            GetRestorePosition: GetRestorePosition::<Impl, IMPL_OFFSET>,
            HideCursor: HideCursor::<Impl, IMPL_OFFSET>,
            IsCursorHidden: IsCursorHidden::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IVideoWindow as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IXDSCodec_Impl: Sized {
    fn XDSToRatObjOK(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
    fn SetCCSubstreamService(&mut self, substreammask: i32) -> ::windows::core::Result<()>;
    fn CCSubstreamService(&mut self) -> ::windows::core::Result<i32>;
    fn GetContentAdvisoryRating(&mut self, prat: *mut i32, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn GetXDSPacket(&mut self, pxdsclasspkt: *mut i32, pxdstypepkt: *mut i32, pbstrxdspkt: *mut super::super::Foundation::BSTR, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()>;
    fn GetCurrLicenseExpDate(&mut self, prottype: *const ProtType) -> ::windows::core::Result<i32>;
    fn GetLastErrorCode(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IXDSCodec_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IXDSCodec_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IXDSCodec_Vtbl {
        unsafe extern "system" fn XDSToRatObjOK<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phrcocreateretval: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).XDSToRatObjOK() {
                ::core::result::Result::Ok(ok__) => {
                    *phrcocreateretval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCCSubstreamService<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, substreammask: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCCSubstreamService(::core::mem::transmute_copy(&substreammask)).into()
        }
        unsafe extern "system" fn CCSubstreamService<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psubstreammask: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CCSubstreamService() {
                ::core::result::Result::Ok(ok__) => {
                    *psubstreammask = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContentAdvisoryRating<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prat: *mut i32, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetContentAdvisoryRating(::core::mem::transmute_copy(&prat), ::core::mem::transmute_copy(&ppktseqid), ::core::mem::transmute_copy(&pcallseqid), ::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn GetXDSPacket<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pxdsclasspkt: *mut i32, pxdstypepkt: *mut i32, pbstrxdspkt: *mut super::super::Foundation::BSTR, ppktseqid: *mut i32, pcallseqid: *mut i32, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetXDSPacket(::core::mem::transmute_copy(&pxdsclasspkt), ::core::mem::transmute_copy(&pxdstypepkt), ::core::mem::transmute_copy(&pbstrxdspkt), ::core::mem::transmute_copy(&ppktseqid), ::core::mem::transmute_copy(&pcallseqid), ::core::mem::transmute_copy(&ptimestart), ::core::mem::transmute_copy(&ptimeend)).into()
        }
        unsafe extern "system" fn GetCurrLicenseExpDate<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prottype: *const ProtType, lpdatetime: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrLicenseExpDate(::core::mem::transmute_copy(&prottype)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpdatetime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastErrorCode<Impl: IXDSCodec_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLastErrorCode().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            XDSToRatObjOK: XDSToRatObjOK::<Impl, IMPL_OFFSET>,
            SetCCSubstreamService: SetCCSubstreamService::<Impl, IMPL_OFFSET>,
            CCSubstreamService: CCSubstreamService::<Impl, IMPL_OFFSET>,
            GetContentAdvisoryRating: GetContentAdvisoryRating::<Impl, IMPL_OFFSET>,
            GetXDSPacket: GetXDSPacket::<Impl, IMPL_OFFSET>,
            GetCurrLicenseExpDate: GetCurrLicenseExpDate::<Impl, IMPL_OFFSET>,
            GetLastErrorCode: GetLastErrorCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IXDSCodec as ::windows::core::Interface>::IID
    }
}
pub trait IXDSCodecConfig_Impl: Sized {
    fn GetSecureChannelObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn SetPauseBufferTime(&mut self, dwpausebuffertime: u32) -> ::windows::core::Result<()>;
}
impl IXDSCodecConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IXDSCodecConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IXDSCodecConfig_Vtbl {
        unsafe extern "system" fn GetSecureChannelObject<Impl: IXDSCodecConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunkdrmsecurechannel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSecureChannelObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkdrmsecurechannel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPauseBufferTime<Impl: IXDSCodecConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwpausebuffertime: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPauseBufferTime(::core::mem::transmute_copy(&dwpausebuffertime)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSecureChannelObject: GetSecureChannelObject::<Impl, IMPL_OFFSET>,
            SetPauseBufferTime: SetPauseBufferTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IXDSCodecConfig as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IXDSCodecEvents_Impl: Sized + super::super::System::Com::IDispatch_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IXDSCodecEvents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IXDSCodecEvents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IXDSCodecEvents_Vtbl {
        Self { base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IXDSCodecEvents as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait IXDSToRat_Impl: Sized + super::super::System::Com::IDispatch_Impl {
    fn Init(&mut self) -> ::windows::core::Result<()>;
    fn ParseXDSBytePair(&mut self, byte1: u8, byte2: u8, pensystem: *mut EnTvRat_System, penlevel: *mut EnTvRat_GenericLevel, plbfenattributes: *mut i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl IXDSToRat_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IXDSToRat_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IXDSToRat_Vtbl {
        unsafe extern "system" fn Init<Impl: IXDSToRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Init().into()
        }
        unsafe extern "system" fn ParseXDSBytePair<Impl: IXDSToRat_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, byte1: u8, byte2: u8, pensystem: *mut EnTvRat_System, penlevel: *mut EnTvRat_GenericLevel, plbfenattributes: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ParseXDSBytePair(::core::mem::transmute_copy(&byte1), ::core::mem::transmute_copy(&byte2), ::core::mem::transmute_copy(&pensystem), ::core::mem::transmute_copy(&penlevel), ::core::mem::transmute_copy(&plbfenattributes)).into()
        }
        Self {
            base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Init: Init::<Impl, IMPL_OFFSET>,
            ParseXDSBytePair: ParseXDSBytePair::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IXDSToRat as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait _IMSVidCtlEvents_Impl: Sized + super::super::System::Com::IDispatch_Impl {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl _IMSVidCtlEvents_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: _IMSVidCtlEvents_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> _IMSVidCtlEvents_Vtbl {
        Self { base: super::super::System::Com::IDispatch_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<_IMSVidCtlEvents as ::windows::core::Interface>::IID
    }
}
