#[cfg(feature = "Win32_Media_DirectShow_Tv")]
pub mod Tv;
#[cfg(feature = "Win32_Media_DirectShow_Xml")]
pub mod Xml;
#[inline]
pub unsafe fn AMGetErrorTextA(hr: windows_core::HRESULT, pbuffer: &mut [u8]) -> u32 {
    windows_core::link!("quartz.dll" "system" fn AMGetErrorTextA(hr : windows_core::HRESULT, pbuffer : windows_core::PSTR, maxlen : u32) -> u32);
    unsafe { AMGetErrorTextA(hr, core::mem::transmute(pbuffer.as_ptr()), pbuffer.len().try_into().unwrap()) }
}
#[inline]
pub unsafe fn AMGetErrorTextW(hr: windows_core::HRESULT, pbuffer: &mut [u16]) -> u32 {
    windows_core::link!("quartz.dll" "system" fn AMGetErrorTextW(hr : windows_core::HRESULT, pbuffer : windows_core::PWSTR, maxlen : u32) -> u32);
    unsafe { AMGetErrorTextW(hr, core::mem::transmute(pbuffer.as_ptr()), pbuffer.len().try_into().unwrap()) }
}
pub const ADVISE_CLIPPING: ADVISE_TYPE = ADVISE_TYPE(1i32);
pub const ADVISE_COLORKEY: ADVISE_TYPE = ADVISE_TYPE(4i32);
pub const ADVISE_DISPLAY_CHANGE: ADVISE_TYPE = ADVISE_TYPE(16i32);
pub const ADVISE_NONE: ADVISE_TYPE = ADVISE_TYPE(0i32);
pub const ADVISE_PALETTE: ADVISE_TYPE = ADVISE_TYPE(2i32);
pub const ADVISE_POSITION: ADVISE_TYPE = ADVISE_TYPE(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ADVISE_TYPE(pub i32);
impl ADVISE_TYPE {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for ADVISE_TYPE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for ADVISE_TYPE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for ADVISE_TYPE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for ADVISE_TYPE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for ADVISE_TYPE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct ALLOCATOR_PROPERTIES {
    pub cBuffers: i32,
    pub cbBuffer: i32,
    pub cbAlign: i32,
    pub cbPrefix: i32,
}
pub const AMAP_3D_TARGET: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(2i32);
pub const AMAP_ALLOW_SYSMEM: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(4i32);
pub const AMAP_DIRECTED_FLIP: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(16i32);
pub const AMAP_DXVA_TARGET: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(32i32);
pub const AMAP_FORCE_SYSMEM: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(8i32);
pub const AMAP_PIXELFORMAT_VALID: VMRSurfaceAllocationFlags = VMRSurfaceAllocationFlags(1i32);
pub const AMCONTROL_COLORINFO_PRESENT: u32 = 128u32;
pub const AMCONTROL_PAD_TO_16x9: u32 = 4u32;
pub const AMCONTROL_PAD_TO_4x3: u32 = 2u32;
pub const AMCONTROL_USED: u32 = 1u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMCOPPCommand {
    pub macKDI: windows_core::GUID,
    pub guidCommandID: windows_core::GUID,
    pub dwSequence: u32,
    pub cbSizeData: u32,
    pub CommandData: [u8; 4056],
}
impl Default for AMCOPPCommand {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMCOPPSignature {
    pub Signature: [u8; 256],
}
impl Default for AMCOPPSignature {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMCOPPStatusInput {
    pub rApp: windows_core::GUID,
    pub guidStatusRequestID: windows_core::GUID,
    pub dwSequence: u32,
    pub cbSizeData: u32,
    pub StatusData: [u8; 4056],
}
impl Default for AMCOPPStatusInput {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMCOPPStatusOutput {
    pub macKDI: windows_core::GUID,
    pub cbSizeData: u32,
    pub COPPStatus: [u8; 4076],
}
impl Default for AMCOPPStatusOutput {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AMCOPYPROTECT_RestrictDuplication: u32 = 1u32;
pub const AMDDS_ALL: u32 = 255u32;
pub const AMDDS_DCIPS: u32 = 1u32;
pub const AMDDS_DEFAULT: u32 = 255u32;
pub const AMDDS_NONE: u32 = 0u32;
pub const AMDDS_PS: u32 = 2u32;
pub const AMDDS_RGBFLP: u32 = 64u32;
pub const AMDDS_RGBOFF: u32 = 16u32;
pub const AMDDS_RGBOVR: u32 = 4u32;
pub const AMDDS_YUVFLP: u32 = 128u32;
pub const AMDDS_YUVOFF: u32 = 32u32;
pub const AMDDS_YUVOVR: u32 = 8u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMExtendedSeekingCapabilities(pub i32);
pub const AMF_AUTOMATICGAIN: f64 = -1f64;
pub type AMGETERRORTEXTPROCA = Option<unsafe extern "system" fn(param0: windows_core::HRESULT, param1: windows_core::PCSTR, param2: u32) -> windows_core::BOOL>;
pub type AMGETERRORTEXTPROCW = Option<unsafe extern "system" fn(param0: windows_core::HRESULT, param1: windows_core::PCWSTR, param2: u32) -> windows_core::BOOL>;
pub const AMINTERLACE_1FieldPerSample: u32 = 2u32;
pub const AMINTERLACE_DisplayModeBobOnly: u32 = 0u32;
pub const AMINTERLACE_DisplayModeBobOrWeave: u32 = 128u32;
pub const AMINTERLACE_DisplayModeMask: u32 = 192u32;
pub const AMINTERLACE_DisplayModeWeaveOnly: u32 = 64u32;
pub const AMINTERLACE_Field1First: u32 = 4u32;
pub const AMINTERLACE_FieldPatBothIrregular: u32 = 48u32;
pub const AMINTERLACE_FieldPatBothRegular: u32 = 32u32;
pub const AMINTERLACE_FieldPatField1Only: u32 = 0u32;
pub const AMINTERLACE_FieldPatField2Only: u32 = 16u32;
pub const AMINTERLACE_FieldPatternMask: u32 = 48u32;
pub const AMINTERLACE_IsInterlaced: u32 = 1u32;
pub const AMINTERLACE_UNUSED: u32 = 8u32;
pub const AMMSF_ADDDEFAULTRENDERER: AMMSF_MS_FLAGS = AMMSF_MS_FLAGS(1i32);
pub const AMMSF_CREATEPEER: AMMSF_MS_FLAGS = AMMSF_MS_FLAGS(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMMSF_MMS_INIT_FLAGS(pub i32);
impl AMMSF_MMS_INIT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for AMMSF_MMS_INIT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for AMMSF_MMS_INIT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMMSF_MS_FLAGS(pub i32);
impl AMMSF_MS_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for AMMSF_MS_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for AMMSF_MS_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for AMMSF_MS_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for AMMSF_MS_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for AMMSF_MS_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const AMMSF_NOCLOCK: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(4i32);
pub const AMMSF_NOGRAPHTHREAD: AMMSF_MMS_INIT_FLAGS = AMMSF_MMS_INIT_FLAGS(1i32);
pub const AMMSF_NORENDER: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(2i32);
pub const AMMSF_NOSTALL: AMMSF_MS_FLAGS = AMMSF_MS_FLAGS(8i32);
pub const AMMSF_RENDERALLSTREAMS: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(1i32);
pub const AMMSF_RENDERTOEXISTING: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(0i32);
pub const AMMSF_RENDERTYPEMASK: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(3i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMMSF_RENDER_FLAGS(pub i32);
impl AMMSF_RENDER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for AMMSF_RENDER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for AMMSF_RENDER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const AMMSF_RUN: AMMSF_RENDER_FLAGS = AMMSF_RENDER_FLAGS(8i32);
pub const AMMSF_STOPIFNOSAMPLES: AMMSF_MS_FLAGS = AMMSF_MS_FLAGS(4i32);
pub const AMOVERFX_DEINTERLACE: AMOVERLAYFX = AMOVERLAYFX(8i32);
pub const AMOVERFX_MIRRORLEFTRIGHT: AMOVERLAYFX = AMOVERLAYFX(2i32);
pub const AMOVERFX_MIRRORUPDOWN: AMOVERLAYFX = AMOVERLAYFX(4i32);
pub const AMOVERFX_NOFX: AMOVERLAYFX = AMOVERLAYFX(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMOVERLAYFX(pub i32);
pub const AMPLAYLISTEVENT_BREAK: AMPlayListEventFlags = AMPlayListEventFlags(1i32);
pub const AMPLAYLISTEVENT_MASK: AMPlayListEventFlags = AMPlayListEventFlags(15i32);
pub const AMPLAYLISTEVENT_NEXT: AMPlayListEventFlags = AMPlayListEventFlags(2i32);
pub const AMPLAYLISTEVENT_REFRESH: AMPlayListEventFlags = AMPlayListEventFlags(16i32);
pub const AMPLAYLISTEVENT_RESUME: AMPlayListEventFlags = AMPlayListEventFlags(0i32);
pub const AMPLAYLISTITEM_CANBIND: AMPlayListItemFlags = AMPlayListItemFlags(2i32);
pub const AMPLAYLISTITEM_CANSKIP: AMPlayListItemFlags = AMPlayListItemFlags(1i32);
pub const AMPLAYLIST_FORCEBANNER: AMPlayListFlags = AMPlayListFlags(2i32);
pub const AMPLAYLIST_STARTINSCANMODE: AMPlayListFlags = AMPlayListFlags(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMPROPERTY_PIN(pub i32);
pub const AMPROPERTY_PIN_CATEGORY: AMPROPERTY_PIN = AMPROPERTY_PIN(0i32);
pub const AMPROPERTY_PIN_MEDIUM: AMPROPERTY_PIN = AMPROPERTY_PIN(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMPlayListEventFlags(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMPlayListFlags(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMPlayListItemFlags(pub i32);
pub const AMRESCTL_RESERVEFLAGS_RESERVE: _AMRESCTL_RESERVEFLAGS = _AMRESCTL_RESERVEFLAGS(0i32);
pub const AMRESCTL_RESERVEFLAGS_UNRESERVE: _AMRESCTL_RESERVEFLAGS = _AMRESCTL_RESERVEFLAGS(1i32);
pub const AMSTREAMSELECTENABLE_ENABLE: _AMSTREAMSELECTENABLEFLAGS = _AMSTREAMSELECTENABLEFLAGS(1i32);
pub const AMSTREAMSELECTENABLE_ENABLEALL: _AMSTREAMSELECTENABLEFLAGS = _AMSTREAMSELECTENABLEFLAGS(2i32);
pub const AMSTREAMSELECTINFO_ENABLED: _AMSTREAMSELECTINFOFLAGS = _AMSTREAMSELECTINFOFLAGS(1i32);
pub const AMSTREAMSELECTINFO_EXCLUSIVE: _AMSTREAMSELECTINFOFLAGS = _AMSTREAMSELECTINFOFLAGS(2i32);
pub const AMTUNER_EVENT_CHANGED: AMTunerEventType = AMTunerEventType(1i32);
pub const AMTUNER_HASNOSIGNALSTRENGTH: AMTunerSignalStrength = AMTunerSignalStrength(-1i32);
pub const AMTUNER_MODE_AM_RADIO: AMTunerModeType = AMTunerModeType(4i32);
pub const AMTUNER_MODE_DEFAULT: AMTunerModeType = AMTunerModeType(0i32);
pub const AMTUNER_MODE_DSS: AMTunerModeType = AMTunerModeType(8i32);
pub const AMTUNER_MODE_FM_RADIO: AMTunerModeType = AMTunerModeType(2i32);
pub const AMTUNER_MODE_TV: AMTunerModeType = AMTunerModeType(1i32);
pub const AMTUNER_NOSIGNAL: AMTunerSignalStrength = AMTunerSignalStrength(0i32);
pub const AMTUNER_SIGNALPRESENT: AMTunerSignalStrength = AMTunerSignalStrength(1i32);
pub const AMTUNER_SUBCHAN_DEFAULT: AMTunerSubChannel = AMTunerSubChannel(-1i32);
pub const AMTUNER_SUBCHAN_NO_TUNE: AMTunerSubChannel = AMTunerSubChannel(-2i32);
pub const AMTVAUDIO_EVENT_CHANGED: AMTVAudioEventType = AMTVAudioEventType(1i32);
pub const AMTVAUDIO_MODE_LANG_A: TVAudioMode = TVAudioMode(16i32);
pub const AMTVAUDIO_MODE_LANG_B: TVAudioMode = TVAudioMode(32i32);
pub const AMTVAUDIO_MODE_LANG_C: TVAudioMode = TVAudioMode(64i32);
pub const AMTVAUDIO_MODE_MONO: TVAudioMode = TVAudioMode(1i32);
pub const AMTVAUDIO_MODE_STEREO: TVAudioMode = TVAudioMode(2i32);
pub const AMTVAUDIO_PRESET_LANG_A: TVAudioMode = TVAudioMode(4096i32);
pub const AMTVAUDIO_PRESET_LANG_B: TVAudioMode = TVAudioMode(8192i32);
pub const AMTVAUDIO_PRESET_LANG_C: TVAudioMode = TVAudioMode(16384i32);
pub const AMTVAUDIO_PRESET_STEREO: TVAudioMode = TVAudioMode(512i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMTVAudioEventType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMTunerEventType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMTunerModeType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMTunerSignalStrength(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMTunerSubChannel(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AMVABUFFERINFO {
    pub dwTypeIndex: u32,
    pub dwBufferIndex: u32,
    pub dwDataOffset: u32,
    pub dwDataSize: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMVABeginFrameInfo {
    pub dwDestSurfaceIndex: u32,
    pub pInputData: *mut core::ffi::c_void,
    pub dwSizeInputData: u32,
    pub pOutputData: *mut core::ffi::c_void,
    pub dwSizeOutputData: u32,
}
impl Default for AMVABeginFrameInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[derive(Clone, Copy)]
pub struct AMVACompBufferInfo {
    pub dwNumCompBuffers: u32,
    pub dwWidthToCreate: u32,
    pub dwHeightToCreate: u32,
    pub dwBytesToAllocate: u32,
    pub ddCompCaps: super::super::Graphics::DirectDraw::DDSCAPS2,
    pub ddPixelFormat: super::super::Graphics::DirectDraw::DDPIXELFORMAT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl Default for AMVACompBufferInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AMVAEndFrameInfo {
    pub dwSizeMiscData: u32,
    pub pMiscData: *mut core::ffi::c_void,
}
impl Default for AMVAEndFrameInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AMVAInternalMemInfo {
    pub dwScratchMemAlloc: u32,
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[derive(Clone, Copy)]
pub struct AMVAUncompBufferInfo {
    pub dwMinNumSurfaces: u32,
    pub dwMaxNumSurfaces: u32,
    pub ddUncompPixelFormat: super::super::Graphics::DirectDraw::DDPIXELFORMAT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl Default for AMVAUncompBufferInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[derive(Clone, Copy)]
pub struct AMVAUncompDataInfo {
    pub dwUncompWidth: u32,
    pub dwUncompHeight: u32,
    pub ddUncompPixelFormat: super::super::Graphics::DirectDraw::DDPIXELFORMAT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl Default for AMVAUncompDataInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AMVA_QUERYRENDERSTATUSF_READ: u32 = 1u32;
pub const AMVA_TYPEINDEX_OUTPUTFRAME: u32 = 4294967295u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AMVPDATAINFO {
    pub dwSize: u32,
    pub dwMicrosecondsPerField: u32,
    pub amvpDimInfo: AMVPDIMINFO,
    pub dwPictAspectRatioX: u32,
    pub dwPictAspectRatioY: u32,
    pub bEnableDoubleClock: windows_core::BOOL,
    pub bEnableVACT: windows_core::BOOL,
    pub bDataIsInterlaced: windows_core::BOOL,
    pub lHalfLinesOdd: i32,
    pub bFieldPolarityInverted: windows_core::BOOL,
    pub dwNumLinesInVREF: u32,
    pub lHalfLinesEven: i32,
    pub dwReserved1: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AMVPDIMINFO {
    pub dwFieldWidth: u32,
    pub dwFieldHeight: u32,
    pub dwVBIWidth: u32,
    pub dwVBIHeight: u32,
    pub rcValidRegion: super::super::Foundation::RECT,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AMVPSIZE {
    pub dwWidth: u32,
    pub dwHeight: u32,
}
pub const AMVP_BEST_BANDWIDTH: AMVP_SELECT_FORMAT_BY = AMVP_SELECT_FORMAT_BY(1i32);
pub const AMVP_DO_NOT_CARE: AMVP_SELECT_FORMAT_BY = AMVP_SELECT_FORMAT_BY(0i32);
pub const AMVP_INPUT_SAME_AS_OUTPUT: AMVP_SELECT_FORMAT_BY = AMVP_SELECT_FORMAT_BY(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMVP_MODE(pub i32);
pub const AMVP_MODE_BOBINTERLEAVED: AMVP_MODE = AMVP_MODE(1i32);
pub const AMVP_MODE_BOBNONINTERLEAVED: AMVP_MODE = AMVP_MODE(2i32);
pub const AMVP_MODE_SKIPEVEN: AMVP_MODE = AMVP_MODE(3i32);
pub const AMVP_MODE_SKIPODD: AMVP_MODE = AMVP_MODE(4i32);
pub const AMVP_MODE_WEAVE: AMVP_MODE = AMVP_MODE(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AMVP_SELECT_FORMAT_BY(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_ALTERNATE_AUDIO {
    pub fStereo: windows_core::BOOL,
    pub DualMode: u32,
}
pub const AM_AC3_ALTERNATE_AUDIO_1: u32 = 1u32;
pub const AM_AC3_ALTERNATE_AUDIO_2: u32 = 2u32;
pub const AM_AC3_ALTERNATE_AUDIO_BOTH: u32 = 3u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_BIT_STREAM_MODE {
    pub BitStreamMode: i32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_DIALOGUE_LEVEL {
    pub DialogueLevel: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_DOWNMIX {
    pub fDownMix: windows_core::BOOL,
    pub fDolbySurround: windows_core::BOOL,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_ERROR_CONCEALMENT {
    pub fRepeatPreviousBlock: windows_core::BOOL,
    pub fErrorInCurrentBlock: windows_core::BOOL,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_AC3_ROOM_TYPE {
    pub fLargeRoom: windows_core::BOOL,
}
pub const AM_AC3_SERVICE_COMMENTARY: u32 = 5u32;
pub const AM_AC3_SERVICE_DIALOG_ONLY: u32 = 4u32;
pub const AM_AC3_SERVICE_EMERGENCY_FLASH: u32 = 6u32;
pub const AM_AC3_SERVICE_HEARING_IMPAIRED: u32 = 3u32;
pub const AM_AC3_SERVICE_MAIN_AUDIO: u32 = 0u32;
pub const AM_AC3_SERVICE_NO_DIALOG: u32 = 1u32;
pub const AM_AC3_SERVICE_VISUALLY_IMPAIRED: u32 = 2u32;
pub const AM_AC3_SERVICE_VOICE_OVER: u32 = 7u32;
pub const AM_ARMODE_CROP: AM_ASPECT_RATIO_MODE = AM_ASPECT_RATIO_MODE(2i32);
pub const AM_ARMODE_LETTER_BOX: AM_ASPECT_RATIO_MODE = AM_ASPECT_RATIO_MODE(1i32);
pub const AM_ARMODE_STRETCHED: AM_ASPECT_RATIO_MODE = AM_ASPECT_RATIO_MODE(0i32);
pub const AM_ARMODE_STRETCHED_AS_PRIMARY: AM_ASPECT_RATIO_MODE = AM_ASPECT_RATIO_MODE(3i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_ASPECT_RATIO_MODE(pub i32);
pub const AM_AUDREND_STAT_PARAM_BREAK_COUNT: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(1i32);
pub const AM_AUDREND_STAT_PARAM_BUFFERFULLNESS: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(11i32);
pub const AM_AUDREND_STAT_PARAM_DISCONTINUITIES: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(5i32);
pub const AM_AUDREND_STAT_PARAM_JITTER: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(12i32);
pub const AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(4i32);
pub const AM_AUDREND_STAT_PARAM_SILENCE_DUR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(3i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(10i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(7i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(8i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(9i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_MODE: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(2i32);
pub const AM_AUDREND_STAT_PARAM_SLAVE_RATE: _AM_AUDIO_RENDERER_STAT_PARAM = _AM_AUDIO_RENDERER_STAT_PARAM(6i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_COLCON {
    pub _bitfield1: u8,
    pub _bitfield2: u8,
    pub _bitfield3: u8,
    pub _bitfield4: u8,
}
pub const AM_CONTENTPROPERTY_AUTHOR: u32 = 2u32;
pub const AM_CONTENTPROPERTY_COPYRIGHT: u32 = 4u32;
pub const AM_CONTENTPROPERTY_DESCRIPTION: u32 = 8u32;
pub const AM_CONTENTPROPERTY_TITLE: u32 = 1u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_COPY_MACROVISION {
    pub MACROVISIONLevel: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_COPY_MACROVISION_LEVEL(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_DIGITAL_CP(pub i32);
pub const AM_DIGITAL_CP_DVD_COMPLIANT: AM_DIGITAL_CP = AM_DIGITAL_CP(2i32);
pub const AM_DIGITAL_CP_OFF: AM_DIGITAL_CP = AM_DIGITAL_CP(0i32);
pub const AM_DIGITAL_CP_ON: AM_DIGITAL_CP = AM_DIGITAL_CP(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_DVDCOPYSTATE(pub i32);
pub const AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED: AM_DVDCOPYSTATE = AM_DVDCOPYSTATE(2i32);
pub const AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED: AM_DVDCOPYSTATE = AM_DVDCOPYSTATE(3i32);
pub const AM_DVDCOPYSTATE_DONE: AM_DVDCOPYSTATE = AM_DVDCOPYSTATE(4i32);
pub const AM_DVDCOPYSTATE_INITIALIZE: AM_DVDCOPYSTATE = AM_DVDCOPYSTATE(0i32);
pub const AM_DVDCOPYSTATE_INITIALIZE_TITLE: AM_DVDCOPYSTATE = AM_DVDCOPYSTATE(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_DVDCOPY_BUSKEY {
    pub BusKey: [u8; 5],
    pub Reserved: [u8; 1],
}
impl Default for AM_DVDCOPY_BUSKEY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_DVDCOPY_CHLGKEY {
    pub ChlgKey: [u8; 10],
    pub Reserved: [u8; 2],
}
impl Default for AM_DVDCOPY_CHLGKEY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_DVDCOPY_DISCKEY {
    pub DiscKey: [u8; 2048],
}
impl Default for AM_DVDCOPY_DISCKEY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_DVDCOPY_SET_COPY_STATE {
    pub DVDCopyState: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_DVDCOPY_TITLEKEY {
    pub KeyFlags: u32,
    pub Reserved1: [u32; 2],
    pub TitleKey: [u8; 6],
    pub Reserved2: [u8; 2],
}
impl Default for AM_DVDCOPY_TITLEKEY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AM_DVD_ADAPT_GRAPH: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(16384i32);
pub const AM_DVD_CGMS_COPY_ONCE: u32 = 16u32;
pub const AM_DVD_CGMS_COPY_PERMITTED: u32 = 0u32;
pub const AM_DVD_CGMS_COPY_PROTECT_MASK: u32 = 24u32;
pub const AM_DVD_CGMS_NO_COPY: u32 = 24u32;
pub const AM_DVD_CGMS_RESERVED_MASK: u32 = 120u32;
pub const AM_DVD_COPYRIGHTED: u32 = 64u32;
pub const AM_DVD_COPYRIGHT_MASK: u32 = 64u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_DVD_ChangeRate {
    pub StartInTime: i64,
    pub StartOutTime: i64,
    pub Rate: i32,
}
pub const AM_DVD_DO_NOT_CLEAR: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(512i32);
pub const AM_DVD_EVR_ONLY: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(4096i32);
pub const AM_DVD_EVR_QOS: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(8192i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_DVD_GRAPH_FLAGS(pub i32);
pub const AM_DVD_HWDEC_ONLY: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(2i32);
pub const AM_DVD_HWDEC_PREFER: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(1i32);
pub const AM_DVD_MASK: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(65535i32);
pub const AM_DVD_NOT_COPYRIGHTED: u32 = 0u32;
pub const AM_DVD_NOVPE: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(256i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_DVD_RENDERSTATUS {
    pub hrVPEStatus: windows_core::HRESULT,
    pub bDvdVolInvalid: windows_core::BOOL,
    pub bDvdVolUnknown: windows_core::BOOL,
    pub bNoLine21In: windows_core::BOOL,
    pub bNoLine21Out: windows_core::BOOL,
    pub iNumStreams: i32,
    pub iNumStreamsFailed: i32,
    pub dwFailedStreamsFlag: u32,
}
pub const AM_DVD_SECTOR_NOT_PROTECTED: u32 = 0u32;
pub const AM_DVD_SECTOR_PROTECTED: u32 = 32u32;
pub const AM_DVD_SECTOR_PROTECT_MASK: u32 = 32u32;
pub const AM_DVD_STREAM_AUDIO: AM_DVD_STREAM_FLAGS = AM_DVD_STREAM_FLAGS(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_DVD_STREAM_FLAGS(pub i32);
pub const AM_DVD_STREAM_SUBPIC: AM_DVD_STREAM_FLAGS = AM_DVD_STREAM_FLAGS(4i32);
pub const AM_DVD_STREAM_VIDEO: AM_DVD_STREAM_FLAGS = AM_DVD_STREAM_FLAGS(1i32);
pub const AM_DVD_SWDEC_ONLY: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(8i32);
pub const AM_DVD_SWDEC_PREFER: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(4i32);
pub const AM_DVD_VMR9_ONLY: AM_DVD_GRAPH_FLAGS = AM_DVD_GRAPH_FLAGS(2048i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_DVD_YUV {
    pub Reserved: u8,
    pub Y: u8,
    pub U: u8,
    pub V: u8,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_DvdKaraokeData {
    pub dwDownmix: u32,
    pub dwSpeakerAssignment: u32,
}
pub const AM_EXSEEK_BUFFERING: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(32i32);
pub const AM_EXSEEK_CANSCAN: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(2i32);
pub const AM_EXSEEK_CANSEEK: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(1i32);
pub const AM_EXSEEK_MARKERSEEK: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(4i32);
pub const AM_EXSEEK_NOSTANDARDREPAINT: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(16i32);
pub const AM_EXSEEK_SCANWITHOUTCLOCK: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(8i32);
pub const AM_EXSEEK_SENDS_VIDEOFRAMEREADY: AMExtendedSeekingCapabilities = AMExtendedSeekingCapabilities(64i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_ExactRateChange {
    pub OutputZeroTime: i64,
    pub Rate: i32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_FILESINK_FLAGS(pub i32);
pub const AM_FILE_OVERWRITE: AM_FILESINK_FLAGS = AM_FILESINK_FLAGS(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_FILTER_FLAGS(pub i32);
pub const AM_FILTER_FLAGS_REMOVABLE: AM_FILTER_FLAGS = AM_FILTER_FLAGS(1i32);
pub const AM_FILTER_MISC_FLAGS_IS_RENDERER: _AM_FILTER_MISC_FLAGS = _AM_FILTER_MISC_FLAGS(1i32);
pub const AM_FILTER_MISC_FLAGS_IS_SOURCE: _AM_FILTER_MISC_FLAGS = _AM_FILTER_MISC_FLAGS(2i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_FRAMESTEP_STEP {
    pub dwFramesToStep: u32,
}
pub const AM_GBF_NODDSURFACELOCK: u32 = 8u32;
pub const AM_GBF_NOTASYNCPOINT: u32 = 2u32;
pub const AM_GBF_NOWAIT: u32 = 4u32;
pub const AM_GBF_PREVFRAMESKIPPED: u32 = 1u32;
pub const AM_GETDECODERCAP_QUERY_EVR_SUPPORT: u32 = 7u32;
pub const AM_GETDECODERCAP_QUERY_VMR9_SUPPORT: u32 = 6u32;
pub const AM_GETDECODERCAP_QUERY_VMR_SUPPORT: u32 = 1u32;
pub const AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS: AM_GRAPH_CONFIG_RECONNECT_FLAGS = AM_GRAPH_CONFIG_RECONNECT_FLAGS(2i32);
pub const AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT: AM_GRAPH_CONFIG_RECONNECT_FLAGS = AM_GRAPH_CONFIG_RECONNECT_FLAGS(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_GRAPH_CONFIG_RECONNECT_FLAGS(pub i32);
pub const AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS: AM_GRAPH_CONFIG_RECONNECT_FLAGS = AM_GRAPH_CONFIG_RECONNECT_FLAGS(4i32);
pub const AM_INTERFACESETID_Standard: windows_core::GUID = windows_core::GUID::from_u128(0x1a8766a0_62ce_11cf_a5d6_28db04c10000);
pub const AM_INTF_SEARCH_FILTER: _AM_INTF_SEARCH_FLAGS = _AM_INTF_SEARCH_FLAGS(4i32);
pub const AM_INTF_SEARCH_INPUT_PIN: _AM_INTF_SEARCH_FLAGS = _AM_INTF_SEARCH_FLAGS(1i32);
pub const AM_INTF_SEARCH_OUTPUT_PIN: _AM_INTF_SEARCH_FLAGS = _AM_INTF_SEARCH_FLAGS(2i32);
pub const AM_KSCATEGORY_AUDIO: windows_core::GUID = windows_core::GUID::from_u128(0x6994ad04_93ef_11d0_a3cc_00a0c9223196);
pub const AM_KSCATEGORY_CAPTURE: windows_core::GUID = windows_core::GUID::from_u128(0x65e8773d_8f56_11d0_a3b9_00a0c9223196);
pub const AM_KSCATEGORY_CROSSBAR: windows_core::GUID = windows_core::GUID::from_u128(0xa799a801_a46d_11d0_a18c_00a02401dcd4);
pub const AM_KSCATEGORY_DATACOMPRESSOR: windows_core::GUID = windows_core::GUID::from_u128(0x1e84c900_7e70_11d0_a5d6_28db04c10000);
pub const AM_KSCATEGORY_RENDER: windows_core::GUID = windows_core::GUID::from_u128(0x65e8773e_8f56_11d0_a3b9_00a0c9223196);
pub const AM_KSCATEGORY_SPLITTER: windows_core::GUID = windows_core::GUID::from_u128(0x0a4252a0_7e70_11d0_a5d6_28db04c10000);
pub const AM_KSCATEGORY_TVAUDIO: windows_core::GUID = windows_core::GUID::from_u128(0xa799a802_a46d_11d0_a18c_00a02401dcd4);
pub const AM_KSCATEGORY_TVTUNER: windows_core::GUID = windows_core::GUID::from_u128(0xa799a800_a46d_11d0_a18c_00a02401dcd4);
pub const AM_KSCATEGORY_VBICODEC: windows_core::GUID = windows_core::GUID::from_u128(0x07dad660_22f1_11d1_a9f4_00c04fbbde8f);
pub const AM_KSCATEGORY_VBICODEC_MI: windows_core::GUID = windows_core::GUID::from_u128(0x9c24a977_0951_451a_8006_0e49bd28cd5f);
pub const AM_KSCATEGORY_VIDEO: windows_core::GUID = windows_core::GUID::from_u128(0x6994ad05_93ef_11d0_a3cc_00a0c9223196);
pub const AM_KSPROPSETID_AC3: windows_core::GUID = windows_core::GUID::from_u128(0xbfabe720_6e1f_11d0_bcf2_444553540000);
pub const AM_KSPROPSETID_CopyProt: windows_core::GUID = windows_core::GUID::from_u128(0x0e8a0a40_6aef_11d0_9ed0_00a024ca19b3);
pub const AM_KSPROPSETID_DVD_RateChange: windows_core::GUID = windows_core::GUID::from_u128(0x3577eb09_9582_477f_b29c_b0c452a4ff9a);
pub const AM_KSPROPSETID_DvdKaraoke: windows_core::GUID = windows_core::GUID::from_u128(0xae4720ae_aa71_42d8_b82a_fffdf58b76fd);
pub const AM_KSPROPSETID_DvdSubPic: windows_core::GUID = windows_core::GUID::from_u128(0xac390460_43af_11d0_bd6a_003505c103a9);
pub const AM_KSPROPSETID_FrameStep: windows_core::GUID = windows_core::GUID::from_u128(0xc830acbd_ab07_492f_8852_45b6987c2979);
pub const AM_KSPROPSETID_MPEG4_MediaType_Attributes: windows_core::GUID = windows_core::GUID::from_u128(0xff6c4bfa_07a9_4c7b_a237_672f9d68065f);
pub const AM_KSPROPSETID_TSRateChange: windows_core::GUID = windows_core::GUID::from_u128(0xa503c5c0_1d1d_11d1_ad80_444553540000);
pub const AM_L21_CCLEVEL_TC2: AM_LINE21_CCLEVEL = AM_LINE21_CCLEVEL(0i32);
pub const AM_L21_CCSERVICE_Caption1: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(1i32);
pub const AM_L21_CCSERVICE_Caption2: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(2i32);
pub const AM_L21_CCSERVICE_DefChannel: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(10i32);
pub const AM_L21_CCSERVICE_Invalid: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(11i32);
pub const AM_L21_CCSERVICE_None: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(0i32);
pub const AM_L21_CCSERVICE_Text1: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(3i32);
pub const AM_L21_CCSERVICE_Text2: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(4i32);
pub const AM_L21_CCSERVICE_XDS: AM_LINE21_CCSERVICE = AM_LINE21_CCSERVICE(5i32);
pub const AM_L21_CCSTATE_Off: AM_LINE21_CCSTATE = AM_LINE21_CCSTATE(0i32);
pub const AM_L21_CCSTATE_On: AM_LINE21_CCSTATE = AM_LINE21_CCSTATE(1i32);
pub const AM_L21_CCSTYLE_None: AM_LINE21_CCSTYLE = AM_LINE21_CCSTYLE(0i32);
pub const AM_L21_CCSTYLE_PaintOn: AM_LINE21_CCSTYLE = AM_LINE21_CCSTYLE(2i32);
pub const AM_L21_CCSTYLE_PopOn: AM_LINE21_CCSTYLE = AM_LINE21_CCSTYLE(1i32);
pub const AM_L21_CCSTYLE_RollUp: AM_LINE21_CCSTYLE = AM_LINE21_CCSTYLE(3i32);
pub const AM_L21_DRAWBGMODE_Opaque: AM_LINE21_DRAWBGMODE = AM_LINE21_DRAWBGMODE(0i32);
pub const AM_L21_DRAWBGMODE_Transparent: AM_LINE21_DRAWBGMODE = AM_LINE21_DRAWBGMODE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_LINE21_CCLEVEL(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_LINE21_CCSERVICE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_LINE21_CCSTATE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_LINE21_CCSTYLE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_LINE21_DRAWBGMODE(pub i32);
pub const AM_LOADSTATUS_CLOSED: u32 = 0u32;
pub const AM_LOADSTATUS_CONNECTING: u32 = 4u32;
pub const AM_LOADSTATUS_LOADINGDESCR: u32 = 1u32;
pub const AM_LOADSTATUS_LOADINGMCAST: u32 = 2u32;
pub const AM_LOADSTATUS_LOCATING: u32 = 3u32;
pub const AM_LOADSTATUS_OPEN: u32 = 6u32;
pub const AM_LOADSTATUS_OPENING: u32 = 5u32;
pub const AM_MACROVISION_DISABLED: AM_COPY_MACROVISION_LEVEL = AM_COPY_MACROVISION_LEVEL(0i32);
pub const AM_MACROVISION_LEVEL1: AM_COPY_MACROVISION_LEVEL = AM_COPY_MACROVISION_LEVEL(1i32);
pub const AM_MACROVISION_LEVEL2: AM_COPY_MACROVISION_LEVEL = AM_COPY_MACROVISION_LEVEL(2i32);
pub const AM_MACROVISION_LEVEL3: AM_COPY_MACROVISION_LEVEL = AM_COPY_MACROVISION_LEVEL(3i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_MEDIAEVENT_FLAGS(pub i32);
pub const AM_MEDIAEVENT_NONOTIFY: AM_MEDIAEVENT_FLAGS = AM_MEDIAEVENT_FLAGS(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_MPEG2Level(pub i32);
pub const AM_MPEG2Level_High: AM_MPEG2Level = AM_MPEG2Level(4i32);
pub const AM_MPEG2Level_High1440: AM_MPEG2Level = AM_MPEG2Level(3i32);
pub const AM_MPEG2Level_Low: AM_MPEG2Level = AM_MPEG2Level(1i32);
pub const AM_MPEG2Level_Main: AM_MPEG2Level = AM_MPEG2Level(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_MPEG2Profile(pub i32);
pub const AM_MPEG2Profile_High: AM_MPEG2Profile = AM_MPEG2Profile(5i32);
pub const AM_MPEG2Profile_Main: AM_MPEG2Profile = AM_MPEG2Profile(2i32);
pub const AM_MPEG2Profile_SNRScalable: AM_MPEG2Profile = AM_MPEG2Profile(3i32);
pub const AM_MPEG2Profile_Simple: AM_MPEG2Profile = AM_MPEG2Profile(1i32);
pub const AM_MPEG2Profile_SpatiallyScalable: AM_MPEG2Profile = AM_MPEG2Profile(4i32);
#[repr(C)]
#[cfg(feature = "Win32_Media_MediaFoundation")]
#[derive(Clone, Debug, PartialEq)]
pub struct AM_MPEGSTREAMTYPE {
    pub dwStreamId: u32,
    pub dwReserved: u32,
    pub mt: super::MediaFoundation::AM_MEDIA_TYPE,
    pub bFormat: [u8; 1],
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl Default for AM_MPEGSTREAMTYPE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Media_MediaFoundation")]
#[derive(Clone, Debug, PartialEq)]
pub struct AM_MPEGSYSTEMTYPE {
    pub dwBitRate: u32,
    pub cStreams: u32,
    pub Streams: [AM_MPEGSTREAMTYPE; 1],
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl Default for AM_MPEGSYSTEMTYPE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AM_MPEG_AUDIO_DUAL_LEFT: u32 = 1u32;
pub const AM_MPEG_AUDIO_DUAL_MERGE: u32 = 0u32;
pub const AM_MPEG_AUDIO_DUAL_RIGHT: u32 = 2u32;
pub const AM_OVERLAY_NOTIFY_DEST_CHANGE: _AM_OVERLAY_NOTIFY_FLAGS = _AM_OVERLAY_NOTIFY_FLAGS(4i32);
pub const AM_OVERLAY_NOTIFY_SOURCE_CHANGE: _AM_OVERLAY_NOTIFY_FLAGS = _AM_OVERLAY_NOTIFY_FLAGS(2i32);
pub const AM_OVERLAY_NOTIFY_VISIBLE_CHANGE: _AM_OVERLAY_NOTIFY_FLAGS = _AM_OVERLAY_NOTIFY_FLAGS(1i32);
pub const AM_PIN_FLOW_CONTROL_BLOCK: _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS = _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_AC3(pub i32);
pub const AM_PROPERTY_AC3_ALTERNATE_AUDIO: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(2i32);
pub const AM_PROPERTY_AC3_BIT_STREAM_MODE: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(4i32);
pub const AM_PROPERTY_AC3_DIALOGUE_LEVEL: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(5i32);
pub const AM_PROPERTY_AC3_DOWNMIX: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(3i32);
pub const AM_PROPERTY_AC3_ERROR_CONCEALMENT: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(1i32);
pub const AM_PROPERTY_AC3_LANGUAGE_CODE: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(6i32);
pub const AM_PROPERTY_AC3_ROOM_TYPE: AM_PROPERTY_AC3 = AM_PROPERTY_AC3(7i32);
pub const AM_PROPERTY_COPY_ANALOG_COMPONENT: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(8i32);
pub const AM_PROPERTY_COPY_DIGITAL_CP: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(9i32);
pub const AM_PROPERTY_COPY_DVD_SRM: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(10i32);
pub const AM_PROPERTY_COPY_MACROVISION: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(5i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_DVDCOPYPROT(pub i32);
pub const AM_PROPERTY_DVDCOPY_CHLG_KEY: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(1i32);
pub const AM_PROPERTY_DVDCOPY_DEC_KEY2: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(3i32);
pub const AM_PROPERTY_DVDCOPY_DISC_KEY: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(128i32);
pub const AM_PROPERTY_DVDCOPY_DVD_KEY1: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(2i32);
pub const AM_PROPERTY_DVDCOPY_REGION: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(6i32);
pub const AM_PROPERTY_DVDCOPY_SET_COPY_STATE: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(7i32);
pub const AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(11i32);
pub const AM_PROPERTY_DVDCOPY_TITLE_KEY: AM_PROPERTY_DVDCOPYPROT = AM_PROPERTY_DVDCOPYPROT(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_DVDKARAOKE(pub i32);
pub const AM_PROPERTY_DVDKARAOKE_DATA: AM_PROPERTY_DVDKARAOKE = AM_PROPERTY_DVDKARAOKE(1i32);
pub const AM_PROPERTY_DVDKARAOKE_ENABLE: AM_PROPERTY_DVDKARAOKE = AM_PROPERTY_DVDKARAOKE(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_DVDSUBPIC(pub i32);
pub const AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON: AM_PROPERTY_DVDSUBPIC = AM_PROPERTY_DVDSUBPIC(2i32);
pub const AM_PROPERTY_DVDSUBPIC_HLI: AM_PROPERTY_DVDSUBPIC = AM_PROPERTY_DVDSUBPIC(1i32);
pub const AM_PROPERTY_DVDSUBPIC_PALETTE: AM_PROPERTY_DVDSUBPIC = AM_PROPERTY_DVDSUBPIC(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_DVD_RATE_CHANGE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_FRAMESTEP(pub i32);
pub const AM_PROPERTY_FRAMESTEP_CANCEL: AM_PROPERTY_FRAMESTEP = AM_PROPERTY_FRAMESTEP(2i32);
pub const AM_PROPERTY_FRAMESTEP_CANSTEP: AM_PROPERTY_FRAMESTEP = AM_PROPERTY_FRAMESTEP(3i32);
pub const AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE: AM_PROPERTY_FRAMESTEP = AM_PROPERTY_FRAMESTEP(4i32);
pub const AM_PROPERTY_FRAMESTEP_STEP: AM_PROPERTY_FRAMESTEP = AM_PROPERTY_FRAMESTEP(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_PROPERTY_SPHLI {
    pub HLISS: u16,
    pub Reserved: u16,
    pub StartPTM: u32,
    pub EndPTM: u32,
    pub StartX: u16,
    pub StartY: u16,
    pub StopX: u16,
    pub StopY: u16,
    pub ColCon: AM_COLCON,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_PROPERTY_SPPAL {
    pub sppal: [AM_DVD_YUV; 16],
}
impl Default for AM_PROPERTY_SPPAL {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_PROPERTY_TS_RATE_CHANGE(pub i32);
pub const AM_PUSHSOURCECAPS_INTERNAL_RM: _AM_PUSHSOURCE_FLAGS = _AM_PUSHSOURCE_FLAGS(1i32);
pub const AM_PUSHSOURCECAPS_NOT_LIVE: _AM_PUSHSOURCE_FLAGS = _AM_PUSHSOURCE_FLAGS(2i32);
pub const AM_PUSHSOURCECAPS_PRIVATE_CLOCK: _AM_PUSHSOURCE_FLAGS = _AM_PUSHSOURCE_FLAGS(4i32);
pub const AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN: _AM_PUSHSOURCE_FLAGS = _AM_PUSHSOURCE_FLAGS(131072i32);
pub const AM_PUSHSOURCEREQS_USE_STREAM_CLOCK: _AM_PUSHSOURCE_FLAGS = _AM_PUSHSOURCE_FLAGS(65536i32);
pub const AM_QUERY_DECODER_ATSC_HD_SUPPORT: u32 = 5u32;
pub const AM_QUERY_DECODER_ATSC_SD_SUPPORT: u32 = 4u32;
pub const AM_QUERY_DECODER_DVD_SUPPORT: u32 = 3u32;
pub const AM_QUERY_DECODER_DXVA_1_SUPPORT: u32 = 2u32;
pub const AM_QUERY_DECODER_VMR_SUPPORT: u32 = 1u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_QueryRate {
    pub lMaxForwardFullFrame: i32,
    pub lMaxReverseFullFrame: i32,
}
pub const AM_RATE_ChangeRate: AM_PROPERTY_DVD_RATE_CHANGE = AM_PROPERTY_DVD_RATE_CHANGE(1i32);
pub const AM_RATE_CorrectTS: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(8i32);
pub const AM_RATE_DecoderPosition: AM_PROPERTY_DVD_RATE_CHANGE = AM_PROPERTY_DVD_RATE_CHANGE(4i32);
pub const AM_RATE_DecoderVersion: AM_PROPERTY_DVD_RATE_CHANGE = AM_PROPERTY_DVD_RATE_CHANGE(5i32);
pub const AM_RATE_ExactRateChange: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(2i32);
pub const AM_RATE_FullDataRateMax: AM_PROPERTY_DVD_RATE_CHANGE = AM_PROPERTY_DVD_RATE_CHANGE(2i32);
pub const AM_RATE_MaxFullDataRate: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(3i32);
pub const AM_RATE_QueryFullFrameRate: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(6i32);
pub const AM_RATE_QueryLastRateSegPTS: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(7i32);
pub const AM_RATE_QueryMapping: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(11i32);
pub const AM_RATE_ResetOnTimeDisc: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(10i32);
pub const AM_RATE_ReverseDecode: AM_PROPERTY_DVD_RATE_CHANGE = AM_PROPERTY_DVD_RATE_CHANGE(3i32);
pub const AM_RATE_ReverseMaxFullDataRate: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(9i32);
pub const AM_RATE_SimpleRateChange: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(1i32);
pub const AM_RATE_Step: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(4i32);
pub const AM_RATE_UseRateVersion: AM_PROPERTY_TS_RATE_CHANGE = AM_PROPERTY_TS_RATE_CHANGE(5i32);
pub const AM_RENDEREX_RENDERTOEXISTINGRENDERERS: _AM_RENSDEREXFLAGS = _AM_RENSDEREXFLAGS(1i32);
pub const AM_ReverseBlockEnd: u32 = 4u32;
pub const AM_ReverseBlockStart: u32 = 2u32;
#[repr(C)]
#[cfg(feature = "Win32_Media_MediaFoundation")]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_SAMPLE2_PROPERTIES {
    pub cbData: u32,
    pub dwTypeSpecificFlags: u32,
    pub dwSampleFlags: u32,
    pub lActual: i32,
    pub tStart: i64,
    pub tStop: i64,
    pub dwStreamId: u32,
    pub pMediaType: *mut super::MediaFoundation::AM_MEDIA_TYPE,
    pub pbBuffer: *mut u8,
    pub cbBuffer: i32,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl Default for AM_SAMPLE2_PROPERTIES {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AM_SAMPLE_DATADISCONTINUITY: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(4i32);
pub const AM_SAMPLE_ENDOFSTREAM: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(512i32);
pub const AM_SAMPLE_FLUSH_ON_PAUSE: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(128i32);
pub const AM_SAMPLE_PREROLL: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_SAMPLE_PROPERTY_FLAGS(pub i32);
pub const AM_SAMPLE_SPLICEPOINT: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(1i32);
pub const AM_SAMPLE_STOPVALID: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(256i32);
pub const AM_SAMPLE_TIMEDISCONTINUITY: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(64i32);
pub const AM_SAMPLE_TIMEVALID: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(16i32);
pub const AM_SAMPLE_TYPECHANGED: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(8i32);
pub const AM_SEEKING_AbsolutePositioning: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(1i32);
pub const AM_SEEKING_CanDoSegments: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(128i32);
pub const AM_SEEKING_CanGetCurrentPos: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(8i32);
pub const AM_SEEKING_CanGetDuration: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(32i32);
pub const AM_SEEKING_CanGetStopPos: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(16i32);
pub const AM_SEEKING_CanPlayBackwards: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(64i32);
pub const AM_SEEKING_CanSeekAbsolute: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(1i32);
pub const AM_SEEKING_CanSeekBackwards: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(4i32);
pub const AM_SEEKING_CanSeekForwards: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(2i32);
pub const AM_SEEKING_IncrementalPositioning: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(3i32);
pub const AM_SEEKING_NoFlush: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(32i32);
pub const AM_SEEKING_NoPositioning: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(0i32);
pub const AM_SEEKING_PositioningBitsMask: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(3i32);
pub const AM_SEEKING_RelativePositioning: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(2i32);
pub const AM_SEEKING_ReturnTime: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_SEEKING_SEEKING_CAPABILITIES(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_SEEKING_SEEKING_FLAGS(pub i32);
pub const AM_SEEKING_SeekToKeyFrame: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(4i32);
pub const AM_SEEKING_Segment: AM_SEEKING_SEEKING_FLAGS = AM_SEEKING_SEEKING_FLAGS(16i32);
pub const AM_SEEKING_Source: AM_SEEKING_SEEKING_CAPABILITIES = AM_SEEKING_SEEKING_CAPABILITIES(256i32);
pub const AM_STREAM_CONTROL: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_STREAM_INFO {
    pub tStart: i64,
    pub tStop: i64,
    pub dwStartCookie: u32,
    pub dwStopCookie: u32,
    pub dwFlags: u32,
}
pub const AM_STREAM_INFO_DISCARDING: AM_STREAM_INFO_FLAGS = AM_STREAM_INFO_FLAGS(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_STREAM_INFO_FLAGS(pub i32);
pub const AM_STREAM_INFO_START_DEFINED: AM_STREAM_INFO_FLAGS = AM_STREAM_INFO_FLAGS(1i32);
pub const AM_STREAM_INFO_STOP_DEFINED: AM_STREAM_INFO_FLAGS = AM_STREAM_INFO_FLAGS(2i32);
pub const AM_STREAM_INFO_STOP_SEND_EXTRA: AM_STREAM_INFO_FLAGS = AM_STREAM_INFO_FLAGS(16i32);
pub const AM_STREAM_MEDIA: AM_SAMPLE_PROPERTY_FLAGS = AM_SAMPLE_PROPERTY_FLAGS(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AM_SimpleRateChange {
    pub StartTime: i64,
    pub Rate: i32,
}
pub const AM_UseNewCSSKey: u32 = 1u32;
pub const AM_VIDEO_FLAG_B_SAMPLE: i32 = 32i32;
pub const AM_VIDEO_FLAG_FIELD1: i32 = 1i32;
pub const AM_VIDEO_FLAG_FIELD1FIRST: i32 = 4i32;
pub const AM_VIDEO_FLAG_FIELD2: i32 = 2i32;
pub const AM_VIDEO_FLAG_FIELD_MASK: i32 = 3i32;
pub const AM_VIDEO_FLAG_INTERLEAVED_FRAME: i32 = 0i32;
pub const AM_VIDEO_FLAG_IPB_MASK: i32 = 48i32;
pub const AM_VIDEO_FLAG_I_SAMPLE: i32 = 0i32;
pub const AM_VIDEO_FLAG_P_SAMPLE: i32 = 16i32;
pub const AM_VIDEO_FLAG_REPEAT_FIELD: i32 = 64i32;
pub const AM_VIDEO_FLAG_WEAVE: i32 = 8i32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_WST_DRAWBGMODE(pub i32);
pub const AM_WST_DRAWBGMODE_Opaque: AM_WST_DRAWBGMODE = AM_WST_DRAWBGMODE(0i32);
pub const AM_WST_DRAWBGMODE_Transparent: AM_WST_DRAWBGMODE = AM_WST_DRAWBGMODE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_WST_LEVEL(pub i32);
pub const AM_WST_LEVEL_1_5: AM_WST_LEVEL = AM_WST_LEVEL(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AM_WST_PAGE {
    pub dwPageNr: u32,
    pub dwSubPageNr: u32,
    pub pucPageData: *mut u8,
}
impl Default for AM_WST_PAGE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_WST_SERVICE(pub i32);
pub const AM_WST_SERVICE_IDS: AM_WST_SERVICE = AM_WST_SERVICE(2i32);
pub const AM_WST_SERVICE_Invalid: AM_WST_SERVICE = AM_WST_SERVICE(3i32);
pub const AM_WST_SERVICE_None: AM_WST_SERVICE = AM_WST_SERVICE(0i32);
pub const AM_WST_SERVICE_Text: AM_WST_SERVICE = AM_WST_SERVICE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_WST_STATE(pub i32);
pub const AM_WST_STATE_Off: AM_WST_STATE = AM_WST_STATE(0i32);
pub const AM_WST_STATE_On: AM_WST_STATE = AM_WST_STATE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AM_WST_STYLE(pub i32);
pub const AM_WST_STYLE_Invers: AM_WST_STYLE = AM_WST_STYLE(1i32);
pub const AM_WST_STYLE_None: AM_WST_STYLE = AM_WST_STYLE(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct ANALOGVIDEOINFO {
    pub rcSource: super::super::Foundation::RECT,
    pub rcTarget: super::super::Foundation::RECT,
    pub dwActiveWidth: u32,
    pub dwActiveHeight: u32,
    pub AvgTimePerFrame: i64,
}
pub const ANNEX_A_DSM_CC: MPEG2StreamType = MPEG2StreamType(8i32);
pub const ATSCCT_AC3: ATSCComponentTypeFlags = ATSCComponentTypeFlags(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ATSCComponentTypeFlags(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AUDIO_STREAM_CONFIG_CAPS {
    pub guid: windows_core::GUID,
    pub MinimumChannels: u32,
    pub MaximumChannels: u32,
    pub ChannelsGranularity: u32,
    pub MinimumBitsPerSample: u32,
    pub MaximumBitsPerSample: u32,
    pub BitsPerSampleGranularity: u32,
    pub MinimumSampleFrequency: u32,
    pub MaximumSampleFrequency: u32,
    pub SampleFrequencyGranularity: u32,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVIEXTHEADER {
    pub fcc: u32,
    pub cb: u32,
    pub dwGrandFrames: u32,
    pub dwFuture: [u32; 61],
}
impl Default for AVIEXTHEADER {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVIFIELDINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub qwBaseOffset: u64,
    pub dwReserved3: u32,
    pub aIndex: [AVIFIELDINDEX_0; 1],
}
impl Default for AVIFIELDINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVIFIELDINDEX_0 {
    pub dwOffset: u32,
    pub dwSize: u32,
    pub dwOffsetField2: u32,
}
pub const AVIF_COPYRIGHTED: u32 = 131072u32;
pub const AVIF_HASINDEX: u32 = 16u32;
pub const AVIF_ISINTERLEAVED: u32 = 256u32;
pub const AVIF_MUSTUSEINDEX: u32 = 32u32;
pub const AVIF_TRUSTCKTYPE: u32 = 2048u32;
pub const AVIF_WASCAPTUREFILE: u32 = 65536u32;
pub const AVIIF_COMPRESSOR: u32 = 268369920u32;
pub const AVIIF_COMPUSE: i32 = 268369920i32;
pub const AVIIF_FIRSTPART: i32 = 32i32;
pub const AVIIF_KEYFRAME: i32 = 16i32;
pub const AVIIF_LASTPART: i32 = 64i32;
pub const AVIIF_LIST: i32 = 1i32;
pub const AVIIF_NOTIME: i32 = 256i32;
pub const AVIIF_NO_TIME: u32 = 256u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AVIINDEXENTRY {
    pub ckid: u32,
    pub dwFlags: u32,
    pub dwChunkOffset: u32,
    pub dwChunkLength: u32,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVIMAINHEADER {
    pub fcc: u32,
    pub cb: u32,
    pub dwMicroSecPerFrame: u32,
    pub dwMaxBytesPerSec: u32,
    pub dwPaddingGranularity: u32,
    pub dwFlags: u32,
    pub dwTotalFrames: u32,
    pub dwInitialFrames: u32,
    pub dwStreams: u32,
    pub dwSuggestedBufferSize: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwReserved: [u32; 4],
}
impl Default for AVIMAINHEADER {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVIMETAINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub dwReserved: [u32; 3],
    pub adwIndex: [u32; 1],
}
impl Default for AVIMETAINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVIOLDINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub aIndex: [AVIOLDINDEX_0; 1],
}
impl Default for AVIOLDINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVIOLDINDEX_0 {
    pub dwChunkId: u32,
    pub dwFlags: u32,
    pub dwOffset: u32,
    pub dwSize: u32,
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVIPALCHANGE {
    pub bFirstEntry: u8,
    pub bNumEntries: u8,
    pub wFlags: u16,
    pub peNew: [super::super::Graphics::Gdi::PALETTEENTRY; 1],
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for AVIPALCHANGE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AVISF_DISABLED: u32 = 1u32;
pub const AVISF_VIDEO_PALCHANGES: u32 = 65536u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVISTDINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub qwBaseOffset: u64,
    pub dwReserved_3: u32,
    pub aIndex: [AVISTDINDEX_ENTRY; 2044],
}
impl Default for AVISTDINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const AVISTDINDEX_DELTAFRAME: u32 = 2147483648u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVISTDINDEX_ENTRY {
    pub dwOffset: u32,
    pub dwSize: u32,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVISTREAMHEADER {
    pub fcc: u32,
    pub cb: u32,
    pub fccType: u32,
    pub fccHandler: u32,
    pub dwFlags: u32,
    pub wPriority: u16,
    pub wLanguage: u16,
    pub dwInitialFrames: u32,
    pub dwScale: u32,
    pub dwRate: u32,
    pub dwStart: u32,
    pub dwLength: u32,
    pub dwSuggestedBufferSize: u32,
    pub dwQuality: u32,
    pub dwSampleSize: u32,
    pub rcFrame: AVISTREAMHEADER_0,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AVISTREAMHEADER_0 {
    pub left: i16,
    pub top: i16,
    pub right: i16,
    pub bottom: i16,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVISUPERINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub dwReserved: [u32; 3],
    pub aIndex: [AVISUPERINDEX_0; 1022],
}
impl Default for AVISUPERINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVISUPERINDEX_0 {
    pub qwOffset: u64,
    pub dwSize: u32,
    pub dwDuration: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct AVIStreamHeader {
    pub fccType: u32,
    pub fccHandler: u32,
    pub dwFlags: u32,
    pub wPriority: u16,
    pub wLanguage: u16,
    pub dwInitialFrames: u32,
    pub dwScale: u32,
    pub dwRate: u32,
    pub dwStart: u32,
    pub dwLength: u32,
    pub dwSuggestedBufferSize: u32,
    pub dwQuality: u32,
    pub dwSampleSize: u32,
    pub rcFrame: super::super::Foundation::RECT,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVITCDLINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub dwReserved: [u32; 3],
    pub aIndex: [AVITCDLINDEX_ENTRY; 584],
    pub adwTrailingFill: [u32; 3512],
}
impl Default for AVITCDLINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVITCDLINDEX_ENTRY {
    pub dwTick: u32,
    pub time: super::TIMECODE,
    pub dwSMPTEflags: u32,
    pub dwUser: u32,
    pub szReelId: [i8; 12],
}
impl Default for AVITCDLINDEX_ENTRY {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVITIMECODEINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub dwReserved: [u32; 3],
    pub aIndex: [TIMECODEDATA; 1022],
}
impl Default for AVITIMECODEINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct AVITIMEDINDEX {
    pub fcc: u32,
    pub cb: u32,
    pub wLongsPerEntry: u16,
    pub bIndexSubType: u8,
    pub bIndexType: u8,
    pub nEntriesInUse: u32,
    pub dwChunkId: u32,
    pub qwBaseOffset: u64,
    pub dwReserved_3: u32,
    pub aIndex: [AVITIMEDINDEX_ENTRY; 1362],
    pub adwTrailingFill: [u32; 2734],
}
impl Default for AVITIMEDINDEX {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct AVITIMEDINDEX_ENTRY {
    pub dwOffset: u32,
    pub dwSize: u32,
    pub dwDuration: u32,
}
pub const AVI_HEADERSIZE: u32 = 2048u32;
pub const AVI_INDEX_IS_DATA: u32 = 128u32;
pub const AVI_INDEX_OF_CHUNKS: u32 = 1u32;
pub const AVI_INDEX_OF_INDEXES: u32 = 0u32;
pub const AVI_INDEX_OF_SUB_2FIELD: u32 = 3u32;
pub const AVI_INDEX_OF_TIMED_CHUNKS: u32 = 2u32;
pub const AVI_INDEX_SUB_2FIELD: u32 = 1u32;
pub const AVI_INDEX_SUB_DEFAULT: u32 = 0u32;
pub const AnalogVideoMask_MCE_NTSC: AnalogVideoStandard = AnalogVideoStandard(1052167i32);
pub const AnalogVideoMask_MCE_PAL: AnalogVideoStandard = AnalogVideoStandard(496i32);
pub const AnalogVideoMask_MCE_SECAM: AnalogVideoStandard = AnalogVideoStandard(1044480i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AnalogVideoStandard(pub i32);
pub const AnalogVideo_NTSC_433: AnalogVideoStandard = AnalogVideoStandard(4i32);
pub const AnalogVideo_NTSC_M: AnalogVideoStandard = AnalogVideoStandard(1i32);
pub const AnalogVideo_NTSC_M_J: AnalogVideoStandard = AnalogVideoStandard(2i32);
pub const AnalogVideo_NTSC_Mask: u32 = 7u32;
pub const AnalogVideo_None: AnalogVideoStandard = AnalogVideoStandard(0i32);
pub const AnalogVideo_PAL_60: AnalogVideoStandard = AnalogVideoStandard(2048i32);
pub const AnalogVideo_PAL_B: AnalogVideoStandard = AnalogVideoStandard(16i32);
pub const AnalogVideo_PAL_D: AnalogVideoStandard = AnalogVideoStandard(32i32);
pub const AnalogVideo_PAL_G: AnalogVideoStandard = AnalogVideoStandard(64i32);
pub const AnalogVideo_PAL_H: AnalogVideoStandard = AnalogVideoStandard(128i32);
pub const AnalogVideo_PAL_I: AnalogVideoStandard = AnalogVideoStandard(256i32);
pub const AnalogVideo_PAL_M: AnalogVideoStandard = AnalogVideoStandard(512i32);
pub const AnalogVideo_PAL_Mask: u32 = 1052656u32;
pub const AnalogVideo_PAL_N: AnalogVideoStandard = AnalogVideoStandard(1024i32);
pub const AnalogVideo_PAL_N_COMBO: AnalogVideoStandard = AnalogVideoStandard(1048576i32);
pub const AnalogVideo_SECAM_B: AnalogVideoStandard = AnalogVideoStandard(4096i32);
pub const AnalogVideo_SECAM_D: AnalogVideoStandard = AnalogVideoStandard(8192i32);
pub const AnalogVideo_SECAM_G: AnalogVideoStandard = AnalogVideoStandard(16384i32);
pub const AnalogVideo_SECAM_H: AnalogVideoStandard = AnalogVideoStandard(32768i32);
pub const AnalogVideo_SECAM_K: AnalogVideoStandard = AnalogVideoStandard(65536i32);
pub const AnalogVideo_SECAM_K1: AnalogVideoStandard = AnalogVideoStandard(131072i32);
pub const AnalogVideo_SECAM_L: AnalogVideoStandard = AnalogVideoStandard(262144i32);
pub const AnalogVideo_SECAM_L1: AnalogVideoStandard = AnalogVideoStandard(524288i32);
pub const AnalogVideo_SECAM_Mask: u32 = 1044480u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ApplicationTypeType(pub i32);
pub const Associated: SmartCardAssociationType = SmartCardAssociationType(1i32);
pub const AssociationUnknown: SmartCardAssociationType = SmartCardAssociationType(2i32);
pub const BDACOMP_EXCLUDE_TS_FROM_TR: BDA_Comp_Flags = BDA_Comp_Flags(1i32);
pub const BDACOMP_INCLUDE_COMPONENTS_IN_TR: BDA_Comp_Flags = BDA_Comp_Flags(4i32);
pub const BDACOMP_INCLUDE_LOCATOR_IN_TR: BDA_Comp_Flags = BDA_Comp_Flags(2i32);
pub const BDACOMP_NOT_DEFINED: BDA_Comp_Flags = BDA_Comp_Flags(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDANODE_DESCRIPTOR {
    pub ulBdaNodeType: u32,
    pub guidFunction: windows_core::GUID,
    pub guidName: windows_core::GUID,
}
pub const BDA_BCC_RATE_1_2: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(1i32);
pub const BDA_BCC_RATE_1_3: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(10i32);
pub const BDA_BCC_RATE_1_4: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(9i32);
pub const BDA_BCC_RATE_2_3: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(2i32);
pub const BDA_BCC_RATE_2_5: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(11i32);
pub const BDA_BCC_RATE_3_4: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(3i32);
pub const BDA_BCC_RATE_3_5: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(4i32);
pub const BDA_BCC_RATE_4_5: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(5i32);
pub const BDA_BCC_RATE_5_11: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(7i32);
pub const BDA_BCC_RATE_5_6: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(6i32);
pub const BDA_BCC_RATE_6_7: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(12i32);
pub const BDA_BCC_RATE_7_8: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(8i32);
pub const BDA_BCC_RATE_8_9: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(13i32);
pub const BDA_BCC_RATE_9_10: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(14i32);
pub const BDA_BCC_RATE_MAX: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(15i32);
pub const BDA_BCC_RATE_NOT_DEFINED: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(0i32);
pub const BDA_BCC_RATE_NOT_SET: BinaryConvolutionCodeRate = BinaryConvolutionCodeRate(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_BUFFER {
    pub lResult: i32,
    pub ulBufferSize: u32,
    pub argbBuffer: [u8; 1],
}
impl Default for BDA_BUFFER {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_CAS_CHECK_ENTITLEMENTTOKEN {
    pub lResult: i32,
    pub ulDescrambleStatus: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_CAS_CLOSEMMIDATA {
    pub ulDialogNumber: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_CAS_CLOSE_MMIDIALOG {
    pub lResult: i32,
    pub SessionResult: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_CAS_OPENMMIDATA {
    pub ulDialogNumber: u32,
    pub ulDialogRequest: u32,
    pub uuidDialogType: windows_core::GUID,
    pub usDialogDataLength: u16,
    pub argbDialogData: [u8; 1],
}
impl Default for BDA_CAS_OPENMMIDATA {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_CAS_REQUESTTUNERDATA {
    pub ucRequestPriority: u8,
    pub ucRequestReason: u8,
    pub ucRequestConsequences: u8,
    pub ulEstimatedTime: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_CA_MODULE_UI {
    pub ulFormat: u32,
    pub ulbcDesc: u32,
    pub ulDesc: [u32; 1],
}
impl Default for BDA_CA_MODULE_UI {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_CHANGES_COMPLETE: BDA_CHANGE_STATE = BDA_CHANGE_STATE(0i32);
pub const BDA_CHANGES_PENDING: BDA_CHANGE_STATE = BDA_CHANGE_STATE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_CHANGE_STATE(pub i32);
pub const BDA_CHAN_BANDWITH_NOT_DEFINED: BDA_Channel_Bandwidth = BDA_Channel_Bandwidth(0i32);
pub const BDA_CHAN_BANDWITH_NOT_SET: BDA_Channel_Bandwidth = BDA_Channel_Bandwidth(-1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_CONDITIONALACCESS_MMICLOSEREASON(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_CONDITIONALACCESS_REQUESTTYPE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_CONDITIONALACCESS_SESSION_RESULT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Channel(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Channel_Bandwidth(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Comp_Flags(pub i32);
pub const BDA_DISCOVERY_COMPLETE: BDA_DISCOVERY_STATE = BDA_DISCOVERY_STATE(2i32);
pub const BDA_DISCOVERY_REQUIRED: BDA_DISCOVERY_STATE = BDA_DISCOVERY_STATE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_DISCOVERY_STATE(pub i32);
pub const BDA_DISCOVERY_UNSPECIFIED: BDA_DISCOVERY_STATE = BDA_DISCOVERY_STATE(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_DISEQC_RESPONSE {
    pub ulRequestId: u32,
    pub ulPacketLength: u32,
    pub argbPacketData: [u8; 8],
}
impl Default for BDA_DISEQC_RESPONSE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_DISEQC_SEND {
    pub ulRequestId: u32,
    pub ulPacketLength: u32,
    pub argbPacketData: [u8; 8],
}
impl Default for BDA_DISEQC_SEND {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_DRM_DRMSTATUS {
    pub lResult: i32,
    pub DRMuuid: windows_core::GUID,
    pub ulDrmUuidListStringSize: u32,
    pub argbDrmUuidListString: [windows_core::GUID; 1],
}
impl Default for BDA_DRM_DRMSTATUS {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_DVBT2_L1_SIGNALLING_DATA {
    pub L1Pre_TYPE: u8,
    pub L1Pre_BWT_S1_S2: u8,
    pub L1Pre_REPETITION_GUARD_PAPR: u8,
    pub L1Pre_MOD_COD_FEC: u8,
    pub L1Pre_POSTSIZE_INFO_PILOT: [u8; 5],
    pub L1Pre_TX_ID_AVAIL: u8,
    pub L1Pre_CELL_ID: [u8; 2],
    pub L1Pre_NETWORK_ID: [u8; 2],
    pub L1Pre_T2SYSTEM_ID: [u8; 2],
    pub L1Pre_NUM_T2_FRAMES: u8,
    pub L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT: [u8; 2],
    pub L1Pre_NUMRF_CURRENTRF_RESERVED: [u8; 2],
    pub L1Pre_CRC32: [u8; 4],
    pub L1PostData: [u8; 1],
}
impl Default for BDA_DVBT2_L1_SIGNALLING_DATA {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_DrmPairingError(pub i32);
pub const BDA_DrmPairing_Aborted: BDA_DrmPairingError = BDA_DrmPairingError(8i32);
pub const BDA_DrmPairing_DrmInitFailed: BDA_DrmPairingError = BDA_DrmPairingError(5i32);
pub const BDA_DrmPairing_DrmNotPaired: BDA_DrmPairingError = BDA_DrmPairingError(6i32);
pub const BDA_DrmPairing_DrmRePairSoon: BDA_DrmPairingError = BDA_DrmPairingError(7i32);
pub const BDA_DrmPairing_HardwareFailure: BDA_DrmPairingError = BDA_DrmPairingError(1i32);
pub const BDA_DrmPairing_NeedIndiv: BDA_DrmPairingError = BDA_DrmPairingError(3i32);
pub const BDA_DrmPairing_NeedRevocationData: BDA_DrmPairingError = BDA_DrmPairingError(2i32);
pub const BDA_DrmPairing_NeedSDKUpdate: BDA_DrmPairingError = BDA_DrmPairingError(9i32);
pub const BDA_DrmPairing_Other: BDA_DrmPairingError = BDA_DrmPairingError(4i32);
pub const BDA_DrmPairing_Succeeded: BDA_DrmPairingError = BDA_DrmPairingError(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_ETHERNET_ADDRESS {
    pub rgbAddress: [u8; 6],
}
impl Default for BDA_ETHERNET_ADDRESS {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_ETHERNET_ADDRESS_LIST {
    pub ulcAddresses: u32,
    pub rgAddressl: [BDA_ETHERNET_ADDRESS; 1],
}
impl Default for BDA_ETHERNET_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_EVENT_ACCESS_DENIED: BDA_EVENT_ID = BDA_EVENT_ID(15i32);
pub const BDA_EVENT_ACCESS_GRANTED: BDA_EVENT_ID = BDA_EVENT_ID(14i32);
pub const BDA_EVENT_CHANNEL_ACQUIRED: BDA_EVENT_ID = BDA_EVENT_ID(4i32);
pub const BDA_EVENT_CHANNEL_ACTIVATED: BDA_EVENT_ID = BDA_EVENT_ID(7i32);
pub const BDA_EVENT_CHANNEL_DEACTIVATED: BDA_EVENT_ID = BDA_EVENT_ID(8i32);
pub const BDA_EVENT_CHANNEL_LOST: BDA_EVENT_ID = BDA_EVENT_ID(5i32);
pub const BDA_EVENT_CHANNEL_SOURCE_CHANGED: BDA_EVENT_ID = BDA_EVENT_ID(6i32);
pub const BDA_EVENT_DATA_START: BDA_EVENT_ID = BDA_EVENT_ID(2i32);
pub const BDA_EVENT_DATA_STOP: BDA_EVENT_ID = BDA_EVENT_ID(3i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_EVENT_ID(pub i32);
pub const BDA_EVENT_OFFER_EXTENDED: BDA_EVENT_ID = BDA_EVENT_ID(16i32);
pub const BDA_EVENT_PURCHASE_COMPLETED: BDA_EVENT_ID = BDA_EVENT_ID(17i32);
pub const BDA_EVENT_SIGNAL_LOCK: BDA_EVENT_ID = BDA_EVENT_ID(1i32);
pub const BDA_EVENT_SIGNAL_LOSS: BDA_EVENT_ID = BDA_EVENT_ID(0i32);
pub const BDA_EVENT_SMART_CARD_INSERTED: BDA_EVENT_ID = BDA_EVENT_ID(18i32);
pub const BDA_EVENT_SMART_CARD_REMOVED: BDA_EVENT_ID = BDA_EVENT_ID(19i32);
pub const BDA_EVENT_SUBCHANNEL_ACQUIRED: BDA_EVENT_ID = BDA_EVENT_ID(9i32);
pub const BDA_EVENT_SUBCHANNEL_ACTIVATED: BDA_EVENT_ID = BDA_EVENT_ID(12i32);
pub const BDA_EVENT_SUBCHANNEL_DEACTIVATED: BDA_EVENT_ID = BDA_EVENT_ID(13i32);
pub const BDA_EVENT_SUBCHANNEL_LOST: BDA_EVENT_ID = BDA_EVENT_ID(10i32);
pub const BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED: BDA_EVENT_ID = BDA_EVENT_ID(11i32);
pub const BDA_E_ACCESS_DENIED: windows_core::HRESULT = windows_core::HRESULT(0xC0040009_u32 as _);
pub const BDA_E_BUFFER_TOO_SMALL: windows_core::HRESULT = windows_core::HRESULT(0xC004000B_u32 as _);
pub const BDA_E_DISABLED: windows_core::HRESULT = windows_core::HRESULT(0xC004000E_u32 as _);
pub const BDA_E_FAILURE: windows_core::HRESULT = windows_core::HRESULT(0xC0040001_u32 as _);
pub const BDA_E_INVALID_CAPTURE_TOKEN: windows_core::HRESULT = windows_core::HRESULT(0xC0044002_u32 as _);
pub const BDA_E_INVALID_ENTITLEMENT_TOKEN: windows_core::HRESULT = windows_core::HRESULT(0xC0044001_u32 as _);
pub const BDA_E_INVALID_HANDLE: windows_core::HRESULT = windows_core::HRESULT(0xC0040006_u32 as _);
pub const BDA_E_INVALID_LANGUAGE: windows_core::HRESULT = windows_core::HRESULT(0xC0040010_u32 as _);
pub const BDA_E_INVALID_PURCHASE_TOKEN: windows_core::HRESULT = windows_core::HRESULT(0xC0044004_u32 as _);
pub const BDA_E_INVALID_SCHEMA: windows_core::HRESULT = windows_core::HRESULT(0xC0040005_u32 as _);
pub const BDA_E_INVALID_TUNE_REQUEST: windows_core::HRESULT = windows_core::HRESULT(0xC0043004_u32 as _);
pub const BDA_E_INVALID_TYPE: windows_core::HRESULT = windows_core::HRESULT(0xC0040007_u32 as _);
pub const BDA_E_IPNETWORK_ADDRESS_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0xC0045002_u32 as _);
pub const BDA_E_IPNETWORK_ERROR: windows_core::HRESULT = windows_core::HRESULT(0xC0045001_u32 as _);
pub const BDA_E_IPNETWORK_TIMEOUT: windows_core::HRESULT = windows_core::HRESULT(0xC0045003_u32 as _);
pub const BDA_E_IPNETWORK_UNAVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0xC0045004_u32 as _);
pub const BDA_E_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0xC004000A_u32 as _);
pub const BDA_E_NOT_IMPLEMENTED: windows_core::HRESULT = windows_core::HRESULT(0xC0040002_u32 as _);
pub const BDA_E_NO_HANDLER: windows_core::HRESULT = windows_core::HRESULT(0xC004000F_u32 as _);
pub const BDA_E_NO_MORE_DATA: windows_core::HRESULT = windows_core::HRESULT(0xC0041002_u32 as _);
pub const BDA_E_NO_MORE_EVENTS: windows_core::HRESULT = windows_core::HRESULT(0xC0041001_u32 as _);
pub const BDA_E_NO_SUCH_COMMAND: windows_core::HRESULT = windows_core::HRESULT(0xC0040003_u32 as _);
pub const BDA_E_OUT_OF_BOUNDS: windows_core::HRESULT = windows_core::HRESULT(0xC0040004_u32 as _);
pub const BDA_E_OUT_OF_MEMORY: windows_core::HRESULT = windows_core::HRESULT(0xC004000D_u32 as _);
pub const BDA_E_OUT_OF_RESOURCES: windows_core::HRESULT = windows_core::HRESULT(0xC004000C_u32 as _);
pub const BDA_E_READ_ONLY: windows_core::HRESULT = windows_core::HRESULT(0xC0040008_u32 as _);
pub const BDA_E_TIMEOUT_ELAPSED: windows_core::HRESULT = windows_core::HRESULT(0xC0040011_u32 as _);
pub const BDA_E_TUNER_CONFLICT: windows_core::HRESULT = windows_core::HRESULT(0xC0043003_u32 as _);
pub const BDA_E_TUNER_INITIALIZING: windows_core::HRESULT = windows_core::HRESULT(0xC0043001_u32 as _);
pub const BDA_E_TUNER_REQUIRED: windows_core::HRESULT = windows_core::HRESULT(0xC0043002_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV01: windows_core::HRESULT = windows_core::HRESULT(0xC0046001_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV02: windows_core::HRESULT = windows_core::HRESULT(0xC0046002_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV03: windows_core::HRESULT = windows_core::HRESULT(0xC0046003_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV04: windows_core::HRESULT = windows_core::HRESULT(0xC0046004_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV05: windows_core::HRESULT = windows_core::HRESULT(0xC0046005_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV06: windows_core::HRESULT = windows_core::HRESULT(0xC0046006_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV07: windows_core::HRESULT = windows_core::HRESULT(0xC0046007_u32 as _);
pub const BDA_E_TUNE_FAILED_SDV08: windows_core::HRESULT = windows_core::HRESULT(0xC0046008_u32 as _);
pub const BDA_E_TUNE_FAILED_SDVFF: windows_core::HRESULT = windows_core::HRESULT(0xC00460FF_u32 as _);
pub const BDA_E_WMDRM_INVALID_CERTIFICATE: windows_core::HRESULT = windows_core::HRESULT(0xC004F002_u32 as _);
pub const BDA_E_WMDRM_INVALID_DATE: windows_core::HRESULT = windows_core::HRESULT(0xC004F005_u32 as _);
pub const BDA_E_WMDRM_INVALID_PROXIMITY: windows_core::HRESULT = windows_core::HRESULT(0xC004F006_u32 as _);
pub const BDA_E_WMDRM_INVALID_SIGNATURE: windows_core::HRESULT = windows_core::HRESULT(0xC004F001_u32 as _);
pub const BDA_E_WMDRM_INVALID_VERSION: windows_core::HRESULT = windows_core::HRESULT(0xC004F004_u32 as _);
pub const BDA_E_WMDRM_KEY_ID_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0xC004F008_u32 as _);
pub const BDA_E_WOULD_DISRUPT_STREAMING: windows_core::HRESULT = windows_core::HRESULT(0xC0044003_u32 as _);
pub const BDA_FEC_BCH: FECMethod = FECMethod(4i32);
pub const BDA_FEC_LDPC: FECMethod = FECMethod(3i32);
pub const BDA_FEC_MAX: FECMethod = FECMethod(6i32);
pub const BDA_FEC_METHOD_NOT_DEFINED: FECMethod = FECMethod(0i32);
pub const BDA_FEC_METHOD_NOT_SET: FECMethod = FECMethod(-1i32);
pub const BDA_FEC_RS_147_130: FECMethod = FECMethod(5i32);
pub const BDA_FEC_RS_204_188: FECMethod = FECMethod(2i32);
pub const BDA_FEC_VITERBI: FECMethod = FECMethod(1i32);
pub const BDA_FILTERED_MULTICAST: BDA_MULTICAST_MODE = BDA_MULTICAST_MODE(1i32);
pub const BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED: BDA_Frequency_Multiplier = BDA_Frequency_Multiplier(0i32);
pub const BDA_FREQUENCY_MULTIPLIER_NOT_SET: BDA_Frequency_Multiplier = BDA_Frequency_Multiplier(-1i32);
pub const BDA_FREQUENCY_NOT_DEFINED: BDA_Frequency = BDA_Frequency(0i32);
pub const BDA_FREQUENCY_NOT_SET: BDA_Frequency = BDA_Frequency(-1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Frequency(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Frequency_Multiplier(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_GDDS_DATA {
    pub lResult: i32,
    pub ulDataLength: u32,
    pub ulPercentageProgress: u32,
    pub argbData: [u8; 1],
}
impl Default for BDA_GDDS_DATA {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_GDDS_DATATYPE {
    pub lResult: i32,
    pub uuidDataType: windows_core::GUID,
}
pub const BDA_GUARD_19_128: GuardInterval = GuardInterval(6i32);
pub const BDA_GUARD_19_256: GuardInterval = GuardInterval(7i32);
pub const BDA_GUARD_1_128: GuardInterval = GuardInterval(5i32);
pub const BDA_GUARD_1_16: GuardInterval = GuardInterval(2i32);
pub const BDA_GUARD_1_32: GuardInterval = GuardInterval(1i32);
pub const BDA_GUARD_1_4: GuardInterval = GuardInterval(4i32);
pub const BDA_GUARD_1_8: GuardInterval = GuardInterval(3i32);
pub const BDA_GUARD_MAX: GuardInterval = GuardInterval(8i32);
pub const BDA_GUARD_NOT_DEFINED: GuardInterval = GuardInterval(0i32);
pub const BDA_GUARD_NOT_SET: GuardInterval = GuardInterval(-1i32);
pub const BDA_HALPHA_1: HierarchyAlpha = HierarchyAlpha(1i32);
pub const BDA_HALPHA_2: HierarchyAlpha = HierarchyAlpha(2i32);
pub const BDA_HALPHA_4: HierarchyAlpha = HierarchyAlpha(3i32);
pub const BDA_HALPHA_MAX: HierarchyAlpha = HierarchyAlpha(4i32);
pub const BDA_HALPHA_NOT_DEFINED: HierarchyAlpha = HierarchyAlpha(0i32);
pub const BDA_HALPHA_NOT_SET: HierarchyAlpha = HierarchyAlpha(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_IPv4_ADDRESS {
    pub rgbAddress: [u8; 4],
}
impl Default for BDA_IPv4_ADDRESS {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_IPv4_ADDRESS_LIST {
    pub ulcAddresses: u32,
    pub rgAddressl: [BDA_IPv4_ADDRESS; 1],
}
impl Default for BDA_IPv4_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_IPv6_ADDRESS {
    pub rgbAddress: [u8; 6],
}
impl Default for BDA_IPv6_ADDRESS {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_IPv6_ADDRESS_LIST {
    pub ulcAddresses: u32,
    pub rgAddressl: [BDA_IPv6_ADDRESS; 1],
}
impl Default for BDA_IPv6_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_ISDBCAS_EMG_REQ {
    pub bCLA: u8,
    pub bINS: u8,
    pub bP1: u8,
    pub bP2: u8,
    pub bLC: u8,
    pub bCardId: [u8; 6],
    pub bProtocol: u8,
    pub bCABroadcasterGroupId: u8,
    pub bMessageControl: u8,
    pub bMessageCode: [u8; 1],
}
impl Default for BDA_ISDBCAS_EMG_REQ {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct BDA_ISDBCAS_REQUESTHEADER {
    pub bInstruction: u8,
    pub bReserved: [u8; 3],
    pub ulDataLength: u32,
    pub argbIsdbCommand: [u8; 1],
}
impl Default for BDA_ISDBCAS_REQUESTHEADER {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct BDA_ISDBCAS_RESPONSEDATA {
    pub lResult: i32,
    pub ulRequestID: u32,
    pub ulIsdbStatus: u32,
    pub ulIsdbDataSize: u32,
    pub argbIsdbCommandData: [u8; 1],
}
impl Default for BDA_ISDBCAS_RESPONSEDATA {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_LNB_SOURCE_A: LNB_Source = LNB_Source(1i32);
pub const BDA_LNB_SOURCE_B: LNB_Source = LNB_Source(2i32);
pub const BDA_LNB_SOURCE_C: LNB_Source = LNB_Source(3i32);
pub const BDA_LNB_SOURCE_D: LNB_Source = LNB_Source(4i32);
pub const BDA_LNB_SOURCE_MAX: LNB_Source = LNB_Source(5i32);
pub const BDA_LNB_SOURCE_NOT_DEFINED: LNB_Source = LNB_Source(0i32);
pub const BDA_LNB_SOURCE_NOT_SET: LNB_Source = LNB_Source(-1i32);
pub const BDA_MOD_1024QAM: ModulationType = ModulationType(19i32);
pub const BDA_MOD_112QAM: ModulationType = ModulationType(6i32);
pub const BDA_MOD_128QAM: ModulationType = ModulationType(7i32);
pub const BDA_MOD_160QAM: ModulationType = ModulationType(8i32);
pub const BDA_MOD_16APSK: ModulationType = ModulationType(29i32);
pub const BDA_MOD_16QAM: ModulationType = ModulationType(1i32);
pub const BDA_MOD_16VSB: ModulationType = ModulationType(24i32);
pub const BDA_MOD_192QAM: ModulationType = ModulationType(9i32);
pub const BDA_MOD_224QAM: ModulationType = ModulationType(10i32);
pub const BDA_MOD_256QAM: ModulationType = ModulationType(11i32);
pub const BDA_MOD_320QAM: ModulationType = ModulationType(12i32);
pub const BDA_MOD_32APSK: ModulationType = ModulationType(30i32);
pub const BDA_MOD_32QAM: ModulationType = ModulationType(2i32);
pub const BDA_MOD_384QAM: ModulationType = ModulationType(13i32);
pub const BDA_MOD_448QAM: ModulationType = ModulationType(14i32);
pub const BDA_MOD_512QAM: ModulationType = ModulationType(15i32);
pub const BDA_MOD_640QAM: ModulationType = ModulationType(16i32);
pub const BDA_MOD_64QAM: ModulationType = ModulationType(3i32);
pub const BDA_MOD_768QAM: ModulationType = ModulationType(17i32);
pub const BDA_MOD_80QAM: ModulationType = ModulationType(4i32);
pub const BDA_MOD_896QAM: ModulationType = ModulationType(18i32);
pub const BDA_MOD_8PSK: ModulationType = ModulationType(27i32);
pub const BDA_MOD_8VSB: ModulationType = ModulationType(23i32);
pub const BDA_MOD_96QAM: ModulationType = ModulationType(5i32);
pub const BDA_MOD_ANALOG_AMPLITUDE: ModulationType = ModulationType(25i32);
pub const BDA_MOD_ANALOG_FREQUENCY: ModulationType = ModulationType(26i32);
pub const BDA_MOD_BPSK: ModulationType = ModulationType(21i32);
pub const BDA_MOD_DIRECTV: ModulationType = ModulationType(33i32);
pub const BDA_MOD_ISDB_S_TMCC: ModulationType = ModulationType(35i32);
pub const BDA_MOD_ISDB_T_TMCC: ModulationType = ModulationType(34i32);
pub const BDA_MOD_MAX: ModulationType = ModulationType(36i32);
pub const BDA_MOD_NBC_8PSK: ModulationType = ModulationType(32i32);
pub const BDA_MOD_NBC_QPSK: ModulationType = ModulationType(31i32);
pub const BDA_MOD_NOT_DEFINED: ModulationType = ModulationType(0i32);
pub const BDA_MOD_NOT_SET: ModulationType = ModulationType(-1i32);
pub const BDA_MOD_OQPSK: ModulationType = ModulationType(22i32);
pub const BDA_MOD_QPSK: ModulationType = ModulationType(20i32);
pub const BDA_MOD_RF: ModulationType = ModulationType(28i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_MULTICAST_MODE(pub i32);
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct BDA_MUX_PIDLISTITEM {
    pub usPIDNumber: u16,
    pub usProgramNumber: u16,
    pub ePIDType: MUX_PID_TYPE,
}
pub const BDA_NO_MULTICAST: BDA_MULTICAST_MODE = BDA_MULTICAST_MODE(2i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_PID_MAP {
    pub MediaSampleContent: MEDIA_SAMPLE_CONTENT,
    pub ulcPIDs: u32,
    pub aulPIDs: [u32; 1],
}
impl Default for BDA_PID_MAP {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_PID_UNMAP {
    pub ulcPIDs: u32,
    pub aulPIDs: [u32; 1],
}
impl Default for BDA_PID_UNMAP {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_PILOT_MAX: Pilot = Pilot(3i32);
pub const BDA_PILOT_NOT_DEFINED: Pilot = Pilot(0i32);
pub const BDA_PILOT_NOT_SET: Pilot = Pilot(-1i32);
pub const BDA_PILOT_OFF: Pilot = Pilot(1i32);
pub const BDA_PILOT_ON: Pilot = Pilot(2i32);
pub const BDA_PLP_ID_NOT_SET: i32 = -1i32;
pub const BDA_POLARISATION_CIRCULAR_L: Polarisation = Polarisation(3i32);
pub const BDA_POLARISATION_CIRCULAR_R: Polarisation = Polarisation(4i32);
pub const BDA_POLARISATION_LINEAR_H: Polarisation = Polarisation(1i32);
pub const BDA_POLARISATION_LINEAR_V: Polarisation = Polarisation(2i32);
pub const BDA_POLARISATION_MAX: Polarisation = Polarisation(5i32);
pub const BDA_POLARISATION_NOT_DEFINED: Polarisation = Polarisation(0i32);
pub const BDA_POLARISATION_NOT_SET: Polarisation = Polarisation(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_PROGRAM_PID_LIST {
    pub ulProgramNumber: u32,
    pub ulcPIDs: u32,
    pub ulPID: [u32; 1],
}
impl Default for BDA_PROGRAM_PID_LIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_PROMISCUOUS_MULTICAST: BDA_MULTICAST_MODE = BDA_MULTICAST_MODE(0i32);
pub const BDA_RANGE_NOT_DEFINED: BDA_Range = BDA_Range(0i32);
pub const BDA_RANGE_NOT_SET: BDA_Range = BDA_Range(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_RATING_PINRESET {
    pub bPinLength: u8,
    pub argbNewPin: [u8; 1],
}
impl Default for BDA_RATING_PINRESET {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_ROLL_OFF_20: RollOff = RollOff(1i32);
pub const BDA_ROLL_OFF_25: RollOff = RollOff(2i32);
pub const BDA_ROLL_OFF_35: RollOff = RollOff(3i32);
pub const BDA_ROLL_OFF_MAX: RollOff = RollOff(4i32);
pub const BDA_ROLL_OFF_NOT_DEFINED: RollOff = RollOff(0i32);
pub const BDA_ROLL_OFF_NOT_SET: RollOff = RollOff(-1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_Range(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_SCAN_CAPABILTIES {
    pub lResult: i32,
    pub ul64AnalogStandardsSupported: u64,
}
pub const BDA_SCAN_MOD_1024QAM: ScanModulationTypes = ScanModulationTypes(262144i32);
pub const BDA_SCAN_MOD_112QAM: ScanModulationTypes = ScanModulationTypes(32i32);
pub const BDA_SCAN_MOD_128QAM: ScanModulationTypes = ScanModulationTypes(64i32);
pub const BDA_SCAN_MOD_160QAM: ScanModulationTypes = ScanModulationTypes(128i32);
pub const BDA_SCAN_MOD_16APSK: ScanModulationTypes = ScanModulationTypes(268435456i32);
pub const BDA_SCAN_MOD_16QAM: ScanModulationTypes = ScanModulationTypes(1i32);
pub const BDA_SCAN_MOD_16VSB: ScanModulationTypes = ScanModulationTypes(8388608i32);
pub const BDA_SCAN_MOD_192QAM: ScanModulationTypes = ScanModulationTypes(256i32);
pub const BDA_SCAN_MOD_224QAM: ScanModulationTypes = ScanModulationTypes(512i32);
pub const BDA_SCAN_MOD_256QAM: ScanModulationTypes = ScanModulationTypes(1024i32);
pub const BDA_SCAN_MOD_320QAM: ScanModulationTypes = ScanModulationTypes(2048i32);
pub const BDA_SCAN_MOD_32APSK: ScanModulationTypes = ScanModulationTypes(536870912i32);
pub const BDA_SCAN_MOD_32QAM: ScanModulationTypes = ScanModulationTypes(2i32);
pub const BDA_SCAN_MOD_384QAM: ScanModulationTypes = ScanModulationTypes(4096i32);
pub const BDA_SCAN_MOD_448QAM: ScanModulationTypes = ScanModulationTypes(8192i32);
pub const BDA_SCAN_MOD_512QAM: ScanModulationTypes = ScanModulationTypes(16384i32);
pub const BDA_SCAN_MOD_640QAM: ScanModulationTypes = ScanModulationTypes(32768i32);
pub const BDA_SCAN_MOD_64QAM: ScanModulationTypes = ScanModulationTypes(4i32);
pub const BDA_SCAN_MOD_768QAM: ScanModulationTypes = ScanModulationTypes(65536i32);
pub const BDA_SCAN_MOD_80QAM: ScanModulationTypes = ScanModulationTypes(8i32);
pub const BDA_SCAN_MOD_896QAM: ScanModulationTypes = ScanModulationTypes(131072i32);
pub const BDA_SCAN_MOD_8PSK: ScanModulationTypes = ScanModulationTypes(67108864i32);
pub const BDA_SCAN_MOD_8VSB: ScanModulationTypes = ScanModulationTypes(4194304i32);
pub const BDA_SCAN_MOD_96QAM: ScanModulationTypes = ScanModulationTypes(16i32);
pub const BDA_SCAN_MOD_AM_RADIO: ScanModulationTypes = ScanModulationTypes(16777216i32);
pub const BDA_SCAN_MOD_BPSK: ScanModulationTypes = ScanModulationTypes(1048576i32);
pub const BDA_SCAN_MOD_FM_RADIO: ScanModulationTypes = ScanModulationTypes(33554432i32);
pub const BDA_SCAN_MOD_OQPSK: ScanModulationTypes = ScanModulationTypes(2097152i32);
pub const BDA_SCAN_MOD_QPSK: ScanModulationTypes = ScanModulationTypes(524288i32);
pub const BDA_SCAN_MOD_RF: ScanModulationTypes = ScanModulationTypes(134217728i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_SCAN_START {
    pub lResult: i32,
    pub LowerFrequency: u32,
    pub HigerFrequency: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_SCAN_STATE {
    pub lResult: i32,
    pub ulSignalLock: u32,
    pub ulSecondsLeft: u32,
    pub ulCurrentFrequency: u32,
}
pub const BDA_SIGNAL_ACTIVE: BDA_SIGNAL_STATE = BDA_SIGNAL_STATE(2i32);
pub const BDA_SIGNAL_INACTIVE: BDA_SIGNAL_STATE = BDA_SIGNAL_STATE(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BDA_SIGNAL_STATE(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_SIGNAL_TIMEOUTS {
    pub ulCarrierTimeoutMs: u32,
    pub ulScanningTimeoutMs: u32,
    pub ulTuningTimeoutMs: u32,
}
pub const BDA_SIGNAL_UNAVAILABLE: BDA_SIGNAL_STATE = BDA_SIGNAL_STATE(0i32);
pub const BDA_SPECTRAL_INVERSION_AUTOMATIC: SpectralInversion = SpectralInversion(1i32);
pub const BDA_SPECTRAL_INVERSION_INVERTED: SpectralInversion = SpectralInversion(3i32);
pub const BDA_SPECTRAL_INVERSION_MAX: SpectralInversion = SpectralInversion(4i32);
pub const BDA_SPECTRAL_INVERSION_NORMAL: SpectralInversion = SpectralInversion(2i32);
pub const BDA_SPECTRAL_INVERSION_NOT_DEFINED: SpectralInversion = SpectralInversion(0i32);
pub const BDA_SPECTRAL_INVERSION_NOT_SET: SpectralInversion = SpectralInversion(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_STRING {
    pub lResult: i32,
    pub ulStringSize: u32,
    pub argbString: [u8; 1],
}
impl Default for BDA_STRING {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_TABLE_SECTION {
    pub ulPrimarySectionId: u32,
    pub ulSecondarySectionId: u32,
    pub ulcbSectionLength: u32,
    pub argbSectionData: [u32; 1],
}
impl Default for BDA_TABLE_SECTION {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_TEMPLATE_CONNECTION {
    pub FromNodeType: u32,
    pub FromNodePinType: u32,
    pub ToNodeType: u32,
    pub ToNodePinType: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_TEMPLATE_PIN_JOINT {
    pub uliTemplateConnection: u32,
    pub ulcInstancesMax: u32,
}
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct BDA_TS_SELECTORINFO {
    pub bTSInfolength: u8,
    pub bReserved: [u8; 2],
    pub guidNetworkType: windows_core::GUID,
    pub bTSIDCount: u8,
    pub usTSID: [u16; 1],
}
impl Default for BDA_TS_SELECTORINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_TS_SELECTORINFO_ISDBS_EXT {
    pub bTMCC: [u8; 48],
}
impl Default for BDA_TS_SELECTORINFO_ISDBS_EXT {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_TUNER_DIAGNOSTICS {
    pub lResult: i32,
    pub ulSignalLevel: u32,
    pub ulSignalLevelQuality: u32,
    pub ulSignalNoiseRatio: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_TUNER_TUNERSTATE {
    pub lResult: i32,
    pub ulTuneLength: u32,
    pub argbTuneData: [u8; 1],
}
impl Default for BDA_TUNER_TUNERSTATE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const BDA_UNDEFINED_CHANNEL: BDA_Channel = BDA_Channel(-1i32);
pub const BDA_UNITIALIZED_MPEG2STREAMTYPE: MPEG2StreamType = MPEG2StreamType(-1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_USERACTIVITY_INTERVAL {
    pub lResult: i32,
    pub ulActivityInterval: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_WMDRMTUNER_PIDPROTECTION {
    pub lResult: i32,
    pub uuidKeyID: windows_core::GUID,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    pub lResult: i32,
    pub ulDescrambleStatus: u32,
    pub ulCaptureTokenLength: u32,
    pub argbCaptureTokenBuffer: [u8; 1],
}
impl Default for BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_WMDRM_KEYINFOLIST {
    pub lResult: i32,
    pub ulKeyuuidBufferLen: u32,
    pub argKeyuuidBuffer: [windows_core::GUID; 1],
}
impl Default for BDA_WMDRM_KEYINFOLIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BDA_WMDRM_RENEWLICENSE {
    pub lResult: i32,
    pub ulDescrambleStatus: u32,
    pub ulXmrLicenseOutputLength: u32,
    pub argbXmrLicenceOutputBuffer: [u8; 1],
}
impl Default for BDA_WMDRM_RENEWLICENSE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct BDA_WMDRM_STATUS {
    pub lResult: i32,
    pub ulMaxCaptureTokenSize: u32,
    pub uMaxStreamingPid: u32,
    pub ulMaxLicense: u32,
    pub ulMinSecurityLevel: u32,
    pub ulRevInfoSequenceNumber: u32,
    pub ulRevInfoIssuedTime: u64,
    pub ulRevListVersion: u32,
    pub ulRevInfoTTL: u32,
    pub ulState: u32,
}
pub const BDA_XMIT_MODE_16K: TransmissionMode = TransmissionMode(7i32);
pub const BDA_XMIT_MODE_1K: TransmissionMode = TransmissionMode(6i32);
pub const BDA_XMIT_MODE_2K: TransmissionMode = TransmissionMode(1i32);
pub const BDA_XMIT_MODE_2K_INTERLEAVED: TransmissionMode = TransmissionMode(4i32);
pub const BDA_XMIT_MODE_32K: TransmissionMode = TransmissionMode(8i32);
pub const BDA_XMIT_MODE_4K: TransmissionMode = TransmissionMode(3i32);
pub const BDA_XMIT_MODE_4K_INTERLEAVED: TransmissionMode = TransmissionMode(5i32);
pub const BDA_XMIT_MODE_8K: TransmissionMode = TransmissionMode(2i32);
pub const BDA_XMIT_MODE_MAX: TransmissionMode = TransmissionMode(9i32);
pub const BDA_XMIT_MODE_NOT_DEFINED: TransmissionMode = TransmissionMode(0i32);
pub const BDA_XMIT_MODE_NOT_SET: TransmissionMode = TransmissionMode(-1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BinaryConvolutionCodeRate(pub i32);
pub const CATEGORY_COUNT: ComponentCategory = ComponentCategory(8i32);
pub const CDEF_BYPASS_CLASS_MANAGER: u32 = 2u32;
pub const CDEF_CLASS_DEFAULT: u32 = 1u32;
pub const CDEF_DEVMON_CMGR_DEVICE: u32 = 16u32;
pub const CDEF_DEVMON_DMO: u32 = 32u32;
pub const CDEF_DEVMON_FILTER: u32 = 128u32;
pub const CDEF_DEVMON_PNP_DEVICE: u32 = 64u32;
pub const CDEF_DEVMON_SELECTIVE_MASK: u32 = 240u32;
pub const CDEF_MERIT_ABOVE_DO_NOT_USE: u32 = 8u32;
pub const CFSTR_VFW_FILTERLIST: windows_core::PCSTR = windows_core::s!("Video for Windows 4 Filters");
pub const CHARS_IN_GUID: u32 = 39u32;
pub const CK_INDEX: COLORKEY_TYPE = COLORKEY_TYPE(1i32);
pub const CK_NOCOLORKEY: COLORKEY_TYPE = COLORKEY_TYPE(0i32);
pub const CK_RGB: COLORKEY_TYPE = COLORKEY_TYPE(2i32);
pub const CLSID_AMAudioData: windows_core::GUID = windows_core::GUID::from_u128(0xf2468580_af8a_11d0_8212_00c04fc32c45);
pub const CLSID_AMAudioStream: windows_core::GUID = windows_core::GUID::from_u128(0x8496e040_af4c_11d0_8212_00c04fc32c45);
pub const CLSID_AMDirectDrawStream: windows_core::GUID = windows_core::GUID::from_u128(0x49c47ce4_9ba4_11d0_8212_00c04fc32c45);
pub const CLSID_AMMediaTypeStream: windows_core::GUID = windows_core::GUID::from_u128(0xcf0f2f7c_f7bf_11d0_900d_00c04fd9189d);
pub const CLSID_AMMultiMediaStream: windows_core::GUID = windows_core::GUID::from_u128(0x49c47ce5_9ba4_11d0_8212_00c04fc32c45);
pub const CLSID_DMOFilterCategory: windows_core::GUID = windows_core::GUID::from_u128(0xbcd5796c_bd52_4d30_ab76_70f975b89199);
pub const CLSID_DMOWrapperFilter: windows_core::GUID = windows_core::GUID::from_u128(0x94297043_bd82_4dfd_b0de_8177739c6d20);
pub const CLSID_PBDA_AUX_DATA_TYPE: windows_core::GUID = windows_core::GUID::from_u128(0xfd456373_3323_4090_adca_8ed45f55cf10);
pub const CLSID_PBDA_Encoder_DATA_TYPE: windows_core::GUID = windows_core::GUID::from_u128(0x728fd6bc_5546_4716_b103_f899f5a1fa68);
pub const CLSID_PBDA_FDC_DATA_TYPE: windows_core::GUID = windows_core::GUID::from_u128(0xe7dbf9a0_22ab_4047_8e67_ef9ad504e729);
pub const CLSID_PBDA_GDDS_DATA_TYPE: windows_core::GUID = windows_core::GUID::from_u128(0xc80c0df3_6052_4c16_9f56_c44c21f73c45);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct COLORKEY {
    pub KeyType: u32,
    pub PaletteIndex: u32,
    pub LowColorValue: super::super::Foundation::COLORREF,
    pub HighColorValue: super::super::Foundation::COLORREF,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COLORKEY_TYPE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COMPLETION_STATUS_FLAGS(pub i32);
pub const COMPSTAT_ABORT: COMPLETION_STATUS_FLAGS = COMPLETION_STATUS_FLAGS(4i32);
pub const COMPSTAT_NOUPDATEOK: COMPLETION_STATUS_FLAGS = COMPLETION_STATUS_FLAGS(1i32);
pub const COMPSTAT_WAIT: COMPLETION_STATUS_FLAGS = COMPLETION_STATUS_FLAGS(2i32);
pub const CONDITIONALACCESS_ABORTED: BDA_CONDITIONALACCESS_SESSION_RESULT = BDA_CONDITIONALACCESS_SESSION_RESULT(2i32);
pub const CONDITIONALACCESS_ACCESS_NOT_POSSIBLE: BDA_CONDITIONALACCESS_REQUESTTYPE = BDA_CONDITIONALACCESS_REQUESTTYPE(1i32);
pub const CONDITIONALACCESS_ACCESS_POSSIBLE: BDA_CONDITIONALACCESS_REQUESTTYPE = BDA_CONDITIONALACCESS_REQUESTTYPE(2i32);
pub const CONDITIONALACCESS_ACCESS_POSSIBLE_NO_STREAMING_DISRUPTION: BDA_CONDITIONALACCESS_REQUESTTYPE = BDA_CONDITIONALACCESS_REQUESTTYPE(3i32);
pub const CONDITIONALACCESS_ACCESS_UNSPECIFIED: BDA_CONDITIONALACCESS_REQUESTTYPE = BDA_CONDITIONALACCESS_REQUESTTYPE(0i32);
pub const CONDITIONALACCESS_CLOSED_ITSELF: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(1i32);
pub const CONDITIONALACCESS_DIALOG_FOCUS_CHANGE: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(4i32);
pub const CONDITIONALACCESS_DIALOG_TIMEOUT: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(3i32);
pub const CONDITIONALACCESS_DIALOG_USER_DISMISSED: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(5i32);
pub const CONDITIONALACCESS_DIALOG_USER_NOT_AVAILABLE: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(6i32);
pub const CONDITIONALACCESS_ENDED_NOCHANGE: BDA_CONDITIONALACCESS_SESSION_RESULT = BDA_CONDITIONALACCESS_SESSION_RESULT(1i32);
pub const CONDITIONALACCESS_SUCCESSFULL: BDA_CONDITIONALACCESS_SESSION_RESULT = BDA_CONDITIONALACCESS_SESSION_RESULT(0i32);
pub const CONDITIONALACCESS_TUNER_REQUESTED_CLOSE: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(2i32);
pub const CONDITIONALACCESS_UNSPECIFIED: BDA_CONDITIONALACCESS_MMICLOSEREASON = BDA_CONDITIONALACCESS_MMICLOSEREASON(0i32);
pub const COPP_ACP_ForceDWORD: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(2147483647i32);
pub const COPP_ACP_Level0: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(0i32);
pub const COPP_ACP_Level1: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(1i32);
pub const COPP_ACP_Level2: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(2i32);
pub const COPP_ACP_Level3: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(3i32);
pub const COPP_ACP_LevelMax: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(3i32);
pub const COPP_ACP_LevelMin: COPP_ACP_Protection_Level = COPP_ACP_Protection_Level(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_ACP_Protection_Level(pub i32);
pub const COPP_AspectRatio_EN300294_Box14by9Center: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(1i32);
pub const COPP_AspectRatio_EN300294_Box14by9Top: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(2i32);
pub const COPP_AspectRatio_EN300294_Box16by9Center: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(3i32);
pub const COPP_AspectRatio_EN300294_Box16by9Top: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(4i32);
pub const COPP_AspectRatio_EN300294_BoxGT16by9Center: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(5i32);
pub const COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(7i32);
pub const COPP_AspectRatio_EN300294_FullFormat4by3: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(0i32);
pub const COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(6i32);
pub const COPP_AspectRatio_ForceDWORD: COPP_ImageAspectRatio_EN300294 = COPP_ImageAspectRatio_EN300294(2147483647i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_BusType(pub i32);
pub const COPP_BusType_AGP: COPP_BusType = COPP_BusType(4i32);
pub const COPP_BusType_ForceDWORD: COPP_BusType = COPP_BusType(2147483647i32);
pub const COPP_BusType_Integrated: COPP_BusType = COPP_BusType(-2147483648i32);
pub const COPP_BusType_PCI: COPP_BusType = COPP_BusType(1i32);
pub const COPP_BusType_PCIExpress: COPP_BusType = COPP_BusType(3i32);
pub const COPP_BusType_PCIX: COPP_BusType = COPP_BusType(2i32);
pub const COPP_BusType_Unknown: COPP_BusType = COPP_BusType(0i32);
pub const COPP_CGMSA_CopyFreely: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(1i32);
pub const COPP_CGMSA_CopyNever: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(4i32);
pub const COPP_CGMSA_CopyNoMore: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(2i32);
pub const COPP_CGMSA_CopyOneGeneration: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(3i32);
pub const COPP_CGMSA_Disabled: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(0i32);
pub const COPP_CGMSA_ForceDWORD: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(2147483647i32);
pub const COPP_CGMSA_LevelMax: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(12i32);
pub const COPP_CGMSA_LevelMin: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_CGMSA_Protection_Level(pub i32);
pub const COPP_CGMSA_RedistributionControlRequired: COPP_CGMSA_Protection_Level = COPP_CGMSA_Protection_Level(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_ConnectorType(pub i32);
pub const COPP_ConnectorType_ComponentVideo: COPP_ConnectorType = COPP_ConnectorType(3i32);
pub const COPP_ConnectorType_CompositeVideo: COPP_ConnectorType = COPP_ConnectorType(2i32);
pub const COPP_ConnectorType_DVI: COPP_ConnectorType = COPP_ConnectorType(4i32);
pub const COPP_ConnectorType_D_JPN: COPP_ConnectorType = COPP_ConnectorType(8i32);
pub const COPP_ConnectorType_ForceDWORD: COPP_ConnectorType = COPP_ConnectorType(2147483647i32);
pub const COPP_ConnectorType_HDMI: COPP_ConnectorType = COPP_ConnectorType(5i32);
pub const COPP_ConnectorType_Internal: COPP_ConnectorType = COPP_ConnectorType(-2147483648i32);
pub const COPP_ConnectorType_LVDS: COPP_ConnectorType = COPP_ConnectorType(6i32);
pub const COPP_ConnectorType_SVideo: COPP_ConnectorType = COPP_ConnectorType(1i32);
pub const COPP_ConnectorType_TMDS: COPP_ConnectorType = COPP_ConnectorType(7i32);
pub const COPP_ConnectorType_Unknown: COPP_ConnectorType = COPP_ConnectorType(-1i32);
pub const COPP_ConnectorType_VGA: COPP_ConnectorType = COPP_ConnectorType(0i32);
pub const COPP_DefaultProtectionLevel: u32 = 0u32;
pub const COPP_HDCPFlagsReserved: COPP_StatusHDCPFlags = COPP_StatusHDCPFlags(-2i32);
pub const COPP_HDCPRepeater: COPP_StatusHDCPFlags = COPP_StatusHDCPFlags(1i32);
pub const COPP_HDCP_ForceDWORD: COPP_HDCP_Protection_Level = COPP_HDCP_Protection_Level(2147483647i32);
pub const COPP_HDCP_Level0: COPP_HDCP_Protection_Level = COPP_HDCP_Protection_Level(0i32);
pub const COPP_HDCP_Level1: COPP_HDCP_Protection_Level = COPP_HDCP_Protection_Level(1i32);
pub const COPP_HDCP_LevelMax: COPP_HDCP_Protection_Level = COPP_HDCP_Protection_Level(1i32);
pub const COPP_HDCP_LevelMin: COPP_HDCP_Protection_Level = COPP_HDCP_Protection_Level(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_HDCP_Protection_Level(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_ImageAspectRatio_EN300294(pub i32);
pub const COPP_ImageAspectRatio_EN300294_Mask: u32 = 7u32;
pub const COPP_LinkLost: COPP_StatusFlags = COPP_StatusFlags(1i32);
pub const COPP_NoProtectionLevelAvailable: i32 = -1i32;
pub const COPP_ProtectionStandard_ARIBTRB15_1125i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(16384i32);
pub const COPP_ProtectionStandard_ARIBTRB15_525i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(2048i32);
pub const COPP_ProtectionStandard_ARIBTRB15_525p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(4096i32);
pub const COPP_ProtectionStandard_ARIBTRB15_750p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(8192i32);
pub const COPP_ProtectionStandard_CEA805A_TypeA_1125i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(128i32);
pub const COPP_ProtectionStandard_CEA805A_TypeA_525p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(32i32);
pub const COPP_ProtectionStandard_CEA805A_TypeA_750p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(64i32);
pub const COPP_ProtectionStandard_CEA805A_TypeB_1125i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(1024i32);
pub const COPP_ProtectionStandard_CEA805A_TypeB_525p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(256i32);
pub const COPP_ProtectionStandard_CEA805A_TypeB_750p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(512i32);
pub const COPP_ProtectionStandard_EIA608B_525: COPP_TVProtectionStandard = COPP_TVProtectionStandard(8i32);
pub const COPP_ProtectionStandard_EN300294_625i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(16i32);
pub const COPP_ProtectionStandard_IEC61880_2_525i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(2i32);
pub const COPP_ProtectionStandard_IEC61880_525i: COPP_TVProtectionStandard = COPP_TVProtectionStandard(1i32);
pub const COPP_ProtectionStandard_IEC62375_625p: COPP_TVProtectionStandard = COPP_TVProtectionStandard(4i32);
pub const COPP_ProtectionStandard_Mask: COPP_TVProtectionStandard = COPP_TVProtectionStandard(-2147450881i32);
pub const COPP_ProtectionStandard_None: COPP_TVProtectionStandard = COPP_TVProtectionStandard(0i32);
pub const COPP_ProtectionStandard_Reserved: COPP_TVProtectionStandard = COPP_TVProtectionStandard(2147450880i32);
pub const COPP_ProtectionStandard_Unknown: COPP_TVProtectionStandard = COPP_TVProtectionStandard(-2147483648i32);
pub const COPP_RenegotiationRequired: COPP_StatusFlags = COPP_StatusFlags(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_StatusFlags(pub i32);
pub const COPP_StatusFlagsReserved: COPP_StatusFlags = COPP_StatusFlags(-4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_StatusHDCPFlags(pub i32);
pub const COPP_StatusNormal: COPP_StatusFlags = COPP_StatusFlags(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct COPP_TVProtectionStandard(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct CameraControlFlags(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct CameraControlProperty(pub i32);
pub const CameraControl_Exposure: CameraControlProperty = CameraControlProperty(4i32);
pub const CameraControl_Flags_Auto: CameraControlFlags = CameraControlFlags(1i32);
pub const CameraControl_Flags_Manual: CameraControlFlags = CameraControlFlags(2i32);
pub const CameraControl_Focus: CameraControlProperty = CameraControlProperty(6i32);
pub const CameraControl_Iris: CameraControlProperty = CameraControlProperty(5i32);
pub const CameraControl_Pan: CameraControlProperty = CameraControlProperty(0i32);
pub const CameraControl_Roll: CameraControlProperty = CameraControlProperty(2i32);
pub const CameraControl_Tilt: CameraControlProperty = CameraControlProperty(1i32);
pub const CameraControl_Zoom: CameraControlProperty = CameraControlProperty(3i32);
pub const CardDataChanged: SmartCardStatusType = SmartCardStatusType(3i32);
pub const CardError: SmartCardStatusType = SmartCardStatusType(2i32);
pub const CardFirmwareUpgrade: SmartCardStatusType = SmartCardStatusType(4i32);
pub const CardInserted: SmartCardStatusType = SmartCardStatusType(0i32);
pub const CardRemoved: SmartCardStatusType = SmartCardStatusType(1i32);
pub const CategoryAudio: ComponentCategory = ComponentCategory(2i32);
pub const CategoryCaptions: ComponentCategory = ComponentCategory(5i32);
pub const CategoryData: ComponentCategory = ComponentCategory(7i32);
pub const CategoryNotSet: ComponentCategory = ComponentCategory(-1i32);
pub const CategoryOther: ComponentCategory = ComponentCategory(0i32);
pub const CategorySubtitles: ComponentCategory = ComponentCategory(4i32);
pub const CategorySuperimpose: ComponentCategory = ComponentCategory(6i32);
pub const CategoryText: ComponentCategory = ComponentCategory(3i32);
pub const CategoryVideo: ComponentCategory = ComponentCategory(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ComponentCategory(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ComponentStatus(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct CompressionCaps(pub i32);
pub const CompressionCaps_CanBFrame: CompressionCaps = CompressionCaps(8i32);
pub const CompressionCaps_CanCrunch: CompressionCaps = CompressionCaps(2i32);
pub const CompressionCaps_CanKeyFrame: CompressionCaps = CompressionCaps(4i32);
pub const CompressionCaps_CanQuality: CompressionCaps = CompressionCaps(1i32);
pub const CompressionCaps_CanWindow: CompressionCaps = CompressionCaps(16i32);
pub const ConstantBitRate: VIDEOENCODER_BITRATE_MODE = VIDEOENCODER_BITRATE_MODE(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DDSFF_FLAGS(pub i32);
impl DDSFF_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for DDSFF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for DDSFF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for DDSFF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for DDSFF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for DDSFF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const DDSFF_PROGRESSIVERENDER: DDSFF_FLAGS = DDSFF_FLAGS(1i32);
pub const DECIMATION_DEFAULT: DECIMATION_USAGE = DECIMATION_USAGE(4i32);
pub const DECIMATION_LEGACY: DECIMATION_USAGE = DECIMATION_USAGE(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DECIMATION_USAGE(pub i32);
pub const DECIMATION_USE_DECODER_ONLY: DECIMATION_USAGE = DECIMATION_USAGE(1i32);
pub const DECIMATION_USE_OVERLAY_ONLY: DECIMATION_USAGE = DECIMATION_USAGE(3i32);
pub const DECIMATION_USE_VIDEOPORT_ONLY: DECIMATION_USAGE = DECIMATION_USAGE(2i32);
pub const DECODER_CAP_NOTSUPPORTED: u32 = 0u32;
pub const DECODER_CAP_SUPPORTED: u32 = 1u32;
pub const DISPLAY_16x9: DVD_PREFERRED_DISPLAY_MODE = DVD_PREFERRED_DISPLAY_MODE(1i32);
pub const DISPLAY_4x3_LETTERBOX_PREFERRED: DVD_PREFERRED_DISPLAY_MODE = DVD_PREFERRED_DISPLAY_MODE(3i32);
pub const DISPLAY_4x3_PANSCAN_PREFERRED: DVD_PREFERRED_DISPLAY_MODE = DVD_PREFERRED_DISPLAY_MODE(2i32);
pub const DISPLAY_CONTENT_DEFAULT: DVD_PREFERRED_DISPLAY_MODE = DVD_PREFERRED_DISPLAY_MODE(0i32);
pub const DOLBY_AC3_AUDIO: MPEG2StreamType = MPEG2StreamType(129i32);
pub const DOLBY_DIGITAL_PLUS_AUDIO_ATSC: MPEG2StreamType = MPEG2StreamType(135i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVBSystemType(pub i32);
pub const DVB_Cable: DVBSystemType = DVBSystemType(0i32);
pub const DVB_Satellite: DVBSystemType = DVBSystemType(2i32);
pub const DVB_Terrestrial: DVBSystemType = DVBSystemType(1i32);
pub const DVDECODERRESOLUTION_180x120: _DVDECODERRESOLUTION = _DVDECODERRESOLUTION(1002i32);
pub const DVDECODERRESOLUTION_360x240: _DVDECODERRESOLUTION = _DVDECODERRESOLUTION(1001i32);
pub const DVDECODERRESOLUTION_720x480: _DVDECODERRESOLUTION = _DVDECODERRESOLUTION(1000i32);
pub const DVDECODERRESOLUTION_88x60: _DVDECODERRESOLUTION = _DVDECODERRESOLUTION(1003i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVD_ATR {
    pub ulCAT: u32,
    pub pbATRI: [u8; 768],
}
impl Default for DVD_ATR {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_AUDIO_APPMODE(pub i32);
pub const DVD_AUDIO_CAPS_AC3: u32 = 1u32;
pub const DVD_AUDIO_CAPS_DTS: u32 = 8u32;
pub const DVD_AUDIO_CAPS_LPCM: u32 = 4u32;
pub const DVD_AUDIO_CAPS_MPEG2: u32 = 2u32;
pub const DVD_AUDIO_CAPS_SDDS: u32 = 16u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_AUDIO_FORMAT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_AUDIO_LANG_EXT(pub i32);
pub const DVD_AUD_EXT_Captions: DVD_AUDIO_LANG_EXT = DVD_AUDIO_LANG_EXT(1i32);
pub const DVD_AUD_EXT_DirectorComments1: DVD_AUDIO_LANG_EXT = DVD_AUDIO_LANG_EXT(3i32);
pub const DVD_AUD_EXT_DirectorComments2: DVD_AUDIO_LANG_EXT = DVD_AUDIO_LANG_EXT(4i32);
pub const DVD_AUD_EXT_NotSpecified: DVD_AUDIO_LANG_EXT = DVD_AUDIO_LANG_EXT(0i32);
pub const DVD_AUD_EXT_VisuallyImpaired: DVD_AUDIO_LANG_EXT = DVD_AUDIO_LANG_EXT(2i32);
pub const DVD_AppMode_Karaoke: DVD_TITLE_APPMODE = DVD_TITLE_APPMODE(1i32);
pub const DVD_AppMode_Not_Specified: DVD_TITLE_APPMODE = DVD_TITLE_APPMODE(0i32);
pub const DVD_AppMode_Other: DVD_TITLE_APPMODE = DVD_TITLE_APPMODE(3i32);
pub const DVD_Assignment_LR: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(2i32);
pub const DVD_Assignment_LR1: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(4i32);
pub const DVD_Assignment_LR12: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(6i32);
pub const DVD_Assignment_LRM: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(3i32);
pub const DVD_Assignment_LRM1: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(5i32);
pub const DVD_Assignment_LRM12: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(7i32);
pub const DVD_Assignment_reserved0: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(0i32);
pub const DVD_Assignment_reserved1: DVD_KARAOKE_ASSIGNMENT = DVD_KARAOKE_ASSIGNMENT(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVD_AudioAttributes {
    pub AppMode: DVD_AUDIO_APPMODE,
    pub AppModeData: u8,
    pub AudioFormat: DVD_AUDIO_FORMAT,
    pub Language: u32,
    pub LanguageExtension: DVD_AUDIO_LANG_EXT,
    pub fHasMultichannelInfo: windows_core::BOOL,
    pub dwFrequency: u32,
    pub bQuantization: u8,
    pub bNumberOfChannels: u8,
    pub dwReserved: [u32; 2],
}
impl Default for DVD_AudioAttributes {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DVD_AudioDuringFFwdRew: DVD_OPTION_FLAG = DVD_OPTION_FLAG(4i32);
pub const DVD_AudioFormat_AC3: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(0i32);
pub const DVD_AudioFormat_DTS: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(6i32);
pub const DVD_AudioFormat_LPCM: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(5i32);
pub const DVD_AudioFormat_MPEG1: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(1i32);
pub const DVD_AudioFormat_MPEG1_DRC: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(2i32);
pub const DVD_AudioFormat_MPEG2: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(3i32);
pub const DVD_AudioFormat_MPEG2_DRC: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(4i32);
pub const DVD_AudioFormat_Other: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(8i32);
pub const DVD_AudioFormat_SDDS: DVD_AUDIO_FORMAT = DVD_AUDIO_FORMAT(7i32);
pub const DVD_AudioMode_Karaoke: DVD_AUDIO_APPMODE = DVD_AUDIO_APPMODE(1i32);
pub const DVD_AudioMode_None: DVD_AUDIO_APPMODE = DVD_AUDIO_APPMODE(0i32);
pub const DVD_AudioMode_Other: DVD_AUDIO_APPMODE = DVD_AUDIO_APPMODE(3i32);
pub const DVD_AudioMode_Surround: DVD_AUDIO_APPMODE = DVD_AUDIO_APPMODE(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_CMD_FLAGS(pub i32);
pub const DVD_CMD_FLAG_Block: DVD_CMD_FLAGS = DVD_CMD_FLAGS(4i32);
pub const DVD_CMD_FLAG_EndAfterRendered: DVD_CMD_FLAGS = DVD_CMD_FLAGS(16i32);
pub const DVD_CMD_FLAG_Flush: DVD_CMD_FLAGS = DVD_CMD_FLAGS(1i32);
pub const DVD_CMD_FLAG_None: DVD_CMD_FLAGS = DVD_CMD_FLAGS(0i32);
pub const DVD_CMD_FLAG_SendEvents: DVD_CMD_FLAGS = DVD_CMD_FLAGS(2i32);
pub const DVD_CMD_FLAG_StartWhenRendered: DVD_CMD_FLAGS = DVD_CMD_FLAGS(8i32);
pub const DVD_CacheSizeInMB: DVD_OPTION_FLAG = DVD_OPTION_FLAG(6i32);
pub const DVD_Channel_Audio: DVD_TextStringType = DVD_TextStringType(32i32);
pub const DVD_CharSet_ISO646: DVD_TextCharSet = DVD_TextCharSet(1i32);
pub const DVD_CharSet_ISO8859_1: DVD_TextCharSet = DVD_TextCharSet(3i32);
pub const DVD_CharSet_JIS_Roman_Kanji: DVD_TextCharSet = DVD_TextCharSet(2i32);
pub const DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana: DVD_TextCharSet = DVD_TextCharSet(4i32);
pub const DVD_CharSet_Unicode: DVD_TextCharSet = DVD_TextCharSet(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_DECODER_CAPS {
    pub dwSize: u32,
    pub dwAudioCaps: u32,
    pub dFwdMaxRateVideo: f64,
    pub dFwdMaxRateAudio: f64,
    pub dFwdMaxRateSP: f64,
    pub dBwdMaxRateVideo: f64,
    pub dBwdMaxRateAudio: f64,
    pub dBwdMaxRateSP: f64,
    pub dwRes1: u32,
    pub dwRes2: u32,
    pub dwRes3: u32,
    pub dwRes4: u32,
}
pub const DVD_DEFAULT_AUDIO_STREAM: u32 = 15u32;
pub const DVD_DIR_BACKWARD: DVD_PLAY_DIRECTION = DVD_PLAY_DIRECTION(1i32);
pub const DVD_DIR_FORWARD: DVD_PLAY_DIRECTION = DVD_PLAY_DIRECTION(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_DISC_SIDE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_DOMAIN(pub i32);
pub const DVD_DOMAIN_FirstPlay: DVD_DOMAIN = DVD_DOMAIN(1i32);
pub const DVD_DOMAIN_Stop: DVD_DOMAIN = DVD_DOMAIN(5i32);
pub const DVD_DOMAIN_Title: DVD_DOMAIN = DVD_DOMAIN(4i32);
pub const DVD_DOMAIN_VideoManagerMenu: DVD_DOMAIN = DVD_DOMAIN(2i32);
pub const DVD_DOMAIN_VideoTitleSetMenu: DVD_DOMAIN = DVD_DOMAIN(3i32);
pub const DVD_DisableStillThrottle: DVD_OPTION_FLAG = DVD_OPTION_FLAG(14i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_ERROR(pub i32);
pub const DVD_ERROR_CopyProtectFail: DVD_ERROR = DVD_ERROR(2i32);
pub const DVD_ERROR_CopyProtectOutputFail: DVD_ERROR = DVD_ERROR(9i32);
pub const DVD_ERROR_CopyProtectOutputNotSupported: DVD_ERROR = DVD_ERROR(10i32);
pub const DVD_ERROR_IncompatibleDiscAndDecoderRegions: DVD_ERROR = DVD_ERROR(8i32);
pub const DVD_ERROR_IncompatibleSystemAndDecoderRegions: DVD_ERROR = DVD_ERROR(7i32);
pub const DVD_ERROR_InvalidDVD1_0Disc: DVD_ERROR = DVD_ERROR(3i32);
pub const DVD_ERROR_InvalidDiscRegion: DVD_ERROR = DVD_ERROR(4i32);
pub const DVD_ERROR_LowParentalLevel: DVD_ERROR = DVD_ERROR(5i32);
pub const DVD_ERROR_MacrovisionFail: DVD_ERROR = DVD_ERROR(6i32);
pub const DVD_ERROR_Unexpected: DVD_ERROR = DVD_ERROR(1i32);
pub const DVD_EnableCC: DVD_OPTION_FLAG = DVD_OPTION_FLAG(19i32);
pub const DVD_EnableESOutput: DVD_OPTION_FLAG = DVD_OPTION_FLAG(12i32);
pub const DVD_EnableExtendedCopyProtectErrors: DVD_OPTION_FLAG = DVD_OPTION_FLAG(8i32);
pub const DVD_EnableLoggingEvents: DVD_OPTION_FLAG = DVD_OPTION_FLAG(15i32);
pub const DVD_EnableNonblockingAPIs: DVD_OPTION_FLAG = DVD_OPTION_FLAG(5i32);
pub const DVD_EnablePortableBookmarks: DVD_OPTION_FLAG = DVD_OPTION_FLAG(7i32);
pub const DVD_EnableStreaming: DVD_OPTION_FLAG = DVD_OPTION_FLAG(11i32);
pub const DVD_EnableTitleLength: DVD_OPTION_FLAG = DVD_OPTION_FLAG(13i32);
pub const DVD_FPS_25: DVD_FRAMERATE = DVD_FRAMERATE(1i32);
pub const DVD_FPS_30NonDrop: DVD_FRAMERATE = DVD_FRAMERATE(3i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_FRAMERATE(pub i32);
pub const DVD_General_Comments: DVD_TextStringType = DVD_TextStringType(49i32);
pub const DVD_General_Name: DVD_TextStringType = DVD_TextStringType(48i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_HMSF_TIMECODE {
    pub bHours: u8,
    pub bMinutes: u8,
    pub bSeconds: u8,
    pub bFrames: u8,
}
pub const DVD_HMSF_TimeCodeEvents: DVD_OPTION_FLAG = DVD_OPTION_FLAG(3i32);
pub const DVD_IncreaseOutputControl: DVD_OPTION_FLAG = DVD_OPTION_FLAG(10i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_KARAOKE_ASSIGNMENT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_KARAOKE_CONTENTS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_KARAOKE_DOWNMIX(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVD_KaraokeAttributes {
    pub bVersion: u8,
    pub fMasterOfCeremoniesInGuideVocal1: windows_core::BOOL,
    pub fDuet: windows_core::BOOL,
    pub ChannelAssignment: DVD_KARAOKE_ASSIGNMENT,
    pub wChannelContents: [u16; 8],
}
impl Default for DVD_KaraokeAttributes {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DVD_Karaoke_GuideMelody1: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(4i32);
pub const DVD_Karaoke_GuideMelody2: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(8i32);
pub const DVD_Karaoke_GuideMelodyA: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(16i32);
pub const DVD_Karaoke_GuideMelodyB: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(32i32);
pub const DVD_Karaoke_GuideVocal1: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(1i32);
pub const DVD_Karaoke_GuideVocal2: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(2i32);
pub const DVD_Karaoke_SoundEffectA: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(64i32);
pub const DVD_Karaoke_SoundEffectB: DVD_KARAOKE_CONTENTS = DVD_KARAOKE_CONTENTS(128i32);
pub const DVD_MENU_Angle: DVD_MENU_ID = DVD_MENU_ID(6i32);
pub const DVD_MENU_Audio: DVD_MENU_ID = DVD_MENU_ID(5i32);
pub const DVD_MENU_Chapter: DVD_MENU_ID = DVD_MENU_ID(7i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_MENU_ID(pub i32);
pub const DVD_MENU_Root: DVD_MENU_ID = DVD_MENU_ID(3i32);
pub const DVD_MENU_Subpicture: DVD_MENU_ID = DVD_MENU_ID(4i32);
pub const DVD_MENU_Title: DVD_MENU_ID = DVD_MENU_ID(2i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_MUA_Coeff {
    pub log2_alpha: f64,
    pub log2_beta: f64,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_MUA_MixingInfo {
    pub fMixTo0: windows_core::BOOL,
    pub fMixTo1: windows_core::BOOL,
    pub fMix0InPhase: windows_core::BOOL,
    pub fMix1InPhase: windows_core::BOOL,
    pub dwSpeakerPosition: u32,
}
pub const DVD_MaxReadBurstInKB: DVD_OPTION_FLAG = DVD_OPTION_FLAG(16i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVD_MenuAttributes {
    pub fCompatibleRegion: [windows_core::BOOL; 8],
    pub VideoAttributes: DVD_VideoAttributes,
    pub fAudioPresent: windows_core::BOOL,
    pub AudioAttributes: DVD_AudioAttributes,
    pub fSubpicturePresent: windows_core::BOOL,
    pub SubpictureAttributes: DVD_SubpictureAttributes,
}
impl Default for DVD_MenuAttributes {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DVD_Mix_0to0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(1i32);
pub const DVD_Mix_0to1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(256i32);
pub const DVD_Mix_1to0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(2i32);
pub const DVD_Mix_1to1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(512i32);
pub const DVD_Mix_2to0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(4i32);
pub const DVD_Mix_2to1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(1024i32);
pub const DVD_Mix_3to0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(8i32);
pub const DVD_Mix_3to1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(2048i32);
pub const DVD_Mix_4to0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(16i32);
pub const DVD_Mix_4to1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(4096i32);
pub const DVD_Mix_Lto0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(32i32);
pub const DVD_Mix_Lto1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(8192i32);
pub const DVD_Mix_Rto0: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(64i32);
pub const DVD_Mix_Rto1: DVD_KARAOKE_DOWNMIX = DVD_KARAOKE_DOWNMIX(16384i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVD_MultichannelAudioAttributes {
    pub Info: [DVD_MUA_MixingInfo; 8],
    pub Coeff: [DVD_MUA_Coeff; 8],
}
impl Default for DVD_MultichannelAudioAttributes {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_NavCmdType(pub i32);
pub const DVD_NavCmdType_Button: DVD_NavCmdType = DVD_NavCmdType(4i32);
pub const DVD_NavCmdType_Cell: DVD_NavCmdType = DVD_NavCmdType(3i32);
pub const DVD_NavCmdType_Post: DVD_NavCmdType = DVD_NavCmdType(2i32);
pub const DVD_NavCmdType_Pre: DVD_NavCmdType = DVD_NavCmdType(1i32);
pub const DVD_NotifyParentalLevelChange: DVD_OPTION_FLAG = DVD_OPTION_FLAG(2i32);
pub const DVD_NotifyPositionChange: DVD_OPTION_FLAG = DVD_OPTION_FLAG(9i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_OPTION_FLAG(pub i32);
pub const DVD_Other_Cut: DVD_TextStringType = DVD_TextStringType(81i32);
pub const DVD_Other_Scene: DVD_TextStringType = DVD_TextStringType(80i32);
pub const DVD_Other_Take: DVD_TextStringType = DVD_TextStringType(82i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_PARENTAL_LEVEL(pub i32);
pub const DVD_PARENTAL_LEVEL_1: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(256i32);
pub const DVD_PARENTAL_LEVEL_2: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(512i32);
pub const DVD_PARENTAL_LEVEL_3: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(1024i32);
pub const DVD_PARENTAL_LEVEL_4: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(2048i32);
pub const DVD_PARENTAL_LEVEL_5: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(4096i32);
pub const DVD_PARENTAL_LEVEL_6: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(8192i32);
pub const DVD_PARENTAL_LEVEL_7: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(16384i32);
pub const DVD_PARENTAL_LEVEL_8: DVD_PARENTAL_LEVEL = DVD_PARENTAL_LEVEL(32768i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_PB_STOPPED(pub i32);
pub const DVD_PB_STOPPED_CopyProtectFailure: DVD_PB_STOPPED = DVD_PB_STOPPED(13i32);
pub const DVD_PB_STOPPED_CopyProtectOutputFailure: DVD_PB_STOPPED = DVD_PB_STOPPED(14i32);
pub const DVD_PB_STOPPED_CopyProtectOutputNotSupported: DVD_PB_STOPPED = DVD_PB_STOPPED(15i32);
pub const DVD_PB_STOPPED_DiscEjected: DVD_PB_STOPPED = DVD_PB_STOPPED(5i32);
pub const DVD_PB_STOPPED_DiscReadError: DVD_PB_STOPPED = DVD_PB_STOPPED(12i32);
pub const DVD_PB_STOPPED_IllegalNavCommand: DVD_PB_STOPPED = DVD_PB_STOPPED(6i32);
pub const DVD_PB_STOPPED_MacrovisionFailure: DVD_PB_STOPPED = DVD_PB_STOPPED(11i32);
pub const DVD_PB_STOPPED_NoBranch: DVD_PB_STOPPED = DVD_PB_STOPPED(1i32);
pub const DVD_PB_STOPPED_NoFirstPlayDomain: DVD_PB_STOPPED = DVD_PB_STOPPED(2i32);
pub const DVD_PB_STOPPED_Other: DVD_PB_STOPPED = DVD_PB_STOPPED(0i32);
pub const DVD_PB_STOPPED_ParentalFailure: DVD_PB_STOPPED = DVD_PB_STOPPED(9i32);
pub const DVD_PB_STOPPED_PlayChapterAutoStop: DVD_PB_STOPPED = DVD_PB_STOPPED(8i32);
pub const DVD_PB_STOPPED_PlayPeriodAutoStop: DVD_PB_STOPPED = DVD_PB_STOPPED(7i32);
pub const DVD_PB_STOPPED_RegionFailure: DVD_PB_STOPPED = DVD_PB_STOPPED(10i32);
pub const DVD_PB_STOPPED_Reset: DVD_PB_STOPPED = DVD_PB_STOPPED(4i32);
pub const DVD_PB_STOPPED_StopCommand: DVD_PB_STOPPED = DVD_PB_STOPPED(3i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_PLAYBACK_LOCATION {
    pub TitleNum: u32,
    pub ChapterNum: u32,
    pub TimeCode: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_PLAYBACK_LOCATION2 {
    pub TitleNum: u32,
    pub ChapterNum: u32,
    pub TimeCode: DVD_HMSF_TIMECODE,
    pub TimeCodeFlags: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_PLAY_DIRECTION(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_PREFERRED_DISPLAY_MODE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_RELATIVE_BUTTON(pub i32);
pub const DVD_ReadBurstPeriodInMS: DVD_OPTION_FLAG = DVD_OPTION_FLAG(17i32);
pub const DVD_Relative_Left: DVD_RELATIVE_BUTTON = DVD_RELATIVE_BUTTON(3i32);
pub const DVD_Relative_Lower: DVD_RELATIVE_BUTTON = DVD_RELATIVE_BUTTON(2i32);
pub const DVD_Relative_Right: DVD_RELATIVE_BUTTON = DVD_RELATIVE_BUTTON(4i32);
pub const DVD_Relative_Upper: DVD_RELATIVE_BUTTON = DVD_RELATIVE_BUTTON(1i32);
pub const DVD_ResetOnStop: DVD_OPTION_FLAG = DVD_OPTION_FLAG(1i32);
pub const DVD_RestartDisc: DVD_OPTION_FLAG = DVD_OPTION_FLAG(18i32);
pub const DVD_SIDE_A: DVD_DISC_SIDE = DVD_DISC_SIDE(1i32);
pub const DVD_SIDE_B: DVD_DISC_SIDE = DVD_DISC_SIDE(2i32);
pub const DVD_SPCoding_Extended: DVD_SUBPICTURE_CODING = DVD_SUBPICTURE_CODING(1i32);
pub const DVD_SPCoding_Other: DVD_SUBPICTURE_CODING = DVD_SUBPICTURE_CODING(2i32);
pub const DVD_SPCoding_RunLength: DVD_SUBPICTURE_CODING = DVD_SUBPICTURE_CODING(0i32);
pub const DVD_SPType_Language: DVD_SUBPICTURE_TYPE = DVD_SUBPICTURE_TYPE(1i32);
pub const DVD_SPType_NotSpecified: DVD_SUBPICTURE_TYPE = DVD_SUBPICTURE_TYPE(0i32);
pub const DVD_SPType_Other: DVD_SUBPICTURE_TYPE = DVD_SUBPICTURE_TYPE(2i32);
pub const DVD_SP_EXT_CC_Big: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(6i32);
pub const DVD_SP_EXT_CC_Children: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(7i32);
pub const DVD_SP_EXT_CC_Normal: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(5i32);
pub const DVD_SP_EXT_Caption_Big: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(2i32);
pub const DVD_SP_EXT_Caption_Children: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(3i32);
pub const DVD_SP_EXT_Caption_Normal: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(1i32);
pub const DVD_SP_EXT_DirectorComments_Big: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(14i32);
pub const DVD_SP_EXT_DirectorComments_Children: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(15i32);
pub const DVD_SP_EXT_DirectorComments_Normal: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(13i32);
pub const DVD_SP_EXT_Forced: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(9i32);
pub const DVD_SP_EXT_NotSpecified: DVD_SUBPICTURE_LANG_EXT = DVD_SUBPICTURE_LANG_EXT(0i32);
pub const DVD_STREAM_DATA_CURRENT: u32 = 2048u32;
pub const DVD_STREAM_DATA_VMGM: u32 = 1024u32;
pub const DVD_STREAM_DATA_VTSM: u32 = 1025u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_SUBPICTURE_CODING(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_SUBPICTURE_LANG_EXT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_SUBPICTURE_TYPE(pub i32);
pub const DVD_Stream_Angle: DVD_TextStringType = DVD_TextStringType(18i32);
pub const DVD_Stream_Audio: DVD_TextStringType = DVD_TextStringType(16i32);
pub const DVD_Stream_Subpicture: DVD_TextStringType = DVD_TextStringType(17i32);
pub const DVD_Struct_Cell: DVD_TextStringType = DVD_TextStringType(5i32);
pub const DVD_Struct_ParentalID: DVD_TextStringType = DVD_TextStringType(3i32);
pub const DVD_Struct_PartOfTitle: DVD_TextStringType = DVD_TextStringType(4i32);
pub const DVD_Struct_Title: DVD_TextStringType = DVD_TextStringType(2i32);
pub const DVD_Struct_Volume: DVD_TextStringType = DVD_TextStringType(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_SubpictureAttributes {
    pub Type: DVD_SUBPICTURE_TYPE,
    pub CodingMode: DVD_SUBPICTURE_CODING,
    pub Language: u32,
    pub LanguageExtension: DVD_SUBPICTURE_LANG_EXT,
}
pub const DVD_TC_FLAG_25fps: DVD_TIMECODE_FLAGS = DVD_TIMECODE_FLAGS(1i32);
pub const DVD_TC_FLAG_30fps: DVD_TIMECODE_FLAGS = DVD_TIMECODE_FLAGS(2i32);
pub const DVD_TC_FLAG_DropFrame: DVD_TIMECODE_FLAGS = DVD_TIMECODE_FLAGS(4i32);
pub const DVD_TC_FLAG_Interpolated: DVD_TIMECODE_FLAGS = DVD_TIMECODE_FLAGS(8i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_TIMECODE {
    pub _bitfield: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_TIMECODE_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_TITLE_APPMODE(pub i32);
pub const DVD_TITLE_MENU: u32 = 0u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_TextCharSet(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_TextStringType(pub i32);
#[repr(C)]
#[derive(Clone, Copy)]
pub struct DVD_TitleAttributes {
    pub Anonymous: DVD_TitleAttributes_0,
    pub VideoAttributes: DVD_VideoAttributes,
    pub ulNumberOfAudioStreams: u32,
    pub AudioAttributes: [DVD_AudioAttributes; 8],
    pub MultichannelAudioAttributes: [DVD_MultichannelAudioAttributes; 8],
    pub ulNumberOfSubpictureStreams: u32,
    pub SubpictureAttributes: [DVD_SubpictureAttributes; 32],
}
impl Default for DVD_TitleAttributes {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union DVD_TitleAttributes_0 {
    pub AppMode: DVD_TITLE_APPMODE,
    pub TitleLength: DVD_HMSF_TIMECODE,
}
impl Default for DVD_TitleAttributes_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DVD_Title_Album: DVD_TextStringType = DVD_TextStringType(59i32);
pub const DVD_Title_Movie: DVD_TextStringType = DVD_TextStringType(57i32);
pub const DVD_Title_Orig_Album: DVD_TextStringType = DVD_TextStringType(75i32);
pub const DVD_Title_Orig_Movie: DVD_TextStringType = DVD_TextStringType(73i32);
pub const DVD_Title_Orig_Other: DVD_TextStringType = DVD_TextStringType(79i32);
pub const DVD_Title_Orig_Series: DVD_TextStringType = DVD_TextStringType(72i32);
pub const DVD_Title_Orig_Song: DVD_TextStringType = DVD_TextStringType(76i32);
pub const DVD_Title_Orig_Video: DVD_TextStringType = DVD_TextStringType(74i32);
pub const DVD_Title_Other: DVD_TextStringType = DVD_TextStringType(63i32);
pub const DVD_Title_Series: DVD_TextStringType = DVD_TextStringType(56i32);
pub const DVD_Title_Song: DVD_TextStringType = DVD_TextStringType(60i32);
pub const DVD_Title_Sub_Album: DVD_TextStringType = DVD_TextStringType(67i32);
pub const DVD_Title_Sub_Movie: DVD_TextStringType = DVD_TextStringType(65i32);
pub const DVD_Title_Sub_Other: DVD_TextStringType = DVD_TextStringType(71i32);
pub const DVD_Title_Sub_Series: DVD_TextStringType = DVD_TextStringType(64i32);
pub const DVD_Title_Sub_Song: DVD_TextStringType = DVD_TextStringType(68i32);
pub const DVD_Title_Sub_Video: DVD_TextStringType = DVD_TextStringType(66i32);
pub const DVD_Title_Video: DVD_TextStringType = DVD_TextStringType(58i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_VIDEO_COMPRESSION(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DVD_VideoAttributes {
    pub fPanscanPermitted: windows_core::BOOL,
    pub fLetterboxPermitted: windows_core::BOOL,
    pub ulAspectX: u32,
    pub ulAspectY: u32,
    pub ulFrameRate: u32,
    pub ulFrameHeight: u32,
    pub Compression: DVD_VIDEO_COMPRESSION,
    pub fLine21Field1InGOP: windows_core::BOOL,
    pub fLine21Field2InGOP: windows_core::BOOL,
    pub ulSourceResolutionX: u32,
    pub ulSourceResolutionY: u32,
    pub fIsSourceLetterboxed: windows_core::BOOL,
    pub fIsFilmMode: windows_core::BOOL,
}
pub const DVD_VideoCompression_MPEG1: DVD_VIDEO_COMPRESSION = DVD_VIDEO_COMPRESSION(1i32);
pub const DVD_VideoCompression_MPEG2: DVD_VIDEO_COMPRESSION = DVD_VIDEO_COMPRESSION(2i32);
pub const DVD_VideoCompression_Other: DVD_VIDEO_COMPRESSION = DVD_VIDEO_COMPRESSION(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DVD_WARNING(pub i32);
pub const DVD_WARNING_FormatNotSupported: DVD_WARNING = DVD_WARNING(2i32);
pub const DVD_WARNING_IllegalNavCommand: DVD_WARNING = DVD_WARNING(3i32);
pub const DVD_WARNING_InvalidDVD1_0Disc: DVD_WARNING = DVD_WARNING(1i32);
pub const DVD_WARNING_Open: DVD_WARNING = DVD_WARNING(4i32);
pub const DVD_WARNING_Read: DVD_WARNING = DVD_WARNING(6i32);
pub const DVD_WARNING_Seek: DVD_WARNING = DVD_WARNING(5i32);
pub const DVENCODERFORMAT_DVHD: _DVENCODERFORMAT = _DVENCODERFORMAT(2008i32);
pub const DVENCODERFORMAT_DVSD: _DVENCODERFORMAT = _DVENCODERFORMAT(2007i32);
pub const DVENCODERFORMAT_DVSL: _DVENCODERFORMAT = _DVENCODERFORMAT(2009i32);
pub const DVENCODERRESOLUTION_180x120: _DVENCODERRESOLUTION = _DVENCODERRESOLUTION(2014i32);
pub const DVENCODERRESOLUTION_360x240: _DVENCODERRESOLUTION = _DVENCODERRESOLUTION(2013i32);
pub const DVENCODERRESOLUTION_720x480: _DVENCODERRESOLUTION = _DVENCODERRESOLUTION(2012i32);
pub const DVENCODERRESOLUTION_88x60: _DVENCODERRESOLUTION = _DVENCODERRESOLUTION(2015i32);
pub const DVENCODERVIDEOFORMAT_NTSC: _DVENCODERVIDEOFORMAT = _DVENCODERVIDEOFORMAT(2000i32);
pub const DVENCODERVIDEOFORMAT_PAL: _DVENCODERVIDEOFORMAT = _DVENCODERVIDEOFORMAT(2001i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DVINFO {
    pub dwDVAAuxSrc: u32,
    pub dwDVAAuxCtl: u32,
    pub dwDVAAuxSrc1: u32,
    pub dwDVAAuxCtl1: u32,
    pub dwDVVAuxSrc: u32,
    pub dwDVVAuxCtl: u32,
    pub dwDVReserved: [u32; 2],
}
impl Default for DVINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DVRESOLUTION_DC: _DVRESOLUTION = _DVRESOLUTION(1003i32);
pub const DVRESOLUTION_FULL: _DVRESOLUTION = _DVRESOLUTION(1000i32);
pub const DVRESOLUTION_HALF: _DVRESOLUTION = _DVRESOLUTION(1001i32);
pub const DVRESOLUTION_QUARTER: _DVRESOLUTION = _DVRESOLUTION(1002i32);
pub const DWORD_ALLPARAMS: i32 = -1i32;
#[repr(C)]
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
#[derive(Clone, Copy, Debug, Default)]
pub struct DXVA2SW_CALLBACKS {
    pub Size: u32,
    pub GetVideoProcessorRenderTargetCount: PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT,
    pub GetVideoProcessorRenderTargets: PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS,
    pub GetVideoProcessorCaps: PDXVA2SW_GETVIDEOPROCESSORCAPS,
    pub GetVideoProcessorSubStreamFormatCount: PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT,
    pub GetVideoProcessorSubStreamFormats: PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS,
    pub GetProcAmpRange: PDXVA2SW_GETPROCAMPRANGE,
    pub GetFilterPropertyRange: PDXVA2SW_GETFILTERPROPERTYRANGE,
    pub CreateVideoProcessDevice: PDXVA2SW_CREATEVIDEOPROCESSDEVICE,
    pub DestroyVideoProcessDevice: PDXVA2SW_DESTROYVIDEOPROCESSDEVICE,
    pub VideoProcessBeginFrame: PDXVA2SW_VIDEOPROCESSBEGINFRAME,
    pub VideoProcessEndFrame: PDXVA2SW_VIDEOPROCESSENDFRAME,
    pub VideoProcessSetRenderTarget: PDXVA2SW_VIDEOPROCESSSETRENDERTARGET,
    pub VideoProcessBlt: PDXVA2SW_VIDEOPROCESSBLT,
}
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2TraceVideoProcessBltData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub pRenderTarget: u64,
    pub TargetFrameTime: u64,
    pub TargetRect: super::super::Foundation::RECT,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2TraceVideoProcessBltData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2Trace_Control: windows_core::GUID = windows_core::GUID::from_u128(0xa0386e75_f70c_464c_a9ce_33c44e091623);
pub const DXVA2Trace_DecodeDevBeginFrame: windows_core::GUID = windows_core::GUID::from_u128(0x9fd1acf6_44cb_4637_bc62_2c11a9608f90);
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_DecodeDevBeginFrameData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub pRenderTarget: u64,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_DecodeDevBeginFrameData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2Trace_DecodeDevCreated: windows_core::GUID = windows_core::GUID::from_u128(0xb4de17a1_c5b2_44fe_86d5_d97a648114ff);
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_DecodeDevCreatedData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub pD3DDevice: u64,
    pub DeviceGuid: windows_core::GUID,
    pub Width: u32,
    pub Height: u32,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_DecodeDevCreatedData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2Trace_DecodeDevDestroyed: windows_core::GUID = windows_core::GUID::from_u128(0x853ebdf2_4160_421d_8893_63dcea4f18bb);
pub const DXVA2Trace_DecodeDevEndFrame: windows_core::GUID = windows_core::GUID::from_u128(0x9fb3cb33_47dc_4899_98c8_c0c6cd7cd3cb);
pub const DXVA2Trace_DecodeDevExecute: windows_core::GUID = windows_core::GUID::from_u128(0x850aeb4c_d19a_4609_b3b4_bcbf0e22121e);
pub const DXVA2Trace_DecodeDevGetBuffer: windows_core::GUID = windows_core::GUID::from_u128(0x57b128fb_72cb_4137_a575_d91fa3160897);
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_DecodeDevGetBufferData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub BufferType: u32,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_DecodeDevGetBufferData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_DecodeDeviceData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_DecodeDeviceData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2Trace_VideoProcessBlt: windows_core::GUID = windows_core::GUID::from_u128(0x69089cc0_71ab_42d0_953a_2887bf05a8af);
pub const DXVA2Trace_VideoProcessDevCreated: windows_core::GUID = windows_core::GUID::from_u128(0x895508c6_540d_4c87_98f8_8dcbf2dabb2a);
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_VideoProcessDevCreatedData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub pD3DDevice: u64,
    pub DeviceGuid: windows_core::GUID,
    pub RTFourCC: u32,
    pub Width: u32,
    pub Height: u32,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_VideoProcessDevCreatedData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2Trace_VideoProcessDevDestroyed: windows_core::GUID = windows_core::GUID::from_u128(0xf97f30b1_fb49_42c7_8ee8_88bdfa92d4e2);
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
#[derive(Clone, Copy)]
pub struct DXVA2Trace_VideoProcessDeviceData {
    pub wmiHeader: super::super::System::Diagnostics::Etw::EVENT_TRACE_HEADER,
    pub pObject: u64,
    pub Enter: windows_core::BOOL,
}
#[cfg(feature = "Win32_System_Diagnostics_Etw")]
impl Default for DXVA2Trace_VideoProcessDeviceData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA2_DestinationFlagMask: DXVA2_DestinationFlags = DXVA2_DestinationFlags(-65521i32);
pub const DXVA2_DestinationFlag_Alpha_Changed: DXVA2_DestinationFlags = DXVA2_DestinationFlags(8i32);
pub const DXVA2_DestinationFlag_Background_Changed: DXVA2_DestinationFlags = DXVA2_DestinationFlags(1i32);
pub const DXVA2_DestinationFlag_ColorData_Changed: DXVA2_DestinationFlags = DXVA2_DestinationFlags(4i32);
pub const DXVA2_DestinationFlag_RFF: DXVA2_DestinationFlags = DXVA2_DestinationFlags(65536i32);
pub const DXVA2_DestinationFlag_RFF_TFF_Present: DXVA2_DestinationFlags = DXVA2_DestinationFlags(262144i32);
pub const DXVA2_DestinationFlag_TFF: DXVA2_DestinationFlags = DXVA2_DestinationFlags(131072i32);
pub const DXVA2_DestinationFlag_TargetRect_Changed: DXVA2_DestinationFlags = DXVA2_DestinationFlags(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DXVA2_DestinationFlags(pub i32);
pub const DXVA2_SampleFlag_ColorData_Changed: DXVA2_SampleFlags = DXVA2_SampleFlags(8i32);
pub const DXVA2_SampleFlag_DstRect_Changed: DXVA2_SampleFlags = DXVA2_SampleFlags(4i32);
pub const DXVA2_SampleFlag_Palette_Changed: DXVA2_SampleFlags = DXVA2_SampleFlags(1i32);
pub const DXVA2_SampleFlag_PlanarAlpha_Changed: DXVA2_SampleFlags = DXVA2_SampleFlags(16i32);
pub const DXVA2_SampleFlag_RFF: DXVA2_SampleFlags = DXVA2_SampleFlags(65536i32);
pub const DXVA2_SampleFlag_RFF_TFF_Present: DXVA2_SampleFlags = DXVA2_SampleFlags(262144i32);
pub const DXVA2_SampleFlag_SrcRect_Changed: DXVA2_SampleFlags = DXVA2_SampleFlags(2i32);
pub const DXVA2_SampleFlag_TFF: DXVA2_SampleFlags = DXVA2_SampleFlags(131072i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DXVA2_SampleFlags(pub i32);
pub const DXVA2_SampleFlagsMask: DXVA2_SampleFlags = DXVA2_SampleFlags(-65505i32);
#[repr(C)]
#[cfg(feature = "Win32_Media_MediaFoundation")]
#[derive(Clone, Copy)]
pub struct DXVA2_VIDEOPROCESSBLT {
    pub TargetFrame: i64,
    pub TargetRect: super::super::Foundation::RECT,
    pub ConstrictionSize: super::super::Foundation::SIZE,
    pub StreamingFlags: u32,
    pub BackgroundColor: super::MediaFoundation::DXVA2_AYUVSample16,
    pub DestFormat: super::MediaFoundation::DXVA2_ExtendedFormat,
    pub DestFlags: u32,
    pub ProcAmpValues: super::MediaFoundation::DXVA2_ProcAmpValues,
    pub Alpha: super::MediaFoundation::DXVA2_Fixed32,
    pub NoiseFilterLuma: super::MediaFoundation::DXVA2_FilterValues,
    pub NoiseFilterChroma: super::MediaFoundation::DXVA2_FilterValues,
    pub DetailFilterLuma: super::MediaFoundation::DXVA2_FilterValues,
    pub DetailFilterChroma: super::MediaFoundation::DXVA2_FilterValues,
    pub pSrcSurfaces: *mut DXVA2_VIDEOSAMPLE,
    pub NumSrcSurfaces: u32,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl Default for DXVA2_VIDEOPROCESSBLT {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Media_MediaFoundation")]
#[derive(Clone, Copy)]
pub struct DXVA2_VIDEOSAMPLE {
    pub Start: i64,
    pub End: i64,
    pub SampleFormat: super::MediaFoundation::DXVA2_ExtendedFormat,
    pub SampleFlags: u32,
    pub SrcResource: *mut core::ffi::c_void,
    pub SrcRect: super::super::Foundation::RECT,
    pub DstRect: super::super::Foundation::RECT,
    pub Pal: [super::MediaFoundation::DXVA2_AYUVSample8; 16],
    pub PlanarAlpha: super::MediaFoundation::DXVA2_Fixed32,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl Default for DXVA2_VIDEOSAMPLE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA_ALPHA_BLEND_COMBINATION_BUFFER: u32 = 13u32;
pub const DXVA_ALPHA_BLEND_COMBINATION_FUNCTION: u32 = 3u32;
pub const DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION: u32 = 2u32;
pub const DXVA_AYUV_BUFFER: u32 = 8u32;
pub const DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC: u32 = 1u32;
pub const DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND: u32 = 0u32;
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD: u32 = 3u32;
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD: u32 = 2u32;
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA: u32 = 1u32;
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED: u32 = 0u32;
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY: u32 = 2u32;
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_MILD: u32 = 1u32;
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE: u32 = 3u32;
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY: u32 = 0u32;
pub const DXVA_BITSTREAM_DATA_BUFFER: u32 = 7u32;
pub const DXVA_CHROMA_FORMAT_420: u32 = 1u32;
pub const DXVA_CHROMA_FORMAT_422: u32 = 2u32;
pub const DXVA_CHROMA_FORMAT_444: u32 = 3u32;
pub const DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED: u32 = 0u32;
pub const DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE: u32 = 1u32;
pub const DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER: u32 = 0u32;
pub const DXVA_CONFIG_DATA_TYPE_AI44: u32 = 1u32;
pub const DXVA_CONFIG_DATA_TYPE_AYUV: u32 = 3u32;
pub const DXVA_CONFIG_DATA_TYPE_DPXD: u32 = 2u32;
pub const DXVA_CONFIG_DATA_TYPE_IA44: u32 = 0u32;
pub const DXVA_COPPCommandFnCode: u32 = 4u32;
pub const DXVA_COPPDevice: windows_core::GUID = windows_core::GUID::from_u128(0xd2457add_8999_45ed_8a8a_d1aa047ba4d5);
pub const DXVA_COPPGetCertificateLengthFnCode: u32 = 1u32;
pub const DXVA_COPPKeyExchangeFnCode: u32 = 2u32;
pub const DXVA_COPPQueryBusData: windows_core::GUID = windows_core::GUID::from_u128(0xc6f4d673_6174_4184_8e35_f6db5200bcba);
pub const DXVA_COPPQueryConnectorType: windows_core::GUID = windows_core::GUID::from_u128(0x81d0bfd5_6afe_48c2_99c0_95a08f97c5da);
pub const DXVA_COPPQueryDisplayData: windows_core::GUID = windows_core::GUID::from_u128(0xd7bf1ba3_ad13_4f8e_af98_0dcb3ca204cc);
pub const DXVA_COPPQueryGlobalProtectionLevel: windows_core::GUID = windows_core::GUID::from_u128(0x1957210a_7766_452a_b99a_d27aed54f03a);
pub const DXVA_COPPQueryHDCPKeyData: windows_core::GUID = windows_core::GUID::from_u128(0x0db59d74_a992_492e_a0bd_c23fda564e00);
pub const DXVA_COPPQueryLocalProtectionLevel: windows_core::GUID = windows_core::GUID::from_u128(0xb2075857_3eda_4d5d_88db_748f8c1a0549);
pub const DXVA_COPPQueryProtectionType: windows_core::GUID = windows_core::GUID::from_u128(0x38f2a801_9a6c_48bb_9107_b6696e6f1797);
pub const DXVA_COPPQuerySignaling: windows_core::GUID = windows_core::GUID::from_u128(0x6629a591_3b79_4cf3_924a_11e8e7811671);
pub const DXVA_COPPQueryStatusFnCode: u32 = 5u32;
pub const DXVA_COPPSequenceStartFnCode: u32 = 3u32;
pub const DXVA_COPPSetProtectionLevel: windows_core::GUID = windows_core::GUID::from_u128(0x9bb9327c_4eb5_4727_9f00_b42b0919c0da);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DXVA_COPPSetProtectionLevelCmdData {
    pub ProtType: u32,
    pub ProtLevel: u32,
    pub ExtendedInfoChangeMask: u32,
    pub ExtendedInfoData: u32,
}
pub const DXVA_COPPSetSignaling: windows_core::GUID = windows_core::GUID::from_u128(0x09a631a5_d684_4c60_8e4d_d3bb0f0be3ee);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DXVA_COPPSetSignalingCmdData {
    pub ActiveTVProtectionStandard: u32,
    pub AspectRatioChangeMask1: u32,
    pub AspectRatioData1: u32,
    pub AspectRatioChangeMask2: u32,
    pub AspectRatioData2: u32,
    pub AspectRatioChangeMask3: u32,
    pub AspectRatioData3: u32,
    pub ExtendedInfoChangeMask: [u32; 4],
    pub ExtendedInfoData: [u32; 4],
    pub Reserved: u32,
}
impl Default for DXVA_COPPSetSignalingCmdData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DXVA_COPPStatusData {
    pub rApp: windows_core::GUID,
    pub dwFlags: u32,
    pub dwData: u32,
    pub ExtendedInfoValidMask: u32,
    pub ExtendedInfoData: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DXVA_COPPStatusDisplayData {
    pub rApp: windows_core::GUID,
    pub dwFlags: u32,
    pub DisplayWidth: u32,
    pub DisplayHeight: u32,
    pub Format: u32,
    pub d3dFormat: u32,
    pub FreqNumerator: u32,
    pub FreqDenominator: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct DXVA_COPPStatusHDCPKeyData {
    pub rApp: windows_core::GUID,
    pub dwFlags: u32,
    pub dwHDCPFlags: u32,
    pub BKey: windows_core::GUID,
    pub Reserved1: windows_core::GUID,
    pub Reserved2: windows_core::GUID,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DXVA_COPPStatusSignalingCmdData {
    pub rApp: windows_core::GUID,
    pub dwFlags: u32,
    pub AvailableTVProtectionStandards: u32,
    pub ActiveTVProtectionStandard: u32,
    pub TVType: u32,
    pub AspectRatioValidMask1: u32,
    pub AspectRatioData1: u32,
    pub AspectRatioValidMask2: u32,
    pub AspectRatioData2: u32,
    pub AspectRatioValidMask3: u32,
    pub AspectRatioData3: u32,
    pub ExtendedInfoValidMask: [u32; 4],
    pub ExtendedInfoData: [u32; 4],
}
impl Default for DXVA_COPPStatusSignalingCmdData {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const DXVA_DCCMD_SURFACE_BUFFER: u32 = 12u32;
pub const DXVA_DEBLOCKING_CONTROL_BUFFER: u32 = 4u32;
pub const DXVA_DEBLOCKING_FILTER_FUNCTION: u32 = 5u32;
pub const DXVA_DPXD_SURFACE_BUFFER: u32 = 10u32;
pub const DXVA_DeinterlaceBltExFnCode: u32 = 2u32;
pub const DXVA_DeinterlaceBltFnCode: u32 = 1u32;
pub const DXVA_DeinterlaceBobDevice: windows_core::GUID = windows_core::GUID::from_u128(0x335aa36e_7884_43a4_9c91_7f87faf3e37e);
pub const DXVA_DeinterlaceContainerDevice: windows_core::GUID = windows_core::GUID::from_u128(0x0e85cb93_3046_4ff0_aecc_d58cb5f035fd);
pub const DXVA_DeinterlaceQueryAvailableModesFnCode: u32 = 1u32;
pub const DXVA_DeinterlaceQueryModeCapsFnCode: u32 = 2u32;
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL: u32 = 16776968u32;
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST: u32 = 16776960u32;
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR: u32 = 1u32;
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE: u32 = 3u32;
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF: u32 = 2u32;
pub const DXVA_EXECUTE_RETURN_OK: u32 = 0u32;
pub const DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE: u32 = 4u32;
pub const DXVA_ExtColorData_ShiftBase: u32 = 8u32;
pub const DXVA_FILM_GRAIN_BUFFER: u32 = 17u32;
pub const DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION: u32 = 6u32;
pub const DXVA_HIGHLIGHT_BUFFER: u32 = 11u32;
pub const DXVA_IA44_SURFACE_BUFFER: u32 = 9u32;
pub const DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER: u32 = 5u32;
pub const DXVA_MACROBLOCK_CONTROL_BUFFER: u32 = 2u32;
pub const DXVA_MOTION_VECTOR_BUFFER: u32 = 16u32;
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261: u32 = 2u32;
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263: u32 = 1u32;
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2: u32 = 0u32;
pub const DXVA_ModeAV1_VLD_12bit_Profile2: windows_core::GUID = windows_core::GUID::from_u128(0x17127009_a00f_4ce1_994e_bf4081f6f3f0);
pub const DXVA_ModeAV1_VLD_12bit_Profile2_420: windows_core::GUID = windows_core::GUID::from_u128(0x2d80bed6_9cac_4835_9e91_327bbc4f9ee8);
pub const DXVA_ModeAV1_VLD_Profile0: windows_core::GUID = windows_core::GUID::from_u128(0xb8be4ccb_cf53_46ba_8d59_d6b8a6da5d2a);
pub const DXVA_ModeAV1_VLD_Profile1: windows_core::GUID = windows_core::GUID::from_u128(0x6936ff0f_45b1_4163_9cc1_646ef6946108);
pub const DXVA_ModeAV1_VLD_Profile2: windows_core::GUID = windows_core::GUID::from_u128(0x0c5f2aa1_e541_4089_bb7b_98110a19d7c8);
pub const DXVA_ModeH261_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be01_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH261_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be02_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be03_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be04_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_C: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be05_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_D: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be06_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_E: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be07_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH263_F: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be08_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be64_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be65_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_C: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be66_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_D: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be67_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_E: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be68_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_F: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be69_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeH264_VLD_Multiview_NoFGT: windows_core::GUID = windows_core::GUID::from_u128(0x705b9d82_76cf_49d6_b7e6_ac8872db013c);
pub const DXVA_ModeH264_VLD_Stereo_NoFGT: windows_core::GUID = windows_core::GUID::from_u128(0xf9aaccbb_c2b6_4cfc_8779_5707b1760552);
pub const DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT: windows_core::GUID = windows_core::GUID::from_u128(0xd79be8da_0cf1_4c81_b82a_69a4e236f43d);
pub const DXVA_ModeH264_VLD_WithFMOASO_NoFGT: windows_core::GUID = windows_core::GUID::from_u128(0xd5f04ff9_3418_45d8_9561_32a76aae2ddd);
pub const DXVA_ModeHEVC_VLD_Main: windows_core::GUID = windows_core::GUID::from_u128(0x5b11d51b_2f4c_4452_bcc3_09f2a1160cc0);
pub const DXVA_ModeHEVC_VLD_Main10: windows_core::GUID = windows_core::GUID::from_u128(0x107af0e0_ef1a_4d19_aba8_67a163073d13);
pub const DXVA_ModeMPEG1_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be09_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeMPEG1_VLD: windows_core::GUID = windows_core::GUID::from_u128(0x6f3ec719_3735_42cc_8063_65cc3cb36616);
pub const DXVA_ModeMPEG2_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be0a_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeMPEG2_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be0b_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeMPEG2_C: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be0c_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeMPEG2_D: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be0d_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeMPEG2and1_VLD: windows_core::GUID = windows_core::GUID::from_u128(0x86695f12_340e_4f04_9fd3_9253dd327460);
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC: windows_core::GUID = windows_core::GUID::from_u128(0xab998b5b_4258_44a9_9feb_94e597a6baae);
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC: windows_core::GUID = windows_core::GUID::from_u128(0xed418a9f_010d_4eda_9ae3_9a65358d8d2e);
pub const DXVA_ModeMPEG4pt2_VLD_Simple: windows_core::GUID = windows_core::GUID::from_u128(0xefd64d74_c9e8_41d7_a5e9_e9b0e39fa319);
pub const DXVA_ModeNone: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be00_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVC1_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bea0_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVC1_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bea1_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVC1_C: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bea2_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVC1_D: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bea3_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVC1_D2010: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bea4_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeVP8_VLD: windows_core::GUID = windows_core::GUID::from_u128(0x90b899ea_3a62_4705_88b3_8df04b2744e7);
pub const DXVA_ModeVP9_VLD_10bit_Profile2: windows_core::GUID = windows_core::GUID::from_u128(0xa4c749ef_6ecf_48aa_8448_50a7a1165ff7);
pub const DXVA_ModeVP9_VLD_Profile0: windows_core::GUID = windows_core::GUID::from_u128(0x463707f8_a1d0_4585_876d_83aa6d60b89e);
pub const DXVA_ModeWMV8_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be80_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeWMV8_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be81_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeWMV9_A: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be90_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeWMV9_B: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be91_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_ModeWMV9_C: windows_core::GUID = windows_core::GUID::from_u128(0x1b81be94_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_NUM_TYPES_COMP_BUFFERS: u32 = 18u32;
pub const DXVA_NoEncrypt: windows_core::GUID = windows_core::GUID::from_u128(0x1b81bed0_a0c7_11d3_b984_00c04f2e73c5);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_off: u32 = 4u32;
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_on: u32 = 5u32;
pub const DXVA_NumMV_OBMC_on__BinPB_off: u32 = 10u32;
pub const DXVA_NumMV_OBMC_on__BinPB_on: u32 = 11u32;
pub const DXVA_PICTURE_DECODE_BUFFER: u32 = 1u32;
pub const DXVA_PICTURE_DECODING_FUNCTION: u32 = 1u32;
pub const DXVA_PICTURE_RESAMPLE_BUFFER: u32 = 14u32;
pub const DXVA_PICTURE_RESAMPLE_FUNCTION: u32 = 4u32;
pub const DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD: u32 = 2u32;
pub const DXVA_PICTURE_STRUCTURE_FRAME: u32 = 3u32;
pub const DXVA_PICTURE_STRUCTURE_TOP_FIELD: u32 = 1u32;
pub const DXVA_ProcAmpControlBltFnCode: u32 = 1u32;
pub const DXVA_ProcAmpControlDevice: windows_core::GUID = windows_core::GUID::from_u128(0x9f200913_2ffd_4056_9f1e_e1b508f22dcf);
pub const DXVA_ProcAmpControlQueryCapsFnCode: u32 = 3u32;
pub const DXVA_ProcAmpControlQueryRangeFnCode: u32 = 4u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS: u32 = 16777215u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY: u32 = 16777212u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS: u32 = 16777211u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY: u32 = 16777208u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS: u32 = 16777209u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY: u32 = 16777205u32;
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY: u32 = 16777201u32;
pub const DXVA_READ_BACK_BUFFER: u32 = 15u32;
pub const DXVA_RESIDUAL_DIFFERENCE_BUFFER: u32 = 3u32;
pub const DXVA_RESTRICTED_MODE_H261_A: u32 = 1u32;
pub const DXVA_RESTRICTED_MODE_H261_B: u32 = 2u32;
pub const DXVA_RESTRICTED_MODE_H263_A: u32 = 3u32;
pub const DXVA_RESTRICTED_MODE_H263_B: u32 = 4u32;
pub const DXVA_RESTRICTED_MODE_H263_C: u32 = 5u32;
pub const DXVA_RESTRICTED_MODE_H263_D: u32 = 6u32;
pub const DXVA_RESTRICTED_MODE_H263_E: u32 = 7u32;
pub const DXVA_RESTRICTED_MODE_H263_F: u32 = 8u32;
pub const DXVA_RESTRICTED_MODE_H264_A: u32 = 100u32;
pub const DXVA_RESTRICTED_MODE_H264_B: u32 = 101u32;
pub const DXVA_RESTRICTED_MODE_H264_C: u32 = 102u32;
pub const DXVA_RESTRICTED_MODE_H264_D: u32 = 103u32;
pub const DXVA_RESTRICTED_MODE_H264_E: u32 = 104u32;
pub const DXVA_RESTRICTED_MODE_H264_F: u32 = 105u32;
pub const DXVA_RESTRICTED_MODE_H264_IDCT_FGT: u32 = 103u32;
pub const DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT: u32 = 102u32;
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT: u32 = 101u32;
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT: u32 = 100u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_FGT: u32 = 105u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_MULTIVIEW_NOFGT: u32 = 115u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_NOFGT: u32 = 104u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_NOFGT: u32 = 114u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_PROGRESSIVE_NOFGT: u32 = 113u32;
pub const DXVA_RESTRICTED_MODE_H264_VLD_WITHFMOASO_NOFGT: u32 = 112u32;
pub const DXVA_RESTRICTED_MODE_MPEG1_A: u32 = 9u32;
pub const DXVA_RESTRICTED_MODE_MPEG1_VLD: u32 = 16u32;
pub const DXVA_RESTRICTED_MODE_MPEG2_A: u32 = 10u32;
pub const DXVA_RESTRICTED_MODE_MPEG2_B: u32 = 11u32;
pub const DXVA_RESTRICTED_MODE_MPEG2_C: u32 = 12u32;
pub const DXVA_RESTRICTED_MODE_MPEG2_D: u32 = 13u32;
pub const DXVA_RESTRICTED_MODE_MPEG2and1_VLD: u32 = 17u32;
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_GMC: u32 = 178u32;
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_NOGMC: u32 = 177u32;
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_SIMPLE: u32 = 176u32;
pub const DXVA_RESTRICTED_MODE_UNRESTRICTED: u32 = 65535u32;
pub const DXVA_RESTRICTED_MODE_VC1_A: u32 = 160u32;
pub const DXVA_RESTRICTED_MODE_VC1_B: u32 = 161u32;
pub const DXVA_RESTRICTED_MODE_VC1_C: u32 = 162u32;
pub const DXVA_RESTRICTED_MODE_VC1_D: u32 = 163u32;
pub const DXVA_RESTRICTED_MODE_VC1_D2010: u32 = 164u32;
pub const DXVA_RESTRICTED_MODE_VC1_IDCT: u32 = 162u32;
pub const DXVA_RESTRICTED_MODE_VC1_MOCOMP: u32 = 161u32;
pub const DXVA_RESTRICTED_MODE_VC1_POSTPROC: u32 = 160u32;
pub const DXVA_RESTRICTED_MODE_VC1_VLD: u32 = 163u32;
pub const DXVA_RESTRICTED_MODE_WMV8_A: u32 = 128u32;
pub const DXVA_RESTRICTED_MODE_WMV8_B: u32 = 129u32;
pub const DXVA_RESTRICTED_MODE_WMV8_MOCOMP: u32 = 129u32;
pub const DXVA_RESTRICTED_MODE_WMV8_POSTPROC: u32 = 128u32;
pub const DXVA_RESTRICTED_MODE_WMV9_A: u32 = 144u32;
pub const DXVA_RESTRICTED_MODE_WMV9_B: u32 = 145u32;
pub const DXVA_RESTRICTED_MODE_WMV9_C: u32 = 148u32;
pub const DXVA_RESTRICTED_MODE_WMV9_IDCT: u32 = 148u32;
pub const DXVA_RESTRICTED_MODE_WMV9_MOCOMP: u32 = 145u32;
pub const DXVA_RESTRICTED_MODE_WMV9_POSTPROC: u32 = 144u32;
pub const DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL: u32 = 2u32;
pub const DXVA_SCAN_METHOD_ALTERNATE_VERTICAL: u32 = 1u32;
pub const DXVA_SCAN_METHOD_ARBITRARY: u32 = 3u32;
pub const DXVA_SCAN_METHOD_ZIG_ZAG: u32 = 0u32;
pub const DXVA_SLICE_CONTROL_BUFFER: u32 = 6u32;
pub const DXVA_STATUS_REPORTING_FUNCTION: u32 = 7u32;
pub const DXVA_USUAL_BLOCK_HEIGHT: u32 = 8u32;
pub const DXVA_USUAL_BLOCK_WIDTH: u32 = 8u32;
pub const DeinterlacePref9_BOB: VMR9DeinterlacePrefs = VMR9DeinterlacePrefs(2i32);
pub const DeinterlacePref9_Mask: VMR9DeinterlacePrefs = VMR9DeinterlacePrefs(7i32);
pub const DeinterlacePref9_NextBest: VMR9DeinterlacePrefs = VMR9DeinterlacePrefs(1i32);
pub const DeinterlacePref9_Weave: VMR9DeinterlacePrefs = VMR9DeinterlacePrefs(4i32);
pub const DeinterlacePref_BOB: VMRDeinterlacePrefs = VMRDeinterlacePrefs(2i32);
pub const DeinterlacePref_Mask: VMRDeinterlacePrefs = VMRDeinterlacePrefs(7i32);
pub const DeinterlacePref_NextBest: VMRDeinterlacePrefs = VMRDeinterlacePrefs(1i32);
pub const DeinterlacePref_Weave: VMRDeinterlacePrefs = VMRDeinterlacePrefs(4i32);
pub const DeinterlaceTech9_BOBLineReplicate: VMR9DeinterlaceTech = VMR9DeinterlaceTech(1i32);
pub const DeinterlaceTech9_BOBVerticalStretch: VMR9DeinterlaceTech = VMR9DeinterlaceTech(2i32);
pub const DeinterlaceTech9_EdgeFiltering: VMR9DeinterlaceTech = VMR9DeinterlaceTech(16i32);
pub const DeinterlaceTech9_FieldAdaptive: VMR9DeinterlaceTech = VMR9DeinterlaceTech(32i32);
pub const DeinterlaceTech9_MedianFiltering: VMR9DeinterlaceTech = VMR9DeinterlaceTech(4i32);
pub const DeinterlaceTech9_MotionVectorSteered: VMR9DeinterlaceTech = VMR9DeinterlaceTech(128i32);
pub const DeinterlaceTech9_PixelAdaptive: VMR9DeinterlaceTech = VMR9DeinterlaceTech(64i32);
pub const DeinterlaceTech9_Unknown: VMR9DeinterlaceTech = VMR9DeinterlaceTech(0i32);
pub const DeinterlaceTech_BOBLineReplicate: VMRDeinterlaceTech = VMRDeinterlaceTech(1i32);
pub const DeinterlaceTech_BOBVerticalStretch: VMRDeinterlaceTech = VMRDeinterlaceTech(2i32);
pub const DeinterlaceTech_EdgeFiltering: VMRDeinterlaceTech = VMRDeinterlaceTech(16i32);
pub const DeinterlaceTech_FieldAdaptive: VMRDeinterlaceTech = VMRDeinterlaceTech(32i32);
pub const DeinterlaceTech_MedianFiltering: VMRDeinterlaceTech = VMRDeinterlaceTech(4i32);
pub const DeinterlaceTech_MotionVectorSteered: VMRDeinterlaceTech = VMRDeinterlaceTech(128i32);
pub const DeinterlaceTech_PixelAdaptive: VMRDeinterlaceTech = VMRDeinterlaceTech(64i32);
pub const DeinterlaceTech_Unknown: VMRDeinterlaceTech = VMRDeinterlaceTech(0i32);
pub const DeviceClosed: UICloseReasonType = UICloseReasonType(3i32);
pub const Disabled: OUTPUT_STATE = OUTPUT_STATE(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct EALocationCodeType {
    pub LocationCodeScheme: LocationCodeSchemeType,
    pub state_code: u8,
    pub county_subdivision: u8,
    pub county_code: u16,
}
pub const EC_ACTIVATE: u32 = 19u32;
pub const EC_BANDWIDTHCHANGE: u32 = 72u32;
pub const EC_BUFFERING_DATA: u32 = 17u32;
pub const EC_BUILT: u32 = 768u32;
pub const EC_CLOCK_CHANGED: u32 = 13u32;
pub const EC_CLOCK_UNSET: u32 = 81u32;
pub const EC_CODECAPI_EVENT: u32 = 87u32;
pub const EC_COMPLETE: u32 = 1u32;
pub const EC_CONTENTPROPERTY_CHANGED: u32 = 71u32;
pub const EC_DEVICE_LOST: u32 = 31u32;
pub const EC_DISPLAY_CHANGED: u32 = 22u32;
pub const EC_DVDBASE: u32 = 256u32;
pub const EC_DVD_ANGLES_AVAILABLE: u32 = 275u32;
pub const EC_DVD_ANGLE_CHANGE: u32 = 262u32;
pub const EC_DVD_AUDIO_STREAM_CHANGE: u32 = 260u32;
pub const EC_DVD_BUTTON_AUTO_ACTIVATED: u32 = 277u32;
pub const EC_DVD_BUTTON_CHANGE: u32 = 263u32;
pub const EC_DVD_BeginNavigationCommands: u32 = 291u32;
pub const EC_DVD_CHAPTER_AUTOSTOP: u32 = 270u32;
pub const EC_DVD_CHAPTER_START: u32 = 259u32;
pub const EC_DVD_CMD_END: u32 = 279u32;
pub const EC_DVD_CMD_START: u32 = 278u32;
pub const EC_DVD_CURRENT_HMSF_TIME: u32 = 282u32;
pub const EC_DVD_CURRENT_TIME: u32 = 267u32;
pub const EC_DVD_DISC_EJECTED: u32 = 280u32;
pub const EC_DVD_DISC_INSERTED: u32 = 281u32;
pub const EC_DVD_DOMAIN_CHANGE: u32 = 257u32;
pub const EC_DVD_ERROR: u32 = 268u32;
pub const EC_DVD_GPRM_Change: u32 = 289u32;
pub const EC_DVD_KARAOKE_MODE: u32 = 283u32;
pub const EC_DVD_NO_FP_PGC: u32 = 271u32;
pub const EC_DVD_NavigationCommand: u32 = 292u32;
pub const EC_DVD_PARENTAL_LEVEL_CHANGE: u32 = 273u32;
pub const EC_DVD_PLAYBACK_RATE_CHANGE: u32 = 272u32;
pub const EC_DVD_PLAYBACK_STOPPED: u32 = 274u32;
pub const EC_DVD_PLAYPERIOD_AUTOSTOP: u32 = 276u32;
pub const EC_DVD_PROGRAM_CELL_CHANGE: u32 = 284u32;
pub const EC_DVD_PROGRAM_CHAIN_CHANGE: u32 = 286u32;
pub const EC_DVD_SPRM_Change: u32 = 290u32;
pub const EC_DVD_STILL_OFF: u32 = 266u32;
pub const EC_DVD_STILL_ON: u32 = 265u32;
pub const EC_DVD_SUBPICTURE_STREAM_CHANGE: u32 = 261u32;
pub const EC_DVD_TITLE_CHANGE: u32 = 258u32;
pub const EC_DVD_TITLE_SET_CHANGE: u32 = 285u32;
pub const EC_DVD_VALID_UOPS_CHANGE: u32 = 264u32;
pub const EC_DVD_VOBU_Offset: u32 = 287u32;
pub const EC_DVD_VOBU_Timestamp: u32 = 288u32;
pub const EC_DVD_WARNING: u32 = 269u32;
pub const EC_END_OF_SEGMENT: u32 = 28u32;
pub const EC_EOS_SOON: u32 = 70u32;
pub const EC_ERRORABORT: u32 = 3u32;
pub const EC_ERRORABORTEX: u32 = 69u32;
pub const EC_ERROR_STILLPLAYING: u32 = 8u32;
pub const EC_EXTDEVICE_MODE_CHANGE: u32 = 49u32;
pub const EC_FILE_CLOSED: u32 = 68u32;
pub const EC_FULLSCREEN_LOST: u32 = 18u32;
pub const EC_GRAPH_CHANGED: u32 = 80u32;
pub const EC_LENGTH_CHANGED: u32 = 30u32;
pub const EC_LOADSTATUS: u32 = 67u32;
pub const EC_MARKER_HIT: u32 = 66u32;
pub const EC_NEED_RESTART: u32 = 20u32;
pub const EC_NEW_PIN: u32 = 32u32;
pub const EC_NOTIFY_WINDOW: u32 = 25u32;
pub const EC_OLE_EVENT: u32 = 24u32;
pub const EC_OPENING_FILE: u32 = 16u32;
pub const EC_PALETTE_CHANGED: u32 = 9u32;
pub const EC_PAUSED: u32 = 14u32;
pub const EC_PLEASE_REOPEN: u32 = 64u32;
pub const EC_PREPROCESS_COMPLETE: u32 = 86u32;
pub const EC_PROCESSING_LATENCY: u32 = 33u32;
pub const EC_QUALITY_CHANGE: u32 = 11u32;
pub const EC_RENDER_FINISHED: u32 = 33u32;
pub const EC_REPAINT: u32 = 5u32;
pub const EC_SAMPLE_LATENCY: u32 = 34u32;
pub const EC_SAMPLE_NEEDED: u32 = 32u32;
pub const EC_SCRUB_TIME: u32 = 35u32;
pub const EC_SEGMENT_STARTED: u32 = 29u32;
pub const EC_SHUTTING_DOWN: u32 = 12u32;
pub const EC_SKIP_FRAMES: u32 = 37u32;
pub const EC_SNDDEV_IN_ERROR: u32 = 512u32;
pub const EC_SNDDEV_OUT_ERROR: u32 = 513u32;
pub const EC_SND_DEVICE_ERROR_BASE: u32 = 512u32;
pub const EC_STARVATION: u32 = 23u32;
pub const EC_STATE_CHANGE: u32 = 50u32;
pub const EC_STATUS: u32 = 65u32;
pub const EC_STEP_COMPLETE: u32 = 36u32;
pub const EC_STREAM_CONTROL_STARTED: u32 = 27u32;
pub const EC_STREAM_CONTROL_STOPPED: u32 = 26u32;
pub const EC_STREAM_ERROR_STILLPLAYING: u32 = 7u32;
pub const EC_STREAM_ERROR_STOPPED: u32 = 6u32;
pub const EC_SYSTEMBASE: u32 = 0u32;
pub const EC_TIME: u32 = 4u32;
pub const EC_TIMECODE_AVAILABLE: u32 = 48u32;
pub const EC_UNBUILT: u32 = 769u32;
pub const EC_USER: u32 = 32768u32;
pub const EC_USERABORT: u32 = 2u32;
pub const EC_VIDEOFRAMEREADY: u32 = 73u32;
pub const EC_VIDEO_SIZE_CHANGED: u32 = 10u32;
pub const EC_VMR_RECONNECTION_FAILED: u32 = 85u32;
pub const EC_VMR_RENDERDEVICE_SET: u32 = 83u32;
pub const EC_VMR_SURFACE_FLIPPED: u32 = 84u32;
pub const EC_WINDOW_DESTROYED: u32 = 21u32;
pub const EC_WMT_EVENT: u32 = 594u32;
pub const EC_WMT_EVENT_BASE: u32 = 593u32;
pub const EC_WMT_INDEX_EVENT: u32 = 593u32;
pub const E_PROP_ID_UNSUPPORTED: windows_core::HRESULT = windows_core::HRESULT(0x80070490_u32 as _);
pub const E_PROP_SET_UNSUPPORTED: windows_core::HRESULT = windows_core::HRESULT(0x80070492_u32 as _);
pub const Entitled: EntitlementType = EntitlementType(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct EntitlementType(pub i32);
pub const ErrorClosed: UICloseReasonType = UICloseReasonType(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct FECMethod(pub i32);
#[repr(C)]
#[derive(Clone, Debug, PartialEq)]
pub struct FILTER_INFO {
    pub achName: [u16; 128],
    pub pGraph: core::mem::ManuallyDrop<Option<IFilterGraph>>,
}
impl Default for FILTER_INFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct FILTER_STATE(pub i32);
pub const FORMAT_DVD_LPCMAudio: windows_core::GUID = windows_core::GUID::from_u128(0xe06d80e6_db46_11cf_b4d1_00805f6cbbea);
pub const FORMAT_DolbyAC3: windows_core::GUID = windows_core::GUID::from_u128(0xe06d80e4_db46_11cf_b4d1_00805f6cbbea);
pub const FORMAT_Image: windows_core::GUID = windows_core::GUID::from_u128(0x692fa379_d3e8_4651_b5b4_0b94b013eeaf);
pub const FORMAT_JPEGImage: windows_core::GUID = windows_core::GUID::from_u128(0x692fa379_d3e8_4651_b5b4_0b94b013eeaf);
pub const FORMAT_MPEG2Audio: windows_core::GUID = windows_core::GUID::from_u128(0xe06d80e5_db46_11cf_b4d1_00805f6cbbea);
pub const FORMAT_MPEG2Video: windows_core::GUID = windows_core::GUID::from_u128(0xe06d80e3_db46_11cf_b4d1_00805f6cbbea);
pub const FORMAT_MPEG2_VIDEO: windows_core::GUID = windows_core::GUID::from_u128(0xe06d80e3_db46_11cf_b4d1_00805f6cbbea);
pub const FORMAT_UVCH264Video: windows_core::GUID = windows_core::GUID::from_u128(0x2017be05_6629_4248_aaed_7e1a47bc9b9c);
pub const Famine: QualityMessageType = QualityMessageType(0i32);
pub const FilgraphManager: windows_core::GUID = windows_core::GUID::from_u128(0xe436ebb3_524f_11ce_9f53_0020af0ba770);
pub const Flood: QualityMessageType = QualityMessageType(1i32);
pub const GUID_TIME_MUSIC: windows_core::GUID = windows_core::GUID::from_u128(0x0574c49d_5b04_4b15_a542_ae282030117b);
pub const GUID_TIME_REFERENCE: windows_core::GUID = windows_core::GUID::from_u128(0x93ad712b_daa0_4ffe_bc81_b0ce500fcdd9);
pub const GUID_TIME_SAMPLES: windows_core::GUID = windows_core::GUID::from_u128(0xa8593d05_0c43_4984_9a63_97af9e02c4c0);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct GuardInterval(pub i32);
#[repr(C)]
#[cfg(feature = "Win32_Media_Audio")]
#[derive(Clone, Copy)]
pub struct HEAACWAVEFORMAT {
    pub wfInfo: HEAACWAVEINFO,
    pub pbAudioSpecificConfig: [u8; 1],
}
#[cfg(feature = "Win32_Media_Audio")]
impl Default for HEAACWAVEFORMAT {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[cfg(feature = "Win32_Media_Audio")]
#[derive(Clone, Copy, Default)]
pub struct HEAACWAVEINFO {
    pub wfx: super::Audio::WAVEFORMATEX,
    pub wPayloadType: u16,
    pub wAudioProfileLevelIndication: u16,
    pub wStructType: u16,
    pub wReserved1: u16,
    pub dwReserved2: u32,
}
pub const HEVC_TEMPORAL_VIDEO_SUBSET: MPEG2StreamType = MPEG2StreamType(37i32);
pub const HEVC_VIDEO_OR_TEMPORAL_VIDEO: MPEG2StreamType = MPEG2StreamType(36i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct HierarchyAlpha(pub i32);
windows_core::imp::define_interface!(IAMAnalogVideoDecoder, IAMAnalogVideoDecoder_Vtbl, 0xc6e13350_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMAnalogVideoDecoder, windows_core::IUnknown);
impl IAMAnalogVideoDecoder {
    pub unsafe fn AvailableTVFormats(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvailableTVFormats)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTVFormat(&self, lanalogvideostandard: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTVFormat)(windows_core::Interface::as_raw(self), lanalogvideostandard).ok() }
    }
    pub unsafe fn TVFormat(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TVFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn HorizontalLocked(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).HorizontalLocked)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetVCRHorizontalLocking(&self, lvcrhorizontallocking: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVCRHorizontalLocking)(windows_core::Interface::as_raw(self), lvcrhorizontallocking).ok() }
    }
    pub unsafe fn VCRHorizontalLocking(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VCRHorizontalLocking)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn NumberOfLines(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).NumberOfLines)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOutputEnable(&self, loutputenable: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputEnable)(windows_core::Interface::as_raw(self), loutputenable).ok() }
    }
    pub unsafe fn OutputEnable(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).OutputEnable)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMAnalogVideoDecoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AvailableTVFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTVFormat: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub TVFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub HorizontalLocked: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetVCRHorizontalLocking: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub VCRHorizontalLocking: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub NumberOfLines: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetOutputEnable: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub OutputEnable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMAnalogVideoDecoder_Impl: windows_core::IUnknownImpl {
    fn AvailableTVFormats(&self) -> windows_core::Result<i32>;
    fn SetTVFormat(&self, lanalogvideostandard: i32) -> windows_core::Result<()>;
    fn TVFormat(&self) -> windows_core::Result<i32>;
    fn HorizontalLocked(&self) -> windows_core::Result<i32>;
    fn SetVCRHorizontalLocking(&self, lvcrhorizontallocking: i32) -> windows_core::Result<()>;
    fn VCRHorizontalLocking(&self) -> windows_core::Result<i32>;
    fn NumberOfLines(&self) -> windows_core::Result<i32>;
    fn SetOutputEnable(&self, loutputenable: i32) -> windows_core::Result<()>;
    fn OutputEnable(&self) -> windows_core::Result<i32>;
}
impl IAMAnalogVideoDecoder_Vtbl {
    pub const fn new<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AvailableTVFormats<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lanalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::AvailableTVFormats(this) {
                    Ok(ok__) => {
                        lanalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTVFormat<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lanalogvideostandard: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoDecoder_Impl::SetTVFormat(this, core::mem::transmute_copy(&lanalogvideostandard)).into()
            }
        }
        unsafe extern "system" fn TVFormat<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::TVFormat(this) {
                    Ok(ok__) => {
                        planalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn HorizontalLocked<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pllocked: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::HorizontalLocked(this) {
                    Ok(ok__) => {
                        pllocked.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetVCRHorizontalLocking<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lvcrhorizontallocking: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoDecoder_Impl::SetVCRHorizontalLocking(this, core::mem::transmute_copy(&lvcrhorizontallocking)).into()
            }
        }
        unsafe extern "system" fn VCRHorizontalLocking<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plvcrhorizontallocking: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::VCRHorizontalLocking(this) {
                    Ok(ok__) => {
                        plvcrhorizontallocking.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn NumberOfLines<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plnumberoflines: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::NumberOfLines(this) {
                    Ok(ok__) => {
                        plnumberoflines.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputEnable<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, loutputenable: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoDecoder_Impl::SetOutputEnable(this, core::mem::transmute_copy(&loutputenable)).into()
            }
        }
        unsafe extern "system" fn OutputEnable<Identity: IAMAnalogVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ploutputenable: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoDecoder_Impl::OutputEnable(this) {
                    Ok(ok__) => {
                        ploutputenable.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Identity, OFFSET>,
            SetTVFormat: SetTVFormat::<Identity, OFFSET>,
            TVFormat: TVFormat::<Identity, OFFSET>,
            HorizontalLocked: HorizontalLocked::<Identity, OFFSET>,
            SetVCRHorizontalLocking: SetVCRHorizontalLocking::<Identity, OFFSET>,
            VCRHorizontalLocking: VCRHorizontalLocking::<Identity, OFFSET>,
            NumberOfLines: NumberOfLines::<Identity, OFFSET>,
            SetOutputEnable: SetOutputEnable::<Identity, OFFSET>,
            OutputEnable: OutputEnable::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMAnalogVideoDecoder as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMAnalogVideoDecoder {}
windows_core::imp::define_interface!(IAMAnalogVideoEncoder, IAMAnalogVideoEncoder_Vtbl, 0xc6e133b0_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMAnalogVideoEncoder, windows_core::IUnknown);
impl IAMAnalogVideoEncoder {
    pub unsafe fn AvailableTVFormats(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvailableTVFormats)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTVFormat(&self, lanalogvideostandard: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTVFormat)(windows_core::Interface::as_raw(self), lanalogvideostandard).ok() }
    }
    pub unsafe fn TVFormat(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TVFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCopyProtection(&self, lvideocopyprotection: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCopyProtection)(windows_core::Interface::as_raw(self), lvideocopyprotection).ok() }
    }
    pub unsafe fn CopyProtection(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CopyProtection)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCCEnable(&self, lccenable: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCCEnable)(windows_core::Interface::as_raw(self), lccenable).ok() }
    }
    pub unsafe fn CCEnable(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CCEnable)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMAnalogVideoEncoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AvailableTVFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTVFormat: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub TVFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetCopyProtection: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub CopyProtection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetCCEnable: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub CCEnable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMAnalogVideoEncoder_Impl: windows_core::IUnknownImpl {
    fn AvailableTVFormats(&self) -> windows_core::Result<i32>;
    fn SetTVFormat(&self, lanalogvideostandard: i32) -> windows_core::Result<()>;
    fn TVFormat(&self) -> windows_core::Result<i32>;
    fn SetCopyProtection(&self, lvideocopyprotection: i32) -> windows_core::Result<()>;
    fn CopyProtection(&self) -> windows_core::Result<i32>;
    fn SetCCEnable(&self, lccenable: i32) -> windows_core::Result<()>;
    fn CCEnable(&self) -> windows_core::Result<i32>;
}
impl IAMAnalogVideoEncoder_Vtbl {
    pub const fn new<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AvailableTVFormats<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lanalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoEncoder_Impl::AvailableTVFormats(this) {
                    Ok(ok__) => {
                        lanalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTVFormat<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lanalogvideostandard: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoEncoder_Impl::SetTVFormat(this, core::mem::transmute_copy(&lanalogvideostandard)).into()
            }
        }
        unsafe extern "system" fn TVFormat<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoEncoder_Impl::TVFormat(this) {
                    Ok(ok__) => {
                        planalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCopyProtection<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lvideocopyprotection: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoEncoder_Impl::SetCopyProtection(this, core::mem::transmute_copy(&lvideocopyprotection)).into()
            }
        }
        unsafe extern "system" fn CopyProtection<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lvideocopyprotection: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoEncoder_Impl::CopyProtection(this) {
                    Ok(ok__) => {
                        lvideocopyprotection.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCCEnable<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lccenable: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAnalogVideoEncoder_Impl::SetCCEnable(this, core::mem::transmute_copy(&lccenable)).into()
            }
        }
        unsafe extern "system" fn CCEnable<Identity: IAMAnalogVideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lccenable: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAnalogVideoEncoder_Impl::CCEnable(this) {
                    Ok(ok__) => {
                        lccenable.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Identity, OFFSET>,
            SetTVFormat: SetTVFormat::<Identity, OFFSET>,
            TVFormat: TVFormat::<Identity, OFFSET>,
            SetCopyProtection: SetCopyProtection::<Identity, OFFSET>,
            CopyProtection: CopyProtection::<Identity, OFFSET>,
            SetCCEnable: SetCCEnable::<Identity, OFFSET>,
            CCEnable: CCEnable::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMAnalogVideoEncoder as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMAnalogVideoEncoder {}
windows_core::imp::define_interface!(IAMAsyncReaderTimestampScaling, IAMAsyncReaderTimestampScaling_Vtbl, 0xcf7b26fc_9a00_485b_8147_3e789d5e8f67);
windows_core::imp::interface_hierarchy!(IAMAsyncReaderTimestampScaling, windows_core::IUnknown);
impl IAMAsyncReaderTimestampScaling {
    pub unsafe fn GetTimestampMode(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTimestampMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTimestampMode(&self, fraw: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTimestampMode)(windows_core::Interface::as_raw(self), fraw.into()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMAsyncReaderTimestampScaling_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetTimestampMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetTimestampMode: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IAMAsyncReaderTimestampScaling_Impl: windows_core::IUnknownImpl {
    fn GetTimestampMode(&self) -> windows_core::Result<windows_core::BOOL>;
    fn SetTimestampMode(&self, fraw: windows_core::BOOL) -> windows_core::Result<()>;
}
impl IAMAsyncReaderTimestampScaling_Vtbl {
    pub const fn new<Identity: IAMAsyncReaderTimestampScaling_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetTimestampMode<Identity: IAMAsyncReaderTimestampScaling_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfraw: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAsyncReaderTimestampScaling_Impl::GetTimestampMode(this) {
                    Ok(ok__) => {
                        pfraw.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTimestampMode<Identity: IAMAsyncReaderTimestampScaling_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fraw: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAsyncReaderTimestampScaling_Impl::SetTimestampMode(this, core::mem::transmute_copy(&fraw)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetTimestampMode: GetTimestampMode::<Identity, OFFSET>,
            SetTimestampMode: SetTimestampMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMAsyncReaderTimestampScaling as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMAsyncReaderTimestampScaling {}
windows_core::imp::define_interface!(IAMAudioInputMixer, IAMAudioInputMixer_Vtbl, 0x54c39221_8380_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMAudioInputMixer, windows_core::IUnknown);
impl IAMAudioInputMixer {
    pub unsafe fn SetEnable(&self, fenable: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnable)(windows_core::Interface::as_raw(self), fenable.into()).ok() }
    }
    pub unsafe fn Enable(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Enable)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMono(&self, fmono: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMono)(windows_core::Interface::as_raw(self), fmono.into()).ok() }
    }
    pub unsafe fn Mono(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Mono)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMixLevel(&self, level: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMixLevel)(windows_core::Interface::as_raw(self), level).ok() }
    }
    pub unsafe fn MixLevel(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).MixLevel)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetPan(&self, pan: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPan)(windows_core::Interface::as_raw(self), pan).ok() }
    }
    pub unsafe fn Pan(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Pan)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetLoudness(&self, floudness: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLoudness)(windows_core::Interface::as_raw(self), floudness.into()).ok() }
    }
    pub unsafe fn Loudness(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Loudness)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTreble(&self, treble: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTreble)(windows_core::Interface::as_raw(self), treble).ok() }
    }
    pub unsafe fn Treble(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Treble)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn TrebleRange(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TrebleRange)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBass(&self, bass: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBass)(windows_core::Interface::as_raw(self), bass).ok() }
    }
    pub unsafe fn Bass(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Bass)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn BassRange(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).BassRange)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMAudioInputMixer_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetEnable: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub Enable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetMono: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub Mono: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetMixLevel: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub MixLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetPan: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Pan: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetLoudness: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub Loudness: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetTreble: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Treble: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub TrebleRange: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetBass: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Bass: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub BassRange: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
}
pub trait IAMAudioInputMixer_Impl: windows_core::IUnknownImpl {
    fn SetEnable(&self, fenable: windows_core::BOOL) -> windows_core::Result<()>;
    fn Enable(&self) -> windows_core::Result<windows_core::BOOL>;
    fn SetMono(&self, fmono: windows_core::BOOL) -> windows_core::Result<()>;
    fn Mono(&self) -> windows_core::Result<windows_core::BOOL>;
    fn SetMixLevel(&self, level: f64) -> windows_core::Result<()>;
    fn MixLevel(&self) -> windows_core::Result<f64>;
    fn SetPan(&self, pan: f64) -> windows_core::Result<()>;
    fn Pan(&self) -> windows_core::Result<f64>;
    fn SetLoudness(&self, floudness: windows_core::BOOL) -> windows_core::Result<()>;
    fn Loudness(&self) -> windows_core::Result<windows_core::BOOL>;
    fn SetTreble(&self, treble: f64) -> windows_core::Result<()>;
    fn Treble(&self) -> windows_core::Result<f64>;
    fn TrebleRange(&self) -> windows_core::Result<f64>;
    fn SetBass(&self, bass: f64) -> windows_core::Result<()>;
    fn Bass(&self) -> windows_core::Result<f64>;
    fn BassRange(&self) -> windows_core::Result<f64>;
}
impl IAMAudioInputMixer_Vtbl {
    pub const fn new<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetEnable<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetEnable(this, core::mem::transmute_copy(&fenable)).into()
            }
        }
        unsafe extern "system" fn Enable<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfenable: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Enable(this) {
                    Ok(ok__) => {
                        pfenable.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMono<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fmono: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetMono(this, core::mem::transmute_copy(&fmono)).into()
            }
        }
        unsafe extern "system" fn Mono<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfmono: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Mono(this) {
                    Ok(ok__) => {
                        pfmono.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMixLevel<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, level: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetMixLevel(this, core::mem::transmute_copy(&level)).into()
            }
        }
        unsafe extern "system" fn MixLevel<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plevel: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::MixLevel(this) {
                    Ok(ok__) => {
                        plevel.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPan<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pan: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetPan(this, core::mem::transmute_copy(&pan)).into()
            }
        }
        unsafe extern "system" fn Pan<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppan: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Pan(this) {
                    Ok(ok__) => {
                        ppan.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLoudness<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, floudness: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetLoudness(this, core::mem::transmute_copy(&floudness)).into()
            }
        }
        unsafe extern "system" fn Loudness<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfloudness: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Loudness(this) {
                    Ok(ok__) => {
                        pfloudness.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTreble<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, treble: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetTreble(this, core::mem::transmute_copy(&treble)).into()
            }
        }
        unsafe extern "system" fn Treble<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptreble: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Treble(this) {
                    Ok(ok__) => {
                        ptreble.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TrebleRange<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prange: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::TrebleRange(this) {
                    Ok(ok__) => {
                        prange.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBass<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bass: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioInputMixer_Impl::SetBass(this, core::mem::transmute_copy(&bass)).into()
            }
        }
        unsafe extern "system" fn Bass<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbass: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::Bass(this) {
                    Ok(ok__) => {
                        pbass.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn BassRange<Identity: IAMAudioInputMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prange: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMAudioInputMixer_Impl::BassRange(this) {
                    Ok(ok__) => {
                        prange.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetEnable: SetEnable::<Identity, OFFSET>,
            Enable: Enable::<Identity, OFFSET>,
            SetMono: SetMono::<Identity, OFFSET>,
            Mono: Mono::<Identity, OFFSET>,
            SetMixLevel: SetMixLevel::<Identity, OFFSET>,
            MixLevel: MixLevel::<Identity, OFFSET>,
            SetPan: SetPan::<Identity, OFFSET>,
            Pan: Pan::<Identity, OFFSET>,
            SetLoudness: SetLoudness::<Identity, OFFSET>,
            Loudness: Loudness::<Identity, OFFSET>,
            SetTreble: SetTreble::<Identity, OFFSET>,
            Treble: Treble::<Identity, OFFSET>,
            TrebleRange: TrebleRange::<Identity, OFFSET>,
            SetBass: SetBass::<Identity, OFFSET>,
            Bass: Bass::<Identity, OFFSET>,
            BassRange: BassRange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMAudioInputMixer as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMAudioInputMixer {}
windows_core::imp::define_interface!(IAMAudioRendererStats, IAMAudioRendererStats_Vtbl, 0x22320cb2_d41a_11d2_bf7c_d7cb9df0bf93);
windows_core::imp::interface_hierarchy!(IAMAudioRendererStats, windows_core::IUnknown);
impl IAMAudioRendererStats {
    pub unsafe fn GetStatParam(&self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStatParam)(windows_core::Interface::as_raw(self), dwparam, pdwparam1 as _, pdwparam2 as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMAudioRendererStats_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetStatParam: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMAudioRendererStats_Impl: windows_core::IUnknownImpl {
    fn GetStatParam(&self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::Result<()>;
}
impl IAMAudioRendererStats_Vtbl {
    pub const fn new<Identity: IAMAudioRendererStats_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetStatParam<Identity: IAMAudioRendererStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMAudioRendererStats_Impl::GetStatParam(this, core::mem::transmute_copy(&dwparam), core::mem::transmute_copy(&pdwparam1), core::mem::transmute_copy(&pdwparam2)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetStatParam: GetStatParam::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMAudioRendererStats as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMAudioRendererStats {}
windows_core::imp::define_interface!(IAMBufferNegotiation, IAMBufferNegotiation_Vtbl, 0x56ed71a0_af5f_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMBufferNegotiation, windows_core::IUnknown);
impl IAMBufferNegotiation {
    pub unsafe fn SuggestAllocatorProperties(&self, pprop: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SuggestAllocatorProperties)(windows_core::Interface::as_raw(self), pprop).ok() }
    }
    pub unsafe fn GetAllocatorProperties(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllocatorProperties)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMBufferNegotiation_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SuggestAllocatorProperties: unsafe extern "system" fn(*mut core::ffi::c_void, *const ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
    pub GetAllocatorProperties: unsafe extern "system" fn(*mut core::ffi::c_void, *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
}
pub trait IAMBufferNegotiation_Impl: windows_core::IUnknownImpl {
    fn SuggestAllocatorProperties(&self, pprop: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<()>;
    fn GetAllocatorProperties(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES>;
}
impl IAMBufferNegotiation_Vtbl {
    pub const fn new<Identity: IAMBufferNegotiation_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SuggestAllocatorProperties<Identity: IAMBufferNegotiation_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprop: *const ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMBufferNegotiation_Impl::SuggestAllocatorProperties(this, core::mem::transmute_copy(&pprop)).into()
            }
        }
        unsafe extern "system" fn GetAllocatorProperties<Identity: IAMBufferNegotiation_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprop: *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMBufferNegotiation_Impl::GetAllocatorProperties(this) {
                    Ok(ok__) => {
                        pprop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SuggestAllocatorProperties: SuggestAllocatorProperties::<Identity, OFFSET>,
            GetAllocatorProperties: GetAllocatorProperties::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMBufferNegotiation as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMBufferNegotiation {}
windows_core::imp::define_interface!(IAMCameraControl, IAMCameraControl_Vtbl, 0xc6e13370_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMCameraControl, windows_core::IUnknown);
impl IAMCameraControl {
    pub unsafe fn GetRange(&self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRange)(windows_core::Interface::as_raw(self), property, pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflags as _).ok() }
    }
    pub unsafe fn Set(&self, property: i32, lvalue: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Set)(windows_core::Interface::as_raw(self), property, lvalue, flags).ok() }
    }
    pub unsafe fn Get(&self, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Get)(windows_core::Interface::as_raw(self), property, lvalue as _, flags as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMCameraControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetRange: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub Set: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub Get: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMCameraControl_Impl: windows_core::IUnknownImpl {
    fn GetRange(&self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::Result<()>;
    fn Set(&self, property: i32, lvalue: i32, flags: i32) -> windows_core::Result<()>;
    fn Get(&self, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::Result<()>;
}
impl IAMCameraControl_Vtbl {
    pub const fn new<Identity: IAMCameraControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetRange<Identity: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCameraControl_Impl::GetRange(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflags)).into()
            }
        }
        unsafe extern "system" fn Set<Identity: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCameraControl_Impl::Set(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&lvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn Get<Identity: IAMCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCameraControl_Impl::Get(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&lvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRange: GetRange::<Identity, OFFSET>,
            Set: Set::<Identity, OFFSET>,
            Get: Get::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMCameraControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMCameraControl {}
windows_core::imp::define_interface!(IAMCertifiedOutputProtection, IAMCertifiedOutputProtection_Vtbl, 0x6feded3e_0ff1_4901_a2f1_43f7012c8515);
windows_core::imp::interface_hierarchy!(IAMCertifiedOutputProtection, windows_core::IUnknown);
impl IAMCertifiedOutputProtection {
    pub unsafe fn KeyExchange(&self, prandom: *mut windows_core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).KeyExchange)(windows_core::Interface::as_raw(self), prandom as _, varlencertgh as _, pdwlengthcertgh as _).ok() }
    }
    pub unsafe fn SessionSequenceStart(&self, psig: *const AMCOPPSignature) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SessionSequenceStart)(windows_core::Interface::as_raw(self), psig).ok() }
    }
    pub unsafe fn ProtectionCommand(&self, cmd: *const AMCOPPCommand) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ProtectionCommand)(windows_core::Interface::as_raw(self), cmd).ok() }
    }
    pub unsafe fn ProtectionStatus(&self, pstatusinput: *const AMCOPPStatusInput, pstatusoutput: *mut AMCOPPStatusOutput) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ProtectionStatus)(windows_core::Interface::as_raw(self), pstatusinput, pstatusoutput as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMCertifiedOutputProtection_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub KeyExchange: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID, *mut *mut u8, *mut u32) -> windows_core::HRESULT,
    pub SessionSequenceStart: unsafe extern "system" fn(*mut core::ffi::c_void, *const AMCOPPSignature) -> windows_core::HRESULT,
    pub ProtectionCommand: unsafe extern "system" fn(*mut core::ffi::c_void, *const AMCOPPCommand) -> windows_core::HRESULT,
    pub ProtectionStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *const AMCOPPStatusInput, *mut AMCOPPStatusOutput) -> windows_core::HRESULT,
}
pub trait IAMCertifiedOutputProtection_Impl: windows_core::IUnknownImpl {
    fn KeyExchange(&self, prandom: *mut windows_core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> windows_core::Result<()>;
    fn SessionSequenceStart(&self, psig: *const AMCOPPSignature) -> windows_core::Result<()>;
    fn ProtectionCommand(&self, cmd: *const AMCOPPCommand) -> windows_core::Result<()>;
    fn ProtectionStatus(&self, pstatusinput: *const AMCOPPStatusInput, pstatusoutput: *mut AMCOPPStatusOutput) -> windows_core::Result<()>;
}
impl IAMCertifiedOutputProtection_Vtbl {
    pub const fn new<Identity: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn KeyExchange<Identity: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prandom: *mut windows_core::GUID, varlencertgh: *mut *mut u8, pdwlengthcertgh: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCertifiedOutputProtection_Impl::KeyExchange(this, core::mem::transmute_copy(&prandom), core::mem::transmute_copy(&varlencertgh), core::mem::transmute_copy(&pdwlengthcertgh)).into()
            }
        }
        unsafe extern "system" fn SessionSequenceStart<Identity: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psig: *const AMCOPPSignature) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCertifiedOutputProtection_Impl::SessionSequenceStart(this, core::mem::transmute_copy(&psig)).into()
            }
        }
        unsafe extern "system" fn ProtectionCommand<Identity: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cmd: *const AMCOPPCommand) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCertifiedOutputProtection_Impl::ProtectionCommand(this, core::mem::transmute_copy(&cmd)).into()
            }
        }
        unsafe extern "system" fn ProtectionStatus<Identity: IAMCertifiedOutputProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatusinput: *const AMCOPPStatusInput, pstatusoutput: *mut AMCOPPStatusOutput) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCertifiedOutputProtection_Impl::ProtectionStatus(this, core::mem::transmute_copy(&pstatusinput), core::mem::transmute_copy(&pstatusoutput)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            KeyExchange: KeyExchange::<Identity, OFFSET>,
            SessionSequenceStart: SessionSequenceStart::<Identity, OFFSET>,
            ProtectionCommand: ProtectionCommand::<Identity, OFFSET>,
            ProtectionStatus: ProtectionStatus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMCertifiedOutputProtection as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMCertifiedOutputProtection {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMChannelInfo, IAMChannelInfo_Vtbl, 0xfa2aa8f2_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMChannelInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMChannelInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMChannelInfo {
    pub unsafe fn ChannelName(&self, pbstrchannelname: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChannelName)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrchannelname)).ok() }
    }
    pub unsafe fn ChannelDescription(&self, pbstrchanneldescription: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChannelDescription)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrchanneldescription)).ok() }
    }
    pub unsafe fn ChannelURL(&self, pbstrchannelurl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChannelURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrchannelurl)).ok() }
    }
    pub unsafe fn ContactAddress(&self, pbstrcontactaddress: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ContactAddress)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrcontactaddress)).ok() }
    }
    pub unsafe fn ContactPhone(&self, pbstrcontactphone: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ContactPhone)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrcontactphone)).ok() }
    }
    pub unsafe fn ContactEmail(&self, pbstrcontactemail: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ContactEmail)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrcontactemail)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMChannelInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub ChannelName: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ChannelDescription: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ChannelURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ContactAddress: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ContactPhone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ContactEmail: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMChannelInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn ChannelName(&self, pbstrchannelname: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ChannelDescription(&self, pbstrchanneldescription: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ChannelURL(&self, pbstrchannelurl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ContactAddress(&self, pbstrcontactaddress: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ContactPhone(&self, pbstrcontactphone: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ContactEmail(&self, pbstrcontactemail: *mut windows_core::BSTR) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMChannelInfo_Vtbl {
    pub const fn new<Identity: IAMChannelInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ChannelName<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrchannelname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ChannelName(this, core::mem::transmute_copy(&pbstrchannelname)).into()
            }
        }
        unsafe extern "system" fn ChannelDescription<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrchanneldescription: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ChannelDescription(this, core::mem::transmute_copy(&pbstrchanneldescription)).into()
            }
        }
        unsafe extern "system" fn ChannelURL<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrchannelurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ChannelURL(this, core::mem::transmute_copy(&pbstrchannelurl)).into()
            }
        }
        unsafe extern "system" fn ContactAddress<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrcontactaddress: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ContactAddress(this, core::mem::transmute_copy(&pbstrcontactaddress)).into()
            }
        }
        unsafe extern "system" fn ContactPhone<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrcontactphone: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ContactPhone(this, core::mem::transmute_copy(&pbstrcontactphone)).into()
            }
        }
        unsafe extern "system" fn ContactEmail<Identity: IAMChannelInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrcontactemail: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMChannelInfo_Impl::ContactEmail(this, core::mem::transmute_copy(&pbstrcontactemail)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            ChannelName: ChannelName::<Identity, OFFSET>,
            ChannelDescription: ChannelDescription::<Identity, OFFSET>,
            ChannelURL: ChannelURL::<Identity, OFFSET>,
            ContactAddress: ContactAddress::<Identity, OFFSET>,
            ContactPhone: ContactPhone::<Identity, OFFSET>,
            ContactEmail: ContactEmail::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMChannelInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMChannelInfo {}
windows_core::imp::define_interface!(IAMClockAdjust, IAMClockAdjust_Vtbl, 0x4d5466b0_a49c_11d1_abe8_00a0c905f375);
windows_core::imp::interface_hierarchy!(IAMClockAdjust, windows_core::IUnknown);
impl IAMClockAdjust {
    pub unsafe fn SetClockDelta(&self, rtdelta: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetClockDelta)(windows_core::Interface::as_raw(self), rtdelta).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMClockAdjust_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetClockDelta: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
pub trait IAMClockAdjust_Impl: windows_core::IUnknownImpl {
    fn SetClockDelta(&self, rtdelta: i64) -> windows_core::Result<()>;
}
impl IAMClockAdjust_Vtbl {
    pub const fn new<Identity: IAMClockAdjust_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetClockDelta<Identity: IAMClockAdjust_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rtdelta: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMClockAdjust_Impl::SetClockDelta(this, core::mem::transmute_copy(&rtdelta)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetClockDelta: SetClockDelta::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMClockAdjust as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMClockAdjust {}
windows_core::imp::define_interface!(IAMClockSlave, IAMClockSlave_Vtbl, 0x9fd52741_176d_4b36_8f51_ca8f933223be);
windows_core::imp::interface_hierarchy!(IAMClockSlave, windows_core::IUnknown);
impl IAMClockSlave {
    pub unsafe fn SetErrorTolerance(&self, dwtolerance: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetErrorTolerance)(windows_core::Interface::as_raw(self), dwtolerance).ok() }
    }
    pub unsafe fn GetErrorTolerance(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetErrorTolerance)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMClockSlave_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetErrorTolerance: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetErrorTolerance: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMClockSlave_Impl: windows_core::IUnknownImpl {
    fn SetErrorTolerance(&self, dwtolerance: u32) -> windows_core::Result<()>;
    fn GetErrorTolerance(&self) -> windows_core::Result<u32>;
}
impl IAMClockSlave_Vtbl {
    pub const fn new<Identity: IAMClockSlave_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetErrorTolerance<Identity: IAMClockSlave_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtolerance: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMClockSlave_Impl::SetErrorTolerance(this, core::mem::transmute_copy(&dwtolerance)).into()
            }
        }
        unsafe extern "system" fn GetErrorTolerance<Identity: IAMClockSlave_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwtolerance: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMClockSlave_Impl::GetErrorTolerance(this) {
                    Ok(ok__) => {
                        pdwtolerance.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetErrorTolerance: SetErrorTolerance::<Identity, OFFSET>,
            GetErrorTolerance: GetErrorTolerance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMClockSlave as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMClockSlave {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMCollection, IAMCollection_Vtbl, 0x56a868b9_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMCollection {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMCollection, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMCollection {
    pub unsafe fn Count(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Count)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Item(&self, litem: i32) -> windows_core::Result<windows_core::IUnknown> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Item)(windows_core::Interface::as_raw(self), litem, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn _NewEnum(&self) -> windows_core::Result<windows_core::IUnknown> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self)._NewEnum)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMCollection_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Count: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Item: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub _NewEnum: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMCollection_Impl: super::super::System::Com::IDispatch_Impl {
    fn Count(&self) -> windows_core::Result<i32>;
    fn Item(&self, litem: i32) -> windows_core::Result<windows_core::IUnknown>;
    fn _NewEnum(&self) -> windows_core::Result<windows_core::IUnknown>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMCollection_Vtbl {
    pub const fn new<Identity: IAMCollection_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Count<Identity: IAMCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plcount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMCollection_Impl::Count(this) {
                    Ok(ok__) => {
                        plcount.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Item<Identity: IAMCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, litem: i32, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMCollection_Impl::Item(this, core::mem::transmute_copy(&litem)) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn _NewEnum<Identity: IAMCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMCollection_Impl::_NewEnum(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Count: Count::<Identity, OFFSET>,
            Item: Item::<Identity, OFFSET>,
            _NewEnum: _NewEnum::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMCollection as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMCollection {}
windows_core::imp::define_interface!(IAMCopyCaptureFileProgress, IAMCopyCaptureFileProgress_Vtbl, 0x670d1d20_a068_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMCopyCaptureFileProgress, windows_core::IUnknown);
impl IAMCopyCaptureFileProgress {
    pub unsafe fn Progress(&self, iprogress: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Progress)(windows_core::Interface::as_raw(self), iprogress).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMCopyCaptureFileProgress_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Progress: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IAMCopyCaptureFileProgress_Impl: windows_core::IUnknownImpl {
    fn Progress(&self, iprogress: i32) -> windows_core::Result<()>;
}
impl IAMCopyCaptureFileProgress_Vtbl {
    pub const fn new<Identity: IAMCopyCaptureFileProgress_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Progress<Identity: IAMCopyCaptureFileProgress_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, iprogress: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCopyCaptureFileProgress_Impl::Progress(this, core::mem::transmute_copy(&iprogress)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Progress: Progress::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMCopyCaptureFileProgress as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMCopyCaptureFileProgress {}
windows_core::imp::define_interface!(IAMCrossbar, IAMCrossbar_Vtbl, 0xc6e13380_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMCrossbar, windows_core::IUnknown);
impl IAMCrossbar {
    pub unsafe fn get_PinCounts(&self, outputpincount: *mut i32, inputpincount: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PinCounts)(windows_core::Interface::as_raw(self), outputpincount as _, inputpincount as _).ok() }
    }
    pub unsafe fn CanRoute(&self, outputpinindex: i32, inputpinindex: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CanRoute)(windows_core::Interface::as_raw(self), outputpinindex, inputpinindex).ok() }
    }
    pub unsafe fn Route(&self, outputpinindex: i32, inputpinindex: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Route)(windows_core::Interface::as_raw(self), outputpinindex, inputpinindex).ok() }
    }
    pub unsafe fn get_IsRoutedTo(&self, outputpinindex: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).get_IsRoutedTo)(windows_core::Interface::as_raw(self), outputpinindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn get_CrossbarPinInfo(&self, isinputpin: bool, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_CrossbarPinInfo)(windows_core::Interface::as_raw(self), isinputpin.into(), pinindex, pinindexrelated as _, physicaltype as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMCrossbar_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_PinCounts: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub CanRoute: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub Route: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub get_IsRoutedTo: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub get_CrossbarPinInfo: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL, i32, *mut i32, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMCrossbar_Impl: windows_core::IUnknownImpl {
    fn get_PinCounts(&self, outputpincount: *mut i32, inputpincount: *mut i32) -> windows_core::Result<()>;
    fn CanRoute(&self, outputpinindex: i32, inputpinindex: i32) -> windows_core::Result<()>;
    fn Route(&self, outputpinindex: i32, inputpinindex: i32) -> windows_core::Result<()>;
    fn get_IsRoutedTo(&self, outputpinindex: i32) -> windows_core::Result<i32>;
    fn get_CrossbarPinInfo(&self, isinputpin: windows_core::BOOL, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> windows_core::Result<()>;
}
impl IAMCrossbar_Vtbl {
    pub const fn new<Identity: IAMCrossbar_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_PinCounts<Identity: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputpincount: *mut i32, inputpincount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCrossbar_Impl::get_PinCounts(this, core::mem::transmute_copy(&outputpincount), core::mem::transmute_copy(&inputpincount)).into()
            }
        }
        unsafe extern "system" fn CanRoute<Identity: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCrossbar_Impl::CanRoute(this, core::mem::transmute_copy(&outputpinindex), core::mem::transmute_copy(&inputpinindex)).into()
            }
        }
        unsafe extern "system" fn Route<Identity: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputpinindex: i32, inputpinindex: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCrossbar_Impl::Route(this, core::mem::transmute_copy(&outputpinindex), core::mem::transmute_copy(&inputpinindex)).into()
            }
        }
        unsafe extern "system" fn get_IsRoutedTo<Identity: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputpinindex: i32, inputpinindex: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMCrossbar_Impl::get_IsRoutedTo(this, core::mem::transmute_copy(&outputpinindex)) {
                    Ok(ok__) => {
                        inputpinindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn get_CrossbarPinInfo<Identity: IAMCrossbar_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, isinputpin: windows_core::BOOL, pinindex: i32, pinindexrelated: *mut i32, physicaltype: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMCrossbar_Impl::get_CrossbarPinInfo(this, core::mem::transmute_copy(&isinputpin), core::mem::transmute_copy(&pinindex), core::mem::transmute_copy(&pinindexrelated), core::mem::transmute_copy(&physicaltype)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_PinCounts: get_PinCounts::<Identity, OFFSET>,
            CanRoute: CanRoute::<Identity, OFFSET>,
            Route: Route::<Identity, OFFSET>,
            get_IsRoutedTo: get_IsRoutedTo::<Identity, OFFSET>,
            get_CrossbarPinInfo: get_CrossbarPinInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMCrossbar as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMCrossbar {}
windows_core::imp::define_interface!(IAMDecoderCaps, IAMDecoderCaps_Vtbl, 0xc0dff467_d499_4986_972b_e1d9090fa941);
windows_core::imp::interface_hierarchy!(IAMDecoderCaps, windows_core::IUnknown);
impl IAMDecoderCaps {
    pub unsafe fn GetDecoderCaps(&self, dwcapindex: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDecoderCaps)(windows_core::Interface::as_raw(self), dwcapindex, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDecoderCaps_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetDecoderCaps: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMDecoderCaps_Impl: windows_core::IUnknownImpl {
    fn GetDecoderCaps(&self, dwcapindex: u32) -> windows_core::Result<u32>;
}
impl IAMDecoderCaps_Vtbl {
    pub const fn new<Identity: IAMDecoderCaps_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDecoderCaps<Identity: IAMDecoderCaps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcapindex: u32, lpdwcap: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDecoderCaps_Impl::GetDecoderCaps(this, core::mem::transmute_copy(&dwcapindex)) {
                    Ok(ok__) => {
                        lpdwcap.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetDecoderCaps: GetDecoderCaps::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDecoderCaps as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMDecoderCaps {}
windows_core::imp::define_interface!(IAMDevMemoryAllocator, IAMDevMemoryAllocator_Vtbl, 0xc6545bf0_e76b_11d0_bd52_00a0c911ce86);
windows_core::imp::interface_hierarchy!(IAMDevMemoryAllocator, windows_core::IUnknown);
impl IAMDevMemoryAllocator {
    pub unsafe fn GetInfo(&self, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInfo)(windows_core::Interface::as_raw(self), pdwcbtotalfree as _, pdwcblargestfree as _, pdwcbtotalmemory as _, pdwcbminimumchunk as _).ok() }
    }
    pub unsafe fn CheckMemory(&self, pbuffer: *const u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CheckMemory)(windows_core::Interface::as_raw(self), pbuffer).ok() }
    }
    pub unsafe fn Alloc(&self, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Alloc)(windows_core::Interface::as_raw(self), ppbuffer as _, pdwcbbuffer as _).ok() }
    }
    pub unsafe fn Free(&self, pbuffer: *const u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Free)(windows_core::Interface::as_raw(self), pbuffer).ok() }
    }
    pub unsafe fn GetDevMemoryObject<P1>(&self, ppunkinnner: *mut Option<windows_core::IUnknown>, punkouter: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).GetDevMemoryObject)(windows_core::Interface::as_raw(self), core::mem::transmute(ppunkinnner), punkouter.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDevMemoryAllocator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub CheckMemory: unsafe extern "system" fn(*mut core::ffi::c_void, *const u8) -> windows_core::HRESULT,
    pub Alloc: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8, *mut u32) -> windows_core::HRESULT,
    pub Free: unsafe extern "system" fn(*mut core::ffi::c_void, *const u8) -> windows_core::HRESULT,
    pub GetDevMemoryObject: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMDevMemoryAllocator_Impl: windows_core::IUnknownImpl {
    fn GetInfo(&self, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> windows_core::Result<()>;
    fn CheckMemory(&self, pbuffer: *const u8) -> windows_core::Result<()>;
    fn Alloc(&self, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> windows_core::Result<()>;
    fn Free(&self, pbuffer: *const u8) -> windows_core::Result<()>;
    fn GetDevMemoryObject(&self, ppunkinnner: windows_core::OutRef<windows_core::IUnknown>, punkouter: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl IAMDevMemoryAllocator_Vtbl {
    pub const fn new<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetInfo<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcbtotalfree: *mut u32, pdwcblargestfree: *mut u32, pdwcbtotalmemory: *mut u32, pdwcbminimumchunk: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryAllocator_Impl::GetInfo(this, core::mem::transmute_copy(&pdwcbtotalfree), core::mem::transmute_copy(&pdwcblargestfree), core::mem::transmute_copy(&pdwcbtotalmemory), core::mem::transmute_copy(&pdwcbminimumchunk)).into()
            }
        }
        unsafe extern "system" fn CheckMemory<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryAllocator_Impl::CheckMemory(this, core::mem::transmute_copy(&pbuffer)).into()
            }
        }
        unsafe extern "system" fn Alloc<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffer: *mut *mut u8, pdwcbbuffer: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryAllocator_Impl::Alloc(this, core::mem::transmute_copy(&ppbuffer), core::mem::transmute_copy(&pdwcbbuffer)).into()
            }
        }
        unsafe extern "system" fn Free<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryAllocator_Impl::Free(this, core::mem::transmute_copy(&pbuffer)).into()
            }
        }
        unsafe extern "system" fn GetDevMemoryObject<Identity: IAMDevMemoryAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunkinnner: *mut *mut core::ffi::c_void, punkouter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryAllocator_Impl::GetDevMemoryObject(this, core::mem::transmute_copy(&ppunkinnner), core::mem::transmute_copy(&punkouter)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetInfo: GetInfo::<Identity, OFFSET>,
            CheckMemory: CheckMemory::<Identity, OFFSET>,
            Alloc: Alloc::<Identity, OFFSET>,
            Free: Free::<Identity, OFFSET>,
            GetDevMemoryObject: GetDevMemoryObject::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDevMemoryAllocator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMDevMemoryAllocator {}
windows_core::imp::define_interface!(IAMDevMemoryControl, IAMDevMemoryControl_Vtbl, 0xc6545bf1_e76b_11d0_bd52_00a0c911ce86);
windows_core::imp::interface_hierarchy!(IAMDevMemoryControl, windows_core::IUnknown);
impl IAMDevMemoryControl {
    pub unsafe fn QueryWriteSync(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryWriteSync)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn WriteSync(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WriteSync)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetDevId(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDevId)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDevMemoryControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryWriteSync: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub WriteSync: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetDevId: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMDevMemoryControl_Impl: windows_core::IUnknownImpl {
    fn QueryWriteSync(&self) -> windows_core::Result<()>;
    fn WriteSync(&self) -> windows_core::Result<()>;
    fn GetDevId(&self) -> windows_core::Result<u32>;
}
impl IAMDevMemoryControl_Vtbl {
    pub const fn new<Identity: IAMDevMemoryControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryWriteSync<Identity: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryControl_Impl::QueryWriteSync(this).into()
            }
        }
        unsafe extern "system" fn WriteSync<Identity: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDevMemoryControl_Impl::WriteSync(this).into()
            }
        }
        unsafe extern "system" fn GetDevId<Identity: IAMDevMemoryControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwdevid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDevMemoryControl_Impl::GetDevId(this) {
                    Ok(ok__) => {
                        pdwdevid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryWriteSync: QueryWriteSync::<Identity, OFFSET>,
            WriteSync: WriteSync::<Identity, OFFSET>,
            GetDevId: GetDevId::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDevMemoryControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMDevMemoryControl {}
windows_core::imp::define_interface!(IAMDeviceRemoval, IAMDeviceRemoval_Vtbl, 0xf90a6130_b658_11d2_ae49_0000f8754b99);
windows_core::imp::interface_hierarchy!(IAMDeviceRemoval, windows_core::IUnknown);
impl IAMDeviceRemoval {
    pub unsafe fn DeviceInfo(&self, pclsidinterfaceclass: *mut windows_core::GUID, pwszsymboliclink: *mut windows_core::PWSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DeviceInfo)(windows_core::Interface::as_raw(self), pclsidinterfaceclass as _, pwszsymboliclink as _).ok() }
    }
    pub unsafe fn Reassociate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reassociate)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Disassociate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Disassociate)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDeviceRemoval_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub DeviceInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID, *mut windows_core::PWSTR) -> windows_core::HRESULT,
    pub Reassociate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Disassociate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMDeviceRemoval_Impl: windows_core::IUnknownImpl {
    fn DeviceInfo(&self, pclsidinterfaceclass: *mut windows_core::GUID, pwszsymboliclink: *mut windows_core::PWSTR) -> windows_core::Result<()>;
    fn Reassociate(&self) -> windows_core::Result<()>;
    fn Disassociate(&self) -> windows_core::Result<()>;
}
impl IAMDeviceRemoval_Vtbl {
    pub const fn new<Identity: IAMDeviceRemoval_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DeviceInfo<Identity: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclsidinterfaceclass: *mut windows_core::GUID, pwszsymboliclink: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDeviceRemoval_Impl::DeviceInfo(this, core::mem::transmute_copy(&pclsidinterfaceclass), core::mem::transmute_copy(&pwszsymboliclink)).into()
            }
        }
        unsafe extern "system" fn Reassociate<Identity: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDeviceRemoval_Impl::Reassociate(this).into()
            }
        }
        unsafe extern "system" fn Disassociate<Identity: IAMDeviceRemoval_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDeviceRemoval_Impl::Disassociate(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            DeviceInfo: DeviceInfo::<Identity, OFFSET>,
            Reassociate: Reassociate::<Identity, OFFSET>,
            Disassociate: Disassociate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDeviceRemoval as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMDeviceRemoval {}
windows_core::imp::define_interface!(IAMDirectSound, IAMDirectSound_Vtbl, 0x546f4260_d53e_11cf_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMDirectSound, windows_core::IUnknown);
impl IAMDirectSound {
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn GetDirectSoundInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSound> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDirectSoundInterface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn GetPrimaryBufferInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSoundBuffer> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPrimaryBufferInterface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn GetSecondaryBufferInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSoundBuffer> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSecondaryBufferInterface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn ReleaseDirectSoundInterface<P0>(&self, lpds: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::Audio::DirectSound::IDirectSound>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReleaseDirectSoundInterface)(windows_core::Interface::as_raw(self), lpds.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn ReleasePrimaryBufferInterface<P0>(&self, lpdsb: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::Audio::DirectSound::IDirectSoundBuffer>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReleasePrimaryBufferInterface)(windows_core::Interface::as_raw(self), lpdsb.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub unsafe fn ReleaseSecondaryBufferInterface<P0>(&self, lpdsb: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::Audio::DirectSound::IDirectSoundBuffer>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReleaseSecondaryBufferInterface)(windows_core::Interface::as_raw(self), lpdsb.param().abi()).ok() }
    }
    pub unsafe fn SetFocusWindow(&self, param0: super::super::Foundation::HWND, param1: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFocusWindow)(windows_core::Interface::as_raw(self), param0, param1.into()).ok() }
    }
    pub unsafe fn GetFocusWindow(&self, param0: *mut super::super::Foundation::HWND, param1: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFocusWindow)(windows_core::Interface::as_raw(self), param0 as _, param1 as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDirectSound_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub GetDirectSoundInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    GetDirectSoundInterface: usize,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub GetPrimaryBufferInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    GetPrimaryBufferInterface: usize,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub GetSecondaryBufferInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    GetSecondaryBufferInterface: usize,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub ReleaseDirectSoundInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    ReleaseDirectSoundInterface: usize,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub ReleasePrimaryBufferInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    ReleasePrimaryBufferInterface: usize,
    #[cfg(feature = "Win32_Media_Audio_DirectSound")]
    pub ReleaseSecondaryBufferInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio_DirectSound"))]
    ReleaseSecondaryBufferInterface: usize,
    pub SetFocusWindow: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetFocusWindow: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::HWND, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_Audio_DirectSound")]
pub trait IAMDirectSound_Impl: windows_core::IUnknownImpl {
    fn GetDirectSoundInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSound>;
    fn GetPrimaryBufferInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSoundBuffer>;
    fn GetSecondaryBufferInterface(&self) -> windows_core::Result<super::Audio::DirectSound::IDirectSoundBuffer>;
    fn ReleaseDirectSoundInterface(&self, lpds: windows_core::Ref<super::Audio::DirectSound::IDirectSound>) -> windows_core::Result<()>;
    fn ReleasePrimaryBufferInterface(&self, lpdsb: windows_core::Ref<super::Audio::DirectSound::IDirectSoundBuffer>) -> windows_core::Result<()>;
    fn ReleaseSecondaryBufferInterface(&self, lpdsb: windows_core::Ref<super::Audio::DirectSound::IDirectSoundBuffer>) -> windows_core::Result<()>;
    fn SetFocusWindow(&self, param0: super::super::Foundation::HWND, param1: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetFocusWindow(&self, param0: *mut super::super::Foundation::HWND, param1: *mut windows_core::BOOL) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_Audio_DirectSound")]
impl IAMDirectSound_Vtbl {
    pub const fn new<Identity: IAMDirectSound_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDirectSoundInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplpds: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDirectSound_Impl::GetDirectSoundInterface(this) {
                    Ok(ok__) => {
                        lplpds.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetPrimaryBufferInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplpdsb: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDirectSound_Impl::GetPrimaryBufferInterface(this) {
                    Ok(ok__) => {
                        lplpdsb.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSecondaryBufferInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplpdsb: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDirectSound_Impl::GetSecondaryBufferInterface(this) {
                    Ok(ok__) => {
                        lplpdsb.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ReleaseDirectSoundInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpds: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDirectSound_Impl::ReleaseDirectSoundInterface(this, core::mem::transmute_copy(&lpds)).into()
            }
        }
        unsafe extern "system" fn ReleasePrimaryBufferInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdsb: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDirectSound_Impl::ReleasePrimaryBufferInterface(this, core::mem::transmute_copy(&lpdsb)).into()
            }
        }
        unsafe extern "system" fn ReleaseSecondaryBufferInterface<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdsb: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDirectSound_Impl::ReleaseSecondaryBufferInterface(this, core::mem::transmute_copy(&lpdsb)).into()
            }
        }
        unsafe extern "system" fn SetFocusWindow<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param0: super::super::Foundation::HWND, param1: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDirectSound_Impl::SetFocusWindow(this, core::mem::transmute_copy(&param0), core::mem::transmute_copy(&param1)).into()
            }
        }
        unsafe extern "system" fn GetFocusWindow<Identity: IAMDirectSound_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param0: *mut super::super::Foundation::HWND, param1: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDirectSound_Impl::GetFocusWindow(this, core::mem::transmute_copy(&param0), core::mem::transmute_copy(&param1)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDirectSoundInterface: GetDirectSoundInterface::<Identity, OFFSET>,
            GetPrimaryBufferInterface: GetPrimaryBufferInterface::<Identity, OFFSET>,
            GetSecondaryBufferInterface: GetSecondaryBufferInterface::<Identity, OFFSET>,
            ReleaseDirectSoundInterface: ReleaseDirectSoundInterface::<Identity, OFFSET>,
            ReleasePrimaryBufferInterface: ReleasePrimaryBufferInterface::<Identity, OFFSET>,
            ReleaseSecondaryBufferInterface: ReleaseSecondaryBufferInterface::<Identity, OFFSET>,
            SetFocusWindow: SetFocusWindow::<Identity, OFFSET>,
            GetFocusWindow: GetFocusWindow::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDirectSound as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio_DirectSound")]
impl windows_core::RuntimeName for IAMDirectSound {}
windows_core::imp::define_interface!(IAMDroppedFrames, IAMDroppedFrames_Vtbl, 0xc6e13344_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMDroppedFrames, windows_core::IUnknown);
impl IAMDroppedFrames {
    pub unsafe fn GetNumDropped(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumDropped)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetNumNotDropped(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumNotDropped)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDroppedInfo(&self, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDroppedInfo)(windows_core::Interface::as_raw(self), lsize, plarray as _, plnumcopied as _).ok() }
    }
    pub unsafe fn GetAverageFrameSize(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAverageFrameSize)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMDroppedFrames_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNumDropped: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetNumNotDropped: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetDroppedInfo: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetAverageFrameSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMDroppedFrames_Impl: windows_core::IUnknownImpl {
    fn GetNumDropped(&self) -> windows_core::Result<i32>;
    fn GetNumNotDropped(&self) -> windows_core::Result<i32>;
    fn GetDroppedInfo(&self, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> windows_core::Result<()>;
    fn GetAverageFrameSize(&self) -> windows_core::Result<i32>;
}
impl IAMDroppedFrames_Vtbl {
    pub const fn new<Identity: IAMDroppedFrames_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNumDropped<Identity: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pldropped: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDroppedFrames_Impl::GetNumDropped(this) {
                    Ok(ok__) => {
                        pldropped.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetNumNotDropped<Identity: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plnotdropped: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDroppedFrames_Impl::GetNumNotDropped(this) {
                    Ok(ok__) => {
                        plnotdropped.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDroppedInfo<Identity: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lsize: i32, plarray: *mut i32, plnumcopied: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMDroppedFrames_Impl::GetDroppedInfo(this, core::mem::transmute_copy(&lsize), core::mem::transmute_copy(&plarray), core::mem::transmute_copy(&plnumcopied)).into()
            }
        }
        unsafe extern "system" fn GetAverageFrameSize<Identity: IAMDroppedFrames_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plaveragesize: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMDroppedFrames_Impl::GetAverageFrameSize(this) {
                    Ok(ok__) => {
                        plaveragesize.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNumDropped: GetNumDropped::<Identity, OFFSET>,
            GetNumNotDropped: GetNumNotDropped::<Identity, OFFSET>,
            GetDroppedInfo: GetDroppedInfo::<Identity, OFFSET>,
            GetAverageFrameSize: GetAverageFrameSize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMDroppedFrames as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMDroppedFrames {}
windows_core::imp::define_interface!(IAMExtDevice, IAMExtDevice_Vtbl, 0xb5730a90_1a2c_11cf_8c23_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMExtDevice, windows_core::IUnknown);
impl IAMExtDevice {
    pub unsafe fn GetCapability(&self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCapability)(windows_core::Interface::as_raw(self), capability, pvalue as _, pdblvalue as _).ok() }
    }
    pub unsafe fn ExternalDeviceID(&self) -> windows_core::Result<windows_core::PWSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ExternalDeviceID)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn ExternalDeviceVersion(&self) -> windows_core::Result<windows_core::PWSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ExternalDeviceVersion)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDevicePower(&self, powermode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDevicePower)(windows_core::Interface::as_raw(self), powermode).ok() }
    }
    pub unsafe fn DevicePower(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DevicePower)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Calibrate(&self, hevent: usize, mode: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Calibrate)(windows_core::Interface::as_raw(self), hevent, mode, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDevicePort(&self, deviceport: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDevicePort)(windows_core::Interface::as_raw(self), deviceport).ok() }
    }
    pub unsafe fn DevicePort(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DevicePort)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMExtDevice_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCapability: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut f64) -> windows_core::HRESULT,
    pub ExternalDeviceID: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR) -> windows_core::HRESULT,
    pub ExternalDeviceVersion: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR) -> windows_core::HRESULT,
    pub SetDevicePower: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DevicePower: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Calibrate: unsafe extern "system" fn(*mut core::ffi::c_void, usize, i32, *mut i32) -> windows_core::HRESULT,
    pub SetDevicePort: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DevicePort: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMExtDevice_Impl: windows_core::IUnknownImpl {
    fn GetCapability(&self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::Result<()>;
    fn ExternalDeviceID(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn ExternalDeviceVersion(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn SetDevicePower(&self, powermode: i32) -> windows_core::Result<()>;
    fn DevicePower(&self) -> windows_core::Result<i32>;
    fn Calibrate(&self, hevent: usize, mode: i32) -> windows_core::Result<i32>;
    fn SetDevicePort(&self, deviceport: i32) -> windows_core::Result<()>;
    fn DevicePort(&self) -> windows_core::Result<i32>;
}
impl IAMExtDevice_Vtbl {
    pub const fn new<Identity: IAMExtDevice_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCapability<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtDevice_Impl::GetCapability(this, core::mem::transmute_copy(&capability), core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pdblvalue)).into()
            }
        }
        unsafe extern "system" fn ExternalDeviceID<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszdata: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtDevice_Impl::ExternalDeviceID(this) {
                    Ok(ok__) => {
                        ppszdata.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ExternalDeviceVersion<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszdata: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtDevice_Impl::ExternalDeviceVersion(this) {
                    Ok(ok__) => {
                        ppszdata.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDevicePower<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, powermode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtDevice_Impl::SetDevicePower(this, core::mem::transmute_copy(&powermode)).into()
            }
        }
        unsafe extern "system" fn DevicePower<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppowermode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtDevice_Impl::DevicePower(this) {
                    Ok(ok__) => {
                        ppowermode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Calibrate<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hevent: usize, mode: i32, pstatus: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtDevice_Impl::Calibrate(this, core::mem::transmute_copy(&hevent), core::mem::transmute_copy(&mode)) {
                    Ok(ok__) => {
                        pstatus.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDevicePort<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, deviceport: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtDevice_Impl::SetDevicePort(this, core::mem::transmute_copy(&deviceport)).into()
            }
        }
        unsafe extern "system" fn DevicePort<Identity: IAMExtDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdeviceport: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtDevice_Impl::DevicePort(this) {
                    Ok(ok__) => {
                        pdeviceport.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCapability: GetCapability::<Identity, OFFSET>,
            ExternalDeviceID: ExternalDeviceID::<Identity, OFFSET>,
            ExternalDeviceVersion: ExternalDeviceVersion::<Identity, OFFSET>,
            SetDevicePower: SetDevicePower::<Identity, OFFSET>,
            DevicePower: DevicePower::<Identity, OFFSET>,
            Calibrate: Calibrate::<Identity, OFFSET>,
            SetDevicePort: SetDevicePort::<Identity, OFFSET>,
            DevicePort: DevicePort::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMExtDevice as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMExtDevice {}
windows_core::imp::define_interface!(IAMExtTransport, IAMExtTransport_Vtbl, 0xa03cd5f0_3045_11cf_8c44_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMExtTransport, windows_core::IUnknown);
impl IAMExtTransport {
    pub unsafe fn GetCapability(&self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCapability)(windows_core::Interface::as_raw(self), capability, pvalue as _, pdblvalue as _).ok() }
    }
    pub unsafe fn SetMediaState(&self, state: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaState)(windows_core::Interface::as_raw(self), state).ok() }
    }
    pub unsafe fn MediaState(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).MediaState)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetLocalControl(&self, state: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLocalControl)(windows_core::Interface::as_raw(self), state).ok() }
    }
    pub unsafe fn LocalControl(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).LocalControl)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetStatus(&self, statusitem: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStatus)(windows_core::Interface::as_raw(self), statusitem, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTransportBasicParameters(&self, param: i32, pvalue: *mut i32, ppszdata: *mut windows_core::PWSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTransportBasicParameters)(windows_core::Interface::as_raw(self), param, pvalue as _, ppszdata as _).ok() }
    }
    pub unsafe fn SetTransportBasicParameters<P2>(&self, param: i32, value: i32, pszdata: P2) -> windows_core::Result<()>
    where
        P2: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetTransportBasicParameters)(windows_core::Interface::as_raw(self), param, value, pszdata.param().abi()).ok() }
    }
    pub unsafe fn GetTransportVideoParameters(&self, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTransportVideoParameters)(windows_core::Interface::as_raw(self), param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTransportVideoParameters(&self, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTransportVideoParameters)(windows_core::Interface::as_raw(self), param, value).ok() }
    }
    pub unsafe fn GetTransportAudioParameters(&self, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTransportAudioParameters)(windows_core::Interface::as_raw(self), param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTransportAudioParameters(&self, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTransportAudioParameters)(windows_core::Interface::as_raw(self), param, value).ok() }
    }
    pub unsafe fn SetMode(&self, mode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn Mode(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Mode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetRate(&self, dblrate: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRate)(windows_core::Interface::as_raw(self), dblrate).ok() }
    }
    pub unsafe fn Rate(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Rate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetChase(&self, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetChase)(windows_core::Interface::as_raw(self), penabled as _, poffset as _, phevent as _).ok() }
    }
    pub unsafe fn SetChase(&self, enable: i32, offset: i32, hevent: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetChase)(windows_core::Interface::as_raw(self), enable, offset, hevent).ok() }
    }
    pub unsafe fn GetBump(&self, pspeed: *mut i32, pduration: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBump)(windows_core::Interface::as_raw(self), pspeed as _, pduration as _).ok() }
    }
    pub unsafe fn SetBump(&self, speed: i32, duration: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBump)(windows_core::Interface::as_raw(self), speed, duration).ok() }
    }
    pub unsafe fn AntiClogControl(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AntiClogControl)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAntiClogControl(&self, enable: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAntiClogControl)(windows_core::Interface::as_raw(self), enable).ok() }
    }
    pub unsafe fn GetEditPropertySet(&self, editid: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEditPropertySet)(windows_core::Interface::as_raw(self), editid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetEditPropertySet(&self, peditid: *mut i32, state: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEditPropertySet)(windows_core::Interface::as_raw(self), peditid as _, state).ok() }
    }
    pub unsafe fn GetEditProperty(&self, editid: i32, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEditProperty)(windows_core::Interface::as_raw(self), editid, param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetEditProperty(&self, editid: i32, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEditProperty)(windows_core::Interface::as_raw(self), editid, param, value).ok() }
    }
    pub unsafe fn EditStart(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EditStart)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetEditStart(&self, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEditStart)(windows_core::Interface::as_raw(self), value).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMExtTransport_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCapability: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut f64) -> windows_core::HRESULT,
    pub SetMediaState: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub MediaState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetLocalControl: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub LocalControl: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetStatus: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub GetTransportBasicParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut windows_core::PWSTR) -> windows_core::HRESULT,
    pub SetTransportBasicParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub GetTransportVideoParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetTransportVideoParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub GetTransportAudioParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetTransportAudioParameters: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub SetMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Mode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetRate: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Rate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub GetChase: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut usize) -> windows_core::HRESULT,
    pub SetChase: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, usize) -> windows_core::HRESULT,
    pub GetBump: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetBump: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub AntiClogControl: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetAntiClogControl: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetEditPropertySet: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetEditPropertySet: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, i32) -> windows_core::HRESULT,
    pub GetEditProperty: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, *mut i32) -> windows_core::HRESULT,
    pub SetEditProperty: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub EditStart: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetEditStart: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IAMExtTransport_Impl: windows_core::IUnknownImpl {
    fn GetCapability(&self, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::Result<()>;
    fn SetMediaState(&self, state: i32) -> windows_core::Result<()>;
    fn MediaState(&self) -> windows_core::Result<i32>;
    fn SetLocalControl(&self, state: i32) -> windows_core::Result<()>;
    fn LocalControl(&self) -> windows_core::Result<i32>;
    fn GetStatus(&self, statusitem: i32) -> windows_core::Result<i32>;
    fn GetTransportBasicParameters(&self, param: i32, pvalue: *mut i32, ppszdata: *mut windows_core::PWSTR) -> windows_core::Result<()>;
    fn SetTransportBasicParameters(&self, param: i32, value: i32, pszdata: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetTransportVideoParameters(&self, param: i32) -> windows_core::Result<i32>;
    fn SetTransportVideoParameters(&self, param: i32, value: i32) -> windows_core::Result<()>;
    fn GetTransportAudioParameters(&self, param: i32) -> windows_core::Result<i32>;
    fn SetTransportAudioParameters(&self, param: i32, value: i32) -> windows_core::Result<()>;
    fn SetMode(&self, mode: i32) -> windows_core::Result<()>;
    fn Mode(&self) -> windows_core::Result<i32>;
    fn SetRate(&self, dblrate: f64) -> windows_core::Result<()>;
    fn Rate(&self) -> windows_core::Result<f64>;
    fn GetChase(&self, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> windows_core::Result<()>;
    fn SetChase(&self, enable: i32, offset: i32, hevent: usize) -> windows_core::Result<()>;
    fn GetBump(&self, pspeed: *mut i32, pduration: *mut i32) -> windows_core::Result<()>;
    fn SetBump(&self, speed: i32, duration: i32) -> windows_core::Result<()>;
    fn AntiClogControl(&self) -> windows_core::Result<i32>;
    fn SetAntiClogControl(&self, enable: i32) -> windows_core::Result<()>;
    fn GetEditPropertySet(&self, editid: i32) -> windows_core::Result<i32>;
    fn SetEditPropertySet(&self, peditid: *mut i32, state: i32) -> windows_core::Result<()>;
    fn GetEditProperty(&self, editid: i32, param: i32) -> windows_core::Result<i32>;
    fn SetEditProperty(&self, editid: i32, param: i32, value: i32) -> windows_core::Result<()>;
    fn EditStart(&self) -> windows_core::Result<i32>;
    fn SetEditStart(&self, value: i32) -> windows_core::Result<()>;
}
impl IAMExtTransport_Vtbl {
    pub const fn new<Identity: IAMExtTransport_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCapability<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, capability: i32, pvalue: *mut i32, pdblvalue: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::GetCapability(this, core::mem::transmute_copy(&capability), core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pdblvalue)).into()
            }
        }
        unsafe extern "system" fn SetMediaState<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetMediaState(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn MediaState<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::MediaState(this) {
                    Ok(ok__) => {
                        pstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLocalControl<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetLocalControl(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn LocalControl<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::LocalControl(this) {
                    Ok(ok__) => {
                        pstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetStatus<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, statusitem: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::GetStatus(this, core::mem::transmute_copy(&statusitem)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTransportBasicParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32, ppszdata: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::GetTransportBasicParameters(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&ppszdata)).into()
            }
        }
        unsafe extern "system" fn SetTransportBasicParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32, pszdata: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetTransportBasicParameters(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value), core::mem::transmute(&pszdata)).into()
            }
        }
        unsafe extern "system" fn GetTransportVideoParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::GetTransportVideoParameters(this, core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTransportVideoParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetTransportVideoParameters(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn GetTransportAudioParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::GetTransportAudioParameters(this, core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTransportAudioParameters<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetTransportAudioParameters(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn SetMode<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn Mode<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::Mode(this) {
                    Ok(ok__) => {
                        pmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRate<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dblrate: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetRate(this, core::mem::transmute_copy(&dblrate)).into()
            }
        }
        unsafe extern "system" fn Rate<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdblrate: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::Rate(this) {
                    Ok(ok__) => {
                        pdblrate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetChase<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penabled: *mut i32, poffset: *mut i32, phevent: *mut usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::GetChase(this, core::mem::transmute_copy(&penabled), core::mem::transmute_copy(&poffset), core::mem::transmute_copy(&phevent)).into()
            }
        }
        unsafe extern "system" fn SetChase<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enable: i32, offset: i32, hevent: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetChase(this, core::mem::transmute_copy(&enable), core::mem::transmute_copy(&offset), core::mem::transmute_copy(&hevent)).into()
            }
        }
        unsafe extern "system" fn GetBump<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pspeed: *mut i32, pduration: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::GetBump(this, core::mem::transmute_copy(&pspeed), core::mem::transmute_copy(&pduration)).into()
            }
        }
        unsafe extern "system" fn SetBump<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, speed: i32, duration: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetBump(this, core::mem::transmute_copy(&speed), core::mem::transmute_copy(&duration)).into()
            }
        }
        unsafe extern "system" fn AntiClogControl<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penabled: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::AntiClogControl(this) {
                    Ok(ok__) => {
                        penabled.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAntiClogControl<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enable: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetAntiClogControl(this, core::mem::transmute_copy(&enable)).into()
            }
        }
        unsafe extern "system" fn GetEditPropertySet<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, editid: i32, pstate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::GetEditPropertySet(this, core::mem::transmute_copy(&editid)) {
                    Ok(ok__) => {
                        pstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetEditPropertySet<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peditid: *mut i32, state: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetEditPropertySet(this, core::mem::transmute_copy(&peditid), core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn GetEditProperty<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, editid: i32, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::GetEditProperty(this, core::mem::transmute_copy(&editid), core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetEditProperty<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, editid: i32, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetEditProperty(this, core::mem::transmute_copy(&editid), core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn EditStart<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMExtTransport_Impl::EditStart(this) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetEditStart<Identity: IAMExtTransport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtTransport_Impl::SetEditStart(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCapability: GetCapability::<Identity, OFFSET>,
            SetMediaState: SetMediaState::<Identity, OFFSET>,
            MediaState: MediaState::<Identity, OFFSET>,
            SetLocalControl: SetLocalControl::<Identity, OFFSET>,
            LocalControl: LocalControl::<Identity, OFFSET>,
            GetStatus: GetStatus::<Identity, OFFSET>,
            GetTransportBasicParameters: GetTransportBasicParameters::<Identity, OFFSET>,
            SetTransportBasicParameters: SetTransportBasicParameters::<Identity, OFFSET>,
            GetTransportVideoParameters: GetTransportVideoParameters::<Identity, OFFSET>,
            SetTransportVideoParameters: SetTransportVideoParameters::<Identity, OFFSET>,
            GetTransportAudioParameters: GetTransportAudioParameters::<Identity, OFFSET>,
            SetTransportAudioParameters: SetTransportAudioParameters::<Identity, OFFSET>,
            SetMode: SetMode::<Identity, OFFSET>,
            Mode: Mode::<Identity, OFFSET>,
            SetRate: SetRate::<Identity, OFFSET>,
            Rate: Rate::<Identity, OFFSET>,
            GetChase: GetChase::<Identity, OFFSET>,
            SetChase: SetChase::<Identity, OFFSET>,
            GetBump: GetBump::<Identity, OFFSET>,
            SetBump: SetBump::<Identity, OFFSET>,
            AntiClogControl: AntiClogControl::<Identity, OFFSET>,
            SetAntiClogControl: SetAntiClogControl::<Identity, OFFSET>,
            GetEditPropertySet: GetEditPropertySet::<Identity, OFFSET>,
            SetEditPropertySet: SetEditPropertySet::<Identity, OFFSET>,
            GetEditProperty: GetEditProperty::<Identity, OFFSET>,
            SetEditProperty: SetEditProperty::<Identity, OFFSET>,
            EditStart: EditStart::<Identity, OFFSET>,
            SetEditStart: SetEditStart::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMExtTransport as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMExtTransport {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMExtendedErrorInfo, IAMExtendedErrorInfo_Vtbl, 0xfa2aa8f6_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMExtendedErrorInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMExtendedErrorInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMExtendedErrorInfo {
    pub unsafe fn HasError(&self, phaserror: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HasError)(windows_core::Interface::as_raw(self), phaserror as _).ok() }
    }
    pub unsafe fn ErrorDescription(&self, pbstrerrordescription: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ErrorDescription)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrerrordescription)).ok() }
    }
    pub unsafe fn ErrorCode(&self, perrorcode: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ErrorCode)(windows_core::Interface::as_raw(self), perrorcode as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMExtendedErrorInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub HasError: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub ErrorDescription: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ErrorCode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMExtendedErrorInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn HasError(&self, phaserror: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn ErrorDescription(&self, pbstrerrordescription: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn ErrorCode(&self, perrorcode: *mut i32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMExtendedErrorInfo_Vtbl {
    pub const fn new<Identity: IAMExtendedErrorInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn HasError<Identity: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phaserror: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedErrorInfo_Impl::HasError(this, core::mem::transmute_copy(&phaserror)).into()
            }
        }
        unsafe extern "system" fn ErrorDescription<Identity: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrerrordescription: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedErrorInfo_Impl::ErrorDescription(this, core::mem::transmute_copy(&pbstrerrordescription)).into()
            }
        }
        unsafe extern "system" fn ErrorCode<Identity: IAMExtendedErrorInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, perrorcode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedErrorInfo_Impl::ErrorCode(this, core::mem::transmute_copy(&perrorcode)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            HasError: HasError::<Identity, OFFSET>,
            ErrorDescription: ErrorDescription::<Identity, OFFSET>,
            ErrorCode: ErrorCode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMExtendedErrorInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMExtendedErrorInfo {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMExtendedSeeking, IAMExtendedSeeking_Vtbl, 0xfa2aa8f9_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMExtendedSeeking {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMExtendedSeeking, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMExtendedSeeking {
    pub unsafe fn ExSeekCapabilities(&self, pexcapabilities: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ExSeekCapabilities)(windows_core::Interface::as_raw(self), pexcapabilities as _).ok() }
    }
    pub unsafe fn MarkerCount(&self, pmarkercount: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MarkerCount)(windows_core::Interface::as_raw(self), pmarkercount as _).ok() }
    }
    pub unsafe fn CurrentMarker(&self, pcurrentmarker: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CurrentMarker)(windows_core::Interface::as_raw(self), pcurrentmarker as _).ok() }
    }
    pub unsafe fn GetMarkerTime(&self, markernum: i32, pmarkertime: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMarkerTime)(windows_core::Interface::as_raw(self), markernum, pmarkertime as _).ok() }
    }
    pub unsafe fn GetMarkerName(&self, markernum: i32, pbstrmarkername: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMarkerName)(windows_core::Interface::as_raw(self), markernum, core::mem::transmute(pbstrmarkername)).ok() }
    }
    pub unsafe fn SetPlaybackSpeed(&self, speed: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPlaybackSpeed)(windows_core::Interface::as_raw(self), speed).ok() }
    }
    pub unsafe fn PlaybackSpeed(&self, pspeed: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PlaybackSpeed)(windows_core::Interface::as_raw(self), pspeed as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMExtendedSeeking_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub ExSeekCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub MarkerCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub CurrentMarker: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetMarkerTime: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut f64) -> windows_core::HRESULT,
    pub GetMarkerName: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetPlaybackSpeed: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub PlaybackSpeed: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMExtendedSeeking_Impl: super::super::System::Com::IDispatch_Impl {
    fn ExSeekCapabilities(&self, pexcapabilities: *mut i32) -> windows_core::Result<()>;
    fn MarkerCount(&self, pmarkercount: *mut i32) -> windows_core::Result<()>;
    fn CurrentMarker(&self, pcurrentmarker: *mut i32) -> windows_core::Result<()>;
    fn GetMarkerTime(&self, markernum: i32, pmarkertime: *mut f64) -> windows_core::Result<()>;
    fn GetMarkerName(&self, markernum: i32, pbstrmarkername: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn SetPlaybackSpeed(&self, speed: f64) -> windows_core::Result<()>;
    fn PlaybackSpeed(&self, pspeed: *mut f64) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMExtendedSeeking_Vtbl {
    pub const fn new<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ExSeekCapabilities<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pexcapabilities: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::ExSeekCapabilities(this, core::mem::transmute_copy(&pexcapabilities)).into()
            }
        }
        unsafe extern "system" fn MarkerCount<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmarkercount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::MarkerCount(this, core::mem::transmute_copy(&pmarkercount)).into()
            }
        }
        unsafe extern "system" fn CurrentMarker<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrentmarker: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::CurrentMarker(this, core::mem::transmute_copy(&pcurrentmarker)).into()
            }
        }
        unsafe extern "system" fn GetMarkerTime<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, markernum: i32, pmarkertime: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::GetMarkerTime(this, core::mem::transmute_copy(&markernum), core::mem::transmute_copy(&pmarkertime)).into()
            }
        }
        unsafe extern "system" fn GetMarkerName<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, markernum: i32, pbstrmarkername: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::GetMarkerName(this, core::mem::transmute_copy(&markernum), core::mem::transmute_copy(&pbstrmarkername)).into()
            }
        }
        unsafe extern "system" fn SetPlaybackSpeed<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, speed: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::SetPlaybackSpeed(this, core::mem::transmute_copy(&speed)).into()
            }
        }
        unsafe extern "system" fn PlaybackSpeed<Identity: IAMExtendedSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pspeed: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMExtendedSeeking_Impl::PlaybackSpeed(this, core::mem::transmute_copy(&pspeed)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            ExSeekCapabilities: ExSeekCapabilities::<Identity, OFFSET>,
            MarkerCount: MarkerCount::<Identity, OFFSET>,
            CurrentMarker: CurrentMarker::<Identity, OFFSET>,
            GetMarkerTime: GetMarkerTime::<Identity, OFFSET>,
            GetMarkerName: GetMarkerName::<Identity, OFFSET>,
            SetPlaybackSpeed: SetPlaybackSpeed::<Identity, OFFSET>,
            PlaybackSpeed: PlaybackSpeed::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMExtendedSeeking as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMExtendedSeeking {}
windows_core::imp::define_interface!(IAMFilterGraphCallback, IAMFilterGraphCallback_Vtbl, 0x56a868fd_0ad4_11ce_b0a3_0020af0ba770);
windows_core::imp::interface_hierarchy!(IAMFilterGraphCallback, windows_core::IUnknown);
impl IAMFilterGraphCallback {
    pub unsafe fn UnableToRender<P0>(&self, ppin: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).UnableToRender)(windows_core::Interface::as_raw(self), ppin.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMFilterGraphCallback_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub UnableToRender: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMFilterGraphCallback_Impl: windows_core::IUnknownImpl {
    fn UnableToRender(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<()>;
}
impl IAMFilterGraphCallback_Vtbl {
    pub const fn new<Identity: IAMFilterGraphCallback_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn UnableToRender<Identity: IAMFilterGraphCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMFilterGraphCallback_Impl::UnableToRender(this, core::mem::transmute_copy(&ppin)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), UnableToRender: UnableToRender::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMFilterGraphCallback as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMFilterGraphCallback {}
windows_core::imp::define_interface!(IAMFilterMiscFlags, IAMFilterMiscFlags_Vtbl, 0x2dd74950_a890_11d1_abe8_00a0c905f375);
windows_core::imp::interface_hierarchy!(IAMFilterMiscFlags, windows_core::IUnknown);
impl IAMFilterMiscFlags {
    pub unsafe fn GetMiscFlags(&self) -> u32 {
        unsafe { (windows_core::Interface::vtable(self).GetMiscFlags)(windows_core::Interface::as_raw(self)) }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMFilterMiscFlags_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMiscFlags: unsafe extern "system" fn(*mut core::ffi::c_void) -> u32,
}
pub trait IAMFilterMiscFlags_Impl: windows_core::IUnknownImpl {
    fn GetMiscFlags(&self) -> u32;
}
impl IAMFilterMiscFlags_Vtbl {
    pub const fn new<Identity: IAMFilterMiscFlags_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMiscFlags<Identity: IAMFilterMiscFlags_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMFilterMiscFlags_Impl::GetMiscFlags(this)
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetMiscFlags: GetMiscFlags::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMFilterMiscFlags as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMFilterMiscFlags {}
windows_core::imp::define_interface!(IAMGraphBuilderCallback, IAMGraphBuilderCallback_Vtbl, 0x4995f511_9ddb_4f12_bd3b_f04611807b79);
windows_core::imp::interface_hierarchy!(IAMGraphBuilderCallback, windows_core::IUnknown);
impl IAMGraphBuilderCallback {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SelectedFilter<P0>(&self, pmon: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::System::Com::IMoniker>,
    {
        unsafe { (windows_core::Interface::vtable(self).SelectedFilter)(windows_core::Interface::as_raw(self), pmon.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreatedFilter<P0>(&self, pfil: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).CreatedFilter)(windows_core::Interface::as_raw(self), pfil.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMGraphBuilderCallback_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub SelectedFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SelectedFilter: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub CreatedFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    CreatedFilter: usize,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMGraphBuilderCallback_Impl: windows_core::IUnknownImpl {
    fn SelectedFilter(&self, pmon: windows_core::Ref<super::super::System::Com::IMoniker>) -> windows_core::Result<()>;
    fn CreatedFilter(&self, pfil: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IAMGraphBuilderCallback_Vtbl {
    pub const fn new<Identity: IAMGraphBuilderCallback_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SelectedFilter<Identity: IAMGraphBuilderCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmon: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMGraphBuilderCallback_Impl::SelectedFilter(this, core::mem::transmute_copy(&pmon)).into()
            }
        }
        unsafe extern "system" fn CreatedFilter<Identity: IAMGraphBuilderCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfil: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMGraphBuilderCallback_Impl::CreatedFilter(this, core::mem::transmute_copy(&pfil)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SelectedFilter: SelectedFilter::<Identity, OFFSET>,
            CreatedFilter: CreatedFilter::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMGraphBuilderCallback as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IAMGraphBuilderCallback {}
windows_core::imp::define_interface!(IAMGraphStreams, IAMGraphStreams_Vtbl, 0x632105fa_072e_11d3_8af9_00c04fb6bd3d);
windows_core::imp::interface_hierarchy!(IAMGraphStreams, windows_core::IUnknown);
impl IAMGraphStreams {
    pub unsafe fn FindUpstreamInterface<P0>(&self, ppin: P0, riid: *const windows_core::GUID, ppvinterface: *mut *mut core::ffi::c_void, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).FindUpstreamInterface)(windows_core::Interface::as_raw(self), ppin.param().abi(), riid, ppvinterface as _, dwflags).ok() }
    }
    pub unsafe fn SyncUsingStreamOffset(&self, busestreamoffset: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SyncUsingStreamOffset)(windows_core::Interface::as_raw(self), busestreamoffset.into()).ok() }
    }
    pub unsafe fn SetMaxGraphLatency(&self, rtmaxgraphlatency: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMaxGraphLatency)(windows_core::Interface::as_raw(self), rtmaxgraphlatency).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMGraphStreams_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub FindUpstreamInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SyncUsingStreamOffset: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub SetMaxGraphLatency: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
pub trait IAMGraphStreams_Impl: windows_core::IUnknownImpl {
    fn FindUpstreamInterface(&self, ppin: windows_core::Ref<IPin>, riid: *const windows_core::GUID, ppvinterface: *mut *mut core::ffi::c_void, dwflags: u32) -> windows_core::Result<()>;
    fn SyncUsingStreamOffset(&self, busestreamoffset: windows_core::BOOL) -> windows_core::Result<()>;
    fn SetMaxGraphLatency(&self, rtmaxgraphlatency: i64) -> windows_core::Result<()>;
}
impl IAMGraphStreams_Vtbl {
    pub const fn new<Identity: IAMGraphStreams_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FindUpstreamInterface<Identity: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvinterface: *mut *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMGraphStreams_Impl::FindUpstreamInterface(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvinterface), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn SyncUsingStreamOffset<Identity: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, busestreamoffset: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMGraphStreams_Impl::SyncUsingStreamOffset(this, core::mem::transmute_copy(&busestreamoffset)).into()
            }
        }
        unsafe extern "system" fn SetMaxGraphLatency<Identity: IAMGraphStreams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rtmaxgraphlatency: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMGraphStreams_Impl::SetMaxGraphLatency(this, core::mem::transmute_copy(&rtmaxgraphlatency)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            FindUpstreamInterface: FindUpstreamInterface::<Identity, OFFSET>,
            SyncUsingStreamOffset: SyncUsingStreamOffset::<Identity, OFFSET>,
            SetMaxGraphLatency: SetMaxGraphLatency::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMGraphStreams as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMGraphStreams {}
windows_core::imp::define_interface!(IAMLatency, IAMLatency_Vtbl, 0x62ea93ba_ec62_11d2_b770_00c04fb6bd3d);
windows_core::imp::interface_hierarchy!(IAMLatency, windows_core::IUnknown);
impl IAMLatency {
    pub unsafe fn GetLatency(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetLatency)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMLatency_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetLatency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
}
pub trait IAMLatency_Impl: windows_core::IUnknownImpl {
    fn GetLatency(&self) -> windows_core::Result<i64>;
}
impl IAMLatency_Vtbl {
    pub const fn new<Identity: IAMLatency_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetLatency<Identity: IAMLatency_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtlatency: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMLatency_Impl::GetLatency(this) {
                    Ok(ok__) => {
                        prtlatency.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetLatency: GetLatency::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMLatency as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMLatency {}
windows_core::imp::define_interface!(IAMLine21Decoder, IAMLine21Decoder_Vtbl, 0x6e8d4a21_310c_11d0_b79a_00aa003767a7);
windows_core::imp::interface_hierarchy!(IAMLine21Decoder, windows_core::IUnknown);
impl IAMLine21Decoder {
    pub unsafe fn GetDecoderLevel(&self, lplevel: *mut AM_LINE21_CCLEVEL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDecoderLevel)(windows_core::Interface::as_raw(self), lplevel as _).ok() }
    }
    pub unsafe fn GetCurrentService(&self, lpservice: *mut AM_LINE21_CCSERVICE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentService)(windows_core::Interface::as_raw(self), lpservice as _).ok() }
    }
    pub unsafe fn SetCurrentService(&self, service: AM_LINE21_CCSERVICE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCurrentService)(windows_core::Interface::as_raw(self), service).ok() }
    }
    pub unsafe fn GetServiceState(&self, lpstate: *mut AM_LINE21_CCSTATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetServiceState)(windows_core::Interface::as_raw(self), lpstate as _).ok() }
    }
    pub unsafe fn SetServiceState(&self, state: AM_LINE21_CCSTATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetServiceState)(windows_core::Interface::as_raw(self), state).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetOutputFormat(&self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetOutputFormat)(windows_core::Interface::as_raw(self), lpbmih as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn SetOutputFormat(&self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputFormat)(windows_core::Interface::as_raw(self), lpbmi as _).ok() }
    }
    pub unsafe fn GetBackgroundColor(&self, pdwphyscolor: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBackgroundColor)(windows_core::Interface::as_raw(self), pdwphyscolor as _).ok() }
    }
    pub unsafe fn SetBackgroundColor(&self, dwphyscolor: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBackgroundColor)(windows_core::Interface::as_raw(self), dwphyscolor).ok() }
    }
    pub unsafe fn GetRedrawAlways(&self, lpboption: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRedrawAlways)(windows_core::Interface::as_raw(self), lpboption as _).ok() }
    }
    pub unsafe fn SetRedrawAlways(&self, boption: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRedrawAlways)(windows_core::Interface::as_raw(self), boption.into()).ok() }
    }
    pub unsafe fn GetDrawBackgroundMode(&self, lpmode: *mut AM_LINE21_DRAWBGMODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDrawBackgroundMode)(windows_core::Interface::as_raw(self), lpmode as _).ok() }
    }
    pub unsafe fn SetDrawBackgroundMode(&self, mode: AM_LINE21_DRAWBGMODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDrawBackgroundMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMLine21Decoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetDecoderLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_LINE21_CCLEVEL) -> windows_core::HRESULT,
    pub GetCurrentService: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_LINE21_CCSERVICE) -> windows_core::HRESULT,
    pub SetCurrentService: unsafe extern "system" fn(*mut core::ffi::c_void, AM_LINE21_CCSERVICE) -> windows_core::HRESULT,
    pub GetServiceState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_LINE21_CCSTATE) -> windows_core::HRESULT,
    pub SetServiceState: unsafe extern "system" fn(*mut core::ffi::c_void, AM_LINE21_CCSTATE) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetOutputFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetOutputFormat: usize,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub SetOutputFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    SetOutputFormat: usize,
    pub GetBackgroundColor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetBackgroundColor: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRedrawAlways: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetRedrawAlways: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetDrawBackgroundMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_LINE21_DRAWBGMODE) -> windows_core::HRESULT,
    pub SetDrawBackgroundMode: unsafe extern "system" fn(*mut core::ffi::c_void, AM_LINE21_DRAWBGMODE) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IAMLine21Decoder_Impl: windows_core::IUnknownImpl {
    fn GetDecoderLevel(&self, lplevel: *mut AM_LINE21_CCLEVEL) -> windows_core::Result<()>;
    fn GetCurrentService(&self, lpservice: *mut AM_LINE21_CCSERVICE) -> windows_core::Result<()>;
    fn SetCurrentService(&self, service: AM_LINE21_CCSERVICE) -> windows_core::Result<()>;
    fn GetServiceState(&self, lpstate: *mut AM_LINE21_CCSTATE) -> windows_core::Result<()>;
    fn SetServiceState(&self, state: AM_LINE21_CCSTATE) -> windows_core::Result<()>;
    fn GetOutputFormat(&self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::Result<()>;
    fn SetOutputFormat(&self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::Result<()>;
    fn GetBackgroundColor(&self, pdwphyscolor: *mut u32) -> windows_core::Result<()>;
    fn SetBackgroundColor(&self, dwphyscolor: u32) -> windows_core::Result<()>;
    fn GetRedrawAlways(&self, lpboption: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetRedrawAlways(&self, boption: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetDrawBackgroundMode(&self, lpmode: *mut AM_LINE21_DRAWBGMODE) -> windows_core::Result<()>;
    fn SetDrawBackgroundMode(&self, mode: AM_LINE21_DRAWBGMODE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IAMLine21Decoder_Vtbl {
    pub const fn new<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDecoderLevel<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplevel: *mut AM_LINE21_CCLEVEL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetDecoderLevel(this, core::mem::transmute_copy(&lplevel)).into()
            }
        }
        unsafe extern "system" fn GetCurrentService<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpservice: *mut AM_LINE21_CCSERVICE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetCurrentService(this, core::mem::transmute_copy(&lpservice)).into()
            }
        }
        unsafe extern "system" fn SetCurrentService<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, service: AM_LINE21_CCSERVICE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetCurrentService(this, core::mem::transmute_copy(&service)).into()
            }
        }
        unsafe extern "system" fn GetServiceState<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpstate: *mut AM_LINE21_CCSTATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetServiceState(this, core::mem::transmute_copy(&lpstate)).into()
            }
        }
        unsafe extern "system" fn SetServiceState<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: AM_LINE21_CCSTATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetServiceState(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn GetOutputFormat<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetOutputFormat(this, core::mem::transmute_copy(&lpbmih)).into()
            }
        }
        unsafe extern "system" fn SetOutputFormat<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetOutputFormat(this, core::mem::transmute_copy(&lpbmi)).into()
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwphyscolor: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetBackgroundColor(this, core::mem::transmute_copy(&pdwphyscolor)).into()
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwphyscolor: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetBackgroundColor(this, core::mem::transmute_copy(&dwphyscolor)).into()
            }
        }
        unsafe extern "system" fn GetRedrawAlways<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpboption: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetRedrawAlways(this, core::mem::transmute_copy(&lpboption)).into()
            }
        }
        unsafe extern "system" fn SetRedrawAlways<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, boption: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetRedrawAlways(this, core::mem::transmute_copy(&boption)).into()
            }
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpmode: *mut AM_LINE21_DRAWBGMODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::GetDrawBackgroundMode(this, core::mem::transmute_copy(&lpmode)).into()
            }
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Identity: IAMLine21Decoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: AM_LINE21_DRAWBGMODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMLine21Decoder_Impl::SetDrawBackgroundMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDecoderLevel: GetDecoderLevel::<Identity, OFFSET>,
            GetCurrentService: GetCurrentService::<Identity, OFFSET>,
            SetCurrentService: SetCurrentService::<Identity, OFFSET>,
            GetServiceState: GetServiceState::<Identity, OFFSET>,
            SetServiceState: SetServiceState::<Identity, OFFSET>,
            GetOutputFormat: GetOutputFormat::<Identity, OFFSET>,
            SetOutputFormat: SetOutputFormat::<Identity, OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Identity, OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Identity, OFFSET>,
            GetRedrawAlways: GetRedrawAlways::<Identity, OFFSET>,
            SetRedrawAlways: SetRedrawAlways::<Identity, OFFSET>,
            GetDrawBackgroundMode: GetDrawBackgroundMode::<Identity, OFFSET>,
            SetDrawBackgroundMode: SetDrawBackgroundMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMLine21Decoder as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IAMLine21Decoder {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMMediaContent, IAMMediaContent_Vtbl, 0xfa2aa8f4_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMMediaContent {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMMediaContent, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaContent {
    pub unsafe fn AuthorName(&self, pbstrauthorname: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AuthorName)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrauthorname)).ok() }
    }
    pub unsafe fn Title(&self, pbstrtitle: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Title)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrtitle)).ok() }
    }
    pub unsafe fn Rating(&self, pbstrrating: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Rating)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrrating)).ok() }
    }
    pub unsafe fn Description(&self, pbstrdescription: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Description)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrdescription)).ok() }
    }
    pub unsafe fn Copyright(&self, pbstrcopyright: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Copyright)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrcopyright)).ok() }
    }
    pub unsafe fn BaseURL(&self, pbstrbaseurl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BaseURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrbaseurl)).ok() }
    }
    pub unsafe fn LogoURL(&self, pbstrlogourl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LogoURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrlogourl)).ok() }
    }
    pub unsafe fn LogoIconURL(&self, pbstrlogourl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LogoIconURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrlogourl)).ok() }
    }
    pub unsafe fn WatermarkURL(&self, pbstrwatermarkurl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WatermarkURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrwatermarkurl)).ok() }
    }
    pub unsafe fn MoreInfoURL(&self, pbstrmoreinfourl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MoreInfoURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrmoreinfourl)).ok() }
    }
    pub unsafe fn MoreInfoBannerImage(&self, pbstrmoreinfobannerimage: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MoreInfoBannerImage)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrmoreinfobannerimage)).ok() }
    }
    pub unsafe fn MoreInfoBannerURL(&self, pbstrmoreinfobannerurl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MoreInfoBannerURL)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrmoreinfobannerurl)).ok() }
    }
    pub unsafe fn MoreInfoText(&self, pbstrmoreinfotext: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MoreInfoText)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrmoreinfotext)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMMediaContent_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub AuthorName: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Title: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Rating: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Description: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Copyright: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub BaseURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LogoURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LogoIconURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub WatermarkURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MoreInfoURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MoreInfoBannerImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MoreInfoBannerURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MoreInfoText: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMMediaContent_Impl: super::super::System::Com::IDispatch_Impl {
    fn AuthorName(&self, pbstrauthorname: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn Title(&self, pbstrtitle: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn Rating(&self, pbstrrating: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn Description(&self, pbstrdescription: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn Copyright(&self, pbstrcopyright: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn BaseURL(&self, pbstrbaseurl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn LogoURL(&self, pbstrlogourl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn LogoIconURL(&self, pbstrlogourl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn WatermarkURL(&self, pbstrwatermarkurl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn MoreInfoURL(&self, pbstrmoreinfourl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn MoreInfoBannerImage(&self, pbstrmoreinfobannerimage: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn MoreInfoBannerURL(&self, pbstrmoreinfobannerurl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn MoreInfoText(&self, pbstrmoreinfotext: *mut windows_core::BSTR) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMMediaContent_Vtbl {
    pub const fn new<Identity: IAMMediaContent_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AuthorName<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrauthorname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::AuthorName(this, core::mem::transmute_copy(&pbstrauthorname)).into()
            }
        }
        unsafe extern "system" fn Title<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrtitle: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::Title(this, core::mem::transmute_copy(&pbstrtitle)).into()
            }
        }
        unsafe extern "system" fn Rating<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrrating: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::Rating(this, core::mem::transmute_copy(&pbstrrating)).into()
            }
        }
        unsafe extern "system" fn Description<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrdescription: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::Description(this, core::mem::transmute_copy(&pbstrdescription)).into()
            }
        }
        unsafe extern "system" fn Copyright<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrcopyright: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::Copyright(this, core::mem::transmute_copy(&pbstrcopyright)).into()
            }
        }
        unsafe extern "system" fn BaseURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrbaseurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::BaseURL(this, core::mem::transmute_copy(&pbstrbaseurl)).into()
            }
        }
        unsafe extern "system" fn LogoURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrlogourl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::LogoURL(this, core::mem::transmute_copy(&pbstrlogourl)).into()
            }
        }
        unsafe extern "system" fn LogoIconURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrlogourl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::LogoIconURL(this, core::mem::transmute_copy(&pbstrlogourl)).into()
            }
        }
        unsafe extern "system" fn WatermarkURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrwatermarkurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::WatermarkURL(this, core::mem::transmute_copy(&pbstrwatermarkurl)).into()
            }
        }
        unsafe extern "system" fn MoreInfoURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrmoreinfourl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::MoreInfoURL(this, core::mem::transmute_copy(&pbstrmoreinfourl)).into()
            }
        }
        unsafe extern "system" fn MoreInfoBannerImage<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrmoreinfobannerimage: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::MoreInfoBannerImage(this, core::mem::transmute_copy(&pbstrmoreinfobannerimage)).into()
            }
        }
        unsafe extern "system" fn MoreInfoBannerURL<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrmoreinfobannerurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::MoreInfoBannerURL(this, core::mem::transmute_copy(&pbstrmoreinfobannerurl)).into()
            }
        }
        unsafe extern "system" fn MoreInfoText<Identity: IAMMediaContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrmoreinfotext: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent_Impl::MoreInfoText(this, core::mem::transmute_copy(&pbstrmoreinfotext)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            AuthorName: AuthorName::<Identity, OFFSET>,
            Title: Title::<Identity, OFFSET>,
            Rating: Rating::<Identity, OFFSET>,
            Description: Description::<Identity, OFFSET>,
            Copyright: Copyright::<Identity, OFFSET>,
            BaseURL: BaseURL::<Identity, OFFSET>,
            LogoURL: LogoURL::<Identity, OFFSET>,
            LogoIconURL: LogoIconURL::<Identity, OFFSET>,
            WatermarkURL: WatermarkURL::<Identity, OFFSET>,
            MoreInfoURL: MoreInfoURL::<Identity, OFFSET>,
            MoreInfoBannerImage: MoreInfoBannerImage::<Identity, OFFSET>,
            MoreInfoBannerURL: MoreInfoBannerURL::<Identity, OFFSET>,
            MoreInfoText: MoreInfoText::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMediaContent as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMMediaContent {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMMediaContent2, IAMMediaContent2_Vtbl, 0xce8f78c1_74d9_11d2_b09d_00a0c9a81117);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMMediaContent2 {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMMediaContent2, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaContent2 {
    pub unsafe fn get_MediaParameter(&self, entrynum: i32, bstrname: &windows_core::BSTR, pbstrvalue: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_MediaParameter)(windows_core::Interface::as_raw(self), entrynum, core::mem::transmute_copy(bstrname), core::mem::transmute(pbstrvalue)).ok() }
    }
    pub unsafe fn get_MediaParameterName(&self, entrynum: i32, index: i32, pbstrname: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_MediaParameterName)(windows_core::Interface::as_raw(self), entrynum, index, core::mem::transmute(pbstrname)).ok() }
    }
    pub unsafe fn PlaylistCount(&self, pnumberentries: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PlaylistCount)(windows_core::Interface::as_raw(self), pnumberentries as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMMediaContent2_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub get_MediaParameter: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub get_MediaParameterName: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlaylistCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMMediaContent2_Impl: super::super::System::Com::IDispatch_Impl {
    fn get_MediaParameter(&self, entrynum: i32, bstrname: &windows_core::BSTR, pbstrvalue: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn get_MediaParameterName(&self, entrynum: i32, index: i32, pbstrname: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn PlaylistCount(&self, pnumberentries: *mut i32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMMediaContent2_Vtbl {
    pub const fn new<Identity: IAMMediaContent2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_MediaParameter<Identity: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, entrynum: i32, bstrname: *mut core::ffi::c_void, pbstrvalue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent2_Impl::get_MediaParameter(this, core::mem::transmute_copy(&entrynum), core::mem::transmute(&bstrname), core::mem::transmute_copy(&pbstrvalue)).into()
            }
        }
        unsafe extern "system" fn get_MediaParameterName<Identity: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, entrynum: i32, index: i32, pbstrname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent2_Impl::get_MediaParameterName(this, core::mem::transmute_copy(&entrynum), core::mem::transmute_copy(&index), core::mem::transmute_copy(&pbstrname)).into()
            }
        }
        unsafe extern "system" fn PlaylistCount<Identity: IAMMediaContent2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnumberentries: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaContent2_Impl::PlaylistCount(this, core::mem::transmute_copy(&pnumberentries)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            get_MediaParameter: get_MediaParameter::<Identity, OFFSET>,
            get_MediaParameterName: get_MediaParameterName::<Identity, OFFSET>,
            PlaylistCount: PlaylistCount::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMediaContent2 as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMMediaContent2 {}
windows_core::imp::define_interface!(IAMMediaStream, IAMMediaStream_Vtbl, 0xbebe595d_9a6f_11d0_8fde_00c04fd9189d);
impl core::ops::Deref for IAMMediaStream {
    type Target = IMediaStream;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMMediaStream, windows_core::IUnknown, IMediaStream);
impl IAMMediaStream {
    pub unsafe fn Initialize<P0>(&self, psourceobject: P0, dwflags: u32, purposeid: *const windows_core::GUID, streamtype: STREAM_TYPE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).Initialize)(windows_core::Interface::as_raw(self), psourceobject.param().abi(), dwflags, purposeid, streamtype).ok() }
    }
    pub unsafe fn SetState(&self, state: FILTER_STATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetState)(windows_core::Interface::as_raw(self), state).ok() }
    }
    pub unsafe fn JoinAMMultiMediaStream<P0>(&self, pammultimediastream: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMMultiMediaStream>,
    {
        unsafe { (windows_core::Interface::vtable(self).JoinAMMultiMediaStream)(windows_core::Interface::as_raw(self), pammultimediastream.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn JoinFilter<P0>(&self, pmediastreamfilter: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaStreamFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).JoinFilter)(windows_core::Interface::as_raw(self), pmediastreamfilter.param().abi()).ok() }
    }
    pub unsafe fn JoinFilterGraph<P0>(&self, pfiltergraph: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IFilterGraph>,
    {
        unsafe { (windows_core::Interface::vtable(self).JoinFilterGraph)(windows_core::Interface::as_raw(self), pfiltergraph.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMMediaStream_Vtbl {
    pub base__: IMediaStream_Vtbl,
    pub Initialize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32, *const windows_core::GUID, STREAM_TYPE) -> windows_core::HRESULT,
    pub SetState: unsafe extern "system" fn(*mut core::ffi::c_void, FILTER_STATE) -> windows_core::HRESULT,
    pub JoinAMMultiMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub JoinFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    JoinFilter: usize,
    pub JoinFilterGraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMMediaStream_Impl: IMediaStream_Impl {
    fn Initialize(&self, psourceobject: windows_core::Ref<windows_core::IUnknown>, dwflags: u32, purposeid: *const windows_core::GUID, streamtype: STREAM_TYPE) -> windows_core::Result<()>;
    fn SetState(&self, state: FILTER_STATE) -> windows_core::Result<()>;
    fn JoinAMMultiMediaStream(&self, pammultimediastream: windows_core::Ref<IAMMultiMediaStream>) -> windows_core::Result<()>;
    fn JoinFilter(&self, pmediastreamfilter: windows_core::Ref<IMediaStreamFilter>) -> windows_core::Result<()>;
    fn JoinFilterGraph(&self, pfiltergraph: windows_core::Ref<IFilterGraph>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IAMMediaStream_Vtbl {
    pub const fn new<Identity: IAMMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Initialize<Identity: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourceobject: *mut core::ffi::c_void, dwflags: u32, purposeid: *const windows_core::GUID, streamtype: STREAM_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaStream_Impl::Initialize(this, core::mem::transmute_copy(&psourceobject), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&purposeid), core::mem::transmute_copy(&streamtype)).into()
            }
        }
        unsafe extern "system" fn SetState<Identity: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: FILTER_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaStream_Impl::SetState(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn JoinAMMultiMediaStream<Identity: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pammultimediastream: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaStream_Impl::JoinAMMultiMediaStream(this, core::mem::transmute_copy(&pammultimediastream)).into()
            }
        }
        unsafe extern "system" fn JoinFilter<Identity: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediastreamfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaStream_Impl::JoinFilter(this, core::mem::transmute_copy(&pmediastreamfilter)).into()
            }
        }
        unsafe extern "system" fn JoinFilterGraph<Identity: IAMMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfiltergraph: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaStream_Impl::JoinFilterGraph(this, core::mem::transmute_copy(&pfiltergraph)).into()
            }
        }
        Self {
            base__: IMediaStream_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            SetState: SetState::<Identity, OFFSET>,
            JoinAMMultiMediaStream: JoinAMMultiMediaStream::<Identity, OFFSET>,
            JoinFilter: JoinFilter::<Identity, OFFSET>,
            JoinFilterGraph: JoinFilterGraph::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMediaStream as windows_core::Interface>::IID || iid == &<IMediaStream as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IAMMediaStream {}
windows_core::imp::define_interface!(IAMMediaTypeSample, IAMMediaTypeSample_Vtbl, 0xab6b4afb_f6e4_11d0_900d_00c04fd9189d);
impl core::ops::Deref for IAMMediaTypeSample {
    type Target = IStreamSample;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMMediaTypeSample, windows_core::IUnknown, IStreamSample);
impl IAMMediaTypeSample {
    pub unsafe fn SetPointer(&self, pbuffer: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPointer)(windows_core::Interface::as_raw(self), core::mem::transmute(pbuffer.as_ptr()), pbuffer.len().try_into().unwrap()).ok() }
    }
    pub unsafe fn GetPointer(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPointer)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSize(&self) -> i32 {
        unsafe { (windows_core::Interface::vtable(self).GetSize)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn GetTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTime)(windows_core::Interface::as_raw(self), ptimestart as _, ptimeend as _).ok() }
    }
    pub unsafe fn SetTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTime)(windows_core::Interface::as_raw(self), ptimestart, ptimeend).ok() }
    }
    pub unsafe fn IsSyncPoint(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsSyncPoint)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SetSyncPoint(&self, bissyncpoint: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSyncPoint)(windows_core::Interface::as_raw(self), bissyncpoint.into()).ok() }
    }
    pub unsafe fn IsPreroll(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsPreroll)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SetPreroll(&self, bispreroll: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPreroll)(windows_core::Interface::as_raw(self), bispreroll.into()).ok() }
    }
    pub unsafe fn GetActualDataLength(&self) -> i32 {
        unsafe { (windows_core::Interface::vtable(self).GetActualDataLength)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn SetActualDataLength(&self, __midl__iammediatypesample0000: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetActualDataLength)(windows_core::Interface::as_raw(self), __midl__iammediatypesample0000).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetMediaType(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMediaType)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetMediaType(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaType)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype)).ok() }
    }
    pub unsafe fn IsDiscontinuity(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsDiscontinuity)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SetDiscontinuity(&self, bdiscontinuity: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDiscontinuity)(windows_core::Interface::as_raw(self), bdiscontinuity.into()).ok() }
    }
    pub unsafe fn GetMediaTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMediaTime)(windows_core::Interface::as_raw(self), ptimestart as _, ptimeend as _).ok() }
    }
    pub unsafe fn SetMediaTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaTime)(windows_core::Interface::as_raw(self), ptimestart, ptimeend).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMMediaTypeSample_Vtbl {
    pub base__: IStreamSample_Vtbl,
    pub SetPointer: unsafe extern "system" fn(*mut core::ffi::c_void, *const u8, i32) -> windows_core::HRESULT,
    pub GetPointer: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub GetSize: unsafe extern "system" fn(*mut core::ffi::c_void) -> i32,
    pub GetTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetTime: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
    pub IsSyncPoint: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetSyncPoint: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub IsPreroll: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetPreroll: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetActualDataLength: unsafe extern "system" fn(*mut core::ffi::c_void) -> i32,
    pub SetActualDataLength: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetMediaType: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetMediaType: usize,
    pub IsDiscontinuity: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetDiscontinuity: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetMediaTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetMediaTime: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IAMMediaTypeSample_Impl: IStreamSample_Impl {
    fn SetPointer(&self, pbuffer: *const u8, lsize: i32) -> windows_core::Result<()>;
    fn GetPointer(&self) -> windows_core::Result<*mut u8>;
    fn GetSize(&self) -> i32;
    fn GetTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()>;
    fn SetTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()>;
    fn IsSyncPoint(&self) -> windows_core::Result<()>;
    fn SetSyncPoint(&self, bissyncpoint: windows_core::BOOL) -> windows_core::Result<()>;
    fn IsPreroll(&self) -> windows_core::Result<()>;
    fn SetPreroll(&self, bispreroll: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetActualDataLength(&self) -> i32;
    fn SetActualDataLength(&self, __midl__iammediatypesample0000: i32) -> windows_core::Result<()>;
    fn GetMediaType(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE>;
    fn SetMediaType(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn IsDiscontinuity(&self) -> windows_core::Result<()>;
    fn SetDiscontinuity(&self, bdiscontinuity: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetMediaTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()>;
    fn SetMediaTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IAMMediaTypeSample_Vtbl {
    pub const fn new<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetPointer<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *const u8, lsize: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetPointer(this, core::mem::transmute_copy(&pbuffer), core::mem::transmute_copy(&lsize)).into()
            }
        }
        unsafe extern "system" fn GetPointer<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffer: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMediaTypeSample_Impl::GetPointer(this) {
                    Ok(ok__) => {
                        ppbuffer.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSize<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> i32 {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::GetSize(this)
            }
        }
        unsafe extern "system" fn GetTime<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::GetTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn SetTime<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn IsSyncPoint<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::IsSyncPoint(this).into()
            }
        }
        unsafe extern "system" fn SetSyncPoint<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bissyncpoint: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetSyncPoint(this, core::mem::transmute_copy(&bissyncpoint)).into()
            }
        }
        unsafe extern "system" fn IsPreroll<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::IsPreroll(this).into()
            }
        }
        unsafe extern "system" fn SetPreroll<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bispreroll: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetPreroll(this, core::mem::transmute_copy(&bispreroll)).into()
            }
        }
        unsafe extern "system" fn GetActualDataLength<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> i32 {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::GetActualDataLength(this)
            }
        }
        unsafe extern "system" fn SetActualDataLength<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__iammediatypesample0000: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetActualDataLength(this, core::mem::transmute_copy(&__midl__iammediatypesample0000)).into()
            }
        }
        unsafe extern "system" fn GetMediaType<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediatype: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMediaTypeSample_Impl::GetMediaType(this) {
                    Ok(ok__) => {
                        ppmediatype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMediaType<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetMediaType(this, core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn IsDiscontinuity<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::IsDiscontinuity(this).into()
            }
        }
        unsafe extern "system" fn SetDiscontinuity<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bdiscontinuity: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetDiscontinuity(this, core::mem::transmute_copy(&bdiscontinuity)).into()
            }
        }
        unsafe extern "system" fn GetMediaTime<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::GetMediaTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn SetMediaTime<Identity: IAMMediaTypeSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeSample_Impl::SetMediaTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        Self {
            base__: IStreamSample_Vtbl::new::<Identity, OFFSET>(),
            SetPointer: SetPointer::<Identity, OFFSET>,
            GetPointer: GetPointer::<Identity, OFFSET>,
            GetSize: GetSize::<Identity, OFFSET>,
            GetTime: GetTime::<Identity, OFFSET>,
            SetTime: SetTime::<Identity, OFFSET>,
            IsSyncPoint: IsSyncPoint::<Identity, OFFSET>,
            SetSyncPoint: SetSyncPoint::<Identity, OFFSET>,
            IsPreroll: IsPreroll::<Identity, OFFSET>,
            SetPreroll: SetPreroll::<Identity, OFFSET>,
            GetActualDataLength: GetActualDataLength::<Identity, OFFSET>,
            SetActualDataLength: SetActualDataLength::<Identity, OFFSET>,
            GetMediaType: GetMediaType::<Identity, OFFSET>,
            SetMediaType: SetMediaType::<Identity, OFFSET>,
            IsDiscontinuity: IsDiscontinuity::<Identity, OFFSET>,
            SetDiscontinuity: SetDiscontinuity::<Identity, OFFSET>,
            GetMediaTime: GetMediaTime::<Identity, OFFSET>,
            SetMediaTime: SetMediaTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMediaTypeSample as windows_core::Interface>::IID || iid == &<IStreamSample as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IAMMediaTypeSample {}
windows_core::imp::define_interface!(IAMMediaTypeStream, IAMMediaTypeStream_Vtbl, 0xab6b4afa_f6e4_11d0_900d_00c04fd9189d);
impl core::ops::Deref for IAMMediaTypeStream {
    type Target = IMediaStream;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMMediaTypeStream, windows_core::IUnknown, IMediaStream);
impl IAMMediaTypeStream {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetFormat(&self, pmediatype: *mut super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFormat)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype), dwflags).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetFormat(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFormat)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype), dwflags).ok() }
    }
    pub unsafe fn CreateSample<P3>(&self, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: P3) -> windows_core::Result<IAMMediaTypeSample>
    where
        P3: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateSample)(windows_core::Interface::as_raw(self), lsamplesize, pbbuffer, dwflags, punkouter.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetStreamAllocatorRequirements(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStreamAllocatorRequirements)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetStreamAllocatorRequirements(&self, pprops: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamAllocatorRequirements)(windows_core::Interface::as_raw(self), pprops).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMMediaTypeStream_Vtbl {
    pub base__: IMediaStream_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::MediaFoundation::AM_MEDIA_TYPE, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetFormat: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetFormat: usize,
    pub CreateSample: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *const u8, u32, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetStreamAllocatorRequirements: unsafe extern "system" fn(*mut core::ffi::c_void, *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
    pub SetStreamAllocatorRequirements: unsafe extern "system" fn(*mut core::ffi::c_void, *const ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IAMMediaTypeStream_Impl: IMediaStream_Impl {
    fn GetFormat(&self, pmediatype: *mut super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::Result<()>;
    fn SetFormat(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::Result<()>;
    fn CreateSample(&self, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<IAMMediaTypeSample>;
    fn GetStreamAllocatorRequirements(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES>;
    fn SetStreamAllocatorRequirements(&self, pprops: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IAMMediaTypeStream_Vtbl {
    pub const fn new<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFormat<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *mut super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeStream_Impl::GetFormat(this, core::mem::transmute_copy(&pmediatype), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn SetFormat<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeStream_Impl::SetFormat(this, core::mem::transmute_copy(&pmediatype), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn CreateSample<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lsamplesize: i32, pbbuffer: *const u8, dwflags: u32, punkouter: *mut core::ffi::c_void, ppammediatypesample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMediaTypeStream_Impl::CreateSample(this, core::mem::transmute_copy(&lsamplesize), core::mem::transmute_copy(&pbbuffer), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&punkouter)) {
                    Ok(ok__) => {
                        ppammediatypesample.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetStreamAllocatorRequirements<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMediaTypeStream_Impl::GetStreamAllocatorRequirements(this) {
                    Ok(ok__) => {
                        pprops.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStreamAllocatorRequirements<Identity: IAMMediaTypeStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprops: *const ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMediaTypeStream_Impl::SetStreamAllocatorRequirements(this, core::mem::transmute_copy(&pprops)).into()
            }
        }
        Self {
            base__: IMediaStream_Vtbl::new::<Identity, OFFSET>(),
            GetFormat: GetFormat::<Identity, OFFSET>,
            SetFormat: SetFormat::<Identity, OFFSET>,
            CreateSample: CreateSample::<Identity, OFFSET>,
            GetStreamAllocatorRequirements: GetStreamAllocatorRequirements::<Identity, OFFSET>,
            SetStreamAllocatorRequirements: SetStreamAllocatorRequirements::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMediaTypeStream as windows_core::Interface>::IID || iid == &<IMediaStream as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IAMMediaTypeStream {}
windows_core::imp::define_interface!(IAMMultiMediaStream, IAMMultiMediaStream_Vtbl, 0xbebe595c_9a6f_11d0_8fde_00c04fd9189d);
impl core::ops::Deref for IAMMultiMediaStream {
    type Target = IMultiMediaStream;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMMultiMediaStream, windows_core::IUnknown, IMultiMediaStream);
impl IAMMultiMediaStream {
    pub unsafe fn Initialize<P2>(&self, streamtype: STREAM_TYPE, dwflags: AMMSF_MMS_INIT_FLAGS, pfiltergraph: P2) -> windows_core::Result<()>
    where
        P2: windows_core::Param<IGraphBuilder>,
    {
        unsafe { (windows_core::Interface::vtable(self).Initialize)(windows_core::Interface::as_raw(self), streamtype, dwflags.0 as _, pfiltergraph.param().abi()).ok() }
    }
    pub unsafe fn GetFilterGraph(&self) -> windows_core::Result<IGraphBuilder> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFilterGraph)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetFilter(&self) -> windows_core::Result<IMediaStreamFilter> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFilter)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn AddMediaStream<P0>(&self, pstreamobject: P0, purposeid: *const windows_core::GUID, dwflags: AMMSF_MS_FLAGS) -> windows_core::Result<IMediaStream>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddMediaStream)(windows_core::Interface::as_raw(self), pstreamobject.param().abi(), purposeid, dwflags.0 as _, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn OpenFile<P0>(&self, pszfilename: P0, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).OpenFile)(windows_core::Interface::as_raw(self), pszfilename.param().abi(), dwflags).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn OpenMoniker<P0, P1>(&self, pctx: P0, pmoniker: P1, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::System::Com::IBindCtx>,
        P1: windows_core::Param<super::super::System::Com::IMoniker>,
    {
        unsafe { (windows_core::Interface::vtable(self).OpenMoniker)(windows_core::Interface::as_raw(self), pctx.param().abi(), pmoniker.param().abi(), dwflags).ok() }
    }
    pub unsafe fn Render(&self, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Render)(windows_core::Interface::as_raw(self), dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMMultiMediaStream_Vtbl {
    pub base__: IMultiMediaStream_Vtbl,
    pub Initialize: unsafe extern "system" fn(*mut core::ffi::c_void, STREAM_TYPE, u32, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetFilterGraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub GetFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    GetFilter: usize,
    pub AddMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const windows_core::GUID, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub OpenFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub OpenMoniker: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    OpenMoniker: usize,
    pub Render: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IAMMultiMediaStream_Impl: IMultiMediaStream_Impl {
    fn Initialize(&self, streamtype: STREAM_TYPE, dwflags: &AMMSF_MMS_INIT_FLAGS, pfiltergraph: windows_core::Ref<IGraphBuilder>) -> windows_core::Result<()>;
    fn GetFilterGraph(&self) -> windows_core::Result<IGraphBuilder>;
    fn GetFilter(&self) -> windows_core::Result<IMediaStreamFilter>;
    fn AddMediaStream(&self, pstreamobject: windows_core::Ref<windows_core::IUnknown>, purposeid: *const windows_core::GUID, dwflags: &AMMSF_MS_FLAGS) -> windows_core::Result<IMediaStream>;
    fn OpenFile(&self, pszfilename: &windows_core::PCWSTR, dwflags: u32) -> windows_core::Result<()>;
    fn OpenMoniker(&self, pctx: windows_core::Ref<super::super::System::Com::IBindCtx>, pmoniker: windows_core::Ref<super::super::System::Com::IMoniker>, dwflags: u32) -> windows_core::Result<()>;
    fn Render(&self, dwflags: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IAMMultiMediaStream_Vtbl {
    pub const fn new<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Initialize<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, streamtype: STREAM_TYPE, dwflags: u32, pfiltergraph: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMultiMediaStream_Impl::Initialize(this, core::mem::transmute_copy(&streamtype), core::mem::transmute(&dwflags), core::mem::transmute_copy(&pfiltergraph)).into()
            }
        }
        unsafe extern "system" fn GetFilterGraph<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppgraphbuilder: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMultiMediaStream_Impl::GetFilterGraph(this) {
                    Ok(ok__) => {
                        ppgraphbuilder.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetFilter<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppfilter: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMultiMediaStream_Impl::GetFilter(this) {
                    Ok(ok__) => {
                        ppfilter.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AddMediaStream<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstreamobject: *mut core::ffi::c_void, purposeid: *const windows_core::GUID, dwflags: u32, ppnewstream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMMultiMediaStream_Impl::AddMediaStream(this, core::mem::transmute_copy(&pstreamobject), core::mem::transmute_copy(&purposeid), core::mem::transmute(&dwflags)) {
                    Ok(ok__) => {
                        ppnewstream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn OpenFile<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszfilename: windows_core::PCWSTR, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMultiMediaStream_Impl::OpenFile(this, core::mem::transmute(&pszfilename), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn OpenMoniker<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pctx: *mut core::ffi::c_void, pmoniker: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMultiMediaStream_Impl::OpenMoniker(this, core::mem::transmute_copy(&pctx), core::mem::transmute_copy(&pmoniker), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn Render<Identity: IAMMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMMultiMediaStream_Impl::Render(this, core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self {
            base__: IMultiMediaStream_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            GetFilterGraph: GetFilterGraph::<Identity, OFFSET>,
            GetFilter: GetFilter::<Identity, OFFSET>,
            AddMediaStream: AddMediaStream::<Identity, OFFSET>,
            OpenFile: OpenFile::<Identity, OFFSET>,
            OpenMoniker: OpenMoniker::<Identity, OFFSET>,
            Render: Render::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMMultiMediaStream as windows_core::Interface>::IID || iid == &<IMultiMediaStream as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IAMMultiMediaStream {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMNetShowConfig, IAMNetShowConfig_Vtbl, 0xfa2aa8f1_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMNetShowConfig {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMNetShowConfig, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowConfig {
    pub unsafe fn BufferingTime(&self, pbufferingtime: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BufferingTime)(windows_core::Interface::as_raw(self), pbufferingtime as _).ok() }
    }
    pub unsafe fn SetBufferingTime(&self, bufferingtime: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBufferingTime)(windows_core::Interface::as_raw(self), bufferingtime).ok() }
    }
    pub unsafe fn UseFixedUDPPort(&self, pusefixedudpport: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UseFixedUDPPort)(windows_core::Interface::as_raw(self), pusefixedudpport as _).ok() }
    }
    pub unsafe fn SetUseFixedUDPPort(&self, usefixedudpport: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetUseFixedUDPPort)(windows_core::Interface::as_raw(self), usefixedudpport).ok() }
    }
    pub unsafe fn FixedUDPPort(&self, pfixedudpport: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FixedUDPPort)(windows_core::Interface::as_raw(self), pfixedudpport as _).ok() }
    }
    pub unsafe fn SetFixedUDPPort(&self, fixedudpport: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFixedUDPPort)(windows_core::Interface::as_raw(self), fixedudpport).ok() }
    }
    pub unsafe fn UseHTTPProxy(&self, pusehttpproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UseHTTPProxy)(windows_core::Interface::as_raw(self), pusehttpproxy as _).ok() }
    }
    pub unsafe fn SetUseHTTPProxy(&self, usehttpproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetUseHTTPProxy)(windows_core::Interface::as_raw(self), usehttpproxy).ok() }
    }
    pub unsafe fn EnableAutoProxy(&self, penableautoproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnableAutoProxy)(windows_core::Interface::as_raw(self), penableautoproxy as _).ok() }
    }
    pub unsafe fn SetEnableAutoProxy(&self, enableautoproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableAutoProxy)(windows_core::Interface::as_raw(self), enableautoproxy).ok() }
    }
    pub unsafe fn HTTPProxyHost(&self, pbstrhttpproxyhost: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HTTPProxyHost)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrhttpproxyhost)).ok() }
    }
    pub unsafe fn SetHTTPProxyHost(&self, bstrhttpproxyhost: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetHTTPProxyHost)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(bstrhttpproxyhost)).ok() }
    }
    pub unsafe fn HTTPProxyPort(&self, phttpproxyport: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HTTPProxyPort)(windows_core::Interface::as_raw(self), phttpproxyport as _).ok() }
    }
    pub unsafe fn SetHTTPProxyPort(&self, httpproxyport: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetHTTPProxyPort)(windows_core::Interface::as_raw(self), httpproxyport).ok() }
    }
    pub unsafe fn EnableMulticast(&self, penablemulticast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnableMulticast)(windows_core::Interface::as_raw(self), penablemulticast as _).ok() }
    }
    pub unsafe fn SetEnableMulticast(&self, enablemulticast: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableMulticast)(windows_core::Interface::as_raw(self), enablemulticast).ok() }
    }
    pub unsafe fn EnableUDP(&self, penableudp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnableUDP)(windows_core::Interface::as_raw(self), penableudp as _).ok() }
    }
    pub unsafe fn SetEnableUDP(&self, enableudp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableUDP)(windows_core::Interface::as_raw(self), enableudp).ok() }
    }
    pub unsafe fn EnableTCP(&self, penabletcp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnableTCP)(windows_core::Interface::as_raw(self), penabletcp as _).ok() }
    }
    pub unsafe fn SetEnableTCP(&self, enabletcp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableTCP)(windows_core::Interface::as_raw(self), enabletcp).ok() }
    }
    pub unsafe fn EnableHTTP(&self, penablehttp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnableHTTP)(windows_core::Interface::as_raw(self), penablehttp as _).ok() }
    }
    pub unsafe fn SetEnableHTTP(&self, enablehttp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableHTTP)(windows_core::Interface::as_raw(self), enablehttp).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMNetShowConfig_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub BufferingTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetBufferingTime: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub UseFixedUDPPort: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetUseFixedUDPPort: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub FixedUDPPort: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetFixedUDPPort: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub UseHTTPProxy: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetUseHTTPProxy: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub EnableAutoProxy: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetEnableAutoProxy: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub HTTPProxyHost: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetHTTPProxyHost: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub HTTPProxyPort: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetHTTPProxyPort: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub EnableMulticast: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetEnableMulticast: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub EnableUDP: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetEnableUDP: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub EnableTCP: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetEnableTCP: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub EnableHTTP: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub SetEnableHTTP: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMNetShowConfig_Impl: super::super::System::Com::IDispatch_Impl {
    fn BufferingTime(&self, pbufferingtime: *mut f64) -> windows_core::Result<()>;
    fn SetBufferingTime(&self, bufferingtime: f64) -> windows_core::Result<()>;
    fn UseFixedUDPPort(&self, pusefixedudpport: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetUseFixedUDPPort(&self, usefixedudpport: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn FixedUDPPort(&self, pfixedudpport: *mut i32) -> windows_core::Result<()>;
    fn SetFixedUDPPort(&self, fixedudpport: i32) -> windows_core::Result<()>;
    fn UseHTTPProxy(&self, pusehttpproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetUseHTTPProxy(&self, usehttpproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn EnableAutoProxy(&self, penableautoproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetEnableAutoProxy(&self, enableautoproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn HTTPProxyHost(&self, pbstrhttpproxyhost: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn SetHTTPProxyHost(&self, bstrhttpproxyhost: &windows_core::BSTR) -> windows_core::Result<()>;
    fn HTTPProxyPort(&self, phttpproxyport: *mut i32) -> windows_core::Result<()>;
    fn SetHTTPProxyPort(&self, httpproxyport: i32) -> windows_core::Result<()>;
    fn EnableMulticast(&self, penablemulticast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetEnableMulticast(&self, enablemulticast: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn EnableUDP(&self, penableudp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetEnableUDP(&self, enableudp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn EnableTCP(&self, penabletcp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetEnableTCP(&self, enabletcp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn EnableHTTP(&self, penablehttp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn SetEnableHTTP(&self, enablehttp: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMNetShowConfig_Vtbl {
    pub const fn new<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn BufferingTime<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbufferingtime: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::BufferingTime(this, core::mem::transmute_copy(&pbufferingtime)).into()
            }
        }
        unsafe extern "system" fn SetBufferingTime<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bufferingtime: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetBufferingTime(this, core::mem::transmute_copy(&bufferingtime)).into()
            }
        }
        unsafe extern "system" fn UseFixedUDPPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pusefixedudpport: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::UseFixedUDPPort(this, core::mem::transmute_copy(&pusefixedudpport)).into()
            }
        }
        unsafe extern "system" fn SetUseFixedUDPPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usefixedudpport: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetUseFixedUDPPort(this, core::mem::transmute_copy(&usefixedudpport)).into()
            }
        }
        unsafe extern "system" fn FixedUDPPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfixedudpport: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::FixedUDPPort(this, core::mem::transmute_copy(&pfixedudpport)).into()
            }
        }
        unsafe extern "system" fn SetFixedUDPPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fixedudpport: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetFixedUDPPort(this, core::mem::transmute_copy(&fixedudpport)).into()
            }
        }
        unsafe extern "system" fn UseHTTPProxy<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pusehttpproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::UseHTTPProxy(this, core::mem::transmute_copy(&pusehttpproxy)).into()
            }
        }
        unsafe extern "system" fn SetUseHTTPProxy<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usehttpproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetUseHTTPProxy(this, core::mem::transmute_copy(&usehttpproxy)).into()
            }
        }
        unsafe extern "system" fn EnableAutoProxy<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penableautoproxy: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::EnableAutoProxy(this, core::mem::transmute_copy(&penableautoproxy)).into()
            }
        }
        unsafe extern "system" fn SetEnableAutoProxy<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enableautoproxy: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetEnableAutoProxy(this, core::mem::transmute_copy(&enableautoproxy)).into()
            }
        }
        unsafe extern "system" fn HTTPProxyHost<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrhttpproxyhost: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::HTTPProxyHost(this, core::mem::transmute_copy(&pbstrhttpproxyhost)).into()
            }
        }
        unsafe extern "system" fn SetHTTPProxyHost<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrhttpproxyhost: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetHTTPProxyHost(this, core::mem::transmute(&bstrhttpproxyhost)).into()
            }
        }
        unsafe extern "system" fn HTTPProxyPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phttpproxyport: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::HTTPProxyPort(this, core::mem::transmute_copy(&phttpproxyport)).into()
            }
        }
        unsafe extern "system" fn SetHTTPProxyPort<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, httpproxyport: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetHTTPProxyPort(this, core::mem::transmute_copy(&httpproxyport)).into()
            }
        }
        unsafe extern "system" fn EnableMulticast<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penablemulticast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::EnableMulticast(this, core::mem::transmute_copy(&penablemulticast)).into()
            }
        }
        unsafe extern "system" fn SetEnableMulticast<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enablemulticast: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetEnableMulticast(this, core::mem::transmute_copy(&enablemulticast)).into()
            }
        }
        unsafe extern "system" fn EnableUDP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penableudp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::EnableUDP(this, core::mem::transmute_copy(&penableudp)).into()
            }
        }
        unsafe extern "system" fn SetEnableUDP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enableudp: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetEnableUDP(this, core::mem::transmute_copy(&enableudp)).into()
            }
        }
        unsafe extern "system" fn EnableTCP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penabletcp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::EnableTCP(this, core::mem::transmute_copy(&penabletcp)).into()
            }
        }
        unsafe extern "system" fn SetEnableTCP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enabletcp: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetEnableTCP(this, core::mem::transmute_copy(&enabletcp)).into()
            }
        }
        unsafe extern "system" fn EnableHTTP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penablehttp: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::EnableHTTP(this, core::mem::transmute_copy(&penablehttp)).into()
            }
        }
        unsafe extern "system" fn SetEnableHTTP<Identity: IAMNetShowConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enablehttp: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowConfig_Impl::SetEnableHTTP(this, core::mem::transmute_copy(&enablehttp)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            BufferingTime: BufferingTime::<Identity, OFFSET>,
            SetBufferingTime: SetBufferingTime::<Identity, OFFSET>,
            UseFixedUDPPort: UseFixedUDPPort::<Identity, OFFSET>,
            SetUseFixedUDPPort: SetUseFixedUDPPort::<Identity, OFFSET>,
            FixedUDPPort: FixedUDPPort::<Identity, OFFSET>,
            SetFixedUDPPort: SetFixedUDPPort::<Identity, OFFSET>,
            UseHTTPProxy: UseHTTPProxy::<Identity, OFFSET>,
            SetUseHTTPProxy: SetUseHTTPProxy::<Identity, OFFSET>,
            EnableAutoProxy: EnableAutoProxy::<Identity, OFFSET>,
            SetEnableAutoProxy: SetEnableAutoProxy::<Identity, OFFSET>,
            HTTPProxyHost: HTTPProxyHost::<Identity, OFFSET>,
            SetHTTPProxyHost: SetHTTPProxyHost::<Identity, OFFSET>,
            HTTPProxyPort: HTTPProxyPort::<Identity, OFFSET>,
            SetHTTPProxyPort: SetHTTPProxyPort::<Identity, OFFSET>,
            EnableMulticast: EnableMulticast::<Identity, OFFSET>,
            SetEnableMulticast: SetEnableMulticast::<Identity, OFFSET>,
            EnableUDP: EnableUDP::<Identity, OFFSET>,
            SetEnableUDP: SetEnableUDP::<Identity, OFFSET>,
            EnableTCP: EnableTCP::<Identity, OFFSET>,
            SetEnableTCP: SetEnableTCP::<Identity, OFFSET>,
            EnableHTTP: EnableHTTP::<Identity, OFFSET>,
            SetEnableHTTP: SetEnableHTTP::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMNetShowConfig as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMNetShowConfig {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMNetShowExProps, IAMNetShowExProps_Vtbl, 0xfa2aa8f5_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMNetShowExProps {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMNetShowExProps, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowExProps {
    pub unsafe fn SourceProtocol(&self, psourceprotocol: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SourceProtocol)(windows_core::Interface::as_raw(self), psourceprotocol as _).ok() }
    }
    pub unsafe fn Bandwidth(&self, pbandwidth: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Bandwidth)(windows_core::Interface::as_raw(self), pbandwidth as _).ok() }
    }
    pub unsafe fn ErrorCorrection(&self, pbstrerrorcorrection: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ErrorCorrection)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrerrorcorrection)).ok() }
    }
    pub unsafe fn CodecCount(&self, pcodeccount: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CodecCount)(windows_core::Interface::as_raw(self), pcodeccount as _).ok() }
    }
    pub unsafe fn GetCodecInstalled(&self, codecnum: i32, pcodecinstalled: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCodecInstalled)(windows_core::Interface::as_raw(self), codecnum, pcodecinstalled as _).ok() }
    }
    pub unsafe fn GetCodecDescription(&self, codecnum: i32, pbstrcodecdescription: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCodecDescription)(windows_core::Interface::as_raw(self), codecnum, core::mem::transmute(pbstrcodecdescription)).ok() }
    }
    pub unsafe fn GetCodecURL(&self, codecnum: i32, pbstrcodecurl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCodecURL)(windows_core::Interface::as_raw(self), codecnum, core::mem::transmute(pbstrcodecurl)).ok() }
    }
    pub unsafe fn CreationDate(&self, pcreationdate: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CreationDate)(windows_core::Interface::as_raw(self), pcreationdate as _).ok() }
    }
    pub unsafe fn SourceLink(&self, pbstrsourcelink: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SourceLink)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrsourcelink)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMNetShowExProps_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub SourceProtocol: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Bandwidth: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub ErrorCorrection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CodecCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetCodecInstalled: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub GetCodecDescription: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetCodecURL: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CreationDate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SourceLink: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMNetShowExProps_Impl: super::super::System::Com::IDispatch_Impl {
    fn SourceProtocol(&self, psourceprotocol: *mut i32) -> windows_core::Result<()>;
    fn Bandwidth(&self, pbandwidth: *mut i32) -> windows_core::Result<()>;
    fn ErrorCorrection(&self, pbstrerrorcorrection: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn CodecCount(&self, pcodeccount: *mut i32) -> windows_core::Result<()>;
    fn GetCodecInstalled(&self, codecnum: i32, pcodecinstalled: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn GetCodecDescription(&self, codecnum: i32, pbstrcodecdescription: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn GetCodecURL(&self, codecnum: i32, pbstrcodecurl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn CreationDate(&self, pcreationdate: *mut f64) -> windows_core::Result<()>;
    fn SourceLink(&self, pbstrsourcelink: *mut windows_core::BSTR) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMNetShowExProps_Vtbl {
    pub const fn new<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SourceProtocol<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourceprotocol: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::SourceProtocol(this, core::mem::transmute_copy(&psourceprotocol)).into()
            }
        }
        unsafe extern "system" fn Bandwidth<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbandwidth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::Bandwidth(this, core::mem::transmute_copy(&pbandwidth)).into()
            }
        }
        unsafe extern "system" fn ErrorCorrection<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrerrorcorrection: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::ErrorCorrection(this, core::mem::transmute_copy(&pbstrerrorcorrection)).into()
            }
        }
        unsafe extern "system" fn CodecCount<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcodeccount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::CodecCount(this, core::mem::transmute_copy(&pcodeccount)).into()
            }
        }
        unsafe extern "system" fn GetCodecInstalled<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, codecnum: i32, pcodecinstalled: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::GetCodecInstalled(this, core::mem::transmute_copy(&codecnum), core::mem::transmute_copy(&pcodecinstalled)).into()
            }
        }
        unsafe extern "system" fn GetCodecDescription<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, codecnum: i32, pbstrcodecdescription: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::GetCodecDescription(this, core::mem::transmute_copy(&codecnum), core::mem::transmute_copy(&pbstrcodecdescription)).into()
            }
        }
        unsafe extern "system" fn GetCodecURL<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, codecnum: i32, pbstrcodecurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::GetCodecURL(this, core::mem::transmute_copy(&codecnum), core::mem::transmute_copy(&pbstrcodecurl)).into()
            }
        }
        unsafe extern "system" fn CreationDate<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcreationdate: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::CreationDate(this, core::mem::transmute_copy(&pcreationdate)).into()
            }
        }
        unsafe extern "system" fn SourceLink<Identity: IAMNetShowExProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrsourcelink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowExProps_Impl::SourceLink(this, core::mem::transmute_copy(&pbstrsourcelink)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            SourceProtocol: SourceProtocol::<Identity, OFFSET>,
            Bandwidth: Bandwidth::<Identity, OFFSET>,
            ErrorCorrection: ErrorCorrection::<Identity, OFFSET>,
            CodecCount: CodecCount::<Identity, OFFSET>,
            GetCodecInstalled: GetCodecInstalled::<Identity, OFFSET>,
            GetCodecDescription: GetCodecDescription::<Identity, OFFSET>,
            GetCodecURL: GetCodecURL::<Identity, OFFSET>,
            CreationDate: CreationDate::<Identity, OFFSET>,
            SourceLink: SourceLink::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMNetShowExProps as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMNetShowExProps {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMNetShowPreroll, IAMNetShowPreroll_Vtbl, 0xaae7e4e2_6388_11d1_8d93_006097c9a2b2);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMNetShowPreroll {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMNetShowPreroll, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMNetShowPreroll {
    pub unsafe fn SetPreroll(&self, fpreroll: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPreroll)(windows_core::Interface::as_raw(self), fpreroll).ok() }
    }
    pub unsafe fn Preroll(&self, pfpreroll: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Preroll)(windows_core::Interface::as_raw(self), pfpreroll as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMNetShowPreroll_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub SetPreroll: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub Preroll: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMNetShowPreroll_Impl: super::super::System::Com::IDispatch_Impl {
    fn SetPreroll(&self, fpreroll: super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn Preroll(&self, pfpreroll: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMNetShowPreroll_Vtbl {
    pub const fn new<Identity: IAMNetShowPreroll_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetPreroll<Identity: IAMNetShowPreroll_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fpreroll: super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowPreroll_Impl::SetPreroll(this, core::mem::transmute_copy(&fpreroll)).into()
            }
        }
        unsafe extern "system" fn Preroll<Identity: IAMNetShowPreroll_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfpreroll: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetShowPreroll_Impl::Preroll(this, core::mem::transmute_copy(&pfpreroll)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            SetPreroll: SetPreroll::<Identity, OFFSET>,
            Preroll: Preroll::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMNetShowPreroll as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMNetShowPreroll {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMNetworkStatus, IAMNetworkStatus_Vtbl, 0xfa2aa8f3_8b62_11d0_a520_000000000000);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMNetworkStatus {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMNetworkStatus, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMNetworkStatus {
    pub unsafe fn ReceivedPackets(&self, preceivedpackets: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReceivedPackets)(windows_core::Interface::as_raw(self), preceivedpackets as _).ok() }
    }
    pub unsafe fn RecoveredPackets(&self, precoveredpackets: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RecoveredPackets)(windows_core::Interface::as_raw(self), precoveredpackets as _).ok() }
    }
    pub unsafe fn LostPackets(&self, plostpackets: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LostPackets)(windows_core::Interface::as_raw(self), plostpackets as _).ok() }
    }
    pub unsafe fn ReceptionQuality(&self, preceptionquality: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReceptionQuality)(windows_core::Interface::as_raw(self), preceptionquality as _).ok() }
    }
    pub unsafe fn BufferingCount(&self, pbufferingcount: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BufferingCount)(windows_core::Interface::as_raw(self), pbufferingcount as _).ok() }
    }
    pub unsafe fn IsBroadcast(&self, pisbroadcast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsBroadcast)(windows_core::Interface::as_raw(self), pisbroadcast as _).ok() }
    }
    pub unsafe fn BufferingProgress(&self, pbufferingprogress: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BufferingProgress)(windows_core::Interface::as_raw(self), pbufferingprogress as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMNetworkStatus_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub ReceivedPackets: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub RecoveredPackets: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub LostPackets: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub ReceptionQuality: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub BufferingCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub IsBroadcast: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub BufferingProgress: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMNetworkStatus_Impl: super::super::System::Com::IDispatch_Impl {
    fn ReceivedPackets(&self, preceivedpackets: *mut i32) -> windows_core::Result<()>;
    fn RecoveredPackets(&self, precoveredpackets: *mut i32) -> windows_core::Result<()>;
    fn LostPackets(&self, plostpackets: *mut i32) -> windows_core::Result<()>;
    fn ReceptionQuality(&self, preceptionquality: *mut i32) -> windows_core::Result<()>;
    fn BufferingCount(&self, pbufferingcount: *mut i32) -> windows_core::Result<()>;
    fn IsBroadcast(&self, pisbroadcast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn BufferingProgress(&self, pbufferingprogress: *mut i32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMNetworkStatus_Vtbl {
    pub const fn new<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ReceivedPackets<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, preceivedpackets: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::ReceivedPackets(this, core::mem::transmute_copy(&preceivedpackets)).into()
            }
        }
        unsafe extern "system" fn RecoveredPackets<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, precoveredpackets: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::RecoveredPackets(this, core::mem::transmute_copy(&precoveredpackets)).into()
            }
        }
        unsafe extern "system" fn LostPackets<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plostpackets: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::LostPackets(this, core::mem::transmute_copy(&plostpackets)).into()
            }
        }
        unsafe extern "system" fn ReceptionQuality<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, preceptionquality: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::ReceptionQuality(this, core::mem::transmute_copy(&preceptionquality)).into()
            }
        }
        unsafe extern "system" fn BufferingCount<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbufferingcount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::BufferingCount(this, core::mem::transmute_copy(&pbufferingcount)).into()
            }
        }
        unsafe extern "system" fn IsBroadcast<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pisbroadcast: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::IsBroadcast(this, core::mem::transmute_copy(&pisbroadcast)).into()
            }
        }
        unsafe extern "system" fn BufferingProgress<Identity: IAMNetworkStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbufferingprogress: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMNetworkStatus_Impl::BufferingProgress(this, core::mem::transmute_copy(&pbufferingprogress)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            ReceivedPackets: ReceivedPackets::<Identity, OFFSET>,
            RecoveredPackets: RecoveredPackets::<Identity, OFFSET>,
            LostPackets: LostPackets::<Identity, OFFSET>,
            ReceptionQuality: ReceptionQuality::<Identity, OFFSET>,
            BufferingCount: BufferingCount::<Identity, OFFSET>,
            IsBroadcast: IsBroadcast::<Identity, OFFSET>,
            BufferingProgress: BufferingProgress::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMNetworkStatus as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMNetworkStatus {}
windows_core::imp::define_interface!(IAMOpenProgress, IAMOpenProgress_Vtbl, 0x8e1c39a1_de53_11cf_aa63_0080c744528d);
windows_core::imp::interface_hierarchy!(IAMOpenProgress, windows_core::IUnknown);
impl IAMOpenProgress {
    pub unsafe fn QueryProgress(&self, plltotal: *mut i64, pllcurrent: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryProgress)(windows_core::Interface::as_raw(self), plltotal as _, pllcurrent as _).ok() }
    }
    pub unsafe fn AbortOperation(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AbortOperation)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMOpenProgress_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryProgress: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub AbortOperation: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMOpenProgress_Impl: windows_core::IUnknownImpl {
    fn QueryProgress(&self, plltotal: *mut i64, pllcurrent: *mut i64) -> windows_core::Result<()>;
    fn AbortOperation(&self) -> windows_core::Result<()>;
}
impl IAMOpenProgress_Vtbl {
    pub const fn new<Identity: IAMOpenProgress_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryProgress<Identity: IAMOpenProgress_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plltotal: *mut i64, pllcurrent: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMOpenProgress_Impl::QueryProgress(this, core::mem::transmute_copy(&plltotal), core::mem::transmute_copy(&pllcurrent)).into()
            }
        }
        unsafe extern "system" fn AbortOperation<Identity: IAMOpenProgress_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMOpenProgress_Impl::AbortOperation(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryProgress: QueryProgress::<Identity, OFFSET>,
            AbortOperation: AbortOperation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMOpenProgress as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMOpenProgress {}
windows_core::imp::define_interface!(IAMOverlayFX, IAMOverlayFX_Vtbl, 0x62fae250_7e65_4460_bfc9_6398b322073c);
windows_core::imp::interface_hierarchy!(IAMOverlayFX, windows_core::IUnknown);
impl IAMOverlayFX {
    pub unsafe fn QueryOverlayFXCaps(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryOverlayFXCaps)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOverlayFX(&self, dwoverlayfx: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOverlayFX)(windows_core::Interface::as_raw(self), dwoverlayfx).ok() }
    }
    pub unsafe fn GetOverlayFX(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetOverlayFX)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMOverlayFX_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryOverlayFXCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetOverlayFX: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetOverlayFX: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMOverlayFX_Impl: windows_core::IUnknownImpl {
    fn QueryOverlayFXCaps(&self) -> windows_core::Result<u32>;
    fn SetOverlayFX(&self, dwoverlayfx: u32) -> windows_core::Result<()>;
    fn GetOverlayFX(&self) -> windows_core::Result<u32>;
}
impl IAMOverlayFX_Vtbl {
    pub const fn new<Identity: IAMOverlayFX_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryOverlayFXCaps<Identity: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwoverlayfxcaps: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMOverlayFX_Impl::QueryOverlayFXCaps(this) {
                    Ok(ok__) => {
                        lpdwoverlayfxcaps.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOverlayFX<Identity: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoverlayfx: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMOverlayFX_Impl::SetOverlayFX(this, core::mem::transmute_copy(&dwoverlayfx)).into()
            }
        }
        unsafe extern "system" fn GetOverlayFX<Identity: IAMOverlayFX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwoverlayfx: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMOverlayFX_Impl::GetOverlayFX(this) {
                    Ok(ok__) => {
                        lpdwoverlayfx.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryOverlayFXCaps: QueryOverlayFXCaps::<Identity, OFFSET>,
            SetOverlayFX: SetOverlayFX::<Identity, OFFSET>,
            GetOverlayFX: GetOverlayFX::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMOverlayFX as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMOverlayFX {}
windows_core::imp::define_interface!(IAMParse, IAMParse_Vtbl, 0xc47a3420_005c_11d2_9038_00a0c9697298);
windows_core::imp::interface_hierarchy!(IAMParse, windows_core::IUnknown);
impl IAMParse {
    pub unsafe fn GetParseTime(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetParseTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetParseTime(&self, rtcurrent: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetParseTime)(windows_core::Interface::as_raw(self), rtcurrent).ok() }
    }
    pub unsafe fn Flush(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Flush)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMParse_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetParseTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub SetParseTime: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub Flush: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMParse_Impl: windows_core::IUnknownImpl {
    fn GetParseTime(&self) -> windows_core::Result<i64>;
    fn SetParseTime(&self, rtcurrent: i64) -> windows_core::Result<()>;
    fn Flush(&self) -> windows_core::Result<()>;
}
impl IAMParse_Vtbl {
    pub const fn new<Identity: IAMParse_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetParseTime<Identity: IAMParse_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtcurrent: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMParse_Impl::GetParseTime(this) {
                    Ok(ok__) => {
                        prtcurrent.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetParseTime<Identity: IAMParse_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rtcurrent: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMParse_Impl::SetParseTime(this, core::mem::transmute_copy(&rtcurrent)).into()
            }
        }
        unsafe extern "system" fn Flush<Identity: IAMParse_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMParse_Impl::Flush(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetParseTime: GetParseTime::<Identity, OFFSET>,
            SetParseTime: SetParseTime::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMParse as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMParse {}
windows_core::imp::define_interface!(IAMPhysicalPinInfo, IAMPhysicalPinInfo_Vtbl, 0xf938c991_3029_11cf_8c44_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMPhysicalPinInfo, windows_core::IUnknown);
impl IAMPhysicalPinInfo {
    pub unsafe fn GetPhysicalType(&self, ptype: *mut i32, ppsztype: *mut windows_core::PWSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPhysicalType)(windows_core::Interface::as_raw(self), ptype as _, ppsztype as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMPhysicalPinInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetPhysicalType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut windows_core::PWSTR) -> windows_core::HRESULT,
}
pub trait IAMPhysicalPinInfo_Impl: windows_core::IUnknownImpl {
    fn GetPhysicalType(&self, ptype: *mut i32, ppsztype: *mut windows_core::PWSTR) -> windows_core::Result<()>;
}
impl IAMPhysicalPinInfo_Vtbl {
    pub const fn new<Identity: IAMPhysicalPinInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPhysicalType<Identity: IAMPhysicalPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *mut i32, ppsztype: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPhysicalPinInfo_Impl::GetPhysicalType(this, core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&ppsztype)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetPhysicalType: GetPhysicalType::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMPhysicalPinInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMPhysicalPinInfo {}
windows_core::imp::define_interface!(IAMPlayList, IAMPlayList_Vtbl, 0x56a868fe_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IAMPlayList, windows_core::IUnknown);
impl IAMPlayList {
    pub unsafe fn GetFlags(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFlags)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetItemCount(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetItemCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetItem(&self, dwitemindex: u32) -> windows_core::Result<IAMPlayListItem> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetItem)(windows_core::Interface::as_raw(self), dwitemindex, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetNamedEvent<P0>(&self, pwszeventname: P0, dwitemindex: u32, ppitem: *mut Option<IAMPlayListItem>, pdwflags: *mut u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).GetNamedEvent)(windows_core::Interface::as_raw(self), pwszeventname.param().abi(), dwitemindex, core::mem::transmute(ppitem), pdwflags as _).ok() }
    }
    pub unsafe fn GetRepeatInfo(&self, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRepeatInfo)(windows_core::Interface::as_raw(self), pdwrepeatcount as _, pdwrepeatstart as _, pdwrepeatend as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMPlayList_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetItemCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetItem: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetNamedEvent: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, u32, *mut *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetRepeatInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
}
pub trait IAMPlayList_Impl: windows_core::IUnknownImpl {
    fn GetFlags(&self) -> windows_core::Result<u32>;
    fn GetItemCount(&self) -> windows_core::Result<u32>;
    fn GetItem(&self, dwitemindex: u32) -> windows_core::Result<IAMPlayListItem>;
    fn GetNamedEvent(&self, pwszeventname: &windows_core::PCWSTR, dwitemindex: u32, ppitem: windows_core::OutRef<IAMPlayListItem>, pdwflags: *mut u32) -> windows_core::Result<()>;
    fn GetRepeatInfo(&self, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> windows_core::Result<()>;
}
impl IAMPlayList_Vtbl {
    pub const fn new<Identity: IAMPlayList_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFlags<Identity: IAMPlayList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayList_Impl::GetFlags(this) {
                    Ok(ok__) => {
                        pdwflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetItemCount<Identity: IAMPlayList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwitems: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayList_Impl::GetItemCount(this) {
                    Ok(ok__) => {
                        pdwitems.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetItem<Identity: IAMPlayList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwitemindex: u32, ppitem: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayList_Impl::GetItem(this, core::mem::transmute_copy(&dwitemindex)) {
                    Ok(ok__) => {
                        ppitem.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetNamedEvent<Identity: IAMPlayList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszeventname: windows_core::PCWSTR, dwitemindex: u32, ppitem: *mut *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPlayList_Impl::GetNamedEvent(this, core::mem::transmute(&pwszeventname), core::mem::transmute_copy(&dwitemindex), core::mem::transmute_copy(&ppitem), core::mem::transmute_copy(&pdwflags)).into()
            }
        }
        unsafe extern "system" fn GetRepeatInfo<Identity: IAMPlayList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrepeatcount: *mut u32, pdwrepeatstart: *mut u32, pdwrepeatend: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPlayList_Impl::GetRepeatInfo(this, core::mem::transmute_copy(&pdwrepeatcount), core::mem::transmute_copy(&pdwrepeatstart), core::mem::transmute_copy(&pdwrepeatend)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFlags: GetFlags::<Identity, OFFSET>,
            GetItemCount: GetItemCount::<Identity, OFFSET>,
            GetItem: GetItem::<Identity, OFFSET>,
            GetNamedEvent: GetNamedEvent::<Identity, OFFSET>,
            GetRepeatInfo: GetRepeatInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMPlayList as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMPlayList {}
windows_core::imp::define_interface!(IAMPlayListItem, IAMPlayListItem_Vtbl, 0x56a868ff_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IAMPlayListItem, windows_core::IUnknown);
impl IAMPlayListItem {
    pub unsafe fn GetFlags(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFlags)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceCount(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceURL(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceURL)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetSourceStart(&self, dwsourceindex: u32) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceStart)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceDuration(&self, dwsourceindex: u32) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceDuration)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceStartMarker(&self, dwsourceindex: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceStartMarker)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceEndMarker(&self, dwsourceindex: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceEndMarker)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSourceStartMarkerName(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceStartMarkerName)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetSourceEndMarkerName(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSourceEndMarkerName)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetLinkURL(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetLinkURL)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetScanDuration(&self, dwsourceindex: u32) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetScanDuration)(windows_core::Interface::as_raw(self), dwsourceindex, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMPlayListItem_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetSourceCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetSourceURL: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetSourceStart: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut i64) -> windows_core::HRESULT,
    pub GetSourceDuration: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut i64) -> windows_core::HRESULT,
    pub GetSourceStartMarker: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetSourceEndMarker: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetSourceStartMarkerName: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetSourceEndMarkerName: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetLinkURL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetScanDuration: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut i64) -> windows_core::HRESULT,
}
pub trait IAMPlayListItem_Impl: windows_core::IUnknownImpl {
    fn GetFlags(&self) -> windows_core::Result<u32>;
    fn GetSourceCount(&self) -> windows_core::Result<u32>;
    fn GetSourceURL(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetSourceStart(&self, dwsourceindex: u32) -> windows_core::Result<i64>;
    fn GetSourceDuration(&self, dwsourceindex: u32) -> windows_core::Result<i64>;
    fn GetSourceStartMarker(&self, dwsourceindex: u32) -> windows_core::Result<u32>;
    fn GetSourceEndMarker(&self, dwsourceindex: u32) -> windows_core::Result<u32>;
    fn GetSourceStartMarkerName(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetSourceEndMarkerName(&self, dwsourceindex: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetLinkURL(&self) -> windows_core::Result<windows_core::BSTR>;
    fn GetScanDuration(&self, dwsourceindex: u32) -> windows_core::Result<i64>;
}
impl IAMPlayListItem_Vtbl {
    pub const fn new<Identity: IAMPlayListItem_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFlags<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetFlags(this) {
                    Ok(ok__) => {
                        pdwflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceCount<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwsources: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceCount(this) {
                    Ok(ok__) => {
                        pdwsources.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceURL<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, pbstrurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceURL(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        pbstrurl.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceStart<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, prtstart: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceStart(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        prtstart.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceDuration<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, prtduration: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceDuration(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        prtduration.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceStartMarker<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceStartMarker(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        pdwmarker.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceEndMarker<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, pdwmarker: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceEndMarker(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        pdwmarker.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceStartMarkerName<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, pbstrstartmarker: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceStartMarkerName(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        pbstrstartmarker.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSourceEndMarkerName<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, pbstrendmarker: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetSourceEndMarkerName(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        pbstrendmarker.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetLinkURL<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetLinkURL(this) {
                    Ok(ok__) => {
                        pbstrurl.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetScanDuration<Identity: IAMPlayListItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourceindex: u32, prtscanduration: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPlayListItem_Impl::GetScanDuration(this, core::mem::transmute_copy(&dwsourceindex)) {
                    Ok(ok__) => {
                        prtscanduration.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFlags: GetFlags::<Identity, OFFSET>,
            GetSourceCount: GetSourceCount::<Identity, OFFSET>,
            GetSourceURL: GetSourceURL::<Identity, OFFSET>,
            GetSourceStart: GetSourceStart::<Identity, OFFSET>,
            GetSourceDuration: GetSourceDuration::<Identity, OFFSET>,
            GetSourceStartMarker: GetSourceStartMarker::<Identity, OFFSET>,
            GetSourceEndMarker: GetSourceEndMarker::<Identity, OFFSET>,
            GetSourceStartMarkerName: GetSourceStartMarkerName::<Identity, OFFSET>,
            GetSourceEndMarkerName: GetSourceEndMarkerName::<Identity, OFFSET>,
            GetLinkURL: GetLinkURL::<Identity, OFFSET>,
            GetScanDuration: GetScanDuration::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMPlayListItem as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMPlayListItem {}
windows_core::imp::define_interface!(IAMPluginControl, IAMPluginControl_Vtbl, 0x0e26a181_f40c_4635_8786_976284b52981);
windows_core::imp::interface_hierarchy!(IAMPluginControl, windows_core::IUnknown);
impl IAMPluginControl {
    pub unsafe fn GetPreferredClsid(&self, subtype: *const windows_core::GUID) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPreferredClsid)(windows_core::Interface::as_raw(self), subtype, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetPreferredClsidByIndex(&self, index: u32, subtype: *mut windows_core::GUID, clsid: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPreferredClsidByIndex)(windows_core::Interface::as_raw(self), index, subtype as _, clsid as _).ok() }
    }
    pub unsafe fn SetPreferredClsid(&self, subtype: *const windows_core::GUID, clsid: Option<*const windows_core::GUID>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPreferredClsid)(windows_core::Interface::as_raw(self), subtype, clsid.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn IsDisabled(&self, clsid: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsDisabled)(windows_core::Interface::as_raw(self), clsid).ok() }
    }
    pub unsafe fn GetDisabledByIndex(&self, index: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDisabledByIndex)(windows_core::Interface::as_raw(self), index, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDisabled(&self, clsid: *const windows_core::GUID, disabled: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDisabled)(windows_core::Interface::as_raw(self), clsid, disabled.into()).ok() }
    }
    pub unsafe fn IsLegacyDisabled<P0>(&self, dllname: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).IsLegacyDisabled)(windows_core::Interface::as_raw(self), dllname.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMPluginControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetPreferredClsid: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetPreferredClsidByIndex: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetPreferredClsid: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const windows_core::GUID) -> windows_core::HRESULT,
    pub IsDisabled: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetDisabledByIndex: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetDisabled: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, windows_core::BOOL) -> windows_core::HRESULT,
    pub IsLegacyDisabled: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
}
pub trait IAMPluginControl_Impl: windows_core::IUnknownImpl {
    fn GetPreferredClsid(&self, subtype: *const windows_core::GUID) -> windows_core::Result<windows_core::GUID>;
    fn GetPreferredClsidByIndex(&self, index: u32, subtype: *mut windows_core::GUID, clsid: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn SetPreferredClsid(&self, subtype: *const windows_core::GUID, clsid: *const windows_core::GUID) -> windows_core::Result<()>;
    fn IsDisabled(&self, clsid: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDisabledByIndex(&self, index: u32) -> windows_core::Result<windows_core::GUID>;
    fn SetDisabled(&self, clsid: *const windows_core::GUID, disabled: windows_core::BOOL) -> windows_core::Result<()>;
    fn IsLegacyDisabled(&self, dllname: &windows_core::PCWSTR) -> windows_core::Result<()>;
}
impl IAMPluginControl_Vtbl {
    pub const fn new<Identity: IAMPluginControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPreferredClsid<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, subtype: *const windows_core::GUID, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPluginControl_Impl::GetPreferredClsid(this, core::mem::transmute_copy(&subtype)) {
                    Ok(ok__) => {
                        clsid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, subtype: *mut windows_core::GUID, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPluginControl_Impl::GetPreferredClsidByIndex(this, core::mem::transmute_copy(&index), core::mem::transmute_copy(&subtype), core::mem::transmute_copy(&clsid)).into()
            }
        }
        unsafe extern "system" fn SetPreferredClsid<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, subtype: *const windows_core::GUID, clsid: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPluginControl_Impl::SetPreferredClsid(this, core::mem::transmute_copy(&subtype), core::mem::transmute_copy(&clsid)).into()
            }
        }
        unsafe extern "system" fn IsDisabled<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPluginControl_Impl::IsDisabled(this, core::mem::transmute_copy(&clsid)).into()
            }
        }
        unsafe extern "system" fn GetDisabledByIndex<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPluginControl_Impl::GetDisabledByIndex(this, core::mem::transmute_copy(&index)) {
                    Ok(ok__) => {
                        clsid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDisabled<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, disabled: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPluginControl_Impl::SetDisabled(this, core::mem::transmute_copy(&clsid), core::mem::transmute_copy(&disabled)).into()
            }
        }
        unsafe extern "system" fn IsLegacyDisabled<Identity: IAMPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dllname: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPluginControl_Impl::IsLegacyDisabled(this, core::mem::transmute(&dllname)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPreferredClsid: GetPreferredClsid::<Identity, OFFSET>,
            GetPreferredClsidByIndex: GetPreferredClsidByIndex::<Identity, OFFSET>,
            SetPreferredClsid: SetPreferredClsid::<Identity, OFFSET>,
            IsDisabled: IsDisabled::<Identity, OFFSET>,
            GetDisabledByIndex: GetDisabledByIndex::<Identity, OFFSET>,
            SetDisabled: SetDisabled::<Identity, OFFSET>,
            IsLegacyDisabled: IsLegacyDisabled::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMPluginControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMPluginControl {}
windows_core::imp::define_interface!(IAMPushSource, IAMPushSource_Vtbl, 0xf185fe76_e64e_11d2_b76e_00c04fb6bd3d);
impl core::ops::Deref for IAMPushSource {
    type Target = IAMLatency;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMPushSource, windows_core::IUnknown, IAMLatency);
impl IAMPushSource {
    pub unsafe fn GetPushSourceFlags(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPushSourceFlags)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetPushSourceFlags(&self, flags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPushSourceFlags)(windows_core::Interface::as_raw(self), flags).ok() }
    }
    pub unsafe fn SetStreamOffset(&self, rtoffset: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamOffset)(windows_core::Interface::as_raw(self), rtoffset).ok() }
    }
    pub unsafe fn GetStreamOffset(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStreamOffset)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetMaxStreamOffset(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMaxStreamOffset)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMaxStreamOffset(&self, rtmaxoffset: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMaxStreamOffset)(windows_core::Interface::as_raw(self), rtmaxoffset).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMPushSource_Vtbl {
    pub base__: IAMLatency_Vtbl,
    pub GetPushSourceFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetPushSourceFlags: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetStreamOffset: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub GetStreamOffset: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetMaxStreamOffset: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub SetMaxStreamOffset: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
pub trait IAMPushSource_Impl: IAMLatency_Impl {
    fn GetPushSourceFlags(&self) -> windows_core::Result<u32>;
    fn SetPushSourceFlags(&self, flags: u32) -> windows_core::Result<()>;
    fn SetStreamOffset(&self, rtoffset: i64) -> windows_core::Result<()>;
    fn GetStreamOffset(&self) -> windows_core::Result<i64>;
    fn GetMaxStreamOffset(&self) -> windows_core::Result<i64>;
    fn SetMaxStreamOffset(&self, rtmaxoffset: i64) -> windows_core::Result<()>;
}
impl IAMPushSource_Vtbl {
    pub const fn new<Identity: IAMPushSource_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPushSourceFlags<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPushSource_Impl::GetPushSourceFlags(this) {
                    Ok(ok__) => {
                        pflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPushSourceFlags<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPushSource_Impl::SetPushSourceFlags(this, core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn SetStreamOffset<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rtoffset: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPushSource_Impl::SetStreamOffset(this, core::mem::transmute_copy(&rtoffset)).into()
            }
        }
        unsafe extern "system" fn GetStreamOffset<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtoffset: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPushSource_Impl::GetStreamOffset(this) {
                    Ok(ok__) => {
                        prtoffset.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetMaxStreamOffset<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtmaxoffset: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMPushSource_Impl::GetMaxStreamOffset(this) {
                    Ok(ok__) => {
                        prtmaxoffset.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMaxStreamOffset<Identity: IAMPushSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rtmaxoffset: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMPushSource_Impl::SetMaxStreamOffset(this, core::mem::transmute_copy(&rtmaxoffset)).into()
            }
        }
        Self {
            base__: IAMLatency_Vtbl::new::<Identity, OFFSET>(),
            GetPushSourceFlags: GetPushSourceFlags::<Identity, OFFSET>,
            SetPushSourceFlags: SetPushSourceFlags::<Identity, OFFSET>,
            SetStreamOffset: SetStreamOffset::<Identity, OFFSET>,
            GetStreamOffset: GetStreamOffset::<Identity, OFFSET>,
            GetMaxStreamOffset: GetMaxStreamOffset::<Identity, OFFSET>,
            SetMaxStreamOffset: SetMaxStreamOffset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMPushSource as windows_core::Interface>::IID || iid == &<IAMLatency as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMPushSource {}
windows_core::imp::define_interface!(IAMRebuild, IAMRebuild_Vtbl, 0x02ef04dd_7580_11d1_bece_00c04fb6e937);
windows_core::imp::interface_hierarchy!(IAMRebuild, windows_core::IUnknown);
impl IAMRebuild {
    pub unsafe fn RebuildNow(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RebuildNow)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMRebuild_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub RebuildNow: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMRebuild_Impl: windows_core::IUnknownImpl {
    fn RebuildNow(&self) -> windows_core::Result<()>;
}
impl IAMRebuild_Vtbl {
    pub const fn new<Identity: IAMRebuild_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RebuildNow<Identity: IAMRebuild_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMRebuild_Impl::RebuildNow(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), RebuildNow: RebuildNow::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMRebuild as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMRebuild {}
windows_core::imp::define_interface!(IAMResourceControl, IAMResourceControl_Vtbl, 0x8389d2d0_77d7_11d1_abe6_00a0c905f375);
windows_core::imp::interface_hierarchy!(IAMResourceControl, windows_core::IUnknown);
impl IAMResourceControl {
    pub unsafe fn Reserve(&self, dwflags: u32, pvreserved: Option<*const core::ffi::c_void>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reserve)(windows_core::Interface::as_raw(self), dwflags, pvreserved.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMResourceControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Reserve: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMResourceControl_Impl: windows_core::IUnknownImpl {
    fn Reserve(&self, dwflags: u32, pvreserved: *const core::ffi::c_void) -> windows_core::Result<()>;
}
impl IAMResourceControl_Vtbl {
    pub const fn new<Identity: IAMResourceControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Reserve<Identity: IAMResourceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pvreserved: *const core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMResourceControl_Impl::Reserve(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&pvreserved)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Reserve: Reserve::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMResourceControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMResourceControl {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IAMStats, IAMStats_Vtbl, 0xbc9bcf80_dcd2_11d2_abf6_00a0c905f375);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IAMStats {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IAMStats, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IAMStats {
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Count(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Count)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetValueByIndex(&self, lindex: i32, szname: *mut windows_core::BSTR, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetValueByIndex)(windows_core::Interface::as_raw(self), lindex, core::mem::transmute(szname), lcount as _, dlast as _, daverage as _, dstddev as _, dmin as _, dmax as _).ok() }
    }
    pub unsafe fn GetValueByName(&self, szname: &windows_core::BSTR, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetValueByName)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(szname), lindex as _, lcount as _, dlast as _, daverage as _, dstddev as _, dmin as _, dmax as _).ok() }
    }
    pub unsafe fn GetIndex(&self, szname: &windows_core::BSTR, lcreate: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetIndex)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(szname), lcreate, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn AddValue(&self, lindex: i32, dvalue: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AddValue)(windows_core::Interface::as_raw(self), lindex, dvalue).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IAMStats_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Count: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetValueByIndex: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void, *mut i32, *mut f64, *mut f64, *mut f64, *mut f64, *mut f64) -> windows_core::HRESULT,
    pub GetValueByName: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut i32, *mut i32, *mut f64, *mut f64, *mut f64, *mut f64, *mut f64) -> windows_core::HRESULT,
    pub GetIndex: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub AddValue: unsafe extern "system" fn(*mut core::ffi::c_void, i32, f64) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IAMStats_Impl: super::super::System::Com::IDispatch_Impl {
    fn Reset(&self) -> windows_core::Result<()>;
    fn Count(&self) -> windows_core::Result<i32>;
    fn GetValueByIndex(&self, lindex: i32, szname: *mut windows_core::BSTR, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::Result<()>;
    fn GetValueByName(&self, szname: &windows_core::BSTR, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::Result<()>;
    fn GetIndex(&self, szname: &windows_core::BSTR, lcreate: i32) -> windows_core::Result<i32>;
    fn AddValue(&self, lindex: i32, dvalue: f64) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IAMStats_Vtbl {
    pub const fn new<Identity: IAMStats_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Reset<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStats_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Count<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plcount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMStats_Impl::Count(this) {
                    Ok(ok__) => {
                        plcount.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetValueByIndex<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, szname: *mut *mut core::ffi::c_void, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStats_Impl::GetValueByIndex(this, core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&szname), core::mem::transmute_copy(&lcount), core::mem::transmute_copy(&dlast), core::mem::transmute_copy(&daverage), core::mem::transmute_copy(&dstddev), core::mem::transmute_copy(&dmin), core::mem::transmute_copy(&dmax)).into()
            }
        }
        unsafe extern "system" fn GetValueByName<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szname: *mut core::ffi::c_void, lindex: *mut i32, lcount: *mut i32, dlast: *mut f64, daverage: *mut f64, dstddev: *mut f64, dmin: *mut f64, dmax: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStats_Impl::GetValueByName(this, core::mem::transmute(&szname), core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&lcount), core::mem::transmute_copy(&dlast), core::mem::transmute_copy(&daverage), core::mem::transmute_copy(&dstddev), core::mem::transmute_copy(&dmin), core::mem::transmute_copy(&dmax)).into()
            }
        }
        unsafe extern "system" fn GetIndex<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szname: *mut core::ffi::c_void, lcreate: i32, plindex: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMStats_Impl::GetIndex(this, core::mem::transmute(&szname), core::mem::transmute_copy(&lcreate)) {
                    Ok(ok__) => {
                        plindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AddValue<Identity: IAMStats_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, dvalue: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStats_Impl::AddValue(this, core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&dvalue)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Reset: Reset::<Identity, OFFSET>,
            Count: Count::<Identity, OFFSET>,
            GetValueByIndex: GetValueByIndex::<Identity, OFFSET>,
            GetValueByName: GetValueByName::<Identity, OFFSET>,
            GetIndex: GetIndex::<Identity, OFFSET>,
            AddValue: AddValue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMStats as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IAMStats {}
windows_core::imp::define_interface!(IAMStreamConfig, IAMStreamConfig_Vtbl, 0xc6e13340_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMStreamConfig, windows_core::IUnknown);
impl IAMStreamConfig {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetFormat(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFormat)(windows_core::Interface::as_raw(self), core::mem::transmute(pmt)).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetFormat(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetNumberOfCapabilities(&self, picount: *mut i32, pisize: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNumberOfCapabilities)(windows_core::Interface::as_raw(self), picount as _, pisize as _).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetStreamCaps(&self, iindex: i32, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pscc: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStreamCaps)(windows_core::Interface::as_raw(self), iindex, ppmt as _, pscc as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMStreamConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetFormat: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetFormat: usize,
    pub GetNumberOfCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetStreamCaps: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, *mut u8) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetStreamCaps: usize,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IAMStreamConfig_Impl: windows_core::IUnknownImpl {
    fn SetFormat(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn GetFormat(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE>;
    fn GetNumberOfCapabilities(&self, picount: *mut i32, pisize: *mut i32) -> windows_core::Result<()>;
    fn GetStreamCaps(&self, iindex: i32, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pscc: *mut u8) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IAMStreamConfig_Vtbl {
    pub const fn new<Identity: IAMStreamConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetFormat<Identity: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamConfig_Impl::SetFormat(this, core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn GetFormat<Identity: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMStreamConfig_Impl::GetFormat(this) {
                    Ok(ok__) => {
                        ppmt.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetNumberOfCapabilities<Identity: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picount: *mut i32, pisize: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamConfig_Impl::GetNumberOfCapabilities(this, core::mem::transmute_copy(&picount), core::mem::transmute_copy(&pisize)).into()
            }
        }
        unsafe extern "system" fn GetStreamCaps<Identity: IAMStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, iindex: i32, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pscc: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamConfig_Impl::GetStreamCaps(this, core::mem::transmute_copy(&iindex), core::mem::transmute_copy(&ppmt), core::mem::transmute_copy(&pscc)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFormat: SetFormat::<Identity, OFFSET>,
            GetFormat: GetFormat::<Identity, OFFSET>,
            GetNumberOfCapabilities: GetNumberOfCapabilities::<Identity, OFFSET>,
            GetStreamCaps: GetStreamCaps::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMStreamConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IAMStreamConfig {}
windows_core::imp::define_interface!(IAMStreamControl, IAMStreamControl_Vtbl, 0x36b73881_c2c8_11cf_8b46_00805f6cef60);
windows_core::imp::interface_hierarchy!(IAMStreamControl, windows_core::IUnknown);
impl IAMStreamControl {
    pub unsafe fn StartAt(&self, ptstart: Option<*const i64>, dwcookie: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StartAt)(windows_core::Interface::as_raw(self), ptstart.unwrap_or(core::mem::zeroed()) as _, dwcookie).ok() }
    }
    pub unsafe fn StopAt(&self, ptstop: Option<*const i64>, bsendextra: bool, dwcookie: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StopAt)(windows_core::Interface::as_raw(self), ptstop.unwrap_or(core::mem::zeroed()) as _, bsendextra.into(), dwcookie).ok() }
    }
    pub unsafe fn GetInfo(&self, pinfo: *mut AM_STREAM_INFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInfo)(windows_core::Interface::as_raw(self), pinfo as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMStreamControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub StartAt: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, u32) -> windows_core::HRESULT,
    pub StopAt: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, windows_core::BOOL, u32) -> windows_core::HRESULT,
    pub GetInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_STREAM_INFO) -> windows_core::HRESULT,
}
pub trait IAMStreamControl_Impl: windows_core::IUnknownImpl {
    fn StartAt(&self, ptstart: *const i64, dwcookie: u32) -> windows_core::Result<()>;
    fn StopAt(&self, ptstop: *const i64, bsendextra: windows_core::BOOL, dwcookie: u32) -> windows_core::Result<()>;
    fn GetInfo(&self, pinfo: *mut AM_STREAM_INFO) -> windows_core::Result<()>;
}
impl IAMStreamControl_Vtbl {
    pub const fn new<Identity: IAMStreamControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartAt<Identity: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptstart: *const i64, dwcookie: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamControl_Impl::StartAt(this, core::mem::transmute_copy(&ptstart), core::mem::transmute_copy(&dwcookie)).into()
            }
        }
        unsafe extern "system" fn StopAt<Identity: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptstop: *const i64, bsendextra: windows_core::BOOL, dwcookie: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamControl_Impl::StopAt(this, core::mem::transmute_copy(&ptstop), core::mem::transmute_copy(&bsendextra), core::mem::transmute_copy(&dwcookie)).into()
            }
        }
        unsafe extern "system" fn GetInfo<Identity: IAMStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinfo: *mut AM_STREAM_INFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamControl_Impl::GetInfo(this, core::mem::transmute_copy(&pinfo)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartAt: StartAt::<Identity, OFFSET>,
            StopAt: StopAt::<Identity, OFFSET>,
            GetInfo: GetInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMStreamControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMStreamControl {}
windows_core::imp::define_interface!(IAMStreamSelect, IAMStreamSelect_Vtbl, 0xc1960960_17f5_11d1_abe1_00a0c905f375);
windows_core::imp::interface_hierarchy!(IAMStreamSelect, windows_core::IUnknown);
impl IAMStreamSelect {
    pub unsafe fn Count(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Count)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn Info(&self, lindex: i32, ppmt: Option<*mut *mut super::MediaFoundation::AM_MEDIA_TYPE>, pdwflags: Option<*mut u32>, plcid: Option<*mut u32>, pdwgroup: Option<*mut u32>, ppszname: Option<*mut windows_core::PWSTR>, ppobject: Option<*mut Option<windows_core::IUnknown>>, ppunk: Option<*mut Option<windows_core::IUnknown>>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Info)(windows_core::Interface::as_raw(self), lindex, ppmt.unwrap_or(core::mem::zeroed()) as _, pdwflags.unwrap_or(core::mem::zeroed()) as _, plcid.unwrap_or(core::mem::zeroed()) as _, pdwgroup.unwrap_or(core::mem::zeroed()) as _, ppszname.unwrap_or(core::mem::zeroed()) as _, ppobject.unwrap_or(core::mem::zeroed()) as _, ppunk.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn Enable(&self, lindex: i32, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Enable)(windows_core::Interface::as_raw(self), lindex, dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMStreamSelect_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Count: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub Info: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, *mut u32, *mut u32, *mut u32, *mut windows_core::PWSTR, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    Info: usize,
    pub Enable: unsafe extern "system" fn(*mut core::ffi::c_void, i32, u32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IAMStreamSelect_Impl: windows_core::IUnknownImpl {
    fn Count(&self) -> windows_core::Result<u32>;
    fn Info(&self, lindex: i32, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pdwflags: *mut u32, plcid: *mut u32, pdwgroup: *mut u32, ppszname: *mut windows_core::PWSTR, ppobject: windows_core::OutRef<windows_core::IUnknown>, ppunk: windows_core::OutRef<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn Enable(&self, lindex: i32, dwflags: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IAMStreamSelect_Vtbl {
    pub const fn new<Identity: IAMStreamSelect_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Count<Identity: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcstreams: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMStreamSelect_Impl::Count(this) {
                    Ok(ok__) => {
                        pcstreams.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Info<Identity: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, ppmt: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pdwflags: *mut u32, plcid: *mut u32, pdwgroup: *mut u32, ppszname: *mut windows_core::PWSTR, ppobject: *mut *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamSelect_Impl::Info(this, core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&ppmt), core::mem::transmute_copy(&pdwflags), core::mem::transmute_copy(&plcid), core::mem::transmute_copy(&pdwgroup), core::mem::transmute_copy(&ppszname), core::mem::transmute_copy(&ppobject), core::mem::transmute_copy(&ppunk)).into()
            }
        }
        unsafe extern "system" fn Enable<Identity: IAMStreamSelect_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMStreamSelect_Impl::Enable(this, core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Count: Count::<Identity, OFFSET>,
            Info: Info::<Identity, OFFSET>,
            Enable: Enable::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMStreamSelect as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IAMStreamSelect {}
windows_core::imp::define_interface!(IAMTVAudio, IAMTVAudio_Vtbl, 0x83ec1c30_23d1_11d1_99e6_00a0c9560266);
windows_core::imp::interface_hierarchy!(IAMTVAudio, windows_core::IUnknown);
impl IAMTVAudio {
    pub unsafe fn GetHardwareSupportedTVAudioModes(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetHardwareSupportedTVAudioModes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAvailableTVAudioModes(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAvailableTVAudioModes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn TVAudioMode(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TVAudioMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTVAudioMode(&self, lmode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTVAudioMode)(windows_core::Interface::as_raw(self), lmode).ok() }
    }
    pub unsafe fn RegisterNotificationCallBack<P0>(&self, pnotify: P0, levents: i32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMTunerNotification>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterNotificationCallBack)(windows_core::Interface::as_raw(self), pnotify.param().abi(), levents).ok() }
    }
    pub unsafe fn UnRegisterNotificationCallBack<P0>(&self, pnotify: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMTunerNotification>,
    {
        unsafe { (windows_core::Interface::vtable(self).UnRegisterNotificationCallBack)(windows_core::Interface::as_raw(self), pnotify.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTVAudio_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetHardwareSupportedTVAudioModes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetAvailableTVAudioModes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub TVAudioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTVAudioMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub RegisterNotificationCallBack: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub UnRegisterNotificationCallBack: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMTVAudio_Impl: windows_core::IUnknownImpl {
    fn GetHardwareSupportedTVAudioModes(&self) -> windows_core::Result<i32>;
    fn GetAvailableTVAudioModes(&self) -> windows_core::Result<i32>;
    fn TVAudioMode(&self) -> windows_core::Result<i32>;
    fn SetTVAudioMode(&self, lmode: i32) -> windows_core::Result<()>;
    fn RegisterNotificationCallBack(&self, pnotify: windows_core::Ref<IAMTunerNotification>, levents: i32) -> windows_core::Result<()>;
    fn UnRegisterNotificationCallBack(&self, pnotify: windows_core::Ref<IAMTunerNotification>) -> windows_core::Result<()>;
}
impl IAMTVAudio_Vtbl {
    pub const fn new<Identity: IAMTVAudio_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetHardwareSupportedTVAudioModes<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmodes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVAudio_Impl::GetHardwareSupportedTVAudioModes(this) {
                    Ok(ok__) => {
                        plmodes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAvailableTVAudioModes<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmodes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVAudio_Impl::GetAvailableTVAudioModes(this) {
                    Ok(ok__) => {
                        plmodes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TVAudioMode<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVAudio_Impl::TVAudioMode(this) {
                    Ok(ok__) => {
                        plmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTVAudioMode<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lmode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVAudio_Impl::SetTVAudioMode(this, core::mem::transmute_copy(&lmode)).into()
            }
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void, levents: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVAudio_Impl::RegisterNotificationCallBack(this, core::mem::transmute_copy(&pnotify), core::mem::transmute_copy(&levents)).into()
            }
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Identity: IAMTVAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVAudio_Impl::UnRegisterNotificationCallBack(this, core::mem::transmute_copy(&pnotify)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetHardwareSupportedTVAudioModes: GetHardwareSupportedTVAudioModes::<Identity, OFFSET>,
            GetAvailableTVAudioModes: GetAvailableTVAudioModes::<Identity, OFFSET>,
            TVAudioMode: TVAudioMode::<Identity, OFFSET>,
            SetTVAudioMode: SetTVAudioMode::<Identity, OFFSET>,
            RegisterNotificationCallBack: RegisterNotificationCallBack::<Identity, OFFSET>,
            UnRegisterNotificationCallBack: UnRegisterNotificationCallBack::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTVAudio as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTVAudio {}
windows_core::imp::define_interface!(IAMTVAudioNotification, IAMTVAudioNotification_Vtbl, 0x83ec1c33_23d1_11d1_99e6_00a0c9560266);
windows_core::imp::interface_hierarchy!(IAMTVAudioNotification, windows_core::IUnknown);
impl IAMTVAudioNotification {
    pub unsafe fn OnEvent(&self, event: AMTVAudioEventType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnEvent)(windows_core::Interface::as_raw(self), event).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTVAudioNotification_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnEvent: unsafe extern "system" fn(*mut core::ffi::c_void, AMTVAudioEventType) -> windows_core::HRESULT,
}
pub trait IAMTVAudioNotification_Impl: windows_core::IUnknownImpl {
    fn OnEvent(&self, event: AMTVAudioEventType) -> windows_core::Result<()>;
}
impl IAMTVAudioNotification_Vtbl {
    pub const fn new<Identity: IAMTVAudioNotification_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnEvent<Identity: IAMTVAudioNotification_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, event: AMTVAudioEventType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVAudioNotification_Impl::OnEvent(this, core::mem::transmute_copy(&event)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnEvent: OnEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTVAudioNotification as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTVAudioNotification {}
windows_core::imp::define_interface!(IAMTVTuner, IAMTVTuner_Vtbl, 0x211a8766_03ac_11d1_8d13_00aa00bd8339);
impl core::ops::Deref for IAMTVTuner {
    type Target = IAMTuner;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAMTVTuner, windows_core::IUnknown, IAMTuner);
impl IAMTVTuner {
    pub unsafe fn AvailableTVFormats(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvailableTVFormats)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn TVFormat(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TVFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn AutoTune(&self, lchannel: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AutoTune)(windows_core::Interface::as_raw(self), lchannel, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn StoreAutoTune(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StoreAutoTune)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn NumInputConnections(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).NumInputConnections)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn put_InputType(&self, lindex: i32, inputtype: TunerInputType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_InputType)(windows_core::Interface::as_raw(self), lindex, inputtype).ok() }
    }
    pub unsafe fn get_InputType(&self, lindex: i32) -> windows_core::Result<TunerInputType> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).get_InputType)(windows_core::Interface::as_raw(self), lindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetConnectInput(&self, lindex: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetConnectInput)(windows_core::Interface::as_raw(self), lindex).ok() }
    }
    pub unsafe fn ConnectInput(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ConnectInput)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn VideoFrequency(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VideoFrequency)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn AudioFrequency(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AudioFrequency)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTVTuner_Vtbl {
    pub base__: IAMTuner_Vtbl,
    pub AvailableTVFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub TVFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub AutoTune: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub StoreAutoTune: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NumInputConnections: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub put_InputType: unsafe extern "system" fn(*mut core::ffi::c_void, i32, TunerInputType) -> windows_core::HRESULT,
    pub get_InputType: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut TunerInputType) -> windows_core::HRESULT,
    pub SetConnectInput: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub ConnectInput: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub VideoFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub AudioFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMTVTuner_Impl: IAMTuner_Impl {
    fn AvailableTVFormats(&self) -> windows_core::Result<i32>;
    fn TVFormat(&self) -> windows_core::Result<i32>;
    fn AutoTune(&self, lchannel: i32) -> windows_core::Result<i32>;
    fn StoreAutoTune(&self) -> windows_core::Result<()>;
    fn NumInputConnections(&self) -> windows_core::Result<i32>;
    fn put_InputType(&self, lindex: i32, inputtype: TunerInputType) -> windows_core::Result<()>;
    fn get_InputType(&self, lindex: i32) -> windows_core::Result<TunerInputType>;
    fn SetConnectInput(&self, lindex: i32) -> windows_core::Result<()>;
    fn ConnectInput(&self) -> windows_core::Result<i32>;
    fn VideoFrequency(&self) -> windows_core::Result<i32>;
    fn AudioFrequency(&self) -> windows_core::Result<i32>;
}
impl IAMTVTuner_Vtbl {
    pub const fn new<Identity: IAMTVTuner_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AvailableTVFormats<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lanalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::AvailableTVFormats(this) {
                    Ok(ok__) => {
                        lanalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TVFormat<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planalogvideostandard: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::TVFormat(this) {
                    Ok(ok__) => {
                        planalogvideostandard.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AutoTune<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lchannel: i32, plfoundsignal: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::AutoTune(this, core::mem::transmute_copy(&lchannel)) {
                    Ok(ok__) => {
                        plfoundsignal.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StoreAutoTune<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVTuner_Impl::StoreAutoTune(this).into()
            }
        }
        unsafe extern "system" fn NumInputConnections<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plnuminputconnections: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::NumInputConnections(this) {
                    Ok(ok__) => {
                        plnuminputconnections.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn put_InputType<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, inputtype: TunerInputType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVTuner_Impl::put_InputType(this, core::mem::transmute_copy(&lindex), core::mem::transmute_copy(&inputtype)).into()
            }
        }
        unsafe extern "system" fn get_InputType<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32, pinputtype: *mut TunerInputType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::get_InputType(this, core::mem::transmute_copy(&lindex)) {
                    Ok(ok__) => {
                        pinputtype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetConnectInput<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lindex: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTVTuner_Impl::SetConnectInput(this, core::mem::transmute_copy(&lindex)).into()
            }
        }
        unsafe extern "system" fn ConnectInput<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plindex: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::ConnectInput(this) {
                    Ok(ok__) => {
                        plindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn VideoFrequency<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lfreq: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::VideoFrequency(this) {
                    Ok(ok__) => {
                        lfreq.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AudioFrequency<Identity: IAMTVTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lfreq: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTVTuner_Impl::AudioFrequency(this) {
                    Ok(ok__) => {
                        lfreq.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IAMTuner_Vtbl::new::<Identity, OFFSET>(),
            AvailableTVFormats: AvailableTVFormats::<Identity, OFFSET>,
            TVFormat: TVFormat::<Identity, OFFSET>,
            AutoTune: AutoTune::<Identity, OFFSET>,
            StoreAutoTune: StoreAutoTune::<Identity, OFFSET>,
            NumInputConnections: NumInputConnections::<Identity, OFFSET>,
            put_InputType: put_InputType::<Identity, OFFSET>,
            get_InputType: get_InputType::<Identity, OFFSET>,
            SetConnectInput: SetConnectInput::<Identity, OFFSET>,
            ConnectInput: ConnectInput::<Identity, OFFSET>,
            VideoFrequency: VideoFrequency::<Identity, OFFSET>,
            AudioFrequency: AudioFrequency::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTVTuner as windows_core::Interface>::IID || iid == &<IAMTuner as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTVTuner {}
windows_core::imp::define_interface!(IAMTimecodeDisplay, IAMTimecodeDisplay_Vtbl, 0x9b496ce2_811b_11cf_8c77_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMTimecodeDisplay, windows_core::IUnknown);
impl IAMTimecodeDisplay {
    pub unsafe fn GetTCDisplayEnable(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTCDisplayEnable)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTCDisplayEnable(&self, state: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTCDisplayEnable)(windows_core::Interface::as_raw(self), state).ok() }
    }
    pub unsafe fn GetTCDisplay(&self, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTCDisplay)(windows_core::Interface::as_raw(self), param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTCDisplay(&self, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTCDisplay)(windows_core::Interface::as_raw(self), param, value).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTimecodeDisplay_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetTCDisplayEnable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTCDisplayEnable: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetTCDisplay: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetTCDisplay: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
}
pub trait IAMTimecodeDisplay_Impl: windows_core::IUnknownImpl {
    fn GetTCDisplayEnable(&self) -> windows_core::Result<i32>;
    fn SetTCDisplayEnable(&self, state: i32) -> windows_core::Result<()>;
    fn GetTCDisplay(&self, param: i32) -> windows_core::Result<i32>;
    fn SetTCDisplay(&self, param: i32, value: i32) -> windows_core::Result<()>;
}
impl IAMTimecodeDisplay_Vtbl {
    pub const fn new<Identity: IAMTimecodeDisplay_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetTCDisplayEnable<Identity: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeDisplay_Impl::GetTCDisplayEnable(this) {
                    Ok(ok__) => {
                        pstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTCDisplayEnable<Identity: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeDisplay_Impl::SetTCDisplayEnable(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn GetTCDisplay<Identity: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeDisplay_Impl::GetTCDisplay(this, core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTCDisplay<Identity: IAMTimecodeDisplay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeDisplay_Impl::SetTCDisplay(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetTCDisplayEnable: GetTCDisplayEnable::<Identity, OFFSET>,
            SetTCDisplayEnable: SetTCDisplayEnable::<Identity, OFFSET>,
            GetTCDisplay: GetTCDisplay::<Identity, OFFSET>,
            SetTCDisplay: SetTCDisplay::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTimecodeDisplay as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTimecodeDisplay {}
windows_core::imp::define_interface!(IAMTimecodeGenerator, IAMTimecodeGenerator_Vtbl, 0x9b496ce0_811b_11cf_8c77_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMTimecodeGenerator, windows_core::IUnknown);
impl IAMTimecodeGenerator {
    pub unsafe fn GetTCGMode(&self, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTCGMode)(windows_core::Interface::as_raw(self), param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTCGMode(&self, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTCGMode)(windows_core::Interface::as_raw(self), param, value).ok() }
    }
    pub unsafe fn SetVITCLine(&self, line: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVITCLine)(windows_core::Interface::as_raw(self), line).ok() }
    }
    pub unsafe fn VITCLine(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VITCLine)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTimecode(&self, ptimecodesample: *const super::TIMECODE_SAMPLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTimecode)(windows_core::Interface::as_raw(self), ptimecodesample).ok() }
    }
    pub unsafe fn GetTimecode(&self, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTimecode)(windows_core::Interface::as_raw(self), ptimecodesample as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTimecodeGenerator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetTCGMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetTCGMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub SetVITCLine: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub VITCLine: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTimecode: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::TIMECODE_SAMPLE) -> windows_core::HRESULT,
    pub GetTimecode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::TIMECODE_SAMPLE) -> windows_core::HRESULT,
}
pub trait IAMTimecodeGenerator_Impl: windows_core::IUnknownImpl {
    fn GetTCGMode(&self, param: i32) -> windows_core::Result<i32>;
    fn SetTCGMode(&self, param: i32, value: i32) -> windows_core::Result<()>;
    fn SetVITCLine(&self, line: i32) -> windows_core::Result<()>;
    fn VITCLine(&self) -> windows_core::Result<i32>;
    fn SetTimecode(&self, ptimecodesample: *const super::TIMECODE_SAMPLE) -> windows_core::Result<()>;
    fn GetTimecode(&self, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::Result<()>;
}
impl IAMTimecodeGenerator_Vtbl {
    pub const fn new<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetTCGMode<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeGenerator_Impl::GetTCGMode(this, core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTCGMode<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeGenerator_Impl::SetTCGMode(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn SetVITCLine<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, line: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeGenerator_Impl::SetVITCLine(this, core::mem::transmute_copy(&line)).into()
            }
        }
        unsafe extern "system" fn VITCLine<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pline: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeGenerator_Impl::VITCLine(this) {
                    Ok(ok__) => {
                        pline.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTimecode<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimecodesample: *const super::TIMECODE_SAMPLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeGenerator_Impl::SetTimecode(this, core::mem::transmute_copy(&ptimecodesample)).into()
            }
        }
        unsafe extern "system" fn GetTimecode<Identity: IAMTimecodeGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeGenerator_Impl::GetTimecode(this, core::mem::transmute_copy(&ptimecodesample)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetTCGMode: GetTCGMode::<Identity, OFFSET>,
            SetTCGMode: SetTCGMode::<Identity, OFFSET>,
            SetVITCLine: SetVITCLine::<Identity, OFFSET>,
            VITCLine: VITCLine::<Identity, OFFSET>,
            SetTimecode: SetTimecode::<Identity, OFFSET>,
            GetTimecode: GetTimecode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTimecodeGenerator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTimecodeGenerator {}
windows_core::imp::define_interface!(IAMTimecodeReader, IAMTimecodeReader_Vtbl, 0x9b496ce1_811b_11cf_8c77_00aa006b6814);
windows_core::imp::interface_hierarchy!(IAMTimecodeReader, windows_core::IUnknown);
impl IAMTimecodeReader {
    pub unsafe fn GetTCRMode(&self, param: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTCRMode)(windows_core::Interface::as_raw(self), param, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTCRMode(&self, param: i32, value: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTCRMode)(windows_core::Interface::as_raw(self), param, value).ok() }
    }
    pub unsafe fn SetVITCLine(&self, line: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVITCLine)(windows_core::Interface::as_raw(self), line).ok() }
    }
    pub unsafe fn VITCLine(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VITCLine)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTimecode(&self, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTimecode)(windows_core::Interface::as_raw(self), ptimecodesample as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTimecodeReader_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetTCRMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub SetTCRMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub SetVITCLine: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub VITCLine: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetTimecode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::TIMECODE_SAMPLE) -> windows_core::HRESULT,
}
pub trait IAMTimecodeReader_Impl: windows_core::IUnknownImpl {
    fn GetTCRMode(&self, param: i32) -> windows_core::Result<i32>;
    fn SetTCRMode(&self, param: i32, value: i32) -> windows_core::Result<()>;
    fn SetVITCLine(&self, line: i32) -> windows_core::Result<()>;
    fn VITCLine(&self) -> windows_core::Result<i32>;
    fn GetTimecode(&self, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::Result<()>;
}
impl IAMTimecodeReader_Vtbl {
    pub const fn new<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetTCRMode<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, pvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeReader_Impl::GetTCRMode(this, core::mem::transmute_copy(&param)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTCRMode<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, param: i32, value: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeReader_Impl::SetTCRMode(this, core::mem::transmute_copy(&param), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn SetVITCLine<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, line: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeReader_Impl::SetVITCLine(this, core::mem::transmute_copy(&line)).into()
            }
        }
        unsafe extern "system" fn VITCLine<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pline: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTimecodeReader_Impl::VITCLine(this) {
                    Ok(ok__) => {
                        pline.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTimecode<Identity: IAMTimecodeReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimecodesample: *mut super::TIMECODE_SAMPLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTimecodeReader_Impl::GetTimecode(this, core::mem::transmute_copy(&ptimecodesample)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetTCRMode: GetTCRMode::<Identity, OFFSET>,
            SetTCRMode: SetTCRMode::<Identity, OFFSET>,
            SetVITCLine: SetVITCLine::<Identity, OFFSET>,
            VITCLine: VITCLine::<Identity, OFFSET>,
            GetTimecode: GetTimecode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTimecodeReader as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTimecodeReader {}
windows_core::imp::define_interface!(IAMTuner, IAMTuner_Vtbl, 0x211a8761_03ac_11d1_8d13_00aa00bd8339);
windows_core::imp::interface_hierarchy!(IAMTuner, windows_core::IUnknown);
impl IAMTuner {
    pub unsafe fn put_Channel(&self, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Channel)(windows_core::Interface::as_raw(self), lchannel, lvideosubchannel, laudiosubchannel).ok() }
    }
    pub unsafe fn get_Channel(&self, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Channel)(windows_core::Interface::as_raw(self), plchannel as _, plvideosubchannel as _, plaudiosubchannel as _).ok() }
    }
    pub unsafe fn ChannelMinMax(&self, lchannelmin: *mut i32, lchannelmax: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChannelMinMax)(windows_core::Interface::as_raw(self), lchannelmin as _, lchannelmax as _).ok() }
    }
    pub unsafe fn SetCountryCode(&self, lcountrycode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCountryCode)(windows_core::Interface::as_raw(self), lcountrycode).ok() }
    }
    pub unsafe fn CountryCode(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CountryCode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTuningSpace(&self, ltuningspace: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTuningSpace)(windows_core::Interface::as_raw(self), ltuningspace).ok() }
    }
    pub unsafe fn TuningSpace(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).TuningSpace)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Logon(&self, hcurrentuser: super::super::Foundation::HANDLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Logon)(windows_core::Interface::as_raw(self), hcurrentuser).ok() }
    }
    pub unsafe fn Logout(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Logout)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SignalPresent(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SignalPresent)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMode(&self, lmode: AMTunerModeType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMode)(windows_core::Interface::as_raw(self), lmode).ok() }
    }
    pub unsafe fn Mode(&self) -> windows_core::Result<AMTunerModeType> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Mode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAvailableModes(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAvailableModes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RegisterNotificationCallBack<P0>(&self, pnotify: P0, levents: i32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMTunerNotification>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterNotificationCallBack)(windows_core::Interface::as_raw(self), pnotify.param().abi(), levents).ok() }
    }
    pub unsafe fn UnRegisterNotificationCallBack<P0>(&self, pnotify: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMTunerNotification>,
    {
        unsafe { (windows_core::Interface::vtable(self).UnRegisterNotificationCallBack)(windows_core::Interface::as_raw(self), pnotify.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTuner_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub put_Channel: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub get_Channel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub ChannelMinMax: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetCountryCode: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub CountryCode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub TuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Logon: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HANDLE) -> windows_core::HRESULT,
    pub Logout: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SignalPresent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetMode: unsafe extern "system" fn(*mut core::ffi::c_void, AMTunerModeType) -> windows_core::HRESULT,
    pub Mode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AMTunerModeType) -> windows_core::HRESULT,
    pub GetAvailableModes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub RegisterNotificationCallBack: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub UnRegisterNotificationCallBack: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMTuner_Impl: windows_core::IUnknownImpl {
    fn put_Channel(&self, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> windows_core::Result<()>;
    fn get_Channel(&self, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> windows_core::Result<()>;
    fn ChannelMinMax(&self, lchannelmin: *mut i32, lchannelmax: *mut i32) -> windows_core::Result<()>;
    fn SetCountryCode(&self, lcountrycode: i32) -> windows_core::Result<()>;
    fn CountryCode(&self) -> windows_core::Result<i32>;
    fn SetTuningSpace(&self, ltuningspace: i32) -> windows_core::Result<()>;
    fn TuningSpace(&self) -> windows_core::Result<i32>;
    fn Logon(&self, hcurrentuser: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn Logout(&self) -> windows_core::Result<()>;
    fn SignalPresent(&self) -> windows_core::Result<i32>;
    fn SetMode(&self, lmode: AMTunerModeType) -> windows_core::Result<()>;
    fn Mode(&self) -> windows_core::Result<AMTunerModeType>;
    fn GetAvailableModes(&self) -> windows_core::Result<i32>;
    fn RegisterNotificationCallBack(&self, pnotify: windows_core::Ref<IAMTunerNotification>, levents: i32) -> windows_core::Result<()>;
    fn UnRegisterNotificationCallBack(&self, pnotify: windows_core::Ref<IAMTunerNotification>) -> windows_core::Result<()>;
}
impl IAMTuner_Vtbl {
    pub const fn new<Identity: IAMTuner_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn put_Channel<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::put_Channel(this, core::mem::transmute_copy(&lchannel), core::mem::transmute_copy(&lvideosubchannel), core::mem::transmute_copy(&laudiosubchannel)).into()
            }
        }
        unsafe extern "system" fn get_Channel<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::get_Channel(this, core::mem::transmute_copy(&plchannel), core::mem::transmute_copy(&plvideosubchannel), core::mem::transmute_copy(&plaudiosubchannel)).into()
            }
        }
        unsafe extern "system" fn ChannelMinMax<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lchannelmin: *mut i32, lchannelmax: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::ChannelMinMax(this, core::mem::transmute_copy(&lchannelmin), core::mem::transmute_copy(&lchannelmax)).into()
            }
        }
        unsafe extern "system" fn SetCountryCode<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lcountrycode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::SetCountryCode(this, core::mem::transmute_copy(&lcountrycode)).into()
            }
        }
        unsafe extern "system" fn CountryCode<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plcountrycode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTuner_Impl::CountryCode(this) {
                    Ok(ok__) => {
                        plcountrycode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTuningSpace<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ltuningspace: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::SetTuningSpace(this, core::mem::transmute_copy(&ltuningspace)).into()
            }
        }
        unsafe extern "system" fn TuningSpace<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pltuningspace: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTuner_Impl::TuningSpace(this) {
                    Ok(ok__) => {
                        pltuningspace.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Logon<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hcurrentuser: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::Logon(this, core::mem::transmute_copy(&hcurrentuser)).into()
            }
        }
        unsafe extern "system" fn Logout<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::Logout(this).into()
            }
        }
        unsafe extern "system" fn SignalPresent<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plsignalstrength: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTuner_Impl::SignalPresent(this) {
                    Ok(ok__) => {
                        plsignalstrength.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMode<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lmode: AMTunerModeType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::SetMode(this, core::mem::transmute_copy(&lmode)).into()
            }
        }
        unsafe extern "system" fn Mode<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmode: *mut AMTunerModeType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTuner_Impl::Mode(this) {
                    Ok(ok__) => {
                        plmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAvailableModes<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmodes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMTuner_Impl::GetAvailableModes(this) {
                    Ok(ok__) => {
                        plmodes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RegisterNotificationCallBack<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void, levents: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::RegisterNotificationCallBack(this, core::mem::transmute_copy(&pnotify), core::mem::transmute_copy(&levents)).into()
            }
        }
        unsafe extern "system" fn UnRegisterNotificationCallBack<Identity: IAMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTuner_Impl::UnRegisterNotificationCallBack(this, core::mem::transmute_copy(&pnotify)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            put_Channel: put_Channel::<Identity, OFFSET>,
            get_Channel: get_Channel::<Identity, OFFSET>,
            ChannelMinMax: ChannelMinMax::<Identity, OFFSET>,
            SetCountryCode: SetCountryCode::<Identity, OFFSET>,
            CountryCode: CountryCode::<Identity, OFFSET>,
            SetTuningSpace: SetTuningSpace::<Identity, OFFSET>,
            TuningSpace: TuningSpace::<Identity, OFFSET>,
            Logon: Logon::<Identity, OFFSET>,
            Logout: Logout::<Identity, OFFSET>,
            SignalPresent: SignalPresent::<Identity, OFFSET>,
            SetMode: SetMode::<Identity, OFFSET>,
            Mode: Mode::<Identity, OFFSET>,
            GetAvailableModes: GetAvailableModes::<Identity, OFFSET>,
            RegisterNotificationCallBack: RegisterNotificationCallBack::<Identity, OFFSET>,
            UnRegisterNotificationCallBack: UnRegisterNotificationCallBack::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTuner as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTuner {}
windows_core::imp::define_interface!(IAMTunerNotification, IAMTunerNotification_Vtbl, 0x211a8760_03ac_11d1_8d13_00aa00bd8339);
windows_core::imp::interface_hierarchy!(IAMTunerNotification, windows_core::IUnknown);
impl IAMTunerNotification {
    pub unsafe fn OnEvent(&self, event: AMTunerEventType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnEvent)(windows_core::Interface::as_raw(self), event).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMTunerNotification_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnEvent: unsafe extern "system" fn(*mut core::ffi::c_void, AMTunerEventType) -> windows_core::HRESULT,
}
pub trait IAMTunerNotification_Impl: windows_core::IUnknownImpl {
    fn OnEvent(&self, event: AMTunerEventType) -> windows_core::Result<()>;
}
impl IAMTunerNotification_Vtbl {
    pub const fn new<Identity: IAMTunerNotification_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnEvent<Identity: IAMTunerNotification_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, event: AMTunerEventType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMTunerNotification_Impl::OnEvent(this, core::mem::transmute_copy(&event)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnEvent: OnEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMTunerNotification as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMTunerNotification {}
windows_core::imp::define_interface!(IAMVfwCaptureDialogs, IAMVfwCaptureDialogs_Vtbl, 0xd8d715a0_6e5e_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMVfwCaptureDialogs, windows_core::IUnknown);
impl IAMVfwCaptureDialogs {
    pub unsafe fn HasDialog(&self, idialog: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HasDialog)(windows_core::Interface::as_raw(self), idialog).ok() }
    }
    pub unsafe fn ShowDialog(&self, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ShowDialog)(windows_core::Interface::as_raw(self), idialog, hwnd).ok() }
    }
    pub unsafe fn SendDriverMessage(&self, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SendDriverMessage)(windows_core::Interface::as_raw(self), idialog, umsg, dw1, dw2).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVfwCaptureDialogs_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub HasDialog: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub ShowDialog: unsafe extern "system" fn(*mut core::ffi::c_void, i32, super::super::Foundation::HWND) -> windows_core::HRESULT,
    pub SendDriverMessage: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32, i32) -> windows_core::HRESULT,
}
pub trait IAMVfwCaptureDialogs_Impl: windows_core::IUnknownImpl {
    fn HasDialog(&self, idialog: i32) -> windows_core::Result<()>;
    fn ShowDialog(&self, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn SendDriverMessage(&self, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> windows_core::Result<()>;
}
impl IAMVfwCaptureDialogs_Vtbl {
    pub const fn new<Identity: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn HasDialog<Identity: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idialog: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCaptureDialogs_Impl::HasDialog(this, core::mem::transmute_copy(&idialog)).into()
            }
        }
        unsafe extern "system" fn ShowDialog<Identity: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCaptureDialogs_Impl::ShowDialog(this, core::mem::transmute_copy(&idialog), core::mem::transmute_copy(&hwnd)).into()
            }
        }
        unsafe extern "system" fn SendDriverMessage<Identity: IAMVfwCaptureDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idialog: i32, umsg: i32, dw1: i32, dw2: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCaptureDialogs_Impl::SendDriverMessage(this, core::mem::transmute_copy(&idialog), core::mem::transmute_copy(&umsg), core::mem::transmute_copy(&dw1), core::mem::transmute_copy(&dw2)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            HasDialog: HasDialog::<Identity, OFFSET>,
            ShowDialog: ShowDialog::<Identity, OFFSET>,
            SendDriverMessage: SendDriverMessage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVfwCaptureDialogs as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVfwCaptureDialogs {}
windows_core::imp::define_interface!(IAMVfwCompressDialogs, IAMVfwCompressDialogs_Vtbl, 0xd8d715a3_6e5e_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(IAMVfwCompressDialogs, windows_core::IUnknown);
impl IAMVfwCompressDialogs {
    pub unsafe fn ShowDialog(&self, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ShowDialog)(windows_core::Interface::as_raw(self), idialog, hwnd).ok() }
    }
    pub unsafe fn GetState(&self, pstate: *mut core::ffi::c_void, pcbstate: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), pstate as _, pcbstate as _).ok() }
    }
    pub unsafe fn SetState(&self, pstate: *const core::ffi::c_void, cbstate: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetState)(windows_core::Interface::as_raw(self), pstate, cbstate).ok() }
    }
    pub unsafe fn SendDriverMessage(&self, umsg: i32, dw1: i32, dw2: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SendDriverMessage)(windows_core::Interface::as_raw(self), umsg, dw1, dw2).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVfwCompressDialogs_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub ShowDialog: unsafe extern "system" fn(*mut core::ffi::c_void, i32, super::super::Foundation::HWND) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetState: unsafe extern "system" fn(*mut core::ffi::c_void, *const core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SendDriverMessage: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
}
pub trait IAMVfwCompressDialogs_Impl: windows_core::IUnknownImpl {
    fn ShowDialog(&self, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn GetState(&self, pstate: *mut core::ffi::c_void, pcbstate: *mut i32) -> windows_core::Result<()>;
    fn SetState(&self, pstate: *const core::ffi::c_void, cbstate: i32) -> windows_core::Result<()>;
    fn SendDriverMessage(&self, umsg: i32, dw1: i32, dw2: i32) -> windows_core::Result<()>;
}
impl IAMVfwCompressDialogs_Vtbl {
    pub const fn new<Identity: IAMVfwCompressDialogs_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ShowDialog<Identity: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idialog: i32, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCompressDialogs_Impl::ShowDialog(this, core::mem::transmute_copy(&idialog), core::mem::transmute_copy(&hwnd)).into()
            }
        }
        unsafe extern "system" fn GetState<Identity: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void, pcbstate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCompressDialogs_Impl::GetState(this, core::mem::transmute_copy(&pstate), core::mem::transmute_copy(&pcbstate)).into()
            }
        }
        unsafe extern "system" fn SetState<Identity: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *const core::ffi::c_void, cbstate: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCompressDialogs_Impl::SetState(this, core::mem::transmute_copy(&pstate), core::mem::transmute_copy(&cbstate)).into()
            }
        }
        unsafe extern "system" fn SendDriverMessage<Identity: IAMVfwCompressDialogs_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, umsg: i32, dw1: i32, dw2: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVfwCompressDialogs_Impl::SendDriverMessage(this, core::mem::transmute_copy(&umsg), core::mem::transmute_copy(&dw1), core::mem::transmute_copy(&dw2)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ShowDialog: ShowDialog::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            SetState: SetState::<Identity, OFFSET>,
            SendDriverMessage: SendDriverMessage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVfwCompressDialogs as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVfwCompressDialogs {}
windows_core::imp::define_interface!(IAMVideoAccelerator, IAMVideoAccelerator_Vtbl, 0x256a6a22_fbad_11d1_82bf_00a0c9696c8f);
windows_core::imp::interface_hierarchy!(IAMVideoAccelerator, windows_core::IUnknown);
impl IAMVideoAccelerator {
    pub unsafe fn GetVideoAcceleratorGUIDs(&self, pdwnumguidssupported: *mut u32, pguidssupported: Option<*mut windows_core::GUID>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoAcceleratorGUIDs)(windows_core::Interface::as_raw(self), pdwnumguidssupported as _, pguidssupported.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetUncompFormatsSupported(&self, pguid: *const windows_core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: Option<*mut super::super::Graphics::DirectDraw::DDPIXELFORMAT>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetUncompFormatsSupported)(windows_core::Interface::as_raw(self), pguid, pdwnumformatssupported as _, pformatssupported.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetInternalMemInfo(&self, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInternalMemInfo)(windows_core::Interface::as_raw(self), pguid, pamvauncompdatainfo, pamvainternalmeminfo as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetCompBufferInfo(&self, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: Option<*mut AMVACompBufferInfo>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCompBufferInfo)(windows_core::Interface::as_raw(self), pguid, pamvauncompdatainfo, pdwnumtypescompbuffers as _, pamvacompbufferinfo.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetInternalCompBufferInfo(&self, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: Option<*mut AMVACompBufferInfo>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInternalCompBufferInfo)(windows_core::Interface::as_raw(self), pdwnumtypescompbuffers as _, pamvacompbufferinfo.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn BeginFrame(&self, amvabeginframeinfo: *const AMVABeginFrameInfo) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BeginFrame)(windows_core::Interface::as_raw(self), amvabeginframeinfo).ok() }
    }
    pub unsafe fn EndFrame(&self, pendframeinfo: *const AMVAEndFrameInfo) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EndFrame)(windows_core::Interface::as_raw(self), pendframeinfo).ok() }
    }
    pub unsafe fn GetBuffer(&self, dwtypeindex: u32, dwbufferindex: u32, breadonly: bool, ppbuffer: *mut *mut core::ffi::c_void, lpstride: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBuffer)(windows_core::Interface::as_raw(self), dwtypeindex, dwbufferindex, breadonly.into(), ppbuffer as _, lpstride as _).ok() }
    }
    pub unsafe fn ReleaseBuffer(&self, dwtypeindex: u32, dwbufferindex: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReleaseBuffer)(windows_core::Interface::as_raw(self), dwtypeindex, dwbufferindex).ok() }
    }
    pub unsafe fn Execute(&self, dwfunction: u32, lpprivateinputdata: *const core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const core::ffi::c_void, cbprivateoutputdata: u32, pamvabufferinfo: &[AMVABUFFERINFO]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Execute)(windows_core::Interface::as_raw(self), dwfunction, lpprivateinputdata, cbprivateinputdata, lpprivateoutputdat, cbprivateoutputdata, pamvabufferinfo.len().try_into().unwrap(), core::mem::transmute(pamvabufferinfo.as_ptr())).ok() }
    }
    pub unsafe fn QueryRenderStatus(&self, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryRenderStatus)(windows_core::Interface::as_raw(self), dwtypeindex, dwbufferindex, dwflags).ok() }
    }
    pub unsafe fn DisplayFrame<P1>(&self, dwfliptoindex: u32, pmediasample: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IMediaSample>,
    {
        unsafe { (windows_core::Interface::vtable(self).DisplayFrame)(windows_core::Interface::as_raw(self), dwfliptoindex, pmediasample.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoAccelerator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetVideoAcceleratorGUIDs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetUncompFormatsSupported: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut u32, *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetUncompFormatsSupported: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetInternalMemInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const AMVAUncompDataInfo, *mut AMVAInternalMemInfo) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetInternalMemInfo: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetCompBufferInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const AMVAUncompDataInfo, *mut u32, *mut AMVACompBufferInfo) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetCompBufferInfo: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetInternalCompBufferInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut AMVACompBufferInfo) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetInternalCompBufferInfo: usize,
    pub BeginFrame: unsafe extern "system" fn(*mut core::ffi::c_void, *const AMVABeginFrameInfo) -> windows_core::HRESULT,
    pub EndFrame: unsafe extern "system" fn(*mut core::ffi::c_void, *const AMVAEndFrameInfo) -> windows_core::HRESULT,
    pub GetBuffer: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, windows_core::BOOL, *mut *mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub ReleaseBuffer: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub Execute: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const core::ffi::c_void, u32, *const core::ffi::c_void, u32, u32, *const AMVABUFFERINFO) -> windows_core::HRESULT,
    pub QueryRenderStatus: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32) -> windows_core::HRESULT,
    pub DisplayFrame: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IAMVideoAccelerator_Impl: windows_core::IUnknownImpl {
    fn GetVideoAcceleratorGUIDs(&self, pdwnumguidssupported: *mut u32, pguidssupported: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetUncompFormatsSupported(&self, pguid: *const windows_core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::Result<()>;
    fn GetInternalMemInfo(&self, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> windows_core::Result<()>;
    fn GetCompBufferInfo(&self, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> windows_core::Result<()>;
    fn GetInternalCompBufferInfo(&self, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> windows_core::Result<()>;
    fn BeginFrame(&self, amvabeginframeinfo: *const AMVABeginFrameInfo) -> windows_core::Result<()>;
    fn EndFrame(&self, pendframeinfo: *const AMVAEndFrameInfo) -> windows_core::Result<()>;
    fn GetBuffer(&self, dwtypeindex: u32, dwbufferindex: u32, breadonly: windows_core::BOOL, ppbuffer: *mut *mut core::ffi::c_void, lpstride: *mut i32) -> windows_core::Result<()>;
    fn ReleaseBuffer(&self, dwtypeindex: u32, dwbufferindex: u32) -> windows_core::Result<()>;
    fn Execute(&self, dwfunction: u32, lpprivateinputdata: *const core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const core::ffi::c_void, cbprivateoutputdata: u32, dwnumbuffers: u32, pamvabufferinfo: *const AMVABUFFERINFO) -> windows_core::Result<()>;
    fn QueryRenderStatus(&self, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> windows_core::Result<()>;
    fn DisplayFrame(&self, dwfliptoindex: u32, pmediasample: windows_core::Ref<IMediaSample>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IAMVideoAccelerator_Vtbl {
    pub const fn new<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetVideoAcceleratorGUIDs<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumguidssupported: *mut u32, pguidssupported: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetVideoAcceleratorGUIDs(this, core::mem::transmute_copy(&pdwnumguidssupported), core::mem::transmute_copy(&pguidssupported)).into()
            }
        }
        unsafe extern "system" fn GetUncompFormatsSupported<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const windows_core::GUID, pdwnumformatssupported: *mut u32, pformatssupported: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetUncompFormatsSupported(this, core::mem::transmute_copy(&pguid), core::mem::transmute_copy(&pdwnumformatssupported), core::mem::transmute_copy(&pformatssupported)).into()
            }
        }
        unsafe extern "system" fn GetInternalMemInfo<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pamvainternalmeminfo: *mut AMVAInternalMemInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetInternalMemInfo(this, core::mem::transmute_copy(&pguid), core::mem::transmute_copy(&pamvauncompdatainfo), core::mem::transmute_copy(&pamvainternalmeminfo)).into()
            }
        }
        unsafe extern "system" fn GetCompBufferInfo<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const windows_core::GUID, pamvauncompdatainfo: *const AMVAUncompDataInfo, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetCompBufferInfo(this, core::mem::transmute_copy(&pguid), core::mem::transmute_copy(&pamvauncompdatainfo), core::mem::transmute_copy(&pdwnumtypescompbuffers), core::mem::transmute_copy(&pamvacompbufferinfo)).into()
            }
        }
        unsafe extern "system" fn GetInternalCompBufferInfo<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumtypescompbuffers: *mut u32, pamvacompbufferinfo: *mut AMVACompBufferInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetInternalCompBufferInfo(this, core::mem::transmute_copy(&pdwnumtypescompbuffers), core::mem::transmute_copy(&pamvacompbufferinfo)).into()
            }
        }
        unsafe extern "system" fn BeginFrame<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, amvabeginframeinfo: *const AMVABeginFrameInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::BeginFrame(this, core::mem::transmute_copy(&amvabeginframeinfo)).into()
            }
        }
        unsafe extern "system" fn EndFrame<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pendframeinfo: *const AMVAEndFrameInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::EndFrame(this, core::mem::transmute_copy(&pendframeinfo)).into()
            }
        }
        unsafe extern "system" fn GetBuffer<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, breadonly: windows_core::BOOL, ppbuffer: *mut *mut core::ffi::c_void, lpstride: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::GetBuffer(this, core::mem::transmute_copy(&dwtypeindex), core::mem::transmute_copy(&dwbufferindex), core::mem::transmute_copy(&breadonly), core::mem::transmute_copy(&ppbuffer), core::mem::transmute_copy(&lpstride)).into()
            }
        }
        unsafe extern "system" fn ReleaseBuffer<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::ReleaseBuffer(this, core::mem::transmute_copy(&dwtypeindex), core::mem::transmute_copy(&dwbufferindex)).into()
            }
        }
        unsafe extern "system" fn Execute<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwfunction: u32, lpprivateinputdata: *const core::ffi::c_void, cbprivateinputdata: u32, lpprivateoutputdat: *const core::ffi::c_void, cbprivateoutputdata: u32, dwnumbuffers: u32, pamvabufferinfo: *const AMVABUFFERINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::Execute(this, core::mem::transmute_copy(&dwfunction), core::mem::transmute_copy(&lpprivateinputdata), core::mem::transmute_copy(&cbprivateinputdata), core::mem::transmute_copy(&lpprivateoutputdat), core::mem::transmute_copy(&cbprivateoutputdata), core::mem::transmute_copy(&dwnumbuffers), core::mem::transmute_copy(&pamvabufferinfo)).into()
            }
        }
        unsafe extern "system" fn QueryRenderStatus<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtypeindex: u32, dwbufferindex: u32, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::QueryRenderStatus(this, core::mem::transmute_copy(&dwtypeindex), core::mem::transmute_copy(&dwbufferindex), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn DisplayFrame<Identity: IAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwfliptoindex: u32, pmediasample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAccelerator_Impl::DisplayFrame(this, core::mem::transmute_copy(&dwfliptoindex), core::mem::transmute_copy(&pmediasample)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetVideoAcceleratorGUIDs: GetVideoAcceleratorGUIDs::<Identity, OFFSET>,
            GetUncompFormatsSupported: GetUncompFormatsSupported::<Identity, OFFSET>,
            GetInternalMemInfo: GetInternalMemInfo::<Identity, OFFSET>,
            GetCompBufferInfo: GetCompBufferInfo::<Identity, OFFSET>,
            GetInternalCompBufferInfo: GetInternalCompBufferInfo::<Identity, OFFSET>,
            BeginFrame: BeginFrame::<Identity, OFFSET>,
            EndFrame: EndFrame::<Identity, OFFSET>,
            GetBuffer: GetBuffer::<Identity, OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Identity, OFFSET>,
            Execute: Execute::<Identity, OFFSET>,
            QueryRenderStatus: QueryRenderStatus::<Identity, OFFSET>,
            DisplayFrame: DisplayFrame::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoAccelerator as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IAMVideoAccelerator {}
windows_core::imp::define_interface!(IAMVideoAcceleratorNotify, IAMVideoAcceleratorNotify_Vtbl, 0x256a6a21_fbad_11d1_82bf_00a0c9696c8f);
windows_core::imp::interface_hierarchy!(IAMVideoAcceleratorNotify, windows_core::IUnknown);
impl IAMVideoAcceleratorNotify {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetUncompSurfacesInfo(&self, pguid: *const windows_core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetUncompSurfacesInfo)(windows_core::Interface::as_raw(self), pguid, puncompbufferinfo as _).ok() }
    }
    pub unsafe fn SetUncompSurfacesInfo(&self, dwactualuncompsurfacesallocated: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetUncompSurfacesInfo)(windows_core::Interface::as_raw(self), dwactualuncompsurfacesallocated).ok() }
    }
    pub unsafe fn GetCreateVideoAcceleratorData(&self, pguid: *const windows_core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut core::ffi::c_void) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCreateVideoAcceleratorData)(windows_core::Interface::as_raw(self), pguid, pdwsizemiscdata as _, ppmiscdata as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoAcceleratorNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetUncompSurfacesInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut AMVAUncompBufferInfo) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetUncompSurfacesInfo: usize,
    pub SetUncompSurfacesInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetCreateVideoAcceleratorData: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IAMVideoAcceleratorNotify_Impl: windows_core::IUnknownImpl {
    fn GetUncompSurfacesInfo(&self, pguid: *const windows_core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> windows_core::Result<()>;
    fn SetUncompSurfacesInfo(&self, dwactualuncompsurfacesallocated: u32) -> windows_core::Result<()>;
    fn GetCreateVideoAcceleratorData(&self, pguid: *const windows_core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IAMVideoAcceleratorNotify_Vtbl {
    pub const fn new<Identity: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetUncompSurfacesInfo<Identity: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const windows_core::GUID, puncompbufferinfo: *mut AMVAUncompBufferInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAcceleratorNotify_Impl::GetUncompSurfacesInfo(this, core::mem::transmute_copy(&pguid), core::mem::transmute_copy(&puncompbufferinfo)).into()
            }
        }
        unsafe extern "system" fn SetUncompSurfacesInfo<Identity: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwactualuncompsurfacesallocated: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAcceleratorNotify_Impl::SetUncompSurfacesInfo(this, core::mem::transmute_copy(&dwactualuncompsurfacesallocated)).into()
            }
        }
        unsafe extern "system" fn GetCreateVideoAcceleratorData<Identity: IAMVideoAcceleratorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const windows_core::GUID, pdwsizemiscdata: *mut u32, ppmiscdata: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoAcceleratorNotify_Impl::GetCreateVideoAcceleratorData(this, core::mem::transmute_copy(&pguid), core::mem::transmute_copy(&pdwsizemiscdata), core::mem::transmute_copy(&ppmiscdata)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetUncompSurfacesInfo: GetUncompSurfacesInfo::<Identity, OFFSET>,
            SetUncompSurfacesInfo: SetUncompSurfacesInfo::<Identity, OFFSET>,
            GetCreateVideoAcceleratorData: GetCreateVideoAcceleratorData::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoAcceleratorNotify as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IAMVideoAcceleratorNotify {}
windows_core::imp::define_interface!(IAMVideoCompression, IAMVideoCompression_Vtbl, 0xc6e13343_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMVideoCompression, windows_core::IUnknown);
impl IAMVideoCompression {
    pub unsafe fn SetKeyFrameRate(&self, keyframerate: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetKeyFrameRate)(windows_core::Interface::as_raw(self), keyframerate).ok() }
    }
    pub unsafe fn KeyFrameRate(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).KeyFrameRate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetPFramesPerKeyFrame(&self, pframesperkeyframe: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPFramesPerKeyFrame)(windows_core::Interface::as_raw(self), pframesperkeyframe).ok() }
    }
    pub unsafe fn PFramesPerKeyFrame(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PFramesPerKeyFrame)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetQuality(&self, quality: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetQuality)(windows_core::Interface::as_raw(self), quality).ok() }
    }
    pub unsafe fn Quality(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Quality)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetWindowSize(&self, windowsize: u64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowSize)(windows_core::Interface::as_raw(self), windowsize).ok() }
    }
    pub unsafe fn WindowSize(&self) -> windows_core::Result<u64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WindowSize)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetInfo(&self, pszversion: Option<windows_core::PWSTR>, pcbversion: Option<*mut i32>, pszdescription: Option<windows_core::PWSTR>, pcbdescription: Option<*mut i32>, pdefaultkeyframerate: Option<*mut i32>, pdefaultpframesperkey: Option<*mut i32>, pdefaultquality: Option<*mut f64>, pcapabilities: Option<*mut i32>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInfo)(windows_core::Interface::as_raw(self), pszversion.unwrap_or(core::mem::zeroed()) as _, pcbversion.unwrap_or(core::mem::zeroed()) as _, pszdescription.unwrap_or(core::mem::zeroed()) as _, pcbdescription.unwrap_or(core::mem::zeroed()) as _, pdefaultkeyframerate.unwrap_or(core::mem::zeroed()) as _, pdefaultpframesperkey.unwrap_or(core::mem::zeroed()) as _, pdefaultquality.unwrap_or(core::mem::zeroed()) as _, pcapabilities.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn OverrideKeyFrame(&self, framenumber: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OverrideKeyFrame)(windows_core::Interface::as_raw(self), framenumber).ok() }
    }
    pub unsafe fn OverrideFrameSize(&self, framenumber: i32, size: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OverrideFrameSize)(windows_core::Interface::as_raw(self), framenumber, size).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoCompression_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetKeyFrameRate: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub KeyFrameRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetPFramesPerKeyFrame: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub PFramesPerKeyFrame: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetQuality: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Quality: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetWindowSize: unsafe extern "system" fn(*mut core::ffi::c_void, u64) -> windows_core::HRESULT,
    pub WindowSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u64) -> windows_core::HRESULT,
    pub GetInfo: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PWSTR, *mut i32, windows_core::PWSTR, *mut i32, *mut i32, *mut i32, *mut f64, *mut i32) -> windows_core::HRESULT,
    pub OverrideKeyFrame: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub OverrideFrameSize: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
}
pub trait IAMVideoCompression_Impl: windows_core::IUnknownImpl {
    fn SetKeyFrameRate(&self, keyframerate: i32) -> windows_core::Result<()>;
    fn KeyFrameRate(&self) -> windows_core::Result<i32>;
    fn SetPFramesPerKeyFrame(&self, pframesperkeyframe: i32) -> windows_core::Result<()>;
    fn PFramesPerKeyFrame(&self) -> windows_core::Result<i32>;
    fn SetQuality(&self, quality: f64) -> windows_core::Result<()>;
    fn Quality(&self) -> windows_core::Result<f64>;
    fn SetWindowSize(&self, windowsize: u64) -> windows_core::Result<()>;
    fn WindowSize(&self) -> windows_core::Result<u64>;
    fn GetInfo(&self, pszversion: windows_core::PWSTR, pcbversion: *mut i32, pszdescription: windows_core::PWSTR, pcbdescription: *mut i32, pdefaultkeyframerate: *mut i32, pdefaultpframesperkey: *mut i32, pdefaultquality: *mut f64, pcapabilities: *mut i32) -> windows_core::Result<()>;
    fn OverrideKeyFrame(&self, framenumber: i32) -> windows_core::Result<()>;
    fn OverrideFrameSize(&self, framenumber: i32, size: i32) -> windows_core::Result<()>;
}
impl IAMVideoCompression_Vtbl {
    pub const fn new<Identity: IAMVideoCompression_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetKeyFrameRate<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keyframerate: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::SetKeyFrameRate(this, core::mem::transmute_copy(&keyframerate)).into()
            }
        }
        unsafe extern "system" fn KeyFrameRate<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkeyframerate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoCompression_Impl::KeyFrameRate(this) {
                    Ok(ok__) => {
                        pkeyframerate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPFramesPerKeyFrame<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pframesperkeyframe: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::SetPFramesPerKeyFrame(this, core::mem::transmute_copy(&pframesperkeyframe)).into()
            }
        }
        unsafe extern "system" fn PFramesPerKeyFrame<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppframesperkeyframe: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoCompression_Impl::PFramesPerKeyFrame(this) {
                    Ok(ok__) => {
                        ppframesperkeyframe.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetQuality<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, quality: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::SetQuality(this, core::mem::transmute_copy(&quality)).into()
            }
        }
        unsafe extern "system" fn Quality<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pquality: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoCompression_Impl::Quality(this) {
                    Ok(ok__) => {
                        pquality.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetWindowSize<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowsize: u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::SetWindowSize(this, core::mem::transmute_copy(&windowsize)).into()
            }
        }
        unsafe extern "system" fn WindowSize<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwindowsize: *mut u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoCompression_Impl::WindowSize(this) {
                    Ok(ok__) => {
                        pwindowsize.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetInfo<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszversion: windows_core::PWSTR, pcbversion: *mut i32, pszdescription: windows_core::PWSTR, pcbdescription: *mut i32, pdefaultkeyframerate: *mut i32, pdefaultpframesperkey: *mut i32, pdefaultquality: *mut f64, pcapabilities: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::GetInfo(this, core::mem::transmute_copy(&pszversion), core::mem::transmute_copy(&pcbversion), core::mem::transmute_copy(&pszdescription), core::mem::transmute_copy(&pcbdescription), core::mem::transmute_copy(&pdefaultkeyframerate), core::mem::transmute_copy(&pdefaultpframesperkey), core::mem::transmute_copy(&pdefaultquality), core::mem::transmute_copy(&pcapabilities)).into()
            }
        }
        unsafe extern "system" fn OverrideKeyFrame<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, framenumber: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::OverrideKeyFrame(this, core::mem::transmute_copy(&framenumber)).into()
            }
        }
        unsafe extern "system" fn OverrideFrameSize<Identity: IAMVideoCompression_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, framenumber: i32, size: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoCompression_Impl::OverrideFrameSize(this, core::mem::transmute_copy(&framenumber), core::mem::transmute_copy(&size)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetKeyFrameRate: SetKeyFrameRate::<Identity, OFFSET>,
            KeyFrameRate: KeyFrameRate::<Identity, OFFSET>,
            SetPFramesPerKeyFrame: SetPFramesPerKeyFrame::<Identity, OFFSET>,
            PFramesPerKeyFrame: PFramesPerKeyFrame::<Identity, OFFSET>,
            SetQuality: SetQuality::<Identity, OFFSET>,
            Quality: Quality::<Identity, OFFSET>,
            SetWindowSize: SetWindowSize::<Identity, OFFSET>,
            WindowSize: WindowSize::<Identity, OFFSET>,
            GetInfo: GetInfo::<Identity, OFFSET>,
            OverrideKeyFrame: OverrideKeyFrame::<Identity, OFFSET>,
            OverrideFrameSize: OverrideFrameSize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoCompression as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVideoCompression {}
windows_core::imp::define_interface!(IAMVideoControl, IAMVideoControl_Vtbl, 0x6a2e0670_28e4_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMVideoControl, windows_core::IUnknown);
impl IAMVideoControl {
    pub unsafe fn GetCaps<P0>(&self, ppin: P0) -> windows_core::Result<i32>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCaps)(windows_core::Interface::as_raw(self), ppin.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMode<P0>(&self, ppin: P0, mode: i32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetMode)(windows_core::Interface::as_raw(self), ppin.param().abi(), mode).ok() }
    }
    pub unsafe fn GetMode<P0>(&self, ppin: P0) -> windows_core::Result<i32>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMode)(windows_core::Interface::as_raw(self), ppin.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentActualFrameRate<P0>(&self, ppin: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentActualFrameRate)(windows_core::Interface::as_raw(self), ppin.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetMaxAvailableFrameRate<P0>(&self, ppin: P0, iindex: i32, dimensions: super::super::Foundation::SIZE) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMaxAvailableFrameRate)(windows_core::Interface::as_raw(self), ppin.param().abi(), iindex, core::mem::transmute(dimensions), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetFrameRateList<P0>(&self, ppin: P0, iindex: i32, dimensions: super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).GetFrameRateList)(windows_core::Interface::as_raw(self), ppin.param().abi(), iindex, core::mem::transmute(dimensions), listsize as _, framerates as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetCurrentActualFrameRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetMaxAvailableFrameRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32, super::super::Foundation::SIZE, *mut i64) -> windows_core::HRESULT,
    pub GetFrameRateList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, i32, super::super::Foundation::SIZE, *mut i32, *mut *mut i64) -> windows_core::HRESULT,
}
pub trait IAMVideoControl_Impl: windows_core::IUnknownImpl {
    fn GetCaps(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<i32>;
    fn SetMode(&self, ppin: windows_core::Ref<IPin>, mode: i32) -> windows_core::Result<()>;
    fn GetMode(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<i32>;
    fn GetCurrentActualFrameRate(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<i64>;
    fn GetMaxAvailableFrameRate(&self, ppin: windows_core::Ref<IPin>, iindex: i32, dimensions: &super::super::Foundation::SIZE) -> windows_core::Result<i64>;
    fn GetFrameRateList(&self, ppin: windows_core::Ref<IPin>, iindex: i32, dimensions: &super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> windows_core::Result<()>;
}
impl IAMVideoControl_Vtbl {
    pub const fn new<Identity: IAMVideoControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCaps<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, pcapsflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoControl_Impl::GetCaps(this, core::mem::transmute_copy(&ppin)) {
                    Ok(ok__) => {
                        pcapsflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMode<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, mode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoControl_Impl::SetMode(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn GetMode<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, mode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoControl_Impl::GetMode(this, core::mem::transmute_copy(&ppin)) {
                    Ok(ok__) => {
                        mode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentActualFrameRate<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, actualframerate: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoControl_Impl::GetCurrentActualFrameRate(this, core::mem::transmute_copy(&ppin)) {
                    Ok(ok__) => {
                        actualframerate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetMaxAvailableFrameRate<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, iindex: i32, dimensions: super::super::Foundation::SIZE, maxavailableframerate: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoControl_Impl::GetMaxAvailableFrameRate(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&iindex), core::mem::transmute(&dimensions)) {
                    Ok(ok__) => {
                        maxavailableframerate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetFrameRateList<Identity: IAMVideoControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, iindex: i32, dimensions: super::super::Foundation::SIZE, listsize: *mut i32, framerates: *mut *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoControl_Impl::GetFrameRateList(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&iindex), core::mem::transmute(&dimensions), core::mem::transmute_copy(&listsize), core::mem::transmute_copy(&framerates)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCaps: GetCaps::<Identity, OFFSET>,
            SetMode: SetMode::<Identity, OFFSET>,
            GetMode: GetMode::<Identity, OFFSET>,
            GetCurrentActualFrameRate: GetCurrentActualFrameRate::<Identity, OFFSET>,
            GetMaxAvailableFrameRate: GetMaxAvailableFrameRate::<Identity, OFFSET>,
            GetFrameRateList: GetFrameRateList::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVideoControl {}
windows_core::imp::define_interface!(IAMVideoDecimationProperties, IAMVideoDecimationProperties_Vtbl, 0x60d32930_13da_11d3_9ec6_c4fcaef5c7be);
windows_core::imp::interface_hierarchy!(IAMVideoDecimationProperties, windows_core::IUnknown);
impl IAMVideoDecimationProperties {
    pub unsafe fn QueryDecimationUsage(&self) -> windows_core::Result<DECIMATION_USAGE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryDecimationUsage)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDecimationUsage(&self, usage: DECIMATION_USAGE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDecimationUsage)(windows_core::Interface::as_raw(self), usage).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoDecimationProperties_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryDecimationUsage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DECIMATION_USAGE) -> windows_core::HRESULT,
    pub SetDecimationUsage: unsafe extern "system" fn(*mut core::ffi::c_void, DECIMATION_USAGE) -> windows_core::HRESULT,
}
pub trait IAMVideoDecimationProperties_Impl: windows_core::IUnknownImpl {
    fn QueryDecimationUsage(&self) -> windows_core::Result<DECIMATION_USAGE>;
    fn SetDecimationUsage(&self, usage: DECIMATION_USAGE) -> windows_core::Result<()>;
}
impl IAMVideoDecimationProperties_Vtbl {
    pub const fn new<Identity: IAMVideoDecimationProperties_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryDecimationUsage<Identity: IAMVideoDecimationProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpusage: *mut DECIMATION_USAGE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAMVideoDecimationProperties_Impl::QueryDecimationUsage(this) {
                    Ok(ok__) => {
                        lpusage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDecimationUsage<Identity: IAMVideoDecimationProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usage: DECIMATION_USAGE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoDecimationProperties_Impl::SetDecimationUsage(this, core::mem::transmute_copy(&usage)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryDecimationUsage: QueryDecimationUsage::<Identity, OFFSET>,
            SetDecimationUsage: SetDecimationUsage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoDecimationProperties as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVideoDecimationProperties {}
windows_core::imp::define_interface!(IAMVideoProcAmp, IAMVideoProcAmp_Vtbl, 0xc6e13360_30ac_11d0_a18c_00a0c9118956);
windows_core::imp::interface_hierarchy!(IAMVideoProcAmp, windows_core::IUnknown);
impl IAMVideoProcAmp {
    pub unsafe fn GetRange(&self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRange)(windows_core::Interface::as_raw(self), property, pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflags as _).ok() }
    }
    pub unsafe fn Set(&self, property: i32, lvalue: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Set)(windows_core::Interface::as_raw(self), property, lvalue, flags).ok() }
    }
    pub unsafe fn Get(&self, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Get)(windows_core::Interface::as_raw(self), property, lvalue as _, flags as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMVideoProcAmp_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetRange: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub Set: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub Get: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32) -> windows_core::HRESULT,
}
pub trait IAMVideoProcAmp_Impl: windows_core::IUnknownImpl {
    fn GetRange(&self, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::Result<()>;
    fn Set(&self, property: i32, lvalue: i32, flags: i32) -> windows_core::Result<()>;
    fn Get(&self, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::Result<()>;
}
impl IAMVideoProcAmp_Vtbl {
    pub const fn new<Identity: IAMVideoProcAmp_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetRange<Identity: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoProcAmp_Impl::GetRange(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflags)).into()
            }
        }
        unsafe extern "system" fn Set<Identity: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, lvalue: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoProcAmp_Impl::Set(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&lvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn Get<Identity: IAMVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, property: i32, lvalue: *mut i32, flags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMVideoProcAmp_Impl::Get(this, core::mem::transmute_copy(&property), core::mem::transmute_copy(&lvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRange: GetRange::<Identity, OFFSET>,
            Set: Set::<Identity, OFFSET>,
            Get: Get::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMVideoProcAmp as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMVideoProcAmp {}
windows_core::imp::define_interface!(IAMWMBufferPass, IAMWMBufferPass_Vtbl, 0x6dd816d7_e740_4123_9e24_2444412644d8);
windows_core::imp::interface_hierarchy!(IAMWMBufferPass, windows_core::IUnknown);
impl IAMWMBufferPass {
    pub unsafe fn SetNotify<P0>(&self, pcallback: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMWMBufferPassCallback>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetNotify)(windows_core::Interface::as_raw(self), pcallback.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMWMBufferPass_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMWMBufferPass_Impl: windows_core::IUnknownImpl {
    fn SetNotify(&self, pcallback: windows_core::Ref<IAMWMBufferPassCallback>) -> windows_core::Result<()>;
}
impl IAMWMBufferPass_Vtbl {
    pub const fn new<Identity: IAMWMBufferPass_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetNotify<Identity: IAMWMBufferPass_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWMBufferPass_Impl::SetNotify(this, core::mem::transmute_copy(&pcallback)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetNotify: SetNotify::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMWMBufferPass as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMWMBufferPass {}
windows_core::imp::define_interface!(IAMWMBufferPassCallback, IAMWMBufferPassCallback_Vtbl, 0xb25b8372_d2d2_44b2_8653_1b8dae332489);
windows_core::imp::interface_hierarchy!(IAMWMBufferPassCallback, windows_core::IUnknown);
impl IAMWMBufferPassCallback {
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn Notify<P0, P1>(&self, pnssbuffer3: P0, ppin: P1, prtstart: *const i64, prtend: *const i64) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::WindowsMediaFormat::INSSBuffer3>,
        P1: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Notify)(windows_core::Interface::as_raw(self), pnssbuffer3.param().abi(), ppin.param().abi(), prtstart, prtend).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMWMBufferPassCallback_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub Notify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_WindowsMediaFormat"))]
    Notify: usize,
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
pub trait IAMWMBufferPassCallback_Impl: windows_core::IUnknownImpl {
    fn Notify(&self, pnssbuffer3: windows_core::Ref<super::WindowsMediaFormat::INSSBuffer3>, ppin: windows_core::Ref<IPin>, prtstart: *const i64, prtend: *const i64) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl IAMWMBufferPassCallback_Vtbl {
    pub const fn new<Identity: IAMWMBufferPassCallback_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Notify<Identity: IAMWMBufferPassCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnssbuffer3: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, prtstart: *const i64, prtend: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWMBufferPassCallback_Impl::Notify(this, core::mem::transmute_copy(&pnssbuffer3), core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&prtstart), core::mem::transmute_copy(&prtend)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Notify: Notify::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMWMBufferPassCallback as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl windows_core::RuntimeName for IAMWMBufferPassCallback {}
windows_core::imp::define_interface!(IAMWstDecoder, IAMWstDecoder_Vtbl, 0xc056de21_75c2_11d3_a184_00105aef9f33);
windows_core::imp::interface_hierarchy!(IAMWstDecoder, windows_core::IUnknown);
impl IAMWstDecoder {
    pub unsafe fn GetDecoderLevel(&self, lplevel: *mut AM_WST_LEVEL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDecoderLevel)(windows_core::Interface::as_raw(self), lplevel as _).ok() }
    }
    pub unsafe fn GetCurrentService(&self, lpservice: *mut AM_WST_SERVICE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentService)(windows_core::Interface::as_raw(self), lpservice as _).ok() }
    }
    pub unsafe fn GetServiceState(&self, lpstate: *mut AM_WST_STATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetServiceState)(windows_core::Interface::as_raw(self), lpstate as _).ok() }
    }
    pub unsafe fn SetServiceState(&self, state: AM_WST_STATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetServiceState)(windows_core::Interface::as_raw(self), state).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetOutputFormat(&self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetOutputFormat)(windows_core::Interface::as_raw(self), lpbmih as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn SetOutputFormat(&self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputFormat)(windows_core::Interface::as_raw(self), lpbmi as _).ok() }
    }
    pub unsafe fn GetBackgroundColor(&self, pdwphyscolor: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBackgroundColor)(windows_core::Interface::as_raw(self), pdwphyscolor as _).ok() }
    }
    pub unsafe fn SetBackgroundColor(&self, dwphyscolor: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBackgroundColor)(windows_core::Interface::as_raw(self), dwphyscolor).ok() }
    }
    pub unsafe fn GetRedrawAlways(&self, lpboption: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRedrawAlways)(windows_core::Interface::as_raw(self), lpboption as _).ok() }
    }
    pub unsafe fn SetRedrawAlways(&self, boption: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRedrawAlways)(windows_core::Interface::as_raw(self), boption.into()).ok() }
    }
    pub unsafe fn GetDrawBackgroundMode(&self, lpmode: *mut AM_WST_DRAWBGMODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDrawBackgroundMode)(windows_core::Interface::as_raw(self), lpmode as _).ok() }
    }
    pub unsafe fn SetDrawBackgroundMode(&self, mode: AM_WST_DRAWBGMODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDrawBackgroundMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn SetAnswerMode(&self, banswer: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAnswerMode)(windows_core::Interface::as_raw(self), banswer.into()).ok() }
    }
    pub unsafe fn GetAnswerMode(&self, pbanswer: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAnswerMode)(windows_core::Interface::as_raw(self), pbanswer as _).ok() }
    }
    pub unsafe fn SetHoldPage(&self, bholdpage: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetHoldPage)(windows_core::Interface::as_raw(self), bholdpage.into()).ok() }
    }
    pub unsafe fn GetHoldPage(&self, pbholdpage: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetHoldPage)(windows_core::Interface::as_raw(self), pbholdpage as _).ok() }
    }
    pub unsafe fn GetCurrentPage(&self, pwstpage: *mut AM_WST_PAGE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentPage)(windows_core::Interface::as_raw(self), pwstpage as _).ok() }
    }
    pub unsafe fn SetCurrentPage(&self, wstpage: AM_WST_PAGE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCurrentPage)(windows_core::Interface::as_raw(self), core::mem::transmute(wstpage)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMWstDecoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetDecoderLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_WST_LEVEL) -> windows_core::HRESULT,
    pub GetCurrentService: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_WST_SERVICE) -> windows_core::HRESULT,
    pub GetServiceState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_WST_STATE) -> windows_core::HRESULT,
    pub SetServiceState: unsafe extern "system" fn(*mut core::ffi::c_void, AM_WST_STATE) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetOutputFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetOutputFormat: usize,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub SetOutputFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    SetOutputFormat: usize,
    pub GetBackgroundColor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetBackgroundColor: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRedrawAlways: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetRedrawAlways: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetDrawBackgroundMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_WST_DRAWBGMODE) -> windows_core::HRESULT,
    pub SetDrawBackgroundMode: unsafe extern "system" fn(*mut core::ffi::c_void, AM_WST_DRAWBGMODE) -> windows_core::HRESULT,
    pub SetAnswerMode: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetAnswerMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetHoldPage: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetHoldPage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub GetCurrentPage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_WST_PAGE) -> windows_core::HRESULT,
    pub SetCurrentPage: unsafe extern "system" fn(*mut core::ffi::c_void, AM_WST_PAGE) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IAMWstDecoder_Impl: windows_core::IUnknownImpl {
    fn GetDecoderLevel(&self, lplevel: *mut AM_WST_LEVEL) -> windows_core::Result<()>;
    fn GetCurrentService(&self, lpservice: *mut AM_WST_SERVICE) -> windows_core::Result<()>;
    fn GetServiceState(&self, lpstate: *mut AM_WST_STATE) -> windows_core::Result<()>;
    fn SetServiceState(&self, state: AM_WST_STATE) -> windows_core::Result<()>;
    fn GetOutputFormat(&self, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::Result<()>;
    fn SetOutputFormat(&self, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::Result<()>;
    fn GetBackgroundColor(&self, pdwphyscolor: *mut u32) -> windows_core::Result<()>;
    fn SetBackgroundColor(&self, dwphyscolor: u32) -> windows_core::Result<()>;
    fn GetRedrawAlways(&self, lpboption: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetRedrawAlways(&self, boption: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetDrawBackgroundMode(&self, lpmode: *mut AM_WST_DRAWBGMODE) -> windows_core::Result<()>;
    fn SetDrawBackgroundMode(&self, mode: AM_WST_DRAWBGMODE) -> windows_core::Result<()>;
    fn SetAnswerMode(&self, banswer: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetAnswerMode(&self, pbanswer: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetHoldPage(&self, bholdpage: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetHoldPage(&self, pbholdpage: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn GetCurrentPage(&self, pwstpage: *mut AM_WST_PAGE) -> windows_core::Result<()>;
    fn SetCurrentPage(&self, wstpage: &AM_WST_PAGE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IAMWstDecoder_Vtbl {
    pub const fn new<Identity: IAMWstDecoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDecoderLevel<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplevel: *mut AM_WST_LEVEL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetDecoderLevel(this, core::mem::transmute_copy(&lplevel)).into()
            }
        }
        unsafe extern "system" fn GetCurrentService<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpservice: *mut AM_WST_SERVICE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetCurrentService(this, core::mem::transmute_copy(&lpservice)).into()
            }
        }
        unsafe extern "system" fn GetServiceState<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpstate: *mut AM_WST_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetServiceState(this, core::mem::transmute_copy(&lpstate)).into()
            }
        }
        unsafe extern "system" fn SetServiceState<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: AM_WST_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetServiceState(this, core::mem::transmute_copy(&state)).into()
            }
        }
        unsafe extern "system" fn GetOutputFormat<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpbmih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetOutputFormat(this, core::mem::transmute_copy(&lpbmih)).into()
            }
        }
        unsafe extern "system" fn SetOutputFormat<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpbmi: *mut super::super::Graphics::Gdi::BITMAPINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetOutputFormat(this, core::mem::transmute_copy(&lpbmi)).into()
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwphyscolor: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetBackgroundColor(this, core::mem::transmute_copy(&pdwphyscolor)).into()
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwphyscolor: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetBackgroundColor(this, core::mem::transmute_copy(&dwphyscolor)).into()
            }
        }
        unsafe extern "system" fn GetRedrawAlways<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpboption: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetRedrawAlways(this, core::mem::transmute_copy(&lpboption)).into()
            }
        }
        unsafe extern "system" fn SetRedrawAlways<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, boption: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetRedrawAlways(this, core::mem::transmute_copy(&boption)).into()
            }
        }
        unsafe extern "system" fn GetDrawBackgroundMode<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpmode: *mut AM_WST_DRAWBGMODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetDrawBackgroundMode(this, core::mem::transmute_copy(&lpmode)).into()
            }
        }
        unsafe extern "system" fn SetDrawBackgroundMode<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: AM_WST_DRAWBGMODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetDrawBackgroundMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn SetAnswerMode<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, banswer: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetAnswerMode(this, core::mem::transmute_copy(&banswer)).into()
            }
        }
        unsafe extern "system" fn GetAnswerMode<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbanswer: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetAnswerMode(this, core::mem::transmute_copy(&pbanswer)).into()
            }
        }
        unsafe extern "system" fn SetHoldPage<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bholdpage: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetHoldPage(this, core::mem::transmute_copy(&bholdpage)).into()
            }
        }
        unsafe extern "system" fn GetHoldPage<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbholdpage: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetHoldPage(this, core::mem::transmute_copy(&pbholdpage)).into()
            }
        }
        unsafe extern "system" fn GetCurrentPage<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwstpage: *mut AM_WST_PAGE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::GetCurrentPage(this, core::mem::transmute_copy(&pwstpage)).into()
            }
        }
        unsafe extern "system" fn SetCurrentPage<Identity: IAMWstDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstpage: AM_WST_PAGE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMWstDecoder_Impl::SetCurrentPage(this, core::mem::transmute(&wstpage)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDecoderLevel: GetDecoderLevel::<Identity, OFFSET>,
            GetCurrentService: GetCurrentService::<Identity, OFFSET>,
            GetServiceState: GetServiceState::<Identity, OFFSET>,
            SetServiceState: SetServiceState::<Identity, OFFSET>,
            GetOutputFormat: GetOutputFormat::<Identity, OFFSET>,
            SetOutputFormat: SetOutputFormat::<Identity, OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Identity, OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Identity, OFFSET>,
            GetRedrawAlways: GetRedrawAlways::<Identity, OFFSET>,
            SetRedrawAlways: SetRedrawAlways::<Identity, OFFSET>,
            GetDrawBackgroundMode: GetDrawBackgroundMode::<Identity, OFFSET>,
            SetDrawBackgroundMode: SetDrawBackgroundMode::<Identity, OFFSET>,
            SetAnswerMode: SetAnswerMode::<Identity, OFFSET>,
            GetAnswerMode: GetAnswerMode::<Identity, OFFSET>,
            SetHoldPage: SetHoldPage::<Identity, OFFSET>,
            GetHoldPage: GetHoldPage::<Identity, OFFSET>,
            GetCurrentPage: GetCurrentPage::<Identity, OFFSET>,
            SetCurrentPage: SetCurrentPage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMWstDecoder as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IAMWstDecoder {}
windows_core::imp::define_interface!(IAMovieSetup, IAMovieSetup_Vtbl, 0xa3d8cec0_7e5a_11cf_bbc5_00805f6cef20);
windows_core::imp::interface_hierarchy!(IAMovieSetup, windows_core::IUnknown);
impl IAMovieSetup {
    pub unsafe fn Register(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Register)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Unregister(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Unregister)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAMovieSetup_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Register: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Unregister: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAMovieSetup_Impl: windows_core::IUnknownImpl {
    fn Register(&self) -> windows_core::Result<()>;
    fn Unregister(&self) -> windows_core::Result<()>;
}
impl IAMovieSetup_Vtbl {
    pub const fn new<Identity: IAMovieSetup_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Register<Identity: IAMovieSetup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMovieSetup_Impl::Register(this).into()
            }
        }
        unsafe extern "system" fn Unregister<Identity: IAMovieSetup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAMovieSetup_Impl::Unregister(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Register: Register::<Identity, OFFSET>,
            Unregister: Unregister::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAMovieSetup as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAMovieSetup {}
windows_core::imp::define_interface!(IAsyncReader, IAsyncReader_Vtbl, 0x56a868aa_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IAsyncReader, windows_core::IUnknown);
impl IAsyncReader {
    pub unsafe fn RequestAllocator<P0>(&self, ppreferred: P0, pprops: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<IMemAllocator>
    where
        P0: windows_core::Param<IMemAllocator>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).RequestAllocator)(windows_core::Interface::as_raw(self), ppreferred.param().abi(), pprops, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Request<P0>(&self, psample: P0, dwuser: usize) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaSample>,
    {
        unsafe { (windows_core::Interface::vtable(self).Request)(windows_core::Interface::as_raw(self), psample.param().abi(), dwuser).ok() }
    }
    pub unsafe fn WaitForNext(&self, dwtimeout: u32, ppsample: Option<*mut Option<IMediaSample>>, pdwuser: *mut usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WaitForNext)(windows_core::Interface::as_raw(self), dwtimeout, ppsample.unwrap_or(core::mem::zeroed()) as _, pdwuser as _).ok() }
    }
    pub unsafe fn SyncReadAligned<P0>(&self, psample: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaSample>,
    {
        unsafe { (windows_core::Interface::vtable(self).SyncReadAligned)(windows_core::Interface::as_raw(self), psample.param().abi()).ok() }
    }
    pub unsafe fn SyncRead(&self, llposition: i64, pbuffer: &mut [u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SyncRead)(windows_core::Interface::as_raw(self), llposition, pbuffer.len().try_into().unwrap(), core::mem::transmute(pbuffer.as_ptr())).ok() }
    }
    pub unsafe fn Length(&self, ptotal: *mut i64, pavailable: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Length)(windows_core::Interface::as_raw(self), ptotal as _, pavailable as _).ok() }
    }
    pub unsafe fn BeginFlush(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BeginFlush)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn EndFlush(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EndFlush)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAsyncReader_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub RequestAllocator: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const ALLOCATOR_PROPERTIES, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Request: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    pub WaitForNext: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void, *mut usize) -> windows_core::HRESULT,
    pub SyncReadAligned: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SyncRead: unsafe extern "system" fn(*mut core::ffi::c_void, i64, i32, *mut u8) -> windows_core::HRESULT,
    pub Length: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub BeginFlush: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub EndFlush: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAsyncReader_Impl: windows_core::IUnknownImpl {
    fn RequestAllocator(&self, ppreferred: windows_core::Ref<IMemAllocator>, pprops: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<IMemAllocator>;
    fn Request(&self, psample: windows_core::Ref<IMediaSample>, dwuser: usize) -> windows_core::Result<()>;
    fn WaitForNext(&self, dwtimeout: u32, ppsample: windows_core::OutRef<IMediaSample>, pdwuser: *mut usize) -> windows_core::Result<()>;
    fn SyncReadAligned(&self, psample: windows_core::Ref<IMediaSample>) -> windows_core::Result<()>;
    fn SyncRead(&self, llposition: i64, llength: i32, pbuffer: *mut u8) -> windows_core::Result<()>;
    fn Length(&self, ptotal: *mut i64, pavailable: *mut i64) -> windows_core::Result<()>;
    fn BeginFlush(&self) -> windows_core::Result<()>;
    fn EndFlush(&self) -> windows_core::Result<()>;
}
impl IAsyncReader_Vtbl {
    pub const fn new<Identity: IAsyncReader_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RequestAllocator<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppreferred: *mut core::ffi::c_void, pprops: *const ALLOCATOR_PROPERTIES, ppactual: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAsyncReader_Impl::RequestAllocator(this, core::mem::transmute_copy(&ppreferred), core::mem::transmute_copy(&pprops)) {
                    Ok(ok__) => {
                        ppactual.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Request<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void, dwuser: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::Request(this, core::mem::transmute_copy(&psample), core::mem::transmute_copy(&dwuser)).into()
            }
        }
        unsafe extern "system" fn WaitForNext<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtimeout: u32, ppsample: *mut *mut core::ffi::c_void, pdwuser: *mut usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::WaitForNext(this, core::mem::transmute_copy(&dwtimeout), core::mem::transmute_copy(&ppsample), core::mem::transmute_copy(&pdwuser)).into()
            }
        }
        unsafe extern "system" fn SyncReadAligned<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::SyncReadAligned(this, core::mem::transmute_copy(&psample)).into()
            }
        }
        unsafe extern "system" fn SyncRead<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, llposition: i64, llength: i32, pbuffer: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::SyncRead(this, core::mem::transmute_copy(&llposition), core::mem::transmute_copy(&llength), core::mem::transmute_copy(&pbuffer)).into()
            }
        }
        unsafe extern "system" fn Length<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptotal: *mut i64, pavailable: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::Length(this, core::mem::transmute_copy(&ptotal), core::mem::transmute_copy(&pavailable)).into()
            }
        }
        unsafe extern "system" fn BeginFlush<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::BeginFlush(this).into()
            }
        }
        unsafe extern "system" fn EndFlush<Identity: IAsyncReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAsyncReader_Impl::EndFlush(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RequestAllocator: RequestAllocator::<Identity, OFFSET>,
            Request: Request::<Identity, OFFSET>,
            WaitForNext: WaitForNext::<Identity, OFFSET>,
            SyncReadAligned: SyncReadAligned::<Identity, OFFSET>,
            SyncRead: SyncRead::<Identity, OFFSET>,
            Length: Length::<Identity, OFFSET>,
            BeginFlush: BeginFlush::<Identity, OFFSET>,
            EndFlush: EndFlush::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAsyncReader as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAsyncReader {}
windows_core::imp::define_interface!(IAudioData, IAudioData_Vtbl, 0x54c719c0_af60_11d0_8212_00c04fc32c45);
impl core::ops::Deref for IAudioData {
    type Target = IMemoryData;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAudioData, windows_core::IUnknown, IMemoryData);
impl IAudioData {
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn GetFormat(&self, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFormat)(windows_core::Interface::as_raw(self), pwaveformatcurrent as _).ok() }
    }
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn SetFormat(&self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFormat)(windows_core::Interface::as_raw(self), lpwaveformat).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAudioData_Vtbl {
    pub base__: IMemoryData_Vtbl,
    #[cfg(feature = "Win32_Media_Audio")]
    pub GetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::Audio::WAVEFORMATEX) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    GetFormat: usize,
    #[cfg(feature = "Win32_Media_Audio")]
    pub SetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::Audio::WAVEFORMATEX) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    SetFormat: usize,
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IAudioData_Impl: IMemoryData_Impl {
    fn GetFormat(&self, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::Result<()>;
    fn SetFormat(&self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IAudioData_Vtbl {
    pub const fn new<Identity: IAudioData_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFormat<Identity: IAudioData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAudioData_Impl::GetFormat(this, core::mem::transmute_copy(&pwaveformatcurrent)).into()
            }
        }
        unsafe extern "system" fn SetFormat<Identity: IAudioData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAudioData_Impl::SetFormat(this, core::mem::transmute_copy(&lpwaveformat)).into()
            }
        }
        Self { base__: IMemoryData_Vtbl::new::<Identity, OFFSET>(), GetFormat: GetFormat::<Identity, OFFSET>, SetFormat: SetFormat::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAudioData as windows_core::Interface>::IID || iid == &<IMemoryData as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl windows_core::RuntimeName for IAudioData {}
windows_core::imp::define_interface!(IAudioMediaStream, IAudioMediaStream_Vtbl, 0xf7537560_a3be_11d0_8212_00c04fc32c45);
impl core::ops::Deref for IAudioMediaStream {
    type Target = IMediaStream;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAudioMediaStream, windows_core::IUnknown, IMediaStream);
impl IAudioMediaStream {
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn GetFormat(&self, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFormat)(windows_core::Interface::as_raw(self), pwaveformatcurrent as _).ok() }
    }
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn SetFormat(&self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFormat)(windows_core::Interface::as_raw(self), lpwaveformat).ok() }
    }
    pub unsafe fn CreateSample<P0>(&self, paudiodata: P0, dwflags: u32) -> windows_core::Result<IAudioStreamSample>
    where
        P0: windows_core::Param<IAudioData>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateSample)(windows_core::Interface::as_raw(self), paudiodata.param().abi(), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAudioMediaStream_Vtbl {
    pub base__: IMediaStream_Vtbl,
    #[cfg(feature = "Win32_Media_Audio")]
    pub GetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::Audio::WAVEFORMATEX) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    GetFormat: usize,
    #[cfg(feature = "Win32_Media_Audio")]
    pub SetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::Audio::WAVEFORMATEX) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    SetFormat: usize,
    pub CreateSample: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IAudioMediaStream_Impl: IMediaStream_Impl {
    fn GetFormat(&self, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::Result<()>;
    fn SetFormat(&self, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::Result<()>;
    fn CreateSample(&self, paudiodata: windows_core::Ref<IAudioData>, dwflags: u32) -> windows_core::Result<IAudioStreamSample>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IAudioMediaStream_Vtbl {
    pub const fn new<Identity: IAudioMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFormat<Identity: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwaveformatcurrent: *mut super::Audio::WAVEFORMATEX) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAudioMediaStream_Impl::GetFormat(this, core::mem::transmute_copy(&pwaveformatcurrent)).into()
            }
        }
        unsafe extern "system" fn SetFormat<Identity: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwaveformat: *const super::Audio::WAVEFORMATEX) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAudioMediaStream_Impl::SetFormat(this, core::mem::transmute_copy(&lpwaveformat)).into()
            }
        }
        unsafe extern "system" fn CreateSample<Identity: IAudioMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, paudiodata: *mut core::ffi::c_void, dwflags: u32, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAudioMediaStream_Impl::CreateSample(this, core::mem::transmute_copy(&paudiodata), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppsample.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IMediaStream_Vtbl::new::<Identity, OFFSET>(),
            GetFormat: GetFormat::<Identity, OFFSET>,
            SetFormat: SetFormat::<Identity, OFFSET>,
            CreateSample: CreateSample::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAudioMediaStream as windows_core::Interface>::IID || iid == &<IMediaStream as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl windows_core::RuntimeName for IAudioMediaStream {}
windows_core::imp::define_interface!(IAudioStreamSample, IAudioStreamSample_Vtbl, 0x345fee00_aba5_11d0_8212_00c04fc32c45);
impl core::ops::Deref for IAudioStreamSample {
    type Target = IStreamSample;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IAudioStreamSample, windows_core::IUnknown, IStreamSample);
impl IAudioStreamSample {
    pub unsafe fn GetAudioData(&self) -> windows_core::Result<IAudioData> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAudioData)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAudioStreamSample_Vtbl {
    pub base__: IStreamSample_Vtbl,
    pub GetAudioData: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IAudioStreamSample_Impl: IStreamSample_Impl {
    fn GetAudioData(&self) -> windows_core::Result<IAudioData>;
}
impl IAudioStreamSample_Vtbl {
    pub const fn new<Identity: IAudioStreamSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetAudioData<Identity: IAudioStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppaudio: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAudioStreamSample_Impl::GetAudioData(this) {
                    Ok(ok__) => {
                        ppaudio.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: IStreamSample_Vtbl::new::<Identity, OFFSET>(), GetAudioData: GetAudioData::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAudioStreamSample as windows_core::Interface>::IID || iid == &<IStreamSample as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IAudioStreamSample {}
windows_core::imp::define_interface!(IBDA_AUX, IBDA_AUX_Vtbl, 0x7def4c09_6e66_4567_a819_f0e17f4a81ab);
windows_core::imp::interface_hierarchy!(IBDA_AUX, windows_core::IUnknown);
impl IBDA_AUX {
    pub unsafe fn QueryCapabilities(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryCapabilities)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn EnumCapability(&self, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut windows_core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnumCapability)(windows_core::Interface::as_raw(self), dwindex, dwinputid as _, pconnectortype as _, conntypenum as _, numvideostds as _, analogstds as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_AUX_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub EnumCapability: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut windows_core::GUID, *mut u32, *mut u32, *mut u64) -> windows_core::HRESULT,
}
pub trait IBDA_AUX_Impl: windows_core::IUnknownImpl {
    fn QueryCapabilities(&self) -> windows_core::Result<u32>;
    fn EnumCapability(&self, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut windows_core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> windows_core::Result<()>;
}
impl IBDA_AUX_Vtbl {
    pub const fn new<Identity: IBDA_AUX_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryCapabilities<Identity: IBDA_AUX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumauxinputsbstr: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_AUX_Impl::QueryCapabilities(this) {
                    Ok(ok__) => {
                        pdwnumauxinputsbstr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn EnumCapability<Identity: IBDA_AUX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, dwinputid: *mut u32, pconnectortype: *mut windows_core::GUID, conntypenum: *mut u32, numvideostds: *mut u32, analogstds: *mut u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_AUX_Impl::EnumCapability(this, core::mem::transmute_copy(&dwindex), core::mem::transmute_copy(&dwinputid), core::mem::transmute_copy(&pconnectortype), core::mem::transmute_copy(&conntypenum), core::mem::transmute_copy(&numvideostds), core::mem::transmute_copy(&analogstds)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryCapabilities: QueryCapabilities::<Identity, OFFSET>,
            EnumCapability: EnumCapability::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_AUX as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_AUX {}
windows_core::imp::define_interface!(IBDA_AutoDemodulate, IBDA_AutoDemodulate_Vtbl, 0xddf15b12_bd25_11d2_9ca0_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_AutoDemodulate, windows_core::IUnknown);
impl IBDA_AutoDemodulate {
    pub unsafe fn put_AutoDemodulate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_AutoDemodulate)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_AutoDemodulate_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub put_AutoDemodulate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_AutoDemodulate_Impl: windows_core::IUnknownImpl {
    fn put_AutoDemodulate(&self) -> windows_core::Result<()>;
}
impl IBDA_AutoDemodulate_Vtbl {
    pub const fn new<Identity: IBDA_AutoDemodulate_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn put_AutoDemodulate<Identity: IBDA_AutoDemodulate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_AutoDemodulate_Impl::put_AutoDemodulate(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), put_AutoDemodulate: put_AutoDemodulate::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_AutoDemodulate as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_AutoDemodulate {}
windows_core::imp::define_interface!(IBDA_AutoDemodulateEx, IBDA_AutoDemodulateEx_Vtbl, 0x34518d13_1182_48e6_b28f_b24987787326);
impl core::ops::Deref for IBDA_AutoDemodulateEx {
    type Target = IBDA_AutoDemodulate;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IBDA_AutoDemodulateEx, windows_core::IUnknown, IBDA_AutoDemodulate);
impl IBDA_AutoDemodulateEx {
    pub unsafe fn get_SupportedDeviceNodeTypes(&self, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_SupportedDeviceNodeTypes)(windows_core::Interface::as_raw(self), ulcdevicenodetypesmax, pulcdevicenodetypes as _, pguiddevicenodetypes as _).ok() }
    }
    pub unsafe fn get_SupportedVideoFormats(&self, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_SupportedVideoFormats)(windows_core::Interface::as_raw(self), pulamtunermodetype as _, pulanalogvideostandard as _).ok() }
    }
    pub unsafe fn get_AuxInputCount(&self, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_AuxInputCount)(windows_core::Interface::as_raw(self), pulcompositecount as _, pulsvideocount as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_AutoDemodulateEx_Vtbl {
    pub base__: IBDA_AutoDemodulate_Vtbl,
    pub get_SupportedDeviceNodeTypes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub get_SupportedVideoFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub get_AuxInputCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_AutoDemodulateEx_Impl: IBDA_AutoDemodulate_Impl {
    fn get_SupportedDeviceNodeTypes(&self, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn get_SupportedVideoFormats(&self, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> windows_core::Result<()>;
    fn get_AuxInputCount(&self, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_AutoDemodulateEx_Vtbl {
    pub const fn new<Identity: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_SupportedDeviceNodeTypes<Identity: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcdevicenodetypesmax: u32, pulcdevicenodetypes: *mut u32, pguiddevicenodetypes: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_AutoDemodulateEx_Impl::get_SupportedDeviceNodeTypes(this, core::mem::transmute_copy(&ulcdevicenodetypesmax), core::mem::transmute_copy(&pulcdevicenodetypes), core::mem::transmute_copy(&pguiddevicenodetypes)).into()
            }
        }
        unsafe extern "system" fn get_SupportedVideoFormats<Identity: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulamtunermodetype: *mut u32, pulanalogvideostandard: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_AutoDemodulateEx_Impl::get_SupportedVideoFormats(this, core::mem::transmute_copy(&pulamtunermodetype), core::mem::transmute_copy(&pulanalogvideostandard)).into()
            }
        }
        unsafe extern "system" fn get_AuxInputCount<Identity: IBDA_AutoDemodulateEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcompositecount: *mut u32, pulsvideocount: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_AutoDemodulateEx_Impl::get_AuxInputCount(this, core::mem::transmute_copy(&pulcompositecount), core::mem::transmute_copy(&pulsvideocount)).into()
            }
        }
        Self {
            base__: IBDA_AutoDemodulate_Vtbl::new::<Identity, OFFSET>(),
            get_SupportedDeviceNodeTypes: get_SupportedDeviceNodeTypes::<Identity, OFFSET>,
            get_SupportedVideoFormats: get_SupportedVideoFormats::<Identity, OFFSET>,
            get_AuxInputCount: get_AuxInputCount::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_AutoDemodulateEx as windows_core::Interface>::IID || iid == &<IBDA_AutoDemodulate as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_AutoDemodulateEx {}
windows_core::imp::define_interface!(IBDA_ConditionalAccess, IBDA_ConditionalAccess_Vtbl, 0xcd51f1e0_7be9_4123_8482_a2a796c0a6b0);
windows_core::imp::interface_hierarchy!(IBDA_ConditionalAccess, windows_core::IUnknown);
impl IBDA_ConditionalAccess {
    pub unsafe fn get_SmartCardStatus(&self, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut windows_core::BSTR, pfooblocked: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_SmartCardStatus)(windows_core::Interface::as_raw(self), pcardstatus as _, pcardassociation as _, core::mem::transmute(pbstrcarderror), pfooblocked as _).ok() }
    }
    pub unsafe fn get_SmartCardInfo(&self, pbstrcardname: *mut windows_core::BSTR, pbstrcardmanufacturer: *mut windows_core::BSTR, pfdaylightsavings: *mut super::super::Foundation::VARIANT_BOOL, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut windows_core::BSTR, pealocationcode: *mut EALocationCodeType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_SmartCardInfo)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrcardname), core::mem::transmute(pbstrcardmanufacturer), pfdaylightsavings as _, pbyratingregion as _, pltimezoneoffsetminutes as _, core::mem::transmute(pbstrlanguage), pealocationcode as _).ok() }
    }
    pub unsafe fn get_SmartCardApplications(&self, pulcapplications: *mut u32, rgapplications: &mut [SmartCardApplication]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_SmartCardApplications)(windows_core::Interface::as_raw(self), pulcapplications as _, rgapplications.len().try_into().unwrap(), core::mem::transmute(rgapplications.as_ptr())).ok() }
    }
    pub unsafe fn get_Entitlement(&self, usvirtualchannel: u16) -> windows_core::Result<EntitlementType> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).get_Entitlement)(windows_core::Interface::as_raw(self), usvirtualchannel, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn TuneByChannel(&self, usvirtualchannel: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TuneByChannel)(windows_core::Interface::as_raw(self), usvirtualchannel).ok() }
    }
    pub unsafe fn SetProgram(&self, usprogramnumber: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetProgram)(windows_core::Interface::as_raw(self), usprogramnumber).ok() }
    }
    pub unsafe fn AddProgram(&self, usprogramnumber: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AddProgram)(windows_core::Interface::as_raw(self), usprogramnumber).ok() }
    }
    pub unsafe fn RemoveProgram(&self, usprogramnumber: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RemoveProgram)(windows_core::Interface::as_raw(self), usprogramnumber).ok() }
    }
    pub unsafe fn GetModuleUI(&self, bydialognumber: u8) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetModuleUI)(windows_core::Interface::as_raw(self), bydialognumber, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn InformUIClosed(&self, bydialognumber: u8, closereason: UICloseReasonType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InformUIClosed)(windows_core::Interface::as_raw(self), bydialognumber, closereason).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_ConditionalAccess_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_SmartCardStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut SmartCardStatusType, *mut SmartCardAssociationType, *mut *mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT,
    pub get_SmartCardInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut super::super::Foundation::VARIANT_BOOL, *mut u8, *mut i32, *mut *mut core::ffi::c_void, *mut EALocationCodeType) -> windows_core::HRESULT,
    pub get_SmartCardApplications: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut SmartCardApplication) -> windows_core::HRESULT,
    pub get_Entitlement: unsafe extern "system" fn(*mut core::ffi::c_void, u16, *mut EntitlementType) -> windows_core::HRESULT,
    pub TuneByChannel: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub SetProgram: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub AddProgram: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub RemoveProgram: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub GetModuleUI: unsafe extern "system" fn(*mut core::ffi::c_void, u8, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub InformUIClosed: unsafe extern "system" fn(*mut core::ffi::c_void, u8, UICloseReasonType) -> windows_core::HRESULT,
}
pub trait IBDA_ConditionalAccess_Impl: windows_core::IUnknownImpl {
    fn get_SmartCardStatus(&self, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut windows_core::BSTR, pfooblocked: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::Result<()>;
    fn get_SmartCardInfo(&self, pbstrcardname: *mut windows_core::BSTR, pbstrcardmanufacturer: *mut windows_core::BSTR, pfdaylightsavings: *mut super::super::Foundation::VARIANT_BOOL, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut windows_core::BSTR, pealocationcode: *mut EALocationCodeType) -> windows_core::Result<()>;
    fn get_SmartCardApplications(&self, pulcapplications: *mut u32, ulcapplicationsmax: u32, rgapplications: *mut SmartCardApplication) -> windows_core::Result<()>;
    fn get_Entitlement(&self, usvirtualchannel: u16) -> windows_core::Result<EntitlementType>;
    fn TuneByChannel(&self, usvirtualchannel: u16) -> windows_core::Result<()>;
    fn SetProgram(&self, usprogramnumber: u16) -> windows_core::Result<()>;
    fn AddProgram(&self, usprogramnumber: u16) -> windows_core::Result<()>;
    fn RemoveProgram(&self, usprogramnumber: u16) -> windows_core::Result<()>;
    fn GetModuleUI(&self, bydialognumber: u8) -> windows_core::Result<windows_core::BSTR>;
    fn InformUIClosed(&self, bydialognumber: u8, closereason: UICloseReasonType) -> windows_core::Result<()>;
}
impl IBDA_ConditionalAccess_Vtbl {
    pub const fn new<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_SmartCardStatus<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcardstatus: *mut SmartCardStatusType, pcardassociation: *mut SmartCardAssociationType, pbstrcarderror: *mut *mut core::ffi::c_void, pfooblocked: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::get_SmartCardStatus(this, core::mem::transmute_copy(&pcardstatus), core::mem::transmute_copy(&pcardassociation), core::mem::transmute_copy(&pbstrcarderror), core::mem::transmute_copy(&pfooblocked)).into()
            }
        }
        unsafe extern "system" fn get_SmartCardInfo<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrcardname: *mut *mut core::ffi::c_void, pbstrcardmanufacturer: *mut *mut core::ffi::c_void, pfdaylightsavings: *mut super::super::Foundation::VARIANT_BOOL, pbyratingregion: *mut u8, pltimezoneoffsetminutes: *mut i32, pbstrlanguage: *mut *mut core::ffi::c_void, pealocationcode: *mut EALocationCodeType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::get_SmartCardInfo(this, core::mem::transmute_copy(&pbstrcardname), core::mem::transmute_copy(&pbstrcardmanufacturer), core::mem::transmute_copy(&pfdaylightsavings), core::mem::transmute_copy(&pbyratingregion), core::mem::transmute_copy(&pltimezoneoffsetminutes), core::mem::transmute_copy(&pbstrlanguage), core::mem::transmute_copy(&pealocationcode)).into()
            }
        }
        unsafe extern "system" fn get_SmartCardApplications<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcapplications: *mut u32, ulcapplicationsmax: u32, rgapplications: *mut SmartCardApplication) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::get_SmartCardApplications(this, core::mem::transmute_copy(&pulcapplications), core::mem::transmute_copy(&ulcapplicationsmax), core::mem::transmute_copy(&rgapplications)).into()
            }
        }
        unsafe extern "system" fn get_Entitlement<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usvirtualchannel: u16, pentitlement: *mut EntitlementType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_ConditionalAccess_Impl::get_Entitlement(this, core::mem::transmute_copy(&usvirtualchannel)) {
                    Ok(ok__) => {
                        pentitlement.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TuneByChannel<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usvirtualchannel: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::TuneByChannel(this, core::mem::transmute_copy(&usvirtualchannel)).into()
            }
        }
        unsafe extern "system" fn SetProgram<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usprogramnumber: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::SetProgram(this, core::mem::transmute_copy(&usprogramnumber)).into()
            }
        }
        unsafe extern "system" fn AddProgram<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usprogramnumber: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::AddProgram(this, core::mem::transmute_copy(&usprogramnumber)).into()
            }
        }
        unsafe extern "system" fn RemoveProgram<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usprogramnumber: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::RemoveProgram(this, core::mem::transmute_copy(&usprogramnumber)).into()
            }
        }
        unsafe extern "system" fn GetModuleUI<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bydialognumber: u8, pbstrurl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_ConditionalAccess_Impl::GetModuleUI(this, core::mem::transmute_copy(&bydialognumber)) {
                    Ok(ok__) => {
                        pbstrurl.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn InformUIClosed<Identity: IBDA_ConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bydialognumber: u8, closereason: UICloseReasonType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccess_Impl::InformUIClosed(this, core::mem::transmute_copy(&bydialognumber), core::mem::transmute_copy(&closereason)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_SmartCardStatus: get_SmartCardStatus::<Identity, OFFSET>,
            get_SmartCardInfo: get_SmartCardInfo::<Identity, OFFSET>,
            get_SmartCardApplications: get_SmartCardApplications::<Identity, OFFSET>,
            get_Entitlement: get_Entitlement::<Identity, OFFSET>,
            TuneByChannel: TuneByChannel::<Identity, OFFSET>,
            SetProgram: SetProgram::<Identity, OFFSET>,
            AddProgram: AddProgram::<Identity, OFFSET>,
            RemoveProgram: RemoveProgram::<Identity, OFFSET>,
            GetModuleUI: GetModuleUI::<Identity, OFFSET>,
            InformUIClosed: InformUIClosed::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_ConditionalAccess as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_ConditionalAccess {}
windows_core::imp::define_interface!(IBDA_ConditionalAccessEx, IBDA_ConditionalAccessEx_Vtbl, 0x497c3418_23cb_44ba_bb62_769f506fcea7);
windows_core::imp::interface_hierarchy!(IBDA_ConditionalAccessEx, windows_core::IUnknown);
impl IBDA_ConditionalAccessEx {
    pub unsafe fn CheckEntitlementToken(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, pbentitlementtoken: &[u8]) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CheckEntitlementToken)(windows_core::Interface::as_raw(self), uldialogrequest, core::mem::transmute_copy(bstrlanguage), requesttype, pbentitlementtoken.len().try_into().unwrap(), core::mem::transmute(pbentitlementtoken.as_ptr()), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCaptureToken(&self, pbcapturetoken: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCaptureToken)(windows_core::Interface::as_raw(self), pbcapturetoken.len().try_into().unwrap(), core::mem::transmute(pbcapturetoken.as_ptr())).ok() }
    }
    pub unsafe fn OpenBroadcastMmi(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, eventid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OpenBroadcastMmi)(windows_core::Interface::as_raw(self), uldialogrequest, core::mem::transmute_copy(bstrlanguage), eventid).ok() }
    }
    pub unsafe fn CloseMmiDialog(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CloseMmiDialog)(windows_core::Interface::as_raw(self), uldialogrequest, core::mem::transmute_copy(bstrlanguage), uldialognumber, reasoncode, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn CreateDialogRequestNumber(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateDialogRequestNumber)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_ConditionalAccessEx_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub CheckEntitlementToken: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void, BDA_CONDITIONALACCESS_REQUESTTYPE, u32, *const u8, *mut u32) -> windows_core::HRESULT,
    pub SetCaptureToken: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub OpenBroadcastMmi: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub CloseMmiDialog: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void, u32, BDA_CONDITIONALACCESS_MMICLOSEREASON, *mut u32) -> windows_core::HRESULT,
    pub CreateDialogRequestNumber: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_ConditionalAccessEx_Impl: windows_core::IUnknownImpl {
    fn CheckEntitlementToken(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbentitlementtokenlen: u32, pbentitlementtoken: *const u8) -> windows_core::Result<u32>;
    fn SetCaptureToken(&self, ulcbcapturetokenlen: u32, pbcapturetoken: *const u8) -> windows_core::Result<()>;
    fn OpenBroadcastMmi(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, eventid: u32) -> windows_core::Result<()>;
    fn CloseMmiDialog(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON) -> windows_core::Result<u32>;
    fn CreateDialogRequestNumber(&self) -> windows_core::Result<u32>;
}
impl IBDA_ConditionalAccessEx_Vtbl {
    pub const fn new<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CheckEntitlementToken<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldialogrequest: u32, bstrlanguage: *mut core::ffi::c_void, requesttype: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_ConditionalAccessEx_Impl::CheckEntitlementToken(this, core::mem::transmute_copy(&uldialogrequest), core::mem::transmute(&bstrlanguage), core::mem::transmute_copy(&requesttype), core::mem::transmute_copy(&ulcbentitlementtokenlen), core::mem::transmute_copy(&pbentitlementtoken)) {
                    Ok(ok__) => {
                        puldescramblestatus.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCaptureToken<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcbcapturetokenlen: u32, pbcapturetoken: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccessEx_Impl::SetCaptureToken(this, core::mem::transmute_copy(&ulcbcapturetokenlen), core::mem::transmute_copy(&pbcapturetoken)).into()
            }
        }
        unsafe extern "system" fn OpenBroadcastMmi<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldialogrequest: u32, bstrlanguage: *mut core::ffi::c_void, eventid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ConditionalAccessEx_Impl::OpenBroadcastMmi(this, core::mem::transmute_copy(&uldialogrequest), core::mem::transmute(&bstrlanguage), core::mem::transmute_copy(&eventid)).into()
            }
        }
        unsafe extern "system" fn CloseMmiDialog<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldialogrequest: u32, bstrlanguage: *mut core::ffi::c_void, uldialognumber: u32, reasoncode: BDA_CONDITIONALACCESS_MMICLOSEREASON, pulsessionresult: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_ConditionalAccessEx_Impl::CloseMmiDialog(this, core::mem::transmute_copy(&uldialogrequest), core::mem::transmute(&bstrlanguage), core::mem::transmute_copy(&uldialognumber), core::mem::transmute_copy(&reasoncode)) {
                    Ok(ok__) => {
                        pulsessionresult.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CreateDialogRequestNumber<Identity: IBDA_ConditionalAccessEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puldialogrequestnumber: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_ConditionalAccessEx_Impl::CreateDialogRequestNumber(this) {
                    Ok(ok__) => {
                        puldialogrequestnumber.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CheckEntitlementToken: CheckEntitlementToken::<Identity, OFFSET>,
            SetCaptureToken: SetCaptureToken::<Identity, OFFSET>,
            OpenBroadcastMmi: OpenBroadcastMmi::<Identity, OFFSET>,
            CloseMmiDialog: CloseMmiDialog::<Identity, OFFSET>,
            CreateDialogRequestNumber: CreateDialogRequestNumber::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_ConditionalAccessEx as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_ConditionalAccessEx {}
windows_core::imp::define_interface!(IBDA_DRIDRMService, IBDA_DRIDRMService_Vtbl, 0x1f9bc2a5_44a3_4c52_aab1_0bbce5a1381d);
windows_core::imp::interface_hierarchy!(IBDA_DRIDRMService, windows_core::IUnknown);
impl IBDA_DRIDRMService {
    pub unsafe fn SetDRM(&self, bstrnewdrm: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDRM)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(bstrnewdrm)).ok() }
    }
    pub unsafe fn GetDRMStatus(&self, pbstrdrmuuidlist: *mut windows_core::BSTR, drmuuid: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDRMStatus)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrdrmuuidlist), drmuuid as _).ok() }
    }
    pub unsafe fn GetPairingStatus(&self, penumpairingstatus: *mut BDA_DrmPairingError) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPairingStatus)(windows_core::Interface::as_raw(self), penumpairingstatus as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DRIDRMService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetDRM: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetDRMStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetPairingStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut BDA_DrmPairingError) -> windows_core::HRESULT,
}
pub trait IBDA_DRIDRMService_Impl: windows_core::IUnknownImpl {
    fn SetDRM(&self, bstrnewdrm: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetDRMStatus(&self, pbstrdrmuuidlist: *mut windows_core::BSTR, drmuuid: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetPairingStatus(&self, penumpairingstatus: *mut BDA_DrmPairingError) -> windows_core::Result<()>;
}
impl IBDA_DRIDRMService_Vtbl {
    pub const fn new<Identity: IBDA_DRIDRMService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetDRM<Identity: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrnewdrm: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIDRMService_Impl::SetDRM(this, core::mem::transmute(&bstrnewdrm)).into()
            }
        }
        unsafe extern "system" fn GetDRMStatus<Identity: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrdrmuuidlist: *mut *mut core::ffi::c_void, drmuuid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIDRMService_Impl::GetDRMStatus(this, core::mem::transmute_copy(&pbstrdrmuuidlist), core::mem::transmute_copy(&drmuuid)).into()
            }
        }
        unsafe extern "system" fn GetPairingStatus<Identity: IBDA_DRIDRMService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penumpairingstatus: *mut BDA_DrmPairingError) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIDRMService_Impl::GetPairingStatus(this, core::mem::transmute_copy(&penumpairingstatus)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDRM: SetDRM::<Identity, OFFSET>,
            GetDRMStatus: GetDRMStatus::<Identity, OFFSET>,
            GetPairingStatus: GetPairingStatus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DRIDRMService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DRIDRMService {}
windows_core::imp::define_interface!(IBDA_DRIWMDRMSession, IBDA_DRIWMDRMSession_Vtbl, 0x05c690f8_56db_4bb2_b053_79c12098bb26);
windows_core::imp::interface_hierarchy!(IBDA_DRIWMDRMSession, windows_core::IUnknown);
impl IBDA_DRIWMDRMSession {
    pub unsafe fn AcknowledgeLicense(&self, hrlicenseack: windows_core::HRESULT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AcknowledgeLicense)(windows_core::Interface::as_raw(self), hrlicenseack).ok() }
    }
    pub unsafe fn ProcessLicenseChallenge(&self, pblicensemessage: &[u8], pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ProcessLicenseChallenge)(windows_core::Interface::as_raw(self), pblicensemessage.len().try_into().unwrap(), core::mem::transmute(pblicensemessage.as_ptr()), pdwcblicenseresponse as _, ppblicenseresponse as _).ok() }
    }
    pub unsafe fn ProcessRegistrationChallenge(&self, pbregistrationmessage: &[u8], pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ProcessRegistrationChallenge)(windows_core::Interface::as_raw(self), pbregistrationmessage.len().try_into().unwrap(), core::mem::transmute(pbregistrationmessage.as_ptr()), pdwcbregistrationresponse as _, ppbregistrationresponse as _).ok() }
    }
    pub unsafe fn SetRevInfo(&self, pbrevinfo: &[u8], pdwresponse: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRevInfo)(windows_core::Interface::as_raw(self), pbrevinfo.len().try_into().unwrap(), core::mem::transmute(pbrevinfo.as_ptr()), pdwresponse as _).ok() }
    }
    pub unsafe fn SetCrl(&self, pbcrllen: &[u8], pdwresponse: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCrl)(windows_core::Interface::as_raw(self), pbcrllen.len().try_into().unwrap(), core::mem::transmute(pbcrllen.as_ptr()), pdwresponse as _).ok() }
    }
    pub unsafe fn GetHMSAssociationData(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetHMSAssociationData)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetLastCardeaError(&self, pdwerror: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetLastCardeaError)(windows_core::Interface::as_raw(self), pdwerror as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DRIWMDRMSession_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AcknowledgeLicense: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::HRESULT) -> windows_core::HRESULT,
    pub ProcessLicenseChallenge: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, *mut u32, *mut *mut u8) -> windows_core::HRESULT,
    pub ProcessRegistrationChallenge: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, *mut u32, *mut *mut u8) -> windows_core::HRESULT,
    pub SetRevInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, *mut u32) -> windows_core::HRESULT,
    pub SetCrl: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, *mut u32) -> windows_core::HRESULT,
    pub GetHMSAssociationData: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetLastCardeaError: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_DRIWMDRMSession_Impl: windows_core::IUnknownImpl {
    fn AcknowledgeLicense(&self, hrlicenseack: windows_core::HRESULT) -> windows_core::Result<()>;
    fn ProcessLicenseChallenge(&self, dwcblicensemessage: u32, pblicensemessage: *const u8, pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> windows_core::Result<()>;
    fn ProcessRegistrationChallenge(&self, dwcbregistrationmessage: u32, pbregistrationmessage: *const u8, pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> windows_core::Result<()>;
    fn SetRevInfo(&self, dwrevinfolen: u32, pbrevinfo: *const u8, pdwresponse: *mut u32) -> windows_core::Result<()>;
    fn SetCrl(&self, dwcrllen: u32, pbcrllen: *const u8, pdwresponse: *mut u32) -> windows_core::Result<()>;
    fn GetHMSAssociationData(&self) -> windows_core::Result<()>;
    fn GetLastCardeaError(&self, pdwerror: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_DRIWMDRMSession_Vtbl {
    pub const fn new<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AcknowledgeLicense<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrlicenseack: windows_core::HRESULT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::AcknowledgeLicense(this, core::mem::transmute_copy(&hrlicenseack)).into()
            }
        }
        unsafe extern "system" fn ProcessLicenseChallenge<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcblicensemessage: u32, pblicensemessage: *const u8, pdwcblicenseresponse: *mut u32, ppblicenseresponse: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::ProcessLicenseChallenge(this, core::mem::transmute_copy(&dwcblicensemessage), core::mem::transmute_copy(&pblicensemessage), core::mem::transmute_copy(&pdwcblicenseresponse), core::mem::transmute_copy(&ppblicenseresponse)).into()
            }
        }
        unsafe extern "system" fn ProcessRegistrationChallenge<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcbregistrationmessage: u32, pbregistrationmessage: *const u8, pdwcbregistrationresponse: *mut u32, ppbregistrationresponse: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::ProcessRegistrationChallenge(this, core::mem::transmute_copy(&dwcbregistrationmessage), core::mem::transmute_copy(&pbregistrationmessage), core::mem::transmute_copy(&pdwcbregistrationresponse), core::mem::transmute_copy(&ppbregistrationresponse)).into()
            }
        }
        unsafe extern "system" fn SetRevInfo<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrevinfolen: u32, pbrevinfo: *const u8, pdwresponse: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::SetRevInfo(this, core::mem::transmute_copy(&dwrevinfolen), core::mem::transmute_copy(&pbrevinfo), core::mem::transmute_copy(&pdwresponse)).into()
            }
        }
        unsafe extern "system" fn SetCrl<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcrllen: u32, pbcrllen: *const u8, pdwresponse: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::SetCrl(this, core::mem::transmute_copy(&dwcrllen), core::mem::transmute_copy(&pbcrllen), core::mem::transmute_copy(&pdwresponse)).into()
            }
        }
        unsafe extern "system" fn GetHMSAssociationData<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::GetHMSAssociationData(this).into()
            }
        }
        unsafe extern "system" fn GetLastCardeaError<Identity: IBDA_DRIWMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwerror: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRIWMDRMSession_Impl::GetLastCardeaError(this, core::mem::transmute_copy(&pdwerror)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AcknowledgeLicense: AcknowledgeLicense::<Identity, OFFSET>,
            ProcessLicenseChallenge: ProcessLicenseChallenge::<Identity, OFFSET>,
            ProcessRegistrationChallenge: ProcessRegistrationChallenge::<Identity, OFFSET>,
            SetRevInfo: SetRevInfo::<Identity, OFFSET>,
            SetCrl: SetCrl::<Identity, OFFSET>,
            GetHMSAssociationData: GetHMSAssociationData::<Identity, OFFSET>,
            GetLastCardeaError: GetLastCardeaError::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DRIWMDRMSession as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DRIWMDRMSession {}
windows_core::imp::define_interface!(IBDA_DRM, IBDA_DRM_Vtbl, 0xf98d88b0_1992_4cd6_a6d9_b9afab99330d);
windows_core::imp::interface_hierarchy!(IBDA_DRM, windows_core::IUnknown);
impl IBDA_DRM {
    pub unsafe fn GetDRMPairingStatus(&self, pdwstatus: *mut u32, pherror: *mut windows_core::HRESULT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDRMPairingStatus)(windows_core::Interface::as_raw(self), pdwstatus as _, pherror as _).ok() }
    }
    pub unsafe fn PerformDRMPairing(&self, fsync: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PerformDRMPairing)(windows_core::Interface::as_raw(self), fsync.into()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DRM_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetDRMPairingStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut windows_core::HRESULT) -> windows_core::HRESULT,
    pub PerformDRMPairing: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IBDA_DRM_Impl: windows_core::IUnknownImpl {
    fn GetDRMPairingStatus(&self, pdwstatus: *mut u32, pherror: *mut windows_core::HRESULT) -> windows_core::Result<()>;
    fn PerformDRMPairing(&self, fsync: windows_core::BOOL) -> windows_core::Result<()>;
}
impl IBDA_DRM_Vtbl {
    pub const fn new<Identity: IBDA_DRM_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDRMPairingStatus<Identity: IBDA_DRM_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstatus: *mut u32, pherror: *mut windows_core::HRESULT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRM_Impl::GetDRMPairingStatus(this, core::mem::transmute_copy(&pdwstatus), core::mem::transmute_copy(&pherror)).into()
            }
        }
        unsafe extern "system" fn PerformDRMPairing<Identity: IBDA_DRM_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fsync: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRM_Impl::PerformDRMPairing(this, core::mem::transmute_copy(&fsync)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDRMPairingStatus: GetDRMPairingStatus::<Identity, OFFSET>,
            PerformDRMPairing: PerformDRMPairing::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DRM as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DRM {}
windows_core::imp::define_interface!(IBDA_DRMService, IBDA_DRMService_Vtbl, 0xbff6b5bb_b0ae_484c_9dca_73528fb0b46e);
windows_core::imp::interface_hierarchy!(IBDA_DRMService, windows_core::IUnknown);
impl IBDA_DRMService {
    pub unsafe fn SetDRM(&self, puuidnewdrm: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDRM)(windows_core::Interface::as_raw(self), puuidnewdrm).ok() }
    }
    pub unsafe fn GetDRMStatus(&self, pbstrdrmuuidlist: *mut windows_core::BSTR, drmuuid: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDRMStatus)(windows_core::Interface::as_raw(self), core::mem::transmute(pbstrdrmuuidlist), drmuuid as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DRMService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetDRM: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetDRMStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IBDA_DRMService_Impl: windows_core::IUnknownImpl {
    fn SetDRM(&self, puuidnewdrm: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDRMStatus(&self, pbstrdrmuuidlist: *mut windows_core::BSTR, drmuuid: *mut windows_core::GUID) -> windows_core::Result<()>;
}
impl IBDA_DRMService_Vtbl {
    pub const fn new<Identity: IBDA_DRMService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetDRM<Identity: IBDA_DRMService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puuidnewdrm: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRMService_Impl::SetDRM(this, core::mem::transmute_copy(&puuidnewdrm)).into()
            }
        }
        unsafe extern "system" fn GetDRMStatus<Identity: IBDA_DRMService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrdrmuuidlist: *mut *mut core::ffi::c_void, drmuuid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DRMService_Impl::GetDRMStatus(this, core::mem::transmute_copy(&pbstrdrmuuidlist), core::mem::transmute_copy(&drmuuid)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDRM: SetDRM::<Identity, OFFSET>,
            GetDRMStatus: GetDRMStatus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DRMService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DRMService {}
windows_core::imp::define_interface!(IBDA_DeviceControl, IBDA_DeviceControl_Vtbl, 0xfd0a5af3_b41d_11d2_9c95_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_DeviceControl, windows_core::IUnknown);
impl IBDA_DeviceControl {
    pub unsafe fn StartChanges(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StartChanges)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn CheckChanges(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CheckChanges)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn CommitChanges(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CommitChanges)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetChangeState(&self, pstate: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetChangeState)(windows_core::Interface::as_raw(self), pstate as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DeviceControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub StartChanges: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CheckChanges: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CommitChanges: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetChangeState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_DeviceControl_Impl: windows_core::IUnknownImpl {
    fn StartChanges(&self) -> windows_core::Result<()>;
    fn CheckChanges(&self) -> windows_core::Result<()>;
    fn CommitChanges(&self) -> windows_core::Result<()>;
    fn GetChangeState(&self, pstate: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_DeviceControl_Vtbl {
    pub const fn new<Identity: IBDA_DeviceControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartChanges<Identity: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DeviceControl_Impl::StartChanges(this).into()
            }
        }
        unsafe extern "system" fn CheckChanges<Identity: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DeviceControl_Impl::CheckChanges(this).into()
            }
        }
        unsafe extern "system" fn CommitChanges<Identity: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DeviceControl_Impl::CommitChanges(this).into()
            }
        }
        unsafe extern "system" fn GetChangeState<Identity: IBDA_DeviceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DeviceControl_Impl::GetChangeState(this, core::mem::transmute_copy(&pstate)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartChanges: StartChanges::<Identity, OFFSET>,
            CheckChanges: CheckChanges::<Identity, OFFSET>,
            CommitChanges: CommitChanges::<Identity, OFFSET>,
            GetChangeState: GetChangeState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DeviceControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DeviceControl {}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
windows_core::imp::define_interface!(IBDA_DiagnosticProperties, IBDA_DiagnosticProperties_Vtbl, 0x20e80cb5_c543_4c1b_8eb3_49e719eee7d4);
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl core::ops::Deref for IBDA_DiagnosticProperties {
    type Target = super::super::System::Com::StructuredStorage::IPropertyBag;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
windows_core::imp::interface_hierarchy!(IBDA_DiagnosticProperties, windows_core::IUnknown, super::super::System::Com::StructuredStorage::IPropertyBag);
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DiagnosticProperties_Vtbl {
    pub base__: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl,
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IBDA_DiagnosticProperties_Impl: super::super::System::Com::StructuredStorage::IPropertyBag_Impl {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IBDA_DiagnosticProperties_Vtbl {
    pub const fn new<Identity: IBDA_DiagnosticProperties_Impl, const OFFSET: isize>() -> Self {
        Self { base__: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl::new::<Identity, OFFSET>() }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DiagnosticProperties as windows_core::Interface>::IID || iid == &<super::super::System::Com::StructuredStorage::IPropertyBag as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IBDA_DiagnosticProperties {}
windows_core::imp::define_interface!(IBDA_DigitalDemodulator, IBDA_DigitalDemodulator_Vtbl, 0xef30f379_985b_4d10_b640_a79d5e04e1e0);
windows_core::imp::interface_hierarchy!(IBDA_DigitalDemodulator, windows_core::IUnknown);
impl IBDA_DigitalDemodulator {
    pub unsafe fn SetModulationType(&self, pmodulationtype: *const ModulationType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetModulationType)(windows_core::Interface::as_raw(self), pmodulationtype).ok() }
    }
    pub unsafe fn ModulationType(&self, pmodulationtype: *mut ModulationType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ModulationType)(windows_core::Interface::as_raw(self), pmodulationtype as _).ok() }
    }
    pub unsafe fn SetInnerFECMethod(&self, pfecmethod: *const FECMethod) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetInnerFECMethod)(windows_core::Interface::as_raw(self), pfecmethod).ok() }
    }
    pub unsafe fn InnerFECMethod(&self, pfecmethod: *mut FECMethod) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InnerFECMethod)(windows_core::Interface::as_raw(self), pfecmethod as _).ok() }
    }
    pub unsafe fn SetInnerFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetInnerFECRate)(windows_core::Interface::as_raw(self), pfecrate).ok() }
    }
    pub unsafe fn InnerFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InnerFECRate)(windows_core::Interface::as_raw(self), pfecrate as _).ok() }
    }
    pub unsafe fn SetOuterFECMethod(&self, pfecmethod: *const FECMethod) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOuterFECMethod)(windows_core::Interface::as_raw(self), pfecmethod).ok() }
    }
    pub unsafe fn OuterFECMethod(&self, pfecmethod: *mut FECMethod) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OuterFECMethod)(windows_core::Interface::as_raw(self), pfecmethod as _).ok() }
    }
    pub unsafe fn SetOuterFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOuterFECRate)(windows_core::Interface::as_raw(self), pfecrate).ok() }
    }
    pub unsafe fn OuterFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OuterFECRate)(windows_core::Interface::as_raw(self), pfecrate as _).ok() }
    }
    pub unsafe fn SetSymbolRate(&self, psymbolrate: *const u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSymbolRate)(windows_core::Interface::as_raw(self), psymbolrate).ok() }
    }
    pub unsafe fn SymbolRate(&self, psymbolrate: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SymbolRate)(windows_core::Interface::as_raw(self), psymbolrate as _).ok() }
    }
    pub unsafe fn SetSpectralInversion(&self, pspectralinversion: *const SpectralInversion) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSpectralInversion)(windows_core::Interface::as_raw(self), pspectralinversion).ok() }
    }
    pub unsafe fn SpectralInversion(&self, pspectralinversion: *mut SpectralInversion) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SpectralInversion)(windows_core::Interface::as_raw(self), pspectralinversion as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DigitalDemodulator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetModulationType: unsafe extern "system" fn(*mut core::ffi::c_void, *const ModulationType) -> windows_core::HRESULT,
    pub ModulationType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut ModulationType) -> windows_core::HRESULT,
    pub SetInnerFECMethod: unsafe extern "system" fn(*mut core::ffi::c_void, *const FECMethod) -> windows_core::HRESULT,
    pub InnerFECMethod: unsafe extern "system" fn(*mut core::ffi::c_void, *mut FECMethod) -> windows_core::HRESULT,
    pub SetInnerFECRate: unsafe extern "system" fn(*mut core::ffi::c_void, *const BinaryConvolutionCodeRate) -> windows_core::HRESULT,
    pub InnerFECRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut BinaryConvolutionCodeRate) -> windows_core::HRESULT,
    pub SetOuterFECMethod: unsafe extern "system" fn(*mut core::ffi::c_void, *const FECMethod) -> windows_core::HRESULT,
    pub OuterFECMethod: unsafe extern "system" fn(*mut core::ffi::c_void, *mut FECMethod) -> windows_core::HRESULT,
    pub SetOuterFECRate: unsafe extern "system" fn(*mut core::ffi::c_void, *const BinaryConvolutionCodeRate) -> windows_core::HRESULT,
    pub OuterFECRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut BinaryConvolutionCodeRate) -> windows_core::HRESULT,
    pub SetSymbolRate: unsafe extern "system" fn(*mut core::ffi::c_void, *const u32) -> windows_core::HRESULT,
    pub SymbolRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetSpectralInversion: unsafe extern "system" fn(*mut core::ffi::c_void, *const SpectralInversion) -> windows_core::HRESULT,
    pub SpectralInversion: unsafe extern "system" fn(*mut core::ffi::c_void, *mut SpectralInversion) -> windows_core::HRESULT,
}
pub trait IBDA_DigitalDemodulator_Impl: windows_core::IUnknownImpl {
    fn SetModulationType(&self, pmodulationtype: *const ModulationType) -> windows_core::Result<()>;
    fn ModulationType(&self, pmodulationtype: *mut ModulationType) -> windows_core::Result<()>;
    fn SetInnerFECMethod(&self, pfecmethod: *const FECMethod) -> windows_core::Result<()>;
    fn InnerFECMethod(&self, pfecmethod: *mut FECMethod) -> windows_core::Result<()>;
    fn SetInnerFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::Result<()>;
    fn InnerFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::Result<()>;
    fn SetOuterFECMethod(&self, pfecmethod: *const FECMethod) -> windows_core::Result<()>;
    fn OuterFECMethod(&self, pfecmethod: *mut FECMethod) -> windows_core::Result<()>;
    fn SetOuterFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::Result<()>;
    fn OuterFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::Result<()>;
    fn SetSymbolRate(&self, psymbolrate: *const u32) -> windows_core::Result<()>;
    fn SymbolRate(&self, psymbolrate: *mut u32) -> windows_core::Result<()>;
    fn SetSpectralInversion(&self, pspectralinversion: *const SpectralInversion) -> windows_core::Result<()>;
    fn SpectralInversion(&self, pspectralinversion: *mut SpectralInversion) -> windows_core::Result<()>;
}
impl IBDA_DigitalDemodulator_Vtbl {
    pub const fn new<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetModulationType<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmodulationtype: *const ModulationType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetModulationType(this, core::mem::transmute_copy(&pmodulationtype)).into()
            }
        }
        unsafe extern "system" fn ModulationType<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmodulationtype: *mut ModulationType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::ModulationType(this, core::mem::transmute_copy(&pmodulationtype)).into()
            }
        }
        unsafe extern "system" fn SetInnerFECMethod<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecmethod: *const FECMethod) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetInnerFECMethod(this, core::mem::transmute_copy(&pfecmethod)).into()
            }
        }
        unsafe extern "system" fn InnerFECMethod<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecmethod: *mut FECMethod) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::InnerFECMethod(this, core::mem::transmute_copy(&pfecmethod)).into()
            }
        }
        unsafe extern "system" fn SetInnerFECRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetInnerFECRate(this, core::mem::transmute_copy(&pfecrate)).into()
            }
        }
        unsafe extern "system" fn InnerFECRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::InnerFECRate(this, core::mem::transmute_copy(&pfecrate)).into()
            }
        }
        unsafe extern "system" fn SetOuterFECMethod<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecmethod: *const FECMethod) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetOuterFECMethod(this, core::mem::transmute_copy(&pfecmethod)).into()
            }
        }
        unsafe extern "system" fn OuterFECMethod<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecmethod: *mut FECMethod) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::OuterFECMethod(this, core::mem::transmute_copy(&pfecmethod)).into()
            }
        }
        unsafe extern "system" fn SetOuterFECRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecrate: *const BinaryConvolutionCodeRate) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetOuterFECRate(this, core::mem::transmute_copy(&pfecrate)).into()
            }
        }
        unsafe extern "system" fn OuterFECRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfecrate: *mut BinaryConvolutionCodeRate) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::OuterFECRate(this, core::mem::transmute_copy(&pfecrate)).into()
            }
        }
        unsafe extern "system" fn SetSymbolRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psymbolrate: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetSymbolRate(this, core::mem::transmute_copy(&psymbolrate)).into()
            }
        }
        unsafe extern "system" fn SymbolRate<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psymbolrate: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SymbolRate(this, core::mem::transmute_copy(&psymbolrate)).into()
            }
        }
        unsafe extern "system" fn SetSpectralInversion<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pspectralinversion: *const SpectralInversion) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SetSpectralInversion(this, core::mem::transmute_copy(&pspectralinversion)).into()
            }
        }
        unsafe extern "system" fn SpectralInversion<Identity: IBDA_DigitalDemodulator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pspectralinversion: *mut SpectralInversion) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator_Impl::SpectralInversion(this, core::mem::transmute_copy(&pspectralinversion)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetModulationType: SetModulationType::<Identity, OFFSET>,
            ModulationType: ModulationType::<Identity, OFFSET>,
            SetInnerFECMethod: SetInnerFECMethod::<Identity, OFFSET>,
            InnerFECMethod: InnerFECMethod::<Identity, OFFSET>,
            SetInnerFECRate: SetInnerFECRate::<Identity, OFFSET>,
            InnerFECRate: InnerFECRate::<Identity, OFFSET>,
            SetOuterFECMethod: SetOuterFECMethod::<Identity, OFFSET>,
            OuterFECMethod: OuterFECMethod::<Identity, OFFSET>,
            SetOuterFECRate: SetOuterFECRate::<Identity, OFFSET>,
            OuterFECRate: OuterFECRate::<Identity, OFFSET>,
            SetSymbolRate: SetSymbolRate::<Identity, OFFSET>,
            SymbolRate: SymbolRate::<Identity, OFFSET>,
            SetSpectralInversion: SetSpectralInversion::<Identity, OFFSET>,
            SpectralInversion: SpectralInversion::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DigitalDemodulator {}
windows_core::imp::define_interface!(IBDA_DigitalDemodulator2, IBDA_DigitalDemodulator2_Vtbl, 0x525ed3ee_5cf3_4e1e_9a06_5368a84f9a6e);
impl core::ops::Deref for IBDA_DigitalDemodulator2 {
    type Target = IBDA_DigitalDemodulator;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IBDA_DigitalDemodulator2, windows_core::IUnknown, IBDA_DigitalDemodulator);
impl IBDA_DigitalDemodulator2 {
    pub unsafe fn SetGuardInterval(&self, pguardinterval: *const GuardInterval) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetGuardInterval)(windows_core::Interface::as_raw(self), pguardinterval).ok() }
    }
    pub unsafe fn GuardInterval(&self, pguardinterval: *mut GuardInterval) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GuardInterval)(windows_core::Interface::as_raw(self), pguardinterval as _).ok() }
    }
    pub unsafe fn SetTransmissionMode(&self, ptransmissionmode: *const TransmissionMode) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTransmissionMode)(windows_core::Interface::as_raw(self), ptransmissionmode).ok() }
    }
    pub unsafe fn TransmissionMode(&self, ptransmissionmode: *mut TransmissionMode) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TransmissionMode)(windows_core::Interface::as_raw(self), ptransmissionmode as _).ok() }
    }
    pub unsafe fn SetRollOff(&self, prolloff: *const RollOff) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRollOff)(windows_core::Interface::as_raw(self), prolloff).ok() }
    }
    pub unsafe fn RollOff(&self, prolloff: *mut RollOff) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RollOff)(windows_core::Interface::as_raw(self), prolloff as _).ok() }
    }
    pub unsafe fn SetPilot(&self, ppilot: *const Pilot) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPilot)(windows_core::Interface::as_raw(self), ppilot).ok() }
    }
    pub unsafe fn Pilot(&self, ppilot: *mut Pilot) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Pilot)(windows_core::Interface::as_raw(self), ppilot as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DigitalDemodulator2_Vtbl {
    pub base__: IBDA_DigitalDemodulator_Vtbl,
    pub SetGuardInterval: unsafe extern "system" fn(*mut core::ffi::c_void, *const GuardInterval) -> windows_core::HRESULT,
    pub GuardInterval: unsafe extern "system" fn(*mut core::ffi::c_void, *mut GuardInterval) -> windows_core::HRESULT,
    pub SetTransmissionMode: unsafe extern "system" fn(*mut core::ffi::c_void, *const TransmissionMode) -> windows_core::HRESULT,
    pub TransmissionMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut TransmissionMode) -> windows_core::HRESULT,
    pub SetRollOff: unsafe extern "system" fn(*mut core::ffi::c_void, *const RollOff) -> windows_core::HRESULT,
    pub RollOff: unsafe extern "system" fn(*mut core::ffi::c_void, *mut RollOff) -> windows_core::HRESULT,
    pub SetPilot: unsafe extern "system" fn(*mut core::ffi::c_void, *const Pilot) -> windows_core::HRESULT,
    pub Pilot: unsafe extern "system" fn(*mut core::ffi::c_void, *mut Pilot) -> windows_core::HRESULT,
}
pub trait IBDA_DigitalDemodulator2_Impl: IBDA_DigitalDemodulator_Impl {
    fn SetGuardInterval(&self, pguardinterval: *const GuardInterval) -> windows_core::Result<()>;
    fn GuardInterval(&self, pguardinterval: *mut GuardInterval) -> windows_core::Result<()>;
    fn SetTransmissionMode(&self, ptransmissionmode: *const TransmissionMode) -> windows_core::Result<()>;
    fn TransmissionMode(&self, ptransmissionmode: *mut TransmissionMode) -> windows_core::Result<()>;
    fn SetRollOff(&self, prolloff: *const RollOff) -> windows_core::Result<()>;
    fn RollOff(&self, prolloff: *mut RollOff) -> windows_core::Result<()>;
    fn SetPilot(&self, ppilot: *const Pilot) -> windows_core::Result<()>;
    fn Pilot(&self, ppilot: *mut Pilot) -> windows_core::Result<()>;
}
impl IBDA_DigitalDemodulator2_Vtbl {
    pub const fn new<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetGuardInterval<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguardinterval: *const GuardInterval) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::SetGuardInterval(this, core::mem::transmute_copy(&pguardinterval)).into()
            }
        }
        unsafe extern "system" fn GuardInterval<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguardinterval: *mut GuardInterval) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::GuardInterval(this, core::mem::transmute_copy(&pguardinterval)).into()
            }
        }
        unsafe extern "system" fn SetTransmissionMode<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptransmissionmode: *const TransmissionMode) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::SetTransmissionMode(this, core::mem::transmute_copy(&ptransmissionmode)).into()
            }
        }
        unsafe extern "system" fn TransmissionMode<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptransmissionmode: *mut TransmissionMode) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::TransmissionMode(this, core::mem::transmute_copy(&ptransmissionmode)).into()
            }
        }
        unsafe extern "system" fn SetRollOff<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prolloff: *const RollOff) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::SetRollOff(this, core::mem::transmute_copy(&prolloff)).into()
            }
        }
        unsafe extern "system" fn RollOff<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prolloff: *mut RollOff) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::RollOff(this, core::mem::transmute_copy(&prolloff)).into()
            }
        }
        unsafe extern "system" fn SetPilot<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppilot: *const Pilot) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::SetPilot(this, core::mem::transmute_copy(&ppilot)).into()
            }
        }
        unsafe extern "system" fn Pilot<Identity: IBDA_DigitalDemodulator2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppilot: *mut Pilot) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator2_Impl::Pilot(this, core::mem::transmute_copy(&ppilot)).into()
            }
        }
        Self {
            base__: IBDA_DigitalDemodulator_Vtbl::new::<Identity, OFFSET>(),
            SetGuardInterval: SetGuardInterval::<Identity, OFFSET>,
            GuardInterval: GuardInterval::<Identity, OFFSET>,
            SetTransmissionMode: SetTransmissionMode::<Identity, OFFSET>,
            TransmissionMode: TransmissionMode::<Identity, OFFSET>,
            SetRollOff: SetRollOff::<Identity, OFFSET>,
            RollOff: RollOff::<Identity, OFFSET>,
            SetPilot: SetPilot::<Identity, OFFSET>,
            Pilot: Pilot::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator2 as windows_core::Interface>::IID || iid == &<IBDA_DigitalDemodulator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DigitalDemodulator2 {}
windows_core::imp::define_interface!(IBDA_DigitalDemodulator3, IBDA_DigitalDemodulator3_Vtbl, 0x13f19604_7d32_4359_93a2_a05205d90ac9);
impl core::ops::Deref for IBDA_DigitalDemodulator3 {
    type Target = IBDA_DigitalDemodulator2;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IBDA_DigitalDemodulator3, windows_core::IUnknown, IBDA_DigitalDemodulator, IBDA_DigitalDemodulator2);
impl IBDA_DigitalDemodulator3 {
    pub unsafe fn SetSignalTimeouts(&self, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSignalTimeouts)(windows_core::Interface::as_raw(self), psignaltimeouts).ok() }
    }
    pub unsafe fn SignalTimeouts(&self, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SignalTimeouts)(windows_core::Interface::as_raw(self), psignaltimeouts as _).ok() }
    }
    pub unsafe fn SetPLPNumber(&self, pplpnumber: *const u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPLPNumber)(windows_core::Interface::as_raw(self), pplpnumber).ok() }
    }
    pub unsafe fn PLPNumber(&self, pplpnumber: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PLPNumber)(windows_core::Interface::as_raw(self), pplpnumber as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DigitalDemodulator3_Vtbl {
    pub base__: IBDA_DigitalDemodulator2_Vtbl,
    pub SetSignalTimeouts: unsafe extern "system" fn(*mut core::ffi::c_void, *const BDA_SIGNAL_TIMEOUTS) -> windows_core::HRESULT,
    pub SignalTimeouts: unsafe extern "system" fn(*mut core::ffi::c_void, *mut BDA_SIGNAL_TIMEOUTS) -> windows_core::HRESULT,
    pub SetPLPNumber: unsafe extern "system" fn(*mut core::ffi::c_void, *const u32) -> windows_core::HRESULT,
    pub PLPNumber: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_DigitalDemodulator3_Impl: IBDA_DigitalDemodulator2_Impl {
    fn SetSignalTimeouts(&self, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> windows_core::Result<()>;
    fn SignalTimeouts(&self, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> windows_core::Result<()>;
    fn SetPLPNumber(&self, pplpnumber: *const u32) -> windows_core::Result<()>;
    fn PLPNumber(&self, pplpnumber: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_DigitalDemodulator3_Vtbl {
    pub const fn new<Identity: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetSignalTimeouts<Identity: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psignaltimeouts: *const BDA_SIGNAL_TIMEOUTS) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator3_Impl::SetSignalTimeouts(this, core::mem::transmute_copy(&psignaltimeouts)).into()
            }
        }
        unsafe extern "system" fn SignalTimeouts<Identity: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psignaltimeouts: *mut BDA_SIGNAL_TIMEOUTS) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator3_Impl::SignalTimeouts(this, core::mem::transmute_copy(&psignaltimeouts)).into()
            }
        }
        unsafe extern "system" fn SetPLPNumber<Identity: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pplpnumber: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator3_Impl::SetPLPNumber(this, core::mem::transmute_copy(&pplpnumber)).into()
            }
        }
        unsafe extern "system" fn PLPNumber<Identity: IBDA_DigitalDemodulator3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pplpnumber: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DigitalDemodulator3_Impl::PLPNumber(this, core::mem::transmute_copy(&pplpnumber)).into()
            }
        }
        Self {
            base__: IBDA_DigitalDemodulator2_Vtbl::new::<Identity, OFFSET>(),
            SetSignalTimeouts: SetSignalTimeouts::<Identity, OFFSET>,
            SignalTimeouts: SignalTimeouts::<Identity, OFFSET>,
            SetPLPNumber: SetPLPNumber::<Identity, OFFSET>,
            PLPNumber: PLPNumber::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DigitalDemodulator3 as windows_core::Interface>::IID || iid == &<IBDA_DigitalDemodulator as windows_core::Interface>::IID || iid == &<IBDA_DigitalDemodulator2 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DigitalDemodulator3 {}
windows_core::imp::define_interface!(IBDA_DiseqCommand, IBDA_DiseqCommand_Vtbl, 0xf84e2ab0_3c6b_45e3_a0fc_8669d4b81f11);
windows_core::imp::interface_hierarchy!(IBDA_DiseqCommand, windows_core::IUnknown);
impl IBDA_DiseqCommand {
    pub unsafe fn SetEnableDiseqCommands(&self, benable: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnableDiseqCommands)(windows_core::Interface::as_raw(self), benable).ok() }
    }
    pub unsafe fn SetDiseqLNBSource(&self, ullnbsource: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDiseqLNBSource)(windows_core::Interface::as_raw(self), ullnbsource).ok() }
    }
    pub unsafe fn SetDiseqUseToneBurst(&self, busetoneburst: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDiseqUseToneBurst)(windows_core::Interface::as_raw(self), busetoneburst).ok() }
    }
    pub unsafe fn SetDiseqRepeats(&self, ulrepeats: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDiseqRepeats)(windows_core::Interface::as_raw(self), ulrepeats).ok() }
    }
    pub unsafe fn put_DiseqSendCommand(&self, ulrequestid: u32, pbcommand: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_DiseqSendCommand)(windows_core::Interface::as_raw(self), ulrequestid, pbcommand.len().try_into().unwrap(), core::mem::transmute(pbcommand.as_ptr())).ok() }
    }
    pub unsafe fn get_DiseqResponse(&self, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_DiseqResponse)(windows_core::Interface::as_raw(self), ulrequestid, pulcbresponselen as _, pbresponse as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_DiseqCommand_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetEnableDiseqCommands: unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub SetDiseqLNBSource: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetDiseqUseToneBurst: unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub SetDiseqRepeats: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub put_DiseqSendCommand: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *const u8) -> windows_core::HRESULT,
    pub get_DiseqResponse: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_DiseqCommand_Impl: windows_core::IUnknownImpl {
    fn SetEnableDiseqCommands(&self, benable: bool) -> windows_core::Result<()>;
    fn SetDiseqLNBSource(&self, ullnbsource: u32) -> windows_core::Result<()>;
    fn SetDiseqUseToneBurst(&self, busetoneburst: bool) -> windows_core::Result<()>;
    fn SetDiseqRepeats(&self, ulrepeats: u32) -> windows_core::Result<()>;
    fn put_DiseqSendCommand(&self, ulrequestid: u32, ulcbcommandlen: u32, pbcommand: *const u8) -> windows_core::Result<()>;
    fn get_DiseqResponse(&self, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> windows_core::Result<()>;
}
impl IBDA_DiseqCommand_Vtbl {
    pub const fn new<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetEnableDiseqCommands<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, benable: bool) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::SetEnableDiseqCommands(this, core::mem::transmute_copy(&benable)).into()
            }
        }
        unsafe extern "system" fn SetDiseqLNBSource<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullnbsource: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::SetDiseqLNBSource(this, core::mem::transmute_copy(&ullnbsource)).into()
            }
        }
        unsafe extern "system" fn SetDiseqUseToneBurst<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, busetoneburst: bool) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::SetDiseqUseToneBurst(this, core::mem::transmute_copy(&busetoneburst)).into()
            }
        }
        unsafe extern "system" fn SetDiseqRepeats<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrepeats: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::SetDiseqRepeats(this, core::mem::transmute_copy(&ulrepeats)).into()
            }
        }
        unsafe extern "system" fn put_DiseqSendCommand<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrequestid: u32, ulcbcommandlen: u32, pbcommand: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::put_DiseqSendCommand(this, core::mem::transmute_copy(&ulrequestid), core::mem::transmute_copy(&ulcbcommandlen), core::mem::transmute_copy(&pbcommand)).into()
            }
        }
        unsafe extern "system" fn get_DiseqResponse<Identity: IBDA_DiseqCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrequestid: u32, pulcbresponselen: *mut u32, pbresponse: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_DiseqCommand_Impl::get_DiseqResponse(this, core::mem::transmute_copy(&ulrequestid), core::mem::transmute_copy(&pulcbresponselen), core::mem::transmute_copy(&pbresponse)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetEnableDiseqCommands: SetEnableDiseqCommands::<Identity, OFFSET>,
            SetDiseqLNBSource: SetDiseqLNBSource::<Identity, OFFSET>,
            SetDiseqUseToneBurst: SetDiseqUseToneBurst::<Identity, OFFSET>,
            SetDiseqRepeats: SetDiseqRepeats::<Identity, OFFSET>,
            put_DiseqSendCommand: put_DiseqSendCommand::<Identity, OFFSET>,
            get_DiseqResponse: get_DiseqResponse::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_DiseqCommand as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_DiseqCommand {}
windows_core::imp::define_interface!(IBDA_EasMessage, IBDA_EasMessage_Vtbl, 0xd806973d_3ebe_46de_8fbb_6358fe784208);
windows_core::imp::interface_hierarchy!(IBDA_EasMessage, windows_core::IUnknown);
impl IBDA_EasMessage {
    pub unsafe fn get_EasMessage(&self, uleventid: u32, ppeasobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_EasMessage)(windows_core::Interface::as_raw(self), uleventid, core::mem::transmute(ppeasobject)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_EasMessage_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_EasMessage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_EasMessage_Impl: windows_core::IUnknownImpl {
    fn get_EasMessage(&self, uleventid: u32, ppeasobject: windows_core::OutRef<windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl IBDA_EasMessage_Vtbl {
    pub const fn new<Identity: IBDA_EasMessage_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_EasMessage<Identity: IBDA_EasMessage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uleventid: u32, ppeasobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EasMessage_Impl::get_EasMessage(this, core::mem::transmute_copy(&uleventid), core::mem::transmute_copy(&ppeasobject)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), get_EasMessage: get_EasMessage::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_EasMessage as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_EasMessage {}
windows_core::imp::define_interface!(IBDA_Encoder, IBDA_Encoder_Vtbl, 0x3a8bad59_59fe_4559_a0ba_396cfaa98ae3);
windows_core::imp::interface_hierarchy!(IBDA_Encoder, windows_core::IUnknown);
impl IBDA_Encoder {
    pub unsafe fn QueryCapabilities(&self, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryCapabilities)(windows_core::Interface::as_raw(self), numaudiofmts as _, numvideofmts as _).ok() }
    }
    pub unsafe fn EnumAudioCapability(&self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnumAudioCapability)(windows_core::Interface::as_raw(self), fmtindex, methodid as _, algorithmtype as _, samplingrate as _, bitdepth as _, numchannels as _).ok() }
    }
    pub unsafe fn EnumVideoCapability(&self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnumVideoCapability)(windows_core::Interface::as_raw(self), fmtindex, methodid as _, algorithmtype as _, verticalsize as _, horizontalsize as _, aspectratio as _, frameratecode as _, progressivesequence as _).ok() }
    }
    pub unsafe fn SetParameters(&self, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetParameters)(windows_core::Interface::as_raw(self), audiobitratemode, audiobitrate, audiomethodid, audioprogram, videobitratemode, videobitrate, videomethodid).ok() }
    }
    pub unsafe fn GetState(&self, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut windows_core::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), audiobitratemax as _, audiobitratemin as _, audiobitratemode as _, audiobitratestepping as _, audiobitrate as _, audiomethodid as _, availableaudioprograms as _, audioprogram as _, videobitratemax as _, videobitratemin as _, videobitratemode as _, videobitrate as _, videobitratestepping as _, videomethodid as _, signalsourceid as _, signalformat as _, signallock as _, signallevel as _, signaltonoiseratio as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_Encoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub EnumAudioCapability: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub EnumVideoCapability: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub SetParameters: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, u32, u32, u32, u32) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u64, *mut windows_core::BOOL, *mut i32, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_Encoder_Impl: windows_core::IUnknownImpl {
    fn QueryCapabilities(&self, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> windows_core::Result<()>;
    fn EnumAudioCapability(&self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> windows_core::Result<()>;
    fn EnumVideoCapability(&self, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> windows_core::Result<()>;
    fn SetParameters(&self, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> windows_core::Result<()>;
    fn GetState(&self, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut windows_core::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_Encoder_Vtbl {
    pub const fn new<Identity: IBDA_Encoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryCapabilities<Identity: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numaudiofmts: *mut u32, numvideofmts: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Encoder_Impl::QueryCapabilities(this, core::mem::transmute_copy(&numaudiofmts), core::mem::transmute_copy(&numvideofmts)).into()
            }
        }
        unsafe extern "system" fn EnumAudioCapability<Identity: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, samplingrate: *mut u32, bitdepth: *mut u32, numchannels: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Encoder_Impl::EnumAudioCapability(this, core::mem::transmute_copy(&fmtindex), core::mem::transmute_copy(&methodid), core::mem::transmute_copy(&algorithmtype), core::mem::transmute_copy(&samplingrate), core::mem::transmute_copy(&bitdepth), core::mem::transmute_copy(&numchannels)).into()
            }
        }
        unsafe extern "system" fn EnumVideoCapability<Identity: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fmtindex: u32, methodid: *mut u32, algorithmtype: *mut u32, verticalsize: *mut u32, horizontalsize: *mut u32, aspectratio: *mut u32, frameratecode: *mut u32, progressivesequence: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Encoder_Impl::EnumVideoCapability(this, core::mem::transmute_copy(&fmtindex), core::mem::transmute_copy(&methodid), core::mem::transmute_copy(&algorithmtype), core::mem::transmute_copy(&verticalsize), core::mem::transmute_copy(&horizontalsize), core::mem::transmute_copy(&aspectratio), core::mem::transmute_copy(&frameratecode), core::mem::transmute_copy(&progressivesequence)).into()
            }
        }
        unsafe extern "system" fn SetParameters<Identity: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, audiobitratemode: u32, audiobitrate: u32, audiomethodid: u32, audioprogram: u32, videobitratemode: u32, videobitrate: u32, videomethodid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Encoder_Impl::SetParameters(this, core::mem::transmute_copy(&audiobitratemode), core::mem::transmute_copy(&audiobitrate), core::mem::transmute_copy(&audiomethodid), core::mem::transmute_copy(&audioprogram), core::mem::transmute_copy(&videobitratemode), core::mem::transmute_copy(&videobitrate), core::mem::transmute_copy(&videomethodid)).into()
            }
        }
        unsafe extern "system" fn GetState<Identity: IBDA_Encoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, audiobitratemax: *mut u32, audiobitratemin: *mut u32, audiobitratemode: *mut u32, audiobitratestepping: *mut u32, audiobitrate: *mut u32, audiomethodid: *mut u32, availableaudioprograms: *mut u32, audioprogram: *mut u32, videobitratemax: *mut u32, videobitratemin: *mut u32, videobitratemode: *mut u32, videobitrate: *mut u32, videobitratestepping: *mut u32, videomethodid: *mut u32, signalsourceid: *mut u32, signalformat: *mut u64, signallock: *mut windows_core::BOOL, signallevel: *mut i32, signaltonoiseratio: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Encoder_Impl::GetState(
                    this,
                    core::mem::transmute_copy(&audiobitratemax),
                    core::mem::transmute_copy(&audiobitratemin),
                    core::mem::transmute_copy(&audiobitratemode),
                    core::mem::transmute_copy(&audiobitratestepping),
                    core::mem::transmute_copy(&audiobitrate),
                    core::mem::transmute_copy(&audiomethodid),
                    core::mem::transmute_copy(&availableaudioprograms),
                    core::mem::transmute_copy(&audioprogram),
                    core::mem::transmute_copy(&videobitratemax),
                    core::mem::transmute_copy(&videobitratemin),
                    core::mem::transmute_copy(&videobitratemode),
                    core::mem::transmute_copy(&videobitrate),
                    core::mem::transmute_copy(&videobitratestepping),
                    core::mem::transmute_copy(&videomethodid),
                    core::mem::transmute_copy(&signalsourceid),
                    core::mem::transmute_copy(&signalformat),
                    core::mem::transmute_copy(&signallock),
                    core::mem::transmute_copy(&signallevel),
                    core::mem::transmute_copy(&signaltonoiseratio),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            QueryCapabilities: QueryCapabilities::<Identity, OFFSET>,
            EnumAudioCapability: EnumAudioCapability::<Identity, OFFSET>,
            EnumVideoCapability: EnumVideoCapability::<Identity, OFFSET>,
            SetParameters: SetParameters::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_Encoder as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_Encoder {}
windows_core::imp::define_interface!(IBDA_EthernetFilter, IBDA_EthernetFilter_Vtbl, 0x71985f43_1ca1_11d3_9cc8_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_EthernetFilter, windows_core::IUnknown);
impl IBDA_EthernetFilter {
    pub unsafe fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastListSize)(windows_core::Interface::as_raw(self), pulcbaddresses as _).ok() }
    }
    pub unsafe fn PutMulticastList(&self, paddresslist: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastList)(windows_core::Interface::as_raw(self), paddresslist.len().try_into().unwrap(), core::mem::transmute(paddresslist.as_ptr())).ok() }
    }
    pub unsafe fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastList)(windows_core::Interface::as_raw(self), pulcbaddresses as _, paddresslist as _).ok() }
    }
    pub unsafe fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastMode)(windows_core::Interface::as_raw(self), ulmodemask).ok() }
    }
    pub unsafe fn GetMulticastMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMulticastMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_EthernetFilter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMulticastListSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub PutMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub GetMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub PutMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_EthernetFilter_Impl: windows_core::IUnknownImpl {
    fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()>;
    fn PutMulticastList(&self, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::Result<()>;
    fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()>;
    fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()>;
    fn GetMulticastMode(&self) -> windows_core::Result<u32>;
}
impl IBDA_EthernetFilter_Vtbl {
    pub const fn new<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMulticastListSize<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EthernetFilter_Impl::GetMulticastListSize(this, core::mem::transmute_copy(&pulcbaddresses)).into()
            }
        }
        unsafe extern "system" fn PutMulticastList<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EthernetFilter_Impl::PutMulticastList(this, core::mem::transmute_copy(&ulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn GetMulticastList<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EthernetFilter_Impl::GetMulticastList(this, core::mem::transmute_copy(&pulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn PutMulticastMode<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmodemask: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EthernetFilter_Impl::PutMulticastMode(this, core::mem::transmute_copy(&ulmodemask)).into()
            }
        }
        unsafe extern "system" fn GetMulticastMode<Identity: IBDA_EthernetFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulmodemask: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_EthernetFilter_Impl::GetMulticastMode(this) {
                    Ok(ok__) => {
                        pulmodemask.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Identity, OFFSET>,
            PutMulticastList: PutMulticastList::<Identity, OFFSET>,
            GetMulticastList: GetMulticastList::<Identity, OFFSET>,
            PutMulticastMode: PutMulticastMode::<Identity, OFFSET>,
            GetMulticastMode: GetMulticastMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_EthernetFilter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_EthernetFilter {}
windows_core::imp::define_interface!(IBDA_EventingService, IBDA_EventingService_Vtbl, 0x207c413f_00dc_4c61_bad6_6fee1ff07064);
windows_core::imp::interface_hierarchy!(IBDA_EventingService, windows_core::IUnknown);
impl IBDA_EventingService {
    pub unsafe fn CompleteEvent(&self, uleventid: u32, uleventresult: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CompleteEvent)(windows_core::Interface::as_raw(self), uleventid, uleventresult).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_EventingService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub CompleteEvent: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
}
pub trait IBDA_EventingService_Impl: windows_core::IUnknownImpl {
    fn CompleteEvent(&self, uleventid: u32, uleventresult: u32) -> windows_core::Result<()>;
}
impl IBDA_EventingService_Vtbl {
    pub const fn new<Identity: IBDA_EventingService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CompleteEvent<Identity: IBDA_EventingService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uleventid: u32, uleventresult: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_EventingService_Impl::CompleteEvent(this, core::mem::transmute_copy(&uleventid), core::mem::transmute_copy(&uleventresult)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CompleteEvent: CompleteEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_EventingService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_EventingService {}
windows_core::imp::define_interface!(IBDA_FDC, IBDA_FDC_Vtbl, 0x138adc7e_58ae_437f_b0b4_c9fe19d5b4ac);
windows_core::imp::interface_hierarchy!(IBDA_FDC, windows_core::IUnknown);
impl IBDA_FDC {
    pub unsafe fn GetStatus(&self, currentbitrate: *mut u32, carrierlock: *mut windows_core::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut windows_core::BOOL, currentpidlist: *mut windows_core::BSTR, currenttidlist: *mut windows_core::BSTR, overflow: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStatus)(windows_core::Interface::as_raw(self), currentbitrate as _, carrierlock as _, currentfrequency as _, currentspectruminversion as _, core::mem::transmute(currentpidlist), core::mem::transmute(currenttidlist), overflow as _).ok() }
    }
    pub unsafe fn RequestTables(&self, tableids: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RequestTables)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(tableids)).ok() }
    }
    pub unsafe fn AddPid(&self, pidstoadd: &windows_core::BSTR) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddPid)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(pidstoadd), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RemovePid(&self, pidstoremove: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RemovePid)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(pidstoremove)).ok() }
    }
    pub unsafe fn AddTid(&self, tidstoadd: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddTid)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(tidstoadd), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn RemoveTid(&self, tidstoremove: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RemoveTid)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(tidstoremove)).ok() }
    }
    pub unsafe fn GetTableSection(&self, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTableSection)(windows_core::Interface::as_raw(self), pid as _, maxbuffersize, actualsize as _, secbuffer as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_FDC_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut windows_core::BOOL, *mut u32, *mut windows_core::BOOL, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub RequestTables: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub AddPid: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub RemovePid: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub AddTid: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RemoveTid: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetTableSection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut u32, *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_FDC_Impl: windows_core::IUnknownImpl {
    fn GetStatus(&self, currentbitrate: *mut u32, carrierlock: *mut windows_core::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut windows_core::BOOL, currentpidlist: *mut windows_core::BSTR, currenttidlist: *mut windows_core::BSTR, overflow: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn RequestTables(&self, tableids: &windows_core::BSTR) -> windows_core::Result<()>;
    fn AddPid(&self, pidstoadd: &windows_core::BSTR) -> windows_core::Result<u32>;
    fn RemovePid(&self, pidstoremove: &windows_core::BSTR) -> windows_core::Result<()>;
    fn AddTid(&self, tidstoadd: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR>;
    fn RemoveTid(&self, tidstoremove: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetTableSection(&self, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> windows_core::Result<()>;
}
impl IBDA_FDC_Vtbl {
    pub const fn new<Identity: IBDA_FDC_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetStatus<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, currentbitrate: *mut u32, carrierlock: *mut windows_core::BOOL, currentfrequency: *mut u32, currentspectruminversion: *mut windows_core::BOOL, currentpidlist: *mut *mut core::ffi::c_void, currenttidlist: *mut *mut core::ffi::c_void, overflow: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FDC_Impl::GetStatus(this, core::mem::transmute_copy(&currentbitrate), core::mem::transmute_copy(&carrierlock), core::mem::transmute_copy(&currentfrequency), core::mem::transmute_copy(&currentspectruminversion), core::mem::transmute_copy(&currentpidlist), core::mem::transmute_copy(&currenttidlist), core::mem::transmute_copy(&overflow)).into()
            }
        }
        unsafe extern "system" fn RequestTables<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tableids: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FDC_Impl::RequestTables(this, core::mem::transmute(&tableids)).into()
            }
        }
        unsafe extern "system" fn AddPid<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pidstoadd: *mut core::ffi::c_void, remainingfilterentries: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_FDC_Impl::AddPid(this, core::mem::transmute(&pidstoadd)) {
                    Ok(ok__) => {
                        remainingfilterentries.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemovePid<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pidstoremove: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FDC_Impl::RemovePid(this, core::mem::transmute(&pidstoremove)).into()
            }
        }
        unsafe extern "system" fn AddTid<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tidstoadd: *mut core::ffi::c_void, currenttidlist: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_FDC_Impl::AddTid(this, core::mem::transmute(&tidstoadd)) {
                    Ok(ok__) => {
                        currenttidlist.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveTid<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tidstoremove: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FDC_Impl::RemoveTid(this, core::mem::transmute(&tidstoremove)).into()
            }
        }
        unsafe extern "system" fn GetTableSection<Identity: IBDA_FDC_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pid: *mut u32, maxbuffersize: u32, actualsize: *mut u32, secbuffer: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FDC_Impl::GetTableSection(this, core::mem::transmute_copy(&pid), core::mem::transmute_copy(&maxbuffersize), core::mem::transmute_copy(&actualsize), core::mem::transmute_copy(&secbuffer)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStatus: GetStatus::<Identity, OFFSET>,
            RequestTables: RequestTables::<Identity, OFFSET>,
            AddPid: AddPid::<Identity, OFFSET>,
            RemovePid: RemovePid::<Identity, OFFSET>,
            AddTid: AddTid::<Identity, OFFSET>,
            RemoveTid: RemoveTid::<Identity, OFFSET>,
            GetTableSection: GetTableSection::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_FDC as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_FDC {}
windows_core::imp::define_interface!(IBDA_FrequencyFilter, IBDA_FrequencyFilter_Vtbl, 0x71985f47_1ca1_11d3_9cc8_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_FrequencyFilter, windows_core::IUnknown);
impl IBDA_FrequencyFilter {
    pub unsafe fn SetAutotune(&self, ultransponder: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAutotune)(windows_core::Interface::as_raw(self), ultransponder).ok() }
    }
    pub unsafe fn Autotune(&self, pultransponder: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Autotune)(windows_core::Interface::as_raw(self), pultransponder as _).ok() }
    }
    pub unsafe fn SetFrequency(&self, ulfrequency: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFrequency)(windows_core::Interface::as_raw(self), ulfrequency).ok() }
    }
    pub unsafe fn Frequency(&self, pulfrequency: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Frequency)(windows_core::Interface::as_raw(self), pulfrequency as _).ok() }
    }
    pub unsafe fn SetPolarity(&self, polarity: Polarisation) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPolarity)(windows_core::Interface::as_raw(self), polarity).ok() }
    }
    pub unsafe fn Polarity(&self, ppolarity: *mut Polarisation) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Polarity)(windows_core::Interface::as_raw(self), ppolarity as _).ok() }
    }
    pub unsafe fn SetRange(&self, ulrange: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRange)(windows_core::Interface::as_raw(self), ulrange).ok() }
    }
    pub unsafe fn Range(&self, pulrange: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Range)(windows_core::Interface::as_raw(self), pulrange as _).ok() }
    }
    pub unsafe fn SetBandwidth(&self, ulbandwidth: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBandwidth)(windows_core::Interface::as_raw(self), ulbandwidth).ok() }
    }
    pub unsafe fn Bandwidth(&self, pulbandwidth: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Bandwidth)(windows_core::Interface::as_raw(self), pulbandwidth as _).ok() }
    }
    pub unsafe fn SetFrequencyMultiplier(&self, ulmultiplier: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFrequencyMultiplier)(windows_core::Interface::as_raw(self), ulmultiplier).ok() }
    }
    pub unsafe fn FrequencyMultiplier(&self, pulmultiplier: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FrequencyMultiplier)(windows_core::Interface::as_raw(self), pulmultiplier as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_FrequencyFilter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetAutotune: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Autotune: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Frequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetPolarity: unsafe extern "system" fn(*mut core::ffi::c_void, Polarisation) -> windows_core::HRESULT,
    pub Polarity: unsafe extern "system" fn(*mut core::ffi::c_void, *mut Polarisation) -> windows_core::HRESULT,
    pub SetRange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Range: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetBandwidth: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Bandwidth: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetFrequencyMultiplier: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub FrequencyMultiplier: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_FrequencyFilter_Impl: windows_core::IUnknownImpl {
    fn SetAutotune(&self, ultransponder: u32) -> windows_core::Result<()>;
    fn Autotune(&self, pultransponder: *mut u32) -> windows_core::Result<()>;
    fn SetFrequency(&self, ulfrequency: u32) -> windows_core::Result<()>;
    fn Frequency(&self, pulfrequency: *mut u32) -> windows_core::Result<()>;
    fn SetPolarity(&self, polarity: Polarisation) -> windows_core::Result<()>;
    fn Polarity(&self, ppolarity: *mut Polarisation) -> windows_core::Result<()>;
    fn SetRange(&self, ulrange: u32) -> windows_core::Result<()>;
    fn Range(&self, pulrange: *mut u32) -> windows_core::Result<()>;
    fn SetBandwidth(&self, ulbandwidth: u32) -> windows_core::Result<()>;
    fn Bandwidth(&self, pulbandwidth: *mut u32) -> windows_core::Result<()>;
    fn SetFrequencyMultiplier(&self, ulmultiplier: u32) -> windows_core::Result<()>;
    fn FrequencyMultiplier(&self, pulmultiplier: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_FrequencyFilter_Vtbl {
    pub const fn new<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAutotune<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultransponder: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetAutotune(this, core::mem::transmute_copy(&ultransponder)).into()
            }
        }
        unsafe extern "system" fn Autotune<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pultransponder: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::Autotune(this, core::mem::transmute_copy(&pultransponder)).into()
            }
        }
        unsafe extern "system" fn SetFrequency<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulfrequency: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetFrequency(this, core::mem::transmute_copy(&ulfrequency)).into()
            }
        }
        unsafe extern "system" fn Frequency<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulfrequency: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::Frequency(this, core::mem::transmute_copy(&pulfrequency)).into()
            }
        }
        unsafe extern "system" fn SetPolarity<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, polarity: Polarisation) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetPolarity(this, core::mem::transmute_copy(&polarity)).into()
            }
        }
        unsafe extern "system" fn Polarity<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppolarity: *mut Polarisation) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::Polarity(this, core::mem::transmute_copy(&ppolarity)).into()
            }
        }
        unsafe extern "system" fn SetRange<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrange: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetRange(this, core::mem::transmute_copy(&ulrange)).into()
            }
        }
        unsafe extern "system" fn Range<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulrange: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::Range(this, core::mem::transmute_copy(&pulrange)).into()
            }
        }
        unsafe extern "system" fn SetBandwidth<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbandwidth: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetBandwidth(this, core::mem::transmute_copy(&ulbandwidth)).into()
            }
        }
        unsafe extern "system" fn Bandwidth<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulbandwidth: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::Bandwidth(this, core::mem::transmute_copy(&pulbandwidth)).into()
            }
        }
        unsafe extern "system" fn SetFrequencyMultiplier<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmultiplier: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::SetFrequencyMultiplier(this, core::mem::transmute_copy(&ulmultiplier)).into()
            }
        }
        unsafe extern "system" fn FrequencyMultiplier<Identity: IBDA_FrequencyFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulmultiplier: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_FrequencyFilter_Impl::FrequencyMultiplier(this, core::mem::transmute_copy(&pulmultiplier)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAutotune: SetAutotune::<Identity, OFFSET>,
            Autotune: Autotune::<Identity, OFFSET>,
            SetFrequency: SetFrequency::<Identity, OFFSET>,
            Frequency: Frequency::<Identity, OFFSET>,
            SetPolarity: SetPolarity::<Identity, OFFSET>,
            Polarity: Polarity::<Identity, OFFSET>,
            SetRange: SetRange::<Identity, OFFSET>,
            Range: Range::<Identity, OFFSET>,
            SetBandwidth: SetBandwidth::<Identity, OFFSET>,
            Bandwidth: Bandwidth::<Identity, OFFSET>,
            SetFrequencyMultiplier: SetFrequencyMultiplier::<Identity, OFFSET>,
            FrequencyMultiplier: FrequencyMultiplier::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_FrequencyFilter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_FrequencyFilter {}
windows_core::imp::define_interface!(IBDA_GuideDataDeliveryService, IBDA_GuideDataDeliveryService_Vtbl, 0xc0afcb73_23e7_4bc6_bafa_fdc167b4719f);
windows_core::imp::interface_hierarchy!(IBDA_GuideDataDeliveryService, windows_core::IUnknown);
impl IBDA_GuideDataDeliveryService {
    pub unsafe fn GetGuideDataType(&self) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetGuideDataType)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetGuideData(&self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetGuideData)(windows_core::Interface::as_raw(self), pulcbbufferlen as _, pbbuffer as _, pulguidedatapercentageprogress as _).ok() }
    }
    pub unsafe fn RequestGuideDataUpdate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RequestGuideDataUpdate)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetTuneXmlFromServiceIdx(&self, ul64serviceidx: u64) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTuneXmlFromServiceIdx)(windows_core::Interface::as_raw(self), ul64serviceidx, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetServices(&self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetServices)(windows_core::Interface::as_raw(self), pulcbbufferlen as _, pbbuffer as _).ok() }
    }
    pub unsafe fn GetServiceInfoFromTuneXml(&self, bstrtunexml: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetServiceInfoFromTuneXml)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(bstrtunexml), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_GuideDataDeliveryService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetGuideDataType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetGuideData: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8, *mut u32) -> windows_core::HRESULT,
    pub RequestGuideDataUpdate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetTuneXmlFromServiceIdx: unsafe extern "system" fn(*mut core::ffi::c_void, u64, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetServices: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub GetServiceInfoFromTuneXml: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_GuideDataDeliveryService_Impl: windows_core::IUnknownImpl {
    fn GetGuideDataType(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetGuideData(&self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> windows_core::Result<()>;
    fn RequestGuideDataUpdate(&self) -> windows_core::Result<()>;
    fn GetTuneXmlFromServiceIdx(&self, ul64serviceidx: u64) -> windows_core::Result<windows_core::BSTR>;
    fn GetServices(&self, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> windows_core::Result<()>;
    fn GetServiceInfoFromTuneXml(&self, bstrtunexml: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR>;
}
impl IBDA_GuideDataDeliveryService_Vtbl {
    pub const fn new<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetGuideDataType<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguiddatatype: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_GuideDataDeliveryService_Impl::GetGuideDataType(this) {
                    Ok(ok__) => {
                        pguiddatatype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetGuideData<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8, pulguidedatapercentageprogress: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_GuideDataDeliveryService_Impl::GetGuideData(this, core::mem::transmute_copy(&pulcbbufferlen), core::mem::transmute_copy(&pbbuffer), core::mem::transmute_copy(&pulguidedatapercentageprogress)).into()
            }
        }
        unsafe extern "system" fn RequestGuideDataUpdate<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_GuideDataDeliveryService_Impl::RequestGuideDataUpdate(this).into()
            }
        }
        unsafe extern "system" fn GetTuneXmlFromServiceIdx<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ul64serviceidx: u64, pbstrtunexml: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_GuideDataDeliveryService_Impl::GetTuneXmlFromServiceIdx(this, core::mem::transmute_copy(&ul64serviceidx)) {
                    Ok(ok__) => {
                        pbstrtunexml.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetServices<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbbufferlen: *mut u32, pbbuffer: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_GuideDataDeliveryService_Impl::GetServices(this, core::mem::transmute_copy(&pulcbbufferlen), core::mem::transmute_copy(&pbbuffer)).into()
            }
        }
        unsafe extern "system" fn GetServiceInfoFromTuneXml<Identity: IBDA_GuideDataDeliveryService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrtunexml: *mut core::ffi::c_void, pbstrservicedescription: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_GuideDataDeliveryService_Impl::GetServiceInfoFromTuneXml(this, core::mem::transmute(&bstrtunexml)) {
                    Ok(ok__) => {
                        pbstrservicedescription.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetGuideDataType: GetGuideDataType::<Identity, OFFSET>,
            GetGuideData: GetGuideData::<Identity, OFFSET>,
            RequestGuideDataUpdate: RequestGuideDataUpdate::<Identity, OFFSET>,
            GetTuneXmlFromServiceIdx: GetTuneXmlFromServiceIdx::<Identity, OFFSET>,
            GetServices: GetServices::<Identity, OFFSET>,
            GetServiceInfoFromTuneXml: GetServiceInfoFromTuneXml::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_GuideDataDeliveryService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_GuideDataDeliveryService {}
windows_core::imp::define_interface!(IBDA_IPSinkControl, IBDA_IPSinkControl_Vtbl, 0x3f4dc8e2_4050_11d3_8f4b_00c04f7971e2);
windows_core::imp::interface_hierarchy!(IBDA_IPSinkControl, windows_core::IUnknown);
impl IBDA_IPSinkControl {
    pub unsafe fn GetMulticastList(&self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastList)(windows_core::Interface::as_raw(self), pulcbsize as _, pbbuffer as _).ok() }
    }
    pub unsafe fn GetAdapterIPAddress(&self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAdapterIPAddress)(windows_core::Interface::as_raw(self), pulcbsize as _, pbbuffer as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_IPSinkControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u8) -> windows_core::HRESULT,
    pub GetAdapterIPAddress: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_IPSinkControl_Impl: windows_core::IUnknownImpl {
    fn GetMulticastList(&self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::Result<()>;
    fn GetAdapterIPAddress(&self, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::Result<()>;
}
impl IBDA_IPSinkControl_Vtbl {
    pub const fn new<Identity: IBDA_IPSinkControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMulticastList<Identity: IBDA_IPSinkControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPSinkControl_Impl::GetMulticastList(this, core::mem::transmute_copy(&pulcbsize), core::mem::transmute_copy(&pbbuffer)).into()
            }
        }
        unsafe extern "system" fn GetAdapterIPAddress<Identity: IBDA_IPSinkControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbsize: *mut u32, pbbuffer: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPSinkControl_Impl::GetAdapterIPAddress(this, core::mem::transmute_copy(&pulcbsize), core::mem::transmute_copy(&pbbuffer)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMulticastList: GetMulticastList::<Identity, OFFSET>,
            GetAdapterIPAddress: GetAdapterIPAddress::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_IPSinkControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_IPSinkControl {}
windows_core::imp::define_interface!(IBDA_IPSinkInfo, IBDA_IPSinkInfo_Vtbl, 0xa750108f_492e_4d51_95f7_649b23ff7ad7);
windows_core::imp::interface_hierarchy!(IBDA_IPSinkInfo, windows_core::IUnknown);
impl IBDA_IPSinkInfo {
    pub unsafe fn get_MulticastList(&self, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_MulticastList)(windows_core::Interface::as_raw(self), pulcbaddresses as _, ppbaddresslist as _).ok() }
    }
    pub unsafe fn AdapterIPAddress(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AdapterIPAddress)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn AdapterDescription(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AdapterDescription)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_IPSinkInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_MulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u8) -> windows_core::HRESULT,
    pub AdapterIPAddress: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub AdapterDescription: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_IPSinkInfo_Impl: windows_core::IUnknownImpl {
    fn get_MulticastList(&self, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> windows_core::Result<()>;
    fn AdapterIPAddress(&self) -> windows_core::Result<windows_core::BSTR>;
    fn AdapterDescription(&self) -> windows_core::Result<windows_core::BSTR>;
}
impl IBDA_IPSinkInfo_Vtbl {
    pub const fn new<Identity: IBDA_IPSinkInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_MulticastList<Identity: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32, ppbaddresslist: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPSinkInfo_Impl::get_MulticastList(this, core::mem::transmute_copy(&pulcbaddresses), core::mem::transmute_copy(&ppbaddresslist)).into()
            }
        }
        unsafe extern "system" fn AdapterIPAddress<Identity: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrbuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_IPSinkInfo_Impl::AdapterIPAddress(this) {
                    Ok(ok__) => {
                        pbstrbuffer.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AdapterDescription<Identity: IBDA_IPSinkInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrbuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_IPSinkInfo_Impl::AdapterDescription(this) {
                    Ok(ok__) => {
                        pbstrbuffer.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_MulticastList: get_MulticastList::<Identity, OFFSET>,
            AdapterIPAddress: AdapterIPAddress::<Identity, OFFSET>,
            AdapterDescription: AdapterDescription::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_IPSinkInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_IPSinkInfo {}
windows_core::imp::define_interface!(IBDA_IPV4Filter, IBDA_IPV4Filter_Vtbl, 0x71985f44_1ca1_11d3_9cc8_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_IPV4Filter, windows_core::IUnknown);
impl IBDA_IPV4Filter {
    pub unsafe fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastListSize)(windows_core::Interface::as_raw(self), pulcbaddresses as _).ok() }
    }
    pub unsafe fn PutMulticastList(&self, paddresslist: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastList)(windows_core::Interface::as_raw(self), paddresslist.len().try_into().unwrap(), core::mem::transmute(paddresslist.as_ptr())).ok() }
    }
    pub unsafe fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastList)(windows_core::Interface::as_raw(self), pulcbaddresses as _, paddresslist as _).ok() }
    }
    pub unsafe fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastMode)(windows_core::Interface::as_raw(self), ulmodemask).ok() }
    }
    pub unsafe fn GetMulticastMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMulticastMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_IPV4Filter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMulticastListSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub PutMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub GetMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub PutMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_IPV4Filter_Impl: windows_core::IUnknownImpl {
    fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()>;
    fn PutMulticastList(&self, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::Result<()>;
    fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()>;
    fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()>;
    fn GetMulticastMode(&self) -> windows_core::Result<u32>;
}
impl IBDA_IPV4Filter_Vtbl {
    pub const fn new<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMulticastListSize<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV4Filter_Impl::GetMulticastListSize(this, core::mem::transmute_copy(&pulcbaddresses)).into()
            }
        }
        unsafe extern "system" fn PutMulticastList<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV4Filter_Impl::PutMulticastList(this, core::mem::transmute_copy(&ulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn GetMulticastList<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV4Filter_Impl::GetMulticastList(this, core::mem::transmute_copy(&pulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn PutMulticastMode<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmodemask: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV4Filter_Impl::PutMulticastMode(this, core::mem::transmute_copy(&ulmodemask)).into()
            }
        }
        unsafe extern "system" fn GetMulticastMode<Identity: IBDA_IPV4Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulmodemask: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_IPV4Filter_Impl::GetMulticastMode(this) {
                    Ok(ok__) => {
                        pulmodemask.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Identity, OFFSET>,
            PutMulticastList: PutMulticastList::<Identity, OFFSET>,
            GetMulticastList: GetMulticastList::<Identity, OFFSET>,
            PutMulticastMode: PutMulticastMode::<Identity, OFFSET>,
            GetMulticastMode: GetMulticastMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_IPV4Filter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_IPV4Filter {}
windows_core::imp::define_interface!(IBDA_IPV6Filter, IBDA_IPV6Filter_Vtbl, 0xe1785a74_2a23_4fb3_9245_a8f88017ef33);
windows_core::imp::interface_hierarchy!(IBDA_IPV6Filter, windows_core::IUnknown);
impl IBDA_IPV6Filter {
    pub unsafe fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastListSize)(windows_core::Interface::as_raw(self), pulcbaddresses as _).ok() }
    }
    pub unsafe fn PutMulticastList(&self, paddresslist: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastList)(windows_core::Interface::as_raw(self), paddresslist.len().try_into().unwrap(), core::mem::transmute(paddresslist.as_ptr())).ok() }
    }
    pub unsafe fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMulticastList)(windows_core::Interface::as_raw(self), pulcbaddresses as _, paddresslist as _).ok() }
    }
    pub unsafe fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutMulticastMode)(windows_core::Interface::as_raw(self), ulmodemask).ok() }
    }
    pub unsafe fn GetMulticastMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMulticastMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_IPV6Filter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMulticastListSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub PutMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub GetMulticastList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub PutMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMulticastMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_IPV6Filter_Impl: windows_core::IUnknownImpl {
    fn GetMulticastListSize(&self, pulcbaddresses: *mut u32) -> windows_core::Result<()>;
    fn PutMulticastList(&self, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::Result<()>;
    fn GetMulticastList(&self, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::Result<()>;
    fn PutMulticastMode(&self, ulmodemask: u32) -> windows_core::Result<()>;
    fn GetMulticastMode(&self) -> windows_core::Result<u32>;
}
impl IBDA_IPV6Filter_Vtbl {
    pub const fn new<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMulticastListSize<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV6Filter_Impl::GetMulticastListSize(this, core::mem::transmute_copy(&pulcbaddresses)).into()
            }
        }
        unsafe extern "system" fn PutMulticastList<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcbaddresses: u32, paddresslist: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV6Filter_Impl::PutMulticastList(this, core::mem::transmute_copy(&ulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn GetMulticastList<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcbaddresses: *mut u32, paddresslist: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV6Filter_Impl::GetMulticastList(this, core::mem::transmute_copy(&pulcbaddresses), core::mem::transmute_copy(&paddresslist)).into()
            }
        }
        unsafe extern "system" fn PutMulticastMode<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmodemask: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_IPV6Filter_Impl::PutMulticastMode(this, core::mem::transmute_copy(&ulmodemask)).into()
            }
        }
        unsafe extern "system" fn GetMulticastMode<Identity: IBDA_IPV6Filter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulmodemask: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_IPV6Filter_Impl::GetMulticastMode(this) {
                    Ok(ok__) => {
                        pulmodemask.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMulticastListSize: GetMulticastListSize::<Identity, OFFSET>,
            PutMulticastList: PutMulticastList::<Identity, OFFSET>,
            GetMulticastList: GetMulticastList::<Identity, OFFSET>,
            PutMulticastMode: PutMulticastMode::<Identity, OFFSET>,
            GetMulticastMode: GetMulticastMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_IPV6Filter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_IPV6Filter {}
windows_core::imp::define_interface!(IBDA_ISDBConditionalAccess, IBDA_ISDBConditionalAccess_Vtbl, 0x5e68c627_16c2_4e6c_b1e2_d00170cdaa0f);
windows_core::imp::interface_hierarchy!(IBDA_ISDBConditionalAccess, windows_core::IUnknown);
impl IBDA_ISDBConditionalAccess {
    pub unsafe fn SetIsdbCasRequest(&self, ulrequestid: u32, pbrequestbuffer: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetIsdbCasRequest)(windows_core::Interface::as_raw(self), ulrequestid, pbrequestbuffer.len().try_into().unwrap(), core::mem::transmute(pbrequestbuffer.as_ptr())).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_ISDBConditionalAccess_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetIsdbCasRequest: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *const u8) -> windows_core::HRESULT,
}
pub trait IBDA_ISDBConditionalAccess_Impl: windows_core::IUnknownImpl {
    fn SetIsdbCasRequest(&self, ulrequestid: u32, ulcbrequestbufferlen: u32, pbrequestbuffer: *const u8) -> windows_core::Result<()>;
}
impl IBDA_ISDBConditionalAccess_Vtbl {
    pub const fn new<Identity: IBDA_ISDBConditionalAccess_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetIsdbCasRequest<Identity: IBDA_ISDBConditionalAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrequestid: u32, ulcbrequestbufferlen: u32, pbrequestbuffer: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_ISDBConditionalAccess_Impl::SetIsdbCasRequest(this, core::mem::transmute_copy(&ulrequestid), core::mem::transmute_copy(&ulcbrequestbufferlen), core::mem::transmute_copy(&pbrequestbuffer)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetIsdbCasRequest: SetIsdbCasRequest::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_ISDBConditionalAccess as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_ISDBConditionalAccess {}
windows_core::imp::define_interface!(IBDA_LNBInfo, IBDA_LNBInfo_Vtbl, 0x992cf102_49f9_4719_a664_c4f23e2408f4);
windows_core::imp::interface_hierarchy!(IBDA_LNBInfo, windows_core::IUnknown);
impl IBDA_LNBInfo {
    pub unsafe fn SetLocalOscilatorFrequencyLowBand(&self, ulloflow: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLocalOscilatorFrequencyLowBand)(windows_core::Interface::as_raw(self), ulloflow).ok() }
    }
    pub unsafe fn LocalOscilatorFrequencyLowBand(&self, pulloflow: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LocalOscilatorFrequencyLowBand)(windows_core::Interface::as_raw(self), pulloflow as _).ok() }
    }
    pub unsafe fn SetLocalOscilatorFrequencyHighBand(&self, ullofhigh: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLocalOscilatorFrequencyHighBand)(windows_core::Interface::as_raw(self), ullofhigh).ok() }
    }
    pub unsafe fn LocalOscilatorFrequencyHighBand(&self, pullofhigh: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LocalOscilatorFrequencyHighBand)(windows_core::Interface::as_raw(self), pullofhigh as _).ok() }
    }
    pub unsafe fn SetHighLowSwitchFrequency(&self, ulswitchfrequency: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetHighLowSwitchFrequency)(windows_core::Interface::as_raw(self), ulswitchfrequency).ok() }
    }
    pub unsafe fn HighLowSwitchFrequency(&self, pulswitchfrequency: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HighLowSwitchFrequency)(windows_core::Interface::as_raw(self), pulswitchfrequency as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_LNBInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetLocalOscilatorFrequencyLowBand: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub LocalOscilatorFrequencyLowBand: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetLocalOscilatorFrequencyHighBand: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub LocalOscilatorFrequencyHighBand: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetHighLowSwitchFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub HighLowSwitchFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_LNBInfo_Impl: windows_core::IUnknownImpl {
    fn SetLocalOscilatorFrequencyLowBand(&self, ulloflow: u32) -> windows_core::Result<()>;
    fn LocalOscilatorFrequencyLowBand(&self, pulloflow: *mut u32) -> windows_core::Result<()>;
    fn SetLocalOscilatorFrequencyHighBand(&self, ullofhigh: u32) -> windows_core::Result<()>;
    fn LocalOscilatorFrequencyHighBand(&self, pullofhigh: *mut u32) -> windows_core::Result<()>;
    fn SetHighLowSwitchFrequency(&self, ulswitchfrequency: u32) -> windows_core::Result<()>;
    fn HighLowSwitchFrequency(&self, pulswitchfrequency: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_LNBInfo_Vtbl {
    pub const fn new<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetLocalOscilatorFrequencyLowBand<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulloflow: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::SetLocalOscilatorFrequencyLowBand(this, core::mem::transmute_copy(&ulloflow)).into()
            }
        }
        unsafe extern "system" fn LocalOscilatorFrequencyLowBand<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulloflow: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::LocalOscilatorFrequencyLowBand(this, core::mem::transmute_copy(&pulloflow)).into()
            }
        }
        unsafe extern "system" fn SetLocalOscilatorFrequencyHighBand<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullofhigh: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::SetLocalOscilatorFrequencyHighBand(this, core::mem::transmute_copy(&ullofhigh)).into()
            }
        }
        unsafe extern "system" fn LocalOscilatorFrequencyHighBand<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pullofhigh: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::LocalOscilatorFrequencyHighBand(this, core::mem::transmute_copy(&pullofhigh)).into()
            }
        }
        unsafe extern "system" fn SetHighLowSwitchFrequency<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulswitchfrequency: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::SetHighLowSwitchFrequency(this, core::mem::transmute_copy(&ulswitchfrequency)).into()
            }
        }
        unsafe extern "system" fn HighLowSwitchFrequency<Identity: IBDA_LNBInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulswitchfrequency: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_LNBInfo_Impl::HighLowSwitchFrequency(this, core::mem::transmute_copy(&pulswitchfrequency)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetLocalOscilatorFrequencyLowBand: SetLocalOscilatorFrequencyLowBand::<Identity, OFFSET>,
            LocalOscilatorFrequencyLowBand: LocalOscilatorFrequencyLowBand::<Identity, OFFSET>,
            SetLocalOscilatorFrequencyHighBand: SetLocalOscilatorFrequencyHighBand::<Identity, OFFSET>,
            LocalOscilatorFrequencyHighBand: LocalOscilatorFrequencyHighBand::<Identity, OFFSET>,
            SetHighLowSwitchFrequency: SetHighLowSwitchFrequency::<Identity, OFFSET>,
            HighLowSwitchFrequency: HighLowSwitchFrequency::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_LNBInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_LNBInfo {}
windows_core::imp::define_interface!(IBDA_MUX, IBDA_MUX_Vtbl, 0x942aafec_4c05_4c74_b8eb_8706c2a4943f);
windows_core::imp::interface_hierarchy!(IBDA_MUX, windows_core::IUnknown);
impl IBDA_MUX {
    pub unsafe fn SetPidList(&self, pbpidlistbuffer: &[BDA_MUX_PIDLISTITEM]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPidList)(windows_core::Interface::as_raw(self), pbpidlistbuffer.len().try_into().unwrap(), core::mem::transmute(pbpidlistbuffer.as_ptr())).ok() }
    }
    pub unsafe fn GetPidList(&self, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPidList)(windows_core::Interface::as_raw(self), pulpidlistcount as _, pbpidlistbuffer as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_MUX_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetPidList: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const BDA_MUX_PIDLISTITEM) -> windows_core::HRESULT,
    pub GetPidList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut BDA_MUX_PIDLISTITEM) -> windows_core::HRESULT,
}
pub trait IBDA_MUX_Impl: windows_core::IUnknownImpl {
    fn SetPidList(&self, ulpidlistcount: u32, pbpidlistbuffer: *const BDA_MUX_PIDLISTITEM) -> windows_core::Result<()>;
    fn GetPidList(&self, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> windows_core::Result<()>;
}
impl IBDA_MUX_Vtbl {
    pub const fn new<Identity: IBDA_MUX_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetPidList<Identity: IBDA_MUX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpidlistcount: u32, pbpidlistbuffer: *const BDA_MUX_PIDLISTITEM) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_MUX_Impl::SetPidList(this, core::mem::transmute_copy(&ulpidlistcount), core::mem::transmute_copy(&pbpidlistbuffer)).into()
            }
        }
        unsafe extern "system" fn GetPidList<Identity: IBDA_MUX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulpidlistcount: *mut u32, pbpidlistbuffer: *mut BDA_MUX_PIDLISTITEM) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_MUX_Impl::GetPidList(this, core::mem::transmute_copy(&pulpidlistcount), core::mem::transmute_copy(&pbpidlistbuffer)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetPidList: SetPidList::<Identity, OFFSET>,
            GetPidList: GetPidList::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_MUX as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_MUX {}
windows_core::imp::define_interface!(IBDA_NameValueService, IBDA_NameValueService_Vtbl, 0x7f0b3150_7b81_4ad4_98e3_7e9097094301);
windows_core::imp::interface_hierarchy!(IBDA_NameValueService, windows_core::IUnknown);
impl IBDA_NameValueService {
    pub unsafe fn GetValueNameByIndex(&self, ulindex: u32) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetValueNameByIndex)(windows_core::Interface::as_raw(self), ulindex, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn GetValue(&self, bstrname: &windows_core::BSTR, bstrlanguage: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetValue)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(bstrname), core::mem::transmute_copy(bstrlanguage), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn SetValue(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, bstrname: &windows_core::BSTR, bstrvalue: &windows_core::BSTR, ulreserved: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetValue)(windows_core::Interface::as_raw(self), uldialogrequest, core::mem::transmute_copy(bstrlanguage), core::mem::transmute_copy(bstrname), core::mem::transmute_copy(bstrvalue), ulreserved).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_NameValueService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetValueNameByIndex: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetValue: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetValue: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IBDA_NameValueService_Impl: windows_core::IUnknownImpl {
    fn GetValueNameByIndex(&self, ulindex: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetValue(&self, bstrname: &windows_core::BSTR, bstrlanguage: &windows_core::BSTR) -> windows_core::Result<windows_core::BSTR>;
    fn SetValue(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, bstrname: &windows_core::BSTR, bstrvalue: &windows_core::BSTR, ulreserved: u32) -> windows_core::Result<()>;
}
impl IBDA_NameValueService_Vtbl {
    pub const fn new<Identity: IBDA_NameValueService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetValueNameByIndex<Identity: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulindex: u32, pbstrname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_NameValueService_Impl::GetValueNameByIndex(this, core::mem::transmute_copy(&ulindex)) {
                    Ok(ok__) => {
                        pbstrname.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetValue<Identity: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrname: *mut core::ffi::c_void, bstrlanguage: *mut core::ffi::c_void, pbstrvalue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_NameValueService_Impl::GetValue(this, core::mem::transmute(&bstrname), core::mem::transmute(&bstrlanguage)) {
                    Ok(ok__) => {
                        pbstrvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetValue<Identity: IBDA_NameValueService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldialogrequest: u32, bstrlanguage: *mut core::ffi::c_void, bstrname: *mut core::ffi::c_void, bstrvalue: *mut core::ffi::c_void, ulreserved: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NameValueService_Impl::SetValue(this, core::mem::transmute_copy(&uldialogrequest), core::mem::transmute(&bstrlanguage), core::mem::transmute(&bstrname), core::mem::transmute(&bstrvalue), core::mem::transmute_copy(&ulreserved)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetValueNameByIndex: GetValueNameByIndex::<Identity, OFFSET>,
            GetValue: GetValue::<Identity, OFFSET>,
            SetValue: SetValue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_NameValueService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_NameValueService {}
windows_core::imp::define_interface!(IBDA_NetworkProvider, IBDA_NetworkProvider_Vtbl, 0xfd501041_8ebe_11ce_8183_00aa00577da2);
windows_core::imp::interface_hierarchy!(IBDA_NetworkProvider, windows_core::IUnknown);
impl IBDA_NetworkProvider {
    pub unsafe fn PutSignalSource(&self, ulsignalsource: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutSignalSource)(windows_core::Interface::as_raw(self), ulsignalsource).ok() }
    }
    pub unsafe fn GetSignalSource(&self, pulsignalsource: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSignalSource)(windows_core::Interface::as_raw(self), pulsignalsource as _).ok() }
    }
    pub unsafe fn GetNetworkType(&self, pguidnetworktype: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNetworkType)(windows_core::Interface::as_raw(self), pguidnetworktype as _).ok() }
    }
    pub unsafe fn PutTuningSpace(&self, guidtuningspace: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutTuningSpace)(windows_core::Interface::as_raw(self), guidtuningspace).ok() }
    }
    pub unsafe fn GetTuningSpace(&self, pguidtuingspace: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTuningSpace)(windows_core::Interface::as_raw(self), pguidtuingspace as _).ok() }
    }
    pub unsafe fn RegisterDeviceFilter<P0>(&self, punkfiltercontrol: P0, ppvregisitrationcontext: *mut u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterDeviceFilter)(windows_core::Interface::as_raw(self), punkfiltercontrol.param().abi(), ppvregisitrationcontext as _).ok() }
    }
    pub unsafe fn UnRegisterDeviceFilter(&self, pvregistrationcontext: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnRegisterDeviceFilter)(windows_core::Interface::as_raw(self), pvregistrationcontext).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_NetworkProvider_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub PutSignalSource: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetSignalSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetNetworkType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub PutTuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetTuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub RegisterDeviceFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub UnRegisterDeviceFilter: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IBDA_NetworkProvider_Impl: windows_core::IUnknownImpl {
    fn PutSignalSource(&self, ulsignalsource: u32) -> windows_core::Result<()>;
    fn GetSignalSource(&self, pulsignalsource: *mut u32) -> windows_core::Result<()>;
    fn GetNetworkType(&self, pguidnetworktype: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn PutTuningSpace(&self, guidtuningspace: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetTuningSpace(&self, pguidtuingspace: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn RegisterDeviceFilter(&self, punkfiltercontrol: windows_core::Ref<windows_core::IUnknown>, ppvregisitrationcontext: *mut u32) -> windows_core::Result<()>;
    fn UnRegisterDeviceFilter(&self, pvregistrationcontext: u32) -> windows_core::Result<()>;
}
impl IBDA_NetworkProvider_Vtbl {
    pub const fn new<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PutSignalSource<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulsignalsource: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::PutSignalSource(this, core::mem::transmute_copy(&ulsignalsource)).into()
            }
        }
        unsafe extern "system" fn GetSignalSource<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulsignalsource: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::GetSignalSource(this, core::mem::transmute_copy(&pulsignalsource)).into()
            }
        }
        unsafe extern "system" fn GetNetworkType<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidnetworktype: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::GetNetworkType(this, core::mem::transmute_copy(&pguidnetworktype)).into()
            }
        }
        unsafe extern "system" fn PutTuningSpace<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidtuningspace: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::PutTuningSpace(this, core::mem::transmute_copy(&guidtuningspace)).into()
            }
        }
        unsafe extern "system" fn GetTuningSpace<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtuingspace: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::GetTuningSpace(this, core::mem::transmute_copy(&pguidtuingspace)).into()
            }
        }
        unsafe extern "system" fn RegisterDeviceFilter<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkfiltercontrol: *mut core::ffi::c_void, ppvregisitrationcontext: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::RegisterDeviceFilter(this, core::mem::transmute_copy(&punkfiltercontrol), core::mem::transmute_copy(&ppvregisitrationcontext)).into()
            }
        }
        unsafe extern "system" fn UnRegisterDeviceFilter<Identity: IBDA_NetworkProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvregistrationcontext: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NetworkProvider_Impl::UnRegisterDeviceFilter(this, core::mem::transmute_copy(&pvregistrationcontext)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            PutSignalSource: PutSignalSource::<Identity, OFFSET>,
            GetSignalSource: GetSignalSource::<Identity, OFFSET>,
            GetNetworkType: GetNetworkType::<Identity, OFFSET>,
            PutTuningSpace: PutTuningSpace::<Identity, OFFSET>,
            GetTuningSpace: GetTuningSpace::<Identity, OFFSET>,
            RegisterDeviceFilter: RegisterDeviceFilter::<Identity, OFFSET>,
            UnRegisterDeviceFilter: UnRegisterDeviceFilter::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_NetworkProvider as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_NetworkProvider {}
windows_core::imp::define_interface!(IBDA_NullTransform, IBDA_NullTransform_Vtbl, 0xddf15b0d_bd25_11d2_9ca0_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_NullTransform, windows_core::IUnknown);
impl IBDA_NullTransform {
    pub unsafe fn Start(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Start)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_NullTransform_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Start: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_NullTransform_Impl: windows_core::IUnknownImpl {
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
}
impl IBDA_NullTransform_Vtbl {
    pub const fn new<Identity: IBDA_NullTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Start<Identity: IBDA_NullTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NullTransform_Impl::Start(this).into()
            }
        }
        unsafe extern "system" fn Stop<Identity: IBDA_NullTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_NullTransform_Impl::Stop(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Start: Start::<Identity, OFFSET>, Stop: Stop::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_NullTransform as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_NullTransform {}
windows_core::imp::define_interface!(IBDA_PinControl, IBDA_PinControl_Vtbl, 0x0ded49d5_a8b7_4d5d_97a1_12b0c195874d);
windows_core::imp::interface_hierarchy!(IBDA_PinControl, windows_core::IUnknown);
impl IBDA_PinControl {
    pub unsafe fn GetPinID(&self, pulpinid: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPinID)(windows_core::Interface::as_raw(self), pulpinid as _).ok() }
    }
    pub unsafe fn GetPinType(&self, pulpintype: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPinType)(windows_core::Interface::as_raw(self), pulpintype as _).ok() }
    }
    pub unsafe fn RegistrationContext(&self, pulregistrationctx: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RegistrationContext)(windows_core::Interface::as_raw(self), pulregistrationctx as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_PinControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetPinID: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetPinType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub RegistrationContext: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_PinControl_Impl: windows_core::IUnknownImpl {
    fn GetPinID(&self, pulpinid: *mut u32) -> windows_core::Result<()>;
    fn GetPinType(&self, pulpintype: *mut u32) -> windows_core::Result<()>;
    fn RegistrationContext(&self, pulregistrationctx: *mut u32) -> windows_core::Result<()>;
}
impl IBDA_PinControl_Vtbl {
    pub const fn new<Identity: IBDA_PinControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPinID<Identity: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulpinid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_PinControl_Impl::GetPinID(this, core::mem::transmute_copy(&pulpinid)).into()
            }
        }
        unsafe extern "system" fn GetPinType<Identity: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulpintype: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_PinControl_Impl::GetPinType(this, core::mem::transmute_copy(&pulpintype)).into()
            }
        }
        unsafe extern "system" fn RegistrationContext<Identity: IBDA_PinControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulregistrationctx: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_PinControl_Impl::RegistrationContext(this, core::mem::transmute_copy(&pulregistrationctx)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPinID: GetPinID::<Identity, OFFSET>,
            GetPinType: GetPinType::<Identity, OFFSET>,
            RegistrationContext: RegistrationContext::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_PinControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_PinControl {}
windows_core::imp::define_interface!(IBDA_SignalProperties, IBDA_SignalProperties_Vtbl, 0xd2f1644b_b409_11d2_bc69_00a0c9ee9e16);
windows_core::imp::interface_hierarchy!(IBDA_SignalProperties, windows_core::IUnknown);
impl IBDA_SignalProperties {
    pub unsafe fn PutNetworkType(&self, guidnetworktype: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutNetworkType)(windows_core::Interface::as_raw(self), guidnetworktype).ok() }
    }
    pub unsafe fn GetNetworkType(&self, pguidnetworktype: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNetworkType)(windows_core::Interface::as_raw(self), pguidnetworktype as _).ok() }
    }
    pub unsafe fn PutSignalSource(&self, ulsignalsource: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutSignalSource)(windows_core::Interface::as_raw(self), ulsignalsource).ok() }
    }
    pub unsafe fn GetSignalSource(&self, pulsignalsource: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSignalSource)(windows_core::Interface::as_raw(self), pulsignalsource as _).ok() }
    }
    pub unsafe fn PutTuningSpace(&self, guidtuningspace: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PutTuningSpace)(windows_core::Interface::as_raw(self), guidtuningspace).ok() }
    }
    pub unsafe fn GetTuningSpace(&self, pguidtuingspace: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTuningSpace)(windows_core::Interface::as_raw(self), pguidtuingspace as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_SignalProperties_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub PutNetworkType: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetNetworkType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub PutSignalSource: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetSignalSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub PutTuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetTuningSpace: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IBDA_SignalProperties_Impl: windows_core::IUnknownImpl {
    fn PutNetworkType(&self, guidnetworktype: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetNetworkType(&self, pguidnetworktype: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn PutSignalSource(&self, ulsignalsource: u32) -> windows_core::Result<()>;
    fn GetSignalSource(&self, pulsignalsource: *mut u32) -> windows_core::Result<()>;
    fn PutTuningSpace(&self, guidtuningspace: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetTuningSpace(&self, pguidtuingspace: *mut windows_core::GUID) -> windows_core::Result<()>;
}
impl IBDA_SignalProperties_Vtbl {
    pub const fn new<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PutNetworkType<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidnetworktype: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::PutNetworkType(this, core::mem::transmute_copy(&guidnetworktype)).into()
            }
        }
        unsafe extern "system" fn GetNetworkType<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidnetworktype: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::GetNetworkType(this, core::mem::transmute_copy(&pguidnetworktype)).into()
            }
        }
        unsafe extern "system" fn PutSignalSource<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulsignalsource: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::PutSignalSource(this, core::mem::transmute_copy(&ulsignalsource)).into()
            }
        }
        unsafe extern "system" fn GetSignalSource<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulsignalsource: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::GetSignalSource(this, core::mem::transmute_copy(&pulsignalsource)).into()
            }
        }
        unsafe extern "system" fn PutTuningSpace<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidtuningspace: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::PutTuningSpace(this, core::mem::transmute_copy(&guidtuningspace)).into()
            }
        }
        unsafe extern "system" fn GetTuningSpace<Identity: IBDA_SignalProperties_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtuingspace: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalProperties_Impl::GetTuningSpace(this, core::mem::transmute_copy(&pguidtuingspace)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            PutNetworkType: PutNetworkType::<Identity, OFFSET>,
            GetNetworkType: GetNetworkType::<Identity, OFFSET>,
            PutSignalSource: PutSignalSource::<Identity, OFFSET>,
            GetSignalSource: GetSignalSource::<Identity, OFFSET>,
            PutTuningSpace: PutTuningSpace::<Identity, OFFSET>,
            GetTuningSpace: GetTuningSpace::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_SignalProperties as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_SignalProperties {}
windows_core::imp::define_interface!(IBDA_SignalStatistics, IBDA_SignalStatistics_Vtbl, 0x1347d106_cf3a_428a_a5cb_ac0d9a2a4338);
windows_core::imp::interface_hierarchy!(IBDA_SignalStatistics, windows_core::IUnknown);
impl IBDA_SignalStatistics {
    pub unsafe fn SetSignalStrength(&self, ldbstrength: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSignalStrength)(windows_core::Interface::as_raw(self), ldbstrength).ok() }
    }
    pub unsafe fn SignalStrength(&self, pldbstrength: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SignalStrength)(windows_core::Interface::as_raw(self), pldbstrength as _).ok() }
    }
    pub unsafe fn SetSignalQuality(&self, lpercentquality: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSignalQuality)(windows_core::Interface::as_raw(self), lpercentquality).ok() }
    }
    pub unsafe fn SignalQuality(&self, plpercentquality: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SignalQuality)(windows_core::Interface::as_raw(self), plpercentquality as _).ok() }
    }
    pub unsafe fn SetSignalPresent(&self, fpresent: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSignalPresent)(windows_core::Interface::as_raw(self), fpresent).ok() }
    }
    pub unsafe fn SignalPresent(&self, pfpresent: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SignalPresent)(windows_core::Interface::as_raw(self), pfpresent as _).ok() }
    }
    pub unsafe fn SetSignalLocked(&self, flocked: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSignalLocked)(windows_core::Interface::as_raw(self), flocked).ok() }
    }
    pub unsafe fn SignalLocked(&self, pflocked: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SignalLocked)(windows_core::Interface::as_raw(self), pflocked as _).ok() }
    }
    pub unsafe fn SetSampleTime(&self, lmssampletime: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSampleTime)(windows_core::Interface::as_raw(self), lmssampletime).ok() }
    }
    pub unsafe fn SampleTime(&self, plmssampletime: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SampleTime)(windows_core::Interface::as_raw(self), plmssampletime as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_SignalStatistics_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetSignalStrength: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SignalStrength: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSignalQuality: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SignalQuality: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSignalPresent: unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub SignalPresent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u8) -> windows_core::HRESULT,
    pub SetSignalLocked: unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub SignalLocked: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u8) -> windows_core::HRESULT,
    pub SetSampleTime: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SampleTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IBDA_SignalStatistics_Impl: windows_core::IUnknownImpl {
    fn SetSignalStrength(&self, ldbstrength: i32) -> windows_core::Result<()>;
    fn SignalStrength(&self, pldbstrength: *mut i32) -> windows_core::Result<()>;
    fn SetSignalQuality(&self, lpercentquality: i32) -> windows_core::Result<()>;
    fn SignalQuality(&self, plpercentquality: *mut i32) -> windows_core::Result<()>;
    fn SetSignalPresent(&self, fpresent: bool) -> windows_core::Result<()>;
    fn SignalPresent(&self, pfpresent: *mut u8) -> windows_core::Result<()>;
    fn SetSignalLocked(&self, flocked: bool) -> windows_core::Result<()>;
    fn SignalLocked(&self, pflocked: *mut u8) -> windows_core::Result<()>;
    fn SetSampleTime(&self, lmssampletime: i32) -> windows_core::Result<()>;
    fn SampleTime(&self, plmssampletime: *mut i32) -> windows_core::Result<()>;
}
impl IBDA_SignalStatistics_Vtbl {
    pub const fn new<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetSignalStrength<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ldbstrength: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SetSignalStrength(this, core::mem::transmute_copy(&ldbstrength)).into()
            }
        }
        unsafe extern "system" fn SignalStrength<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pldbstrength: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SignalStrength(this, core::mem::transmute_copy(&pldbstrength)).into()
            }
        }
        unsafe extern "system" fn SetSignalQuality<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpercentquality: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SetSignalQuality(this, core::mem::transmute_copy(&lpercentquality)).into()
            }
        }
        unsafe extern "system" fn SignalQuality<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plpercentquality: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SignalQuality(this, core::mem::transmute_copy(&plpercentquality)).into()
            }
        }
        unsafe extern "system" fn SetSignalPresent<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fpresent: bool) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SetSignalPresent(this, core::mem::transmute_copy(&fpresent)).into()
            }
        }
        unsafe extern "system" fn SignalPresent<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfpresent: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SignalPresent(this, core::mem::transmute_copy(&pfpresent)).into()
            }
        }
        unsafe extern "system" fn SetSignalLocked<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flocked: bool) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SetSignalLocked(this, core::mem::transmute_copy(&flocked)).into()
            }
        }
        unsafe extern "system" fn SignalLocked<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflocked: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SignalLocked(this, core::mem::transmute_copy(&pflocked)).into()
            }
        }
        unsafe extern "system" fn SetSampleTime<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lmssampletime: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SetSampleTime(this, core::mem::transmute_copy(&lmssampletime)).into()
            }
        }
        unsafe extern "system" fn SampleTime<Identity: IBDA_SignalStatistics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plmssampletime: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_SignalStatistics_Impl::SampleTime(this, core::mem::transmute_copy(&plmssampletime)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetSignalStrength: SetSignalStrength::<Identity, OFFSET>,
            SignalStrength: SignalStrength::<Identity, OFFSET>,
            SetSignalQuality: SetSignalQuality::<Identity, OFFSET>,
            SignalQuality: SignalQuality::<Identity, OFFSET>,
            SetSignalPresent: SetSignalPresent::<Identity, OFFSET>,
            SignalPresent: SignalPresent::<Identity, OFFSET>,
            SetSignalLocked: SetSignalLocked::<Identity, OFFSET>,
            SignalLocked: SignalLocked::<Identity, OFFSET>,
            SetSampleTime: SetSampleTime::<Identity, OFFSET>,
            SampleTime: SampleTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_SignalStatistics as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_SignalStatistics {}
windows_core::imp::define_interface!(IBDA_Topology, IBDA_Topology_Vtbl, 0x79b56888_7fea_4690_b45d_38fd3c7849be);
windows_core::imp::interface_hierarchy!(IBDA_Topology, windows_core::IUnknown);
impl IBDA_Topology {
    pub unsafe fn GetNodeTypes(&self, pulcnodetypes: *mut u32, rgulnodetypes: &mut [u32]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNodeTypes)(windows_core::Interface::as_raw(self), pulcnodetypes as _, rgulnodetypes.len().try_into().unwrap(), core::mem::transmute(rgulnodetypes.as_ptr())).ok() }
    }
    pub unsafe fn GetNodeDescriptors(&self, ulcnodedescriptors: *mut u32, rgnodedescriptors: &mut [BDANODE_DESCRIPTOR]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNodeDescriptors)(windows_core::Interface::as_raw(self), ulcnodedescriptors as _, rgnodedescriptors.len().try_into().unwrap(), core::mem::transmute(rgnodedescriptors.as_ptr())).ok() }
    }
    pub unsafe fn GetNodeInterfaces(&self, ulnodetype: u32, pulcinterfaces: *mut u32, rgguidinterfaces: &mut [windows_core::GUID]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNodeInterfaces)(windows_core::Interface::as_raw(self), ulnodetype, pulcinterfaces as _, rgguidinterfaces.len().try_into().unwrap(), core::mem::transmute(rgguidinterfaces.as_ptr())).ok() }
    }
    pub unsafe fn GetPinTypes(&self, pulcpintypes: *mut u32, rgulpintypes: &mut [u32]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPinTypes)(windows_core::Interface::as_raw(self), pulcpintypes as _, rgulpintypes.len().try_into().unwrap(), core::mem::transmute(rgulpintypes.as_ptr())).ok() }
    }
    pub unsafe fn GetTemplateConnections(&self, pulcconnections: *mut u32, rgconnections: &mut [BDA_TEMPLATE_CONNECTION]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTemplateConnections)(windows_core::Interface::as_raw(self), pulcconnections as _, rgconnections.len().try_into().unwrap(), core::mem::transmute(rgconnections.as_ptr())).ok() }
    }
    pub unsafe fn CreatePin(&self, ulpintype: u32, pulpinid: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CreatePin)(windows_core::Interface::as_raw(self), ulpintype, pulpinid as _).ok() }
    }
    pub unsafe fn DeletePin(&self, ulpinid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DeletePin)(windows_core::Interface::as_raw(self), ulpinid).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetMediaType(&self, ulpinid: u32, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaType)(windows_core::Interface::as_raw(self), ulpinid, core::mem::transmute(pmediatype)).ok() }
    }
    pub unsafe fn SetMedium(&self, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMedium)(windows_core::Interface::as_raw(self), ulpinid, pmedium).ok() }
    }
    pub unsafe fn CreateTopology(&self, ulinputpinid: u32, uloutputpinid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CreateTopology)(windows_core::Interface::as_raw(self), ulinputpinid, uloutputpinid).ok() }
    }
    pub unsafe fn GetControlNode(&self, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetControlNode)(windows_core::Interface::as_raw(self), ulinputpinid, uloutputpinid, ulnodetype, core::mem::transmute(ppcontrolnode)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_Topology_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNodeTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut u32) -> windows_core::HRESULT,
    pub GetNodeDescriptors: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut BDANODE_DESCRIPTOR) -> windows_core::HRESULT,
    pub GetNodeInterfaces: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetPinTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut u32) -> windows_core::HRESULT,
    pub GetTemplateConnections: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut BDA_TEMPLATE_CONNECTION) -> windows_core::HRESULT,
    pub CreatePin: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub DeletePin: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetMediaType: usize,
    pub SetMedium: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const REGPINMEDIUM) -> windows_core::HRESULT,
    pub CreateTopology: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub GetControlNode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IBDA_Topology_Impl: windows_core::IUnknownImpl {
    fn GetNodeTypes(&self, pulcnodetypes: *mut u32, ulcnodetypesmax: u32, rgulnodetypes: *mut u32) -> windows_core::Result<()>;
    fn GetNodeDescriptors(&self, ulcnodedescriptors: *mut u32, ulcnodedescriptorsmax: u32, rgnodedescriptors: *mut BDANODE_DESCRIPTOR) -> windows_core::Result<()>;
    fn GetNodeInterfaces(&self, ulnodetype: u32, pulcinterfaces: *mut u32, ulcinterfacesmax: u32, rgguidinterfaces: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetPinTypes(&self, pulcpintypes: *mut u32, ulcpintypesmax: u32, rgulpintypes: *mut u32) -> windows_core::Result<()>;
    fn GetTemplateConnections(&self, pulcconnections: *mut u32, ulcconnectionsmax: u32, rgconnections: *mut BDA_TEMPLATE_CONNECTION) -> windows_core::Result<()>;
    fn CreatePin(&self, ulpintype: u32, pulpinid: *mut u32) -> windows_core::Result<()>;
    fn DeletePin(&self, ulpinid: u32) -> windows_core::Result<()>;
    fn SetMediaType(&self, ulpinid: u32, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn SetMedium(&self, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> windows_core::Result<()>;
    fn CreateTopology(&self, ulinputpinid: u32, uloutputpinid: u32) -> windows_core::Result<()>;
    fn GetControlNode(&self, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: windows_core::OutRef<windows_core::IUnknown>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IBDA_Topology_Vtbl {
    pub const fn new<Identity: IBDA_Topology_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNodeTypes<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcnodetypes: *mut u32, ulcnodetypesmax: u32, rgulnodetypes: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetNodeTypes(this, core::mem::transmute_copy(&pulcnodetypes), core::mem::transmute_copy(&ulcnodetypesmax), core::mem::transmute_copy(&rgulnodetypes)).into()
            }
        }
        unsafe extern "system" fn GetNodeDescriptors<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcnodedescriptors: *mut u32, ulcnodedescriptorsmax: u32, rgnodedescriptors: *mut BDANODE_DESCRIPTOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetNodeDescriptors(this, core::mem::transmute_copy(&ulcnodedescriptors), core::mem::transmute_copy(&ulcnodedescriptorsmax), core::mem::transmute_copy(&rgnodedescriptors)).into()
            }
        }
        unsafe extern "system" fn GetNodeInterfaces<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulnodetype: u32, pulcinterfaces: *mut u32, ulcinterfacesmax: u32, rgguidinterfaces: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetNodeInterfaces(this, core::mem::transmute_copy(&ulnodetype), core::mem::transmute_copy(&pulcinterfaces), core::mem::transmute_copy(&ulcinterfacesmax), core::mem::transmute_copy(&rgguidinterfaces)).into()
            }
        }
        unsafe extern "system" fn GetPinTypes<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcpintypes: *mut u32, ulcpintypesmax: u32, rgulpintypes: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetPinTypes(this, core::mem::transmute_copy(&pulcpintypes), core::mem::transmute_copy(&ulcpintypesmax), core::mem::transmute_copy(&rgulpintypes)).into()
            }
        }
        unsafe extern "system" fn GetTemplateConnections<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcconnections: *mut u32, ulcconnectionsmax: u32, rgconnections: *mut BDA_TEMPLATE_CONNECTION) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetTemplateConnections(this, core::mem::transmute_copy(&pulcconnections), core::mem::transmute_copy(&ulcconnectionsmax), core::mem::transmute_copy(&rgconnections)).into()
            }
        }
        unsafe extern "system" fn CreatePin<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpintype: u32, pulpinid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::CreatePin(this, core::mem::transmute_copy(&ulpintype), core::mem::transmute_copy(&pulpinid)).into()
            }
        }
        unsafe extern "system" fn DeletePin<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpinid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::DeletePin(this, core::mem::transmute_copy(&ulpinid)).into()
            }
        }
        unsafe extern "system" fn SetMediaType<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpinid: u32, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::SetMediaType(this, core::mem::transmute_copy(&ulpinid), core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn SetMedium<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpinid: u32, pmedium: *const REGPINMEDIUM) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::SetMedium(this, core::mem::transmute_copy(&ulpinid), core::mem::transmute_copy(&pmedium)).into()
            }
        }
        unsafe extern "system" fn CreateTopology<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::CreateTopology(this, core::mem::transmute_copy(&ulinputpinid), core::mem::transmute_copy(&uloutputpinid)).into()
            }
        }
        unsafe extern "system" fn GetControlNode<Identity: IBDA_Topology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulinputpinid: u32, uloutputpinid: u32, ulnodetype: u32, ppcontrolnode: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_Topology_Impl::GetControlNode(this, core::mem::transmute_copy(&ulinputpinid), core::mem::transmute_copy(&uloutputpinid), core::mem::transmute_copy(&ulnodetype), core::mem::transmute_copy(&ppcontrolnode)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNodeTypes: GetNodeTypes::<Identity, OFFSET>,
            GetNodeDescriptors: GetNodeDescriptors::<Identity, OFFSET>,
            GetNodeInterfaces: GetNodeInterfaces::<Identity, OFFSET>,
            GetPinTypes: GetPinTypes::<Identity, OFFSET>,
            GetTemplateConnections: GetTemplateConnections::<Identity, OFFSET>,
            CreatePin: CreatePin::<Identity, OFFSET>,
            DeletePin: DeletePin::<Identity, OFFSET>,
            SetMediaType: SetMediaType::<Identity, OFFSET>,
            SetMedium: SetMedium::<Identity, OFFSET>,
            CreateTopology: CreateTopology::<Identity, OFFSET>,
            GetControlNode: GetControlNode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_Topology as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IBDA_Topology {}
windows_core::imp::define_interface!(IBDA_TransportStreamInfo, IBDA_TransportStreamInfo_Vtbl, 0x8e882535_5f86_47ab_86cf_c281a72a0549);
windows_core::imp::interface_hierarchy!(IBDA_TransportStreamInfo, windows_core::IUnknown);
impl IBDA_TransportStreamInfo {
    pub unsafe fn PatTableTickCount(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PatTableTickCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_TransportStreamInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub PatTableTickCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IBDA_TransportStreamInfo_Impl: windows_core::IUnknownImpl {
    fn PatTableTickCount(&self) -> windows_core::Result<u32>;
}
impl IBDA_TransportStreamInfo_Vtbl {
    pub const fn new<Identity: IBDA_TransportStreamInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PatTableTickCount<Identity: IBDA_TransportStreamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattickcount: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_TransportStreamInfo_Impl::PatTableTickCount(this) {
                    Ok(ok__) => {
                        ppattickcount.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), PatTableTickCount: PatTableTickCount::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_TransportStreamInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_TransportStreamInfo {}
windows_core::imp::define_interface!(IBDA_TransportStreamSelector, IBDA_TransportStreamSelector_Vtbl, 0x1dcfafe9_b45e_41b3_bb2a_561eb129ae98);
windows_core::imp::interface_hierarchy!(IBDA_TransportStreamSelector, windows_core::IUnknown);
impl IBDA_TransportStreamSelector {
    pub unsafe fn SetTSID(&self, ustsid: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTSID)(windows_core::Interface::as_raw(self), ustsid).ok() }
    }
    pub unsafe fn GetTSInformation(&self, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTSInformation)(windows_core::Interface::as_raw(self), pultsinformationbufferlen as _, pbtsinformationbuffer as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_TransportStreamSelector_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetTSID: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub GetTSInformation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_TransportStreamSelector_Impl: windows_core::IUnknownImpl {
    fn SetTSID(&self, ustsid: u16) -> windows_core::Result<()>;
    fn GetTSInformation(&self, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> windows_core::Result<()>;
}
impl IBDA_TransportStreamSelector_Vtbl {
    pub const fn new<Identity: IBDA_TransportStreamSelector_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetTSID<Identity: IBDA_TransportStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ustsid: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_TransportStreamSelector_Impl::SetTSID(this, core::mem::transmute_copy(&ustsid)).into()
            }
        }
        unsafe extern "system" fn GetTSInformation<Identity: IBDA_TransportStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pultsinformationbufferlen: *mut u32, pbtsinformationbuffer: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_TransportStreamSelector_Impl::GetTSInformation(this, core::mem::transmute_copy(&pultsinformationbufferlen), core::mem::transmute_copy(&pbtsinformationbuffer)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetTSID: SetTSID::<Identity, OFFSET>,
            GetTSInformation: GetTSInformation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_TransportStreamSelector as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_TransportStreamSelector {}
windows_core::imp::define_interface!(IBDA_UserActivityService, IBDA_UserActivityService_Vtbl, 0x53b14189_e478_4b7a_a1ff_506db4b99dfe);
windows_core::imp::interface_hierarchy!(IBDA_UserActivityService, windows_core::IUnknown);
impl IBDA_UserActivityService {
    pub unsafe fn SetCurrentTunerUseReason(&self, dwusereason: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCurrentTunerUseReason)(windows_core::Interface::as_raw(self), dwusereason).ok() }
    }
    pub unsafe fn GetUserActivityInterval(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetUserActivityInterval)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn UserActivityDetected(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UserActivityDetected)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_UserActivityService_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetCurrentTunerUseReason: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetUserActivityInterval: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub UserActivityDetected: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_UserActivityService_Impl: windows_core::IUnknownImpl {
    fn SetCurrentTunerUseReason(&self, dwusereason: u32) -> windows_core::Result<()>;
    fn GetUserActivityInterval(&self) -> windows_core::Result<u32>;
    fn UserActivityDetected(&self) -> windows_core::Result<()>;
}
impl IBDA_UserActivityService_Vtbl {
    pub const fn new<Identity: IBDA_UserActivityService_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetCurrentTunerUseReason<Identity: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwusereason: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_UserActivityService_Impl::SetCurrentTunerUseReason(this, core::mem::transmute_copy(&dwusereason)).into()
            }
        }
        unsafe extern "system" fn GetUserActivityInterval<Identity: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwactivityinterval: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_UserActivityService_Impl::GetUserActivityInterval(this) {
                    Ok(ok__) => {
                        pdwactivityinterval.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn UserActivityDetected<Identity: IBDA_UserActivityService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_UserActivityService_Impl::UserActivityDetected(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetCurrentTunerUseReason: SetCurrentTunerUseReason::<Identity, OFFSET>,
            GetUserActivityInterval: GetUserActivityInterval::<Identity, OFFSET>,
            UserActivityDetected: UserActivityDetected::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_UserActivityService as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_UserActivityService {}
windows_core::imp::define_interface!(IBDA_VoidTransform, IBDA_VoidTransform_Vtbl, 0x71985f46_1ca1_11d3_9cc8_00c04f7971e0);
windows_core::imp::interface_hierarchy!(IBDA_VoidTransform, windows_core::IUnknown);
impl IBDA_VoidTransform {
    pub unsafe fn Start(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Start)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_VoidTransform_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Start: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBDA_VoidTransform_Impl: windows_core::IUnknownImpl {
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
}
impl IBDA_VoidTransform_Vtbl {
    pub const fn new<Identity: IBDA_VoidTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Start<Identity: IBDA_VoidTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_VoidTransform_Impl::Start(this).into()
            }
        }
        unsafe extern "system" fn Stop<Identity: IBDA_VoidTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_VoidTransform_Impl::Stop(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Start: Start::<Identity, OFFSET>, Stop: Stop::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_VoidTransform as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_VoidTransform {}
windows_core::imp::define_interface!(IBDA_WMDRMSession, IBDA_WMDRMSession_Vtbl, 0x4be6fa3d_07cd_4139_8b80_8c18ba3aec88);
windows_core::imp::interface_hierarchy!(IBDA_WMDRMSession, windows_core::IUnknown);
impl IBDA_WMDRMSession {
    pub unsafe fn GetStatus(&self, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStatus)(windows_core::Interface::as_raw(self), maxcapturetoken as _, maxstreamingpid as _, maxlicense as _, minsecuritylevel as _, revinfosequencenumber as _, revinfoissuedtime as _, revinfottl as _, revlistversion as _, ulstate as _).ok() }
    }
    pub unsafe fn SetRevInfo(&self, pbrevinfo: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRevInfo)(windows_core::Interface::as_raw(self), pbrevinfo.len().try_into().unwrap(), core::mem::transmute(pbrevinfo.as_ptr())).ok() }
    }
    pub unsafe fn SetCrl(&self, pbcrllen: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCrl)(windows_core::Interface::as_raw(self), pbcrllen.len().try_into().unwrap(), core::mem::transmute(pbcrllen.as_ptr())).ok() }
    }
    pub unsafe fn TransactMessage(&self, pbrequest: &[u8], pulcbresponse: *mut u32, pbresponse: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TransactMessage)(windows_core::Interface::as_raw(self), pbrequest.len().try_into().unwrap(), core::mem::transmute(pbrequest.as_ptr()), pulcbresponse as _, pbresponse as _).ok() }
    }
    pub unsafe fn GetLicense(&self, uuidkey: *const windows_core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetLicense)(windows_core::Interface::as_raw(self), uuidkey, pulpackagelen as _, pbpackage as _).ok() }
    }
    pub unsafe fn ReissueLicense(&self, uuidkey: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReissueLicense)(windows_core::Interface::as_raw(self), uuidkey).ok() }
    }
    pub unsafe fn RenewLicense(&self, pbinxmrlicense: &[u8], pbentitlementtoken: &[u8], puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RenewLicense)(windows_core::Interface::as_raw(self), pbinxmrlicense.len().try_into().unwrap(), core::mem::transmute(pbinxmrlicense.as_ptr()), pbentitlementtoken.len().try_into().unwrap(), core::mem::transmute(pbentitlementtoken.as_ptr()), puldescramblestatus as _, puloutxmrlicenselen as _, pboutxmrlicense as _).ok() }
    }
    pub unsafe fn GetKeyInfo(&self, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetKeyInfo)(windows_core::Interface::as_raw(self), pulkeyinfolen as _, pbkeyinfo as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_WMDRMSession_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32, *mut u32, *mut u32, *mut u64, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub SetRevInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub SetCrl: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub TransactMessage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub GetLicense: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub ReissueLicense: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub RenewLicense: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, u32, *const u8, *mut u32, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub GetKeyInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_WMDRMSession_Impl: windows_core::IUnknownImpl {
    fn GetStatus(&self, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> windows_core::Result<()>;
    fn SetRevInfo(&self, ulrevinfolen: u32, pbrevinfo: *const u8) -> windows_core::Result<()>;
    fn SetCrl(&self, ulcrllen: u32, pbcrllen: *const u8) -> windows_core::Result<()>;
    fn TransactMessage(&self, ulcbrequest: u32, pbrequest: *const u8, pulcbresponse: *mut u32, pbresponse: *mut u8) -> windows_core::Result<()>;
    fn GetLicense(&self, uuidkey: *const windows_core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> windows_core::Result<()>;
    fn ReissueLicense(&self, uuidkey: *const windows_core::GUID) -> windows_core::Result<()>;
    fn RenewLicense(&self, ulinxmrlicenselen: u32, pbinxmrlicense: *const u8, ulentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> windows_core::Result<()>;
    fn GetKeyInfo(&self, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> windows_core::Result<()>;
}
impl IBDA_WMDRMSession_Vtbl {
    pub const fn new<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetStatus<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, maxcapturetoken: *mut u32, maxstreamingpid: *mut u32, maxlicense: *mut u32, minsecuritylevel: *mut u32, revinfosequencenumber: *mut u32, revinfoissuedtime: *mut u64, revinfottl: *mut u32, revlistversion: *mut u32, ulstate: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::GetStatus(this, core::mem::transmute_copy(&maxcapturetoken), core::mem::transmute_copy(&maxstreamingpid), core::mem::transmute_copy(&maxlicense), core::mem::transmute_copy(&minsecuritylevel), core::mem::transmute_copy(&revinfosequencenumber), core::mem::transmute_copy(&revinfoissuedtime), core::mem::transmute_copy(&revinfottl), core::mem::transmute_copy(&revlistversion), core::mem::transmute_copy(&ulstate)).into()
            }
        }
        unsafe extern "system" fn SetRevInfo<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulrevinfolen: u32, pbrevinfo: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::SetRevInfo(this, core::mem::transmute_copy(&ulrevinfolen), core::mem::transmute_copy(&pbrevinfo)).into()
            }
        }
        unsafe extern "system" fn SetCrl<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcrllen: u32, pbcrllen: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::SetCrl(this, core::mem::transmute_copy(&ulcrllen), core::mem::transmute_copy(&pbcrllen)).into()
            }
        }
        unsafe extern "system" fn TransactMessage<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcbrequest: u32, pbrequest: *const u8, pulcbresponse: *mut u32, pbresponse: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::TransactMessage(this, core::mem::transmute_copy(&ulcbrequest), core::mem::transmute_copy(&pbrequest), core::mem::transmute_copy(&pulcbresponse), core::mem::transmute_copy(&pbresponse)).into()
            }
        }
        unsafe extern "system" fn GetLicense<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uuidkey: *const windows_core::GUID, pulpackagelen: *mut u32, pbpackage: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::GetLicense(this, core::mem::transmute_copy(&uuidkey), core::mem::transmute_copy(&pulpackagelen), core::mem::transmute_copy(&pbpackage)).into()
            }
        }
        unsafe extern "system" fn ReissueLicense<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uuidkey: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::ReissueLicense(this, core::mem::transmute_copy(&uuidkey)).into()
            }
        }
        unsafe extern "system" fn RenewLicense<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulinxmrlicenselen: u32, pbinxmrlicense: *const u8, ulentitlementtokenlen: u32, pbentitlementtoken: *const u8, puldescramblestatus: *mut u32, puloutxmrlicenselen: *mut u32, pboutxmrlicense: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::RenewLicense(this, core::mem::transmute_copy(&ulinxmrlicenselen), core::mem::transmute_copy(&pbinxmrlicense), core::mem::transmute_copy(&ulentitlementtokenlen), core::mem::transmute_copy(&pbentitlementtoken), core::mem::transmute_copy(&puldescramblestatus), core::mem::transmute_copy(&puloutxmrlicenselen), core::mem::transmute_copy(&pboutxmrlicense)).into()
            }
        }
        unsafe extern "system" fn GetKeyInfo<Identity: IBDA_WMDRMSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulkeyinfolen: *mut u32, pbkeyinfo: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMSession_Impl::GetKeyInfo(this, core::mem::transmute_copy(&pulkeyinfolen), core::mem::transmute_copy(&pbkeyinfo)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStatus: GetStatus::<Identity, OFFSET>,
            SetRevInfo: SetRevInfo::<Identity, OFFSET>,
            SetCrl: SetCrl::<Identity, OFFSET>,
            TransactMessage: TransactMessage::<Identity, OFFSET>,
            GetLicense: GetLicense::<Identity, OFFSET>,
            ReissueLicense: ReissueLicense::<Identity, OFFSET>,
            RenewLicense: RenewLicense::<Identity, OFFSET>,
            GetKeyInfo: GetKeyInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_WMDRMSession as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_WMDRMSession {}
windows_core::imp::define_interface!(IBDA_WMDRMTuner, IBDA_WMDRMTuner_Vtbl, 0x86d979cf_a8a7_4f94_b5fb_14c0aca68fe6);
windows_core::imp::interface_hierarchy!(IBDA_WMDRMTuner, windows_core::IUnknown);
impl IBDA_WMDRMTuner {
    pub unsafe fn PurchaseEntitlement(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, pbpurchasetoken: &[u8], puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PurchaseEntitlement)(windows_core::Interface::as_raw(self), uldialogrequest, core::mem::transmute_copy(bstrlanguage), pbpurchasetoken.len().try_into().unwrap(), core::mem::transmute(pbpurchasetoken.as_ptr()), puldescramblestatus as _, pulcapturetokenlen as _, pbcapturetoken as _).ok() }
    }
    pub unsafe fn CancelCaptureToken(&self, pbcapturetoken: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CancelCaptureToken)(windows_core::Interface::as_raw(self), pbcapturetoken.len().try_into().unwrap(), core::mem::transmute(pbcapturetoken.as_ptr())).ok() }
    }
    pub unsafe fn SetPidProtection(&self, ulpid: u32, uuidkey: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPidProtection)(windows_core::Interface::as_raw(self), ulpid, uuidkey).ok() }
    }
    pub unsafe fn GetPidProtection(&self, pulpid: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPidProtection)(windows_core::Interface::as_raw(self), pulpid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSyncValue(&self, ulsyncvalue: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSyncValue)(windows_core::Interface::as_raw(self), ulsyncvalue).ok() }
    }
    pub unsafe fn GetStartCodeProfile(&self, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStartCodeProfile)(windows_core::Interface::as_raw(self), pulstartcodeprofilelen as _, pbstartcodeprofile as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBDA_WMDRMTuner_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub PurchaseEntitlement: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void, u32, *const u8, *mut u32, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub CancelCaptureToken: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
    pub SetPidProtection: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetPidProtection: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetSyncValue: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetStartCodeProfile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
}
pub trait IBDA_WMDRMTuner_Impl: windows_core::IUnknownImpl {
    fn PurchaseEntitlement(&self, uldialogrequest: u32, bstrlanguage: &windows_core::BSTR, ulpurchasetokenlen: u32, pbpurchasetoken: *const u8, puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> windows_core::Result<()>;
    fn CancelCaptureToken(&self, ulcapturetokenlen: u32, pbcapturetoken: *const u8) -> windows_core::Result<()>;
    fn SetPidProtection(&self, ulpid: u32, uuidkey: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetPidProtection(&self, pulpid: u32) -> windows_core::Result<windows_core::GUID>;
    fn SetSyncValue(&self, ulsyncvalue: u32) -> windows_core::Result<()>;
    fn GetStartCodeProfile(&self, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> windows_core::Result<()>;
}
impl IBDA_WMDRMTuner_Vtbl {
    pub const fn new<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PurchaseEntitlement<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldialogrequest: u32, bstrlanguage: *mut core::ffi::c_void, ulpurchasetokenlen: u32, pbpurchasetoken: *const u8, puldescramblestatus: *mut u32, pulcapturetokenlen: *mut u32, pbcapturetoken: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMTuner_Impl::PurchaseEntitlement(this, core::mem::transmute_copy(&uldialogrequest), core::mem::transmute(&bstrlanguage), core::mem::transmute_copy(&ulpurchasetokenlen), core::mem::transmute_copy(&pbpurchasetoken), core::mem::transmute_copy(&puldescramblestatus), core::mem::transmute_copy(&pulcapturetokenlen), core::mem::transmute_copy(&pbcapturetoken)).into()
            }
        }
        unsafe extern "system" fn CancelCaptureToken<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcapturetokenlen: u32, pbcapturetoken: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMTuner_Impl::CancelCaptureToken(this, core::mem::transmute_copy(&ulcapturetokenlen), core::mem::transmute_copy(&pbcapturetoken)).into()
            }
        }
        unsafe extern "system" fn SetPidProtection<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpid: u32, uuidkey: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMTuner_Impl::SetPidProtection(this, core::mem::transmute_copy(&ulpid), core::mem::transmute_copy(&uuidkey)).into()
            }
        }
        unsafe extern "system" fn GetPidProtection<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulpid: u32, uuidkey: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBDA_WMDRMTuner_Impl::GetPidProtection(this, core::mem::transmute_copy(&pulpid)) {
                    Ok(ok__) => {
                        uuidkey.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSyncValue<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulsyncvalue: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMTuner_Impl::SetSyncValue(this, core::mem::transmute_copy(&ulsyncvalue)).into()
            }
        }
        unsafe extern "system" fn GetStartCodeProfile<Identity: IBDA_WMDRMTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulstartcodeprofilelen: *mut u32, pbstartcodeprofile: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBDA_WMDRMTuner_Impl::GetStartCodeProfile(this, core::mem::transmute_copy(&pulstartcodeprofilelen), core::mem::transmute_copy(&pbstartcodeprofile)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            PurchaseEntitlement: PurchaseEntitlement::<Identity, OFFSET>,
            CancelCaptureToken: CancelCaptureToken::<Identity, OFFSET>,
            SetPidProtection: SetPidProtection::<Identity, OFFSET>,
            GetPidProtection: GetPidProtection::<Identity, OFFSET>,
            SetSyncValue: SetSyncValue::<Identity, OFFSET>,
            GetStartCodeProfile: GetStartCodeProfile::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBDA_WMDRMTuner as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBDA_WMDRMTuner {}
windows_core::imp::define_interface!(IBPCSatelliteTuner, IBPCSatelliteTuner_Vtbl, 0x211a8765_03ac_11d1_8d13_00aa00bd8339);
impl core::ops::Deref for IBPCSatelliteTuner {
    type Target = IAMTuner;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IBPCSatelliteTuner, windows_core::IUnknown, IAMTuner);
impl IBPCSatelliteTuner {
    pub unsafe fn get_DefaultSubChannelTypes(&self, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_DefaultSubChannelTypes)(windows_core::Interface::as_raw(self), pldefaultvideotype as _, pldefaultaudiotype as _).ok() }
    }
    pub unsafe fn put_DefaultSubChannelTypes(&self, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_DefaultSubChannelTypes)(windows_core::Interface::as_raw(self), ldefaultvideotype, ldefaultaudiotype).ok() }
    }
    pub unsafe fn IsTapingPermitted(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsTapingPermitted)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBPCSatelliteTuner_Vtbl {
    pub base__: IAMTuner_Vtbl,
    pub get_DefaultSubChannelTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_DefaultSubChannelTypes: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub IsTapingPermitted: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IBPCSatelliteTuner_Impl: IAMTuner_Impl {
    fn get_DefaultSubChannelTypes(&self, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> windows_core::Result<()>;
    fn put_DefaultSubChannelTypes(&self, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> windows_core::Result<()>;
    fn IsTapingPermitted(&self) -> windows_core::Result<()>;
}
impl IBPCSatelliteTuner_Vtbl {
    pub const fn new<Identity: IBPCSatelliteTuner_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_DefaultSubChannelTypes<Identity: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pldefaultvideotype: *mut i32, pldefaultaudiotype: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBPCSatelliteTuner_Impl::get_DefaultSubChannelTypes(this, core::mem::transmute_copy(&pldefaultvideotype), core::mem::transmute_copy(&pldefaultaudiotype)).into()
            }
        }
        unsafe extern "system" fn put_DefaultSubChannelTypes<Identity: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ldefaultvideotype: i32, ldefaultaudiotype: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBPCSatelliteTuner_Impl::put_DefaultSubChannelTypes(this, core::mem::transmute_copy(&ldefaultvideotype), core::mem::transmute_copy(&ldefaultaudiotype)).into()
            }
        }
        unsafe extern "system" fn IsTapingPermitted<Identity: IBPCSatelliteTuner_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBPCSatelliteTuner_Impl::IsTapingPermitted(this).into()
            }
        }
        Self {
            base__: IAMTuner_Vtbl::new::<Identity, OFFSET>(),
            get_DefaultSubChannelTypes: get_DefaultSubChannelTypes::<Identity, OFFSET>,
            put_DefaultSubChannelTypes: put_DefaultSubChannelTypes::<Identity, OFFSET>,
            IsTapingPermitted: IsTapingPermitted::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBPCSatelliteTuner as windows_core::Interface>::IID || iid == &<IAMTuner as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBPCSatelliteTuner {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IBaseFilter, IBaseFilter_Vtbl, 0x56a86895_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IBaseFilter {
    type Target = IMediaFilter;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IBaseFilter, windows_core::IUnknown, super::super::System::Com::IPersist, IMediaFilter);
#[cfg(feature = "Win32_System_Com")]
impl IBaseFilter {
    pub unsafe fn EnumPins(&self) -> windows_core::Result<IEnumPins> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumPins)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn FindPin<P0>(&self, id: P0) -> windows_core::Result<IPin>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FindPin)(windows_core::Interface::as_raw(self), id.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn QueryFilterInfo(&self, pinfo: *mut FILTER_INFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryFilterInfo)(windows_core::Interface::as_raw(self), core::mem::transmute(pinfo)).ok() }
    }
    pub unsafe fn JoinFilterGraph<P0, P1>(&self, pgraph: P0, pname: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IFilterGraph>,
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).JoinFilterGraph)(windows_core::Interface::as_raw(self), pgraph.param().abi(), pname.param().abi()).ok() }
    }
    pub unsafe fn QueryVendorInfo(&self) -> windows_core::Result<windows_core::PWSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryVendorInfo)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IBaseFilter_Vtbl {
    pub base__: IMediaFilter_Vtbl,
    pub EnumPins: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub FindPin: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub QueryFilterInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut FILTER_INFO) -> windows_core::HRESULT,
    pub JoinFilterGraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub QueryVendorInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IBaseFilter_Impl: IMediaFilter_Impl {
    fn EnumPins(&self) -> windows_core::Result<IEnumPins>;
    fn FindPin(&self, id: &windows_core::PCWSTR) -> windows_core::Result<IPin>;
    fn QueryFilterInfo(&self, pinfo: *mut FILTER_INFO) -> windows_core::Result<()>;
    fn JoinFilterGraph(&self, pgraph: windows_core::Ref<IFilterGraph>, pname: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn QueryVendorInfo(&self) -> windows_core::Result<windows_core::PWSTR>;
}
#[cfg(feature = "Win32_System_Com")]
impl IBaseFilter_Vtbl {
    pub const fn new<Identity: IBaseFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn EnumPins<Identity: IBaseFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseFilter_Impl::EnumPins(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FindPin<Identity: IBaseFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, id: windows_core::PCWSTR, pppin: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseFilter_Impl::FindPin(this, core::mem::transmute(&id)) {
                    Ok(ok__) => {
                        pppin.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn QueryFilterInfo<Identity: IBaseFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinfo: *mut FILTER_INFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBaseFilter_Impl::QueryFilterInfo(this, core::mem::transmute_copy(&pinfo)).into()
            }
        }
        unsafe extern "system" fn JoinFilterGraph<Identity: IBaseFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pgraph: *mut core::ffi::c_void, pname: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBaseFilter_Impl::JoinFilterGraph(this, core::mem::transmute_copy(&pgraph), core::mem::transmute(&pname)).into()
            }
        }
        unsafe extern "system" fn QueryVendorInfo<Identity: IBaseFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvendorinfo: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseFilter_Impl::QueryVendorInfo(this) {
                    Ok(ok__) => {
                        pvendorinfo.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IMediaFilter_Vtbl::new::<Identity, OFFSET>(),
            EnumPins: EnumPins::<Identity, OFFSET>,
            FindPin: FindPin::<Identity, OFFSET>,
            QueryFilterInfo: QueryFilterInfo::<Identity, OFFSET>,
            JoinFilterGraph: JoinFilterGraph::<Identity, OFFSET>,
            QueryVendorInfo: QueryVendorInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBaseFilter as windows_core::Interface>::IID || iid == &<super::super::System::Com::IPersist as windows_core::Interface>::IID || iid == &<IMediaFilter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IBaseFilter {}
windows_core::imp::define_interface!(IBaseVideoMixer, IBaseVideoMixer_Vtbl, 0x61ded640_e912_11ce_a099_00aa00479a58);
windows_core::imp::interface_hierarchy!(IBaseVideoMixer, windows_core::IUnknown);
impl IBaseVideoMixer {
    pub unsafe fn SetLeadPin(&self, ipin: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLeadPin)(windows_core::Interface::as_raw(self), ipin).ok() }
    }
    pub unsafe fn GetLeadPin(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetLeadPin)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetInputPinCount(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetInputPinCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn IsUsingClock(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsUsingClock)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetUsingClock(&self, bvalue: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetUsingClock)(windows_core::Interface::as_raw(self), bvalue).ok() }
    }
    pub unsafe fn GetClockPeriod(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetClockPeriod)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetClockPeriod(&self, bvalue: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetClockPeriod)(windows_core::Interface::as_raw(self), bvalue).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBaseVideoMixer_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetLeadPin: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetLeadPin: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetInputPinCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub IsUsingClock: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetUsingClock: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetClockPeriod: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetClockPeriod: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IBaseVideoMixer_Impl: windows_core::IUnknownImpl {
    fn SetLeadPin(&self, ipin: i32) -> windows_core::Result<()>;
    fn GetLeadPin(&self) -> windows_core::Result<i32>;
    fn GetInputPinCount(&self) -> windows_core::Result<i32>;
    fn IsUsingClock(&self) -> windows_core::Result<i32>;
    fn SetUsingClock(&self, bvalue: i32) -> windows_core::Result<()>;
    fn GetClockPeriod(&self) -> windows_core::Result<i32>;
    fn SetClockPeriod(&self, bvalue: i32) -> windows_core::Result<()>;
}
impl IBaseVideoMixer_Vtbl {
    pub const fn new<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetLeadPin<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ipin: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBaseVideoMixer_Impl::SetLeadPin(this, core::mem::transmute_copy(&ipin)).into()
            }
        }
        unsafe extern "system" fn GetLeadPin<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pipin: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseVideoMixer_Impl::GetLeadPin(this) {
                    Ok(ok__) => {
                        pipin.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetInputPinCount<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pipincount: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseVideoMixer_Impl::GetInputPinCount(this) {
                    Ok(ok__) => {
                        pipincount.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsUsingClock<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseVideoMixer_Impl::IsUsingClock(this) {
                    Ok(ok__) => {
                        pbvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetUsingClock<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bvalue: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBaseVideoMixer_Impl::SetUsingClock(this, core::mem::transmute_copy(&bvalue)).into()
            }
        }
        unsafe extern "system" fn GetClockPeriod<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbvalue: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBaseVideoMixer_Impl::GetClockPeriod(this) {
                    Ok(ok__) => {
                        pbvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetClockPeriod<Identity: IBaseVideoMixer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bvalue: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBaseVideoMixer_Impl::SetClockPeriod(this, core::mem::transmute_copy(&bvalue)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetLeadPin: SetLeadPin::<Identity, OFFSET>,
            GetLeadPin: GetLeadPin::<Identity, OFFSET>,
            GetInputPinCount: GetInputPinCount::<Identity, OFFSET>,
            IsUsingClock: IsUsingClock::<Identity, OFFSET>,
            SetUsingClock: SetUsingClock::<Identity, OFFSET>,
            GetClockPeriod: GetClockPeriod::<Identity, OFFSET>,
            SetClockPeriod: SetClockPeriod::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBaseVideoMixer as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBaseVideoMixer {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IBasicAudio, IBasicAudio_Vtbl, 0x56a868b3_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IBasicAudio {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IBasicAudio, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IBasicAudio {
    pub unsafe fn SetVolume(&self, lvolume: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVolume)(windows_core::Interface::as_raw(self), lvolume).ok() }
    }
    pub unsafe fn Volume(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Volume)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBalance(&self, lbalance: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBalance)(windows_core::Interface::as_raw(self), lbalance).ok() }
    }
    pub unsafe fn Balance(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Balance)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IBasicAudio_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub SetVolume: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Volume: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetBalance: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Balance: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IBasicAudio_Impl: super::super::System::Com::IDispatch_Impl {
    fn SetVolume(&self, lvolume: i32) -> windows_core::Result<()>;
    fn Volume(&self) -> windows_core::Result<i32>;
    fn SetBalance(&self, lbalance: i32) -> windows_core::Result<()>;
    fn Balance(&self) -> windows_core::Result<i32>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IBasicAudio_Vtbl {
    pub const fn new<Identity: IBasicAudio_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetVolume<Identity: IBasicAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lvolume: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicAudio_Impl::SetVolume(this, core::mem::transmute_copy(&lvolume)).into()
            }
        }
        unsafe extern "system" fn Volume<Identity: IBasicAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plvolume: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicAudio_Impl::Volume(this) {
                    Ok(ok__) => {
                        plvolume.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBalance<Identity: IBasicAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lbalance: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicAudio_Impl::SetBalance(this, core::mem::transmute_copy(&lbalance)).into()
            }
        }
        unsafe extern "system" fn Balance<Identity: IBasicAudio_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plbalance: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicAudio_Impl::Balance(this) {
                    Ok(ok__) => {
                        plbalance.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            SetVolume: SetVolume::<Identity, OFFSET>,
            Volume: Volume::<Identity, OFFSET>,
            SetBalance: SetBalance::<Identity, OFFSET>,
            Balance: Balance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBasicAudio as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IBasicAudio {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IBasicVideo, IBasicVideo_Vtbl, 0x56a868b5_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IBasicVideo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IBasicVideo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IBasicVideo {
    pub unsafe fn AvgTimePerFrame(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvgTimePerFrame)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn BitRate(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).BitRate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn BitErrorRate(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).BitErrorRate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn VideoWidth(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VideoWidth)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn VideoHeight(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VideoHeight)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourceLeft(&self, sourceleft: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourceLeft)(windows_core::Interface::as_raw(self), sourceleft).ok() }
    }
    pub unsafe fn SourceLeft(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SourceLeft)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourceWidth(&self, sourcewidth: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourceWidth)(windows_core::Interface::as_raw(self), sourcewidth).ok() }
    }
    pub unsafe fn SourceWidth(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SourceWidth)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourceTop(&self, sourcetop: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourceTop)(windows_core::Interface::as_raw(self), sourcetop).ok() }
    }
    pub unsafe fn SourceTop(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SourceTop)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourceHeight(&self, sourceheight: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourceHeight)(windows_core::Interface::as_raw(self), sourceheight).ok() }
    }
    pub unsafe fn SourceHeight(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SourceHeight)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDestinationLeft(&self, destinationleft: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDestinationLeft)(windows_core::Interface::as_raw(self), destinationleft).ok() }
    }
    pub unsafe fn DestinationLeft(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DestinationLeft)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDestinationWidth(&self, destinationwidth: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDestinationWidth)(windows_core::Interface::as_raw(self), destinationwidth).ok() }
    }
    pub unsafe fn DestinationWidth(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DestinationWidth)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDestinationTop(&self, destinationtop: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDestinationTop)(windows_core::Interface::as_raw(self), destinationtop).ok() }
    }
    pub unsafe fn DestinationTop(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DestinationTop)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDestinationHeight(&self, destinationheight: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDestinationHeight)(windows_core::Interface::as_raw(self), destinationheight).ok() }
    }
    pub unsafe fn DestinationHeight(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DestinationHeight)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourcePosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourcePosition)(windows_core::Interface::as_raw(self), left, top, width, height).ok() }
    }
    pub unsafe fn GetSourcePosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSourcePosition)(windows_core::Interface::as_raw(self), pleft as _, ptop as _, pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn SetDefaultSourcePosition(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefaultSourcePosition)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SetDestinationPosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDestinationPosition)(windows_core::Interface::as_raw(self), left, top, width, height).ok() }
    }
    pub unsafe fn GetDestinationPosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDestinationPosition)(windows_core::Interface::as_raw(self), pleft as _, ptop as _, pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn SetDefaultDestinationPosition(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefaultDestinationPosition)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetVideoSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoSize)(windows_core::Interface::as_raw(self), pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn GetVideoPaletteEntries(&self, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoPaletteEntries)(windows_core::Interface::as_raw(self), startindex, entries, pretrieved as _, ppalette as _).ok() }
    }
    pub unsafe fn GetCurrentImage(&self, pbuffersize: *mut i32, pdibimage: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentImage)(windows_core::Interface::as_raw(self), pbuffersize as _, pdibimage as _).ok() }
    }
    pub unsafe fn IsUsingDefaultSource(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsUsingDefaultSource)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn IsUsingDefaultDestination(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsUsingDefaultDestination)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IBasicVideo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub AvgTimePerFrame: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub BitRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub BitErrorRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub VideoWidth: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub VideoHeight: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSourceLeft: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SourceLeft: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSourceWidth: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SourceWidth: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSourceTop: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SourceTop: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSourceHeight: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SourceHeight: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetDestinationLeft: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DestinationLeft: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetDestinationWidth: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DestinationWidth: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetDestinationTop: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DestinationTop: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetDestinationHeight: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub DestinationHeight: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSourcePosition: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32, i32) -> windows_core::HRESULT,
    pub GetSourcePosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetDefaultSourcePosition: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetDestinationPosition: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32, i32) -> windows_core::HRESULT,
    pub GetDestinationPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetDefaultDestinationPosition: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetVideoPaletteEntries: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetCurrentImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub IsUsingDefaultSource: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub IsUsingDefaultDestination: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IBasicVideo_Impl: super::super::System::Com::IDispatch_Impl {
    fn AvgTimePerFrame(&self) -> windows_core::Result<f64>;
    fn BitRate(&self) -> windows_core::Result<i32>;
    fn BitErrorRate(&self) -> windows_core::Result<i32>;
    fn VideoWidth(&self) -> windows_core::Result<i32>;
    fn VideoHeight(&self) -> windows_core::Result<i32>;
    fn SetSourceLeft(&self, sourceleft: i32) -> windows_core::Result<()>;
    fn SourceLeft(&self) -> windows_core::Result<i32>;
    fn SetSourceWidth(&self, sourcewidth: i32) -> windows_core::Result<()>;
    fn SourceWidth(&self) -> windows_core::Result<i32>;
    fn SetSourceTop(&self, sourcetop: i32) -> windows_core::Result<()>;
    fn SourceTop(&self) -> windows_core::Result<i32>;
    fn SetSourceHeight(&self, sourceheight: i32) -> windows_core::Result<()>;
    fn SourceHeight(&self) -> windows_core::Result<i32>;
    fn SetDestinationLeft(&self, destinationleft: i32) -> windows_core::Result<()>;
    fn DestinationLeft(&self) -> windows_core::Result<i32>;
    fn SetDestinationWidth(&self, destinationwidth: i32) -> windows_core::Result<()>;
    fn DestinationWidth(&self) -> windows_core::Result<i32>;
    fn SetDestinationTop(&self, destinationtop: i32) -> windows_core::Result<()>;
    fn DestinationTop(&self) -> windows_core::Result<i32>;
    fn SetDestinationHeight(&self, destinationheight: i32) -> windows_core::Result<()>;
    fn DestinationHeight(&self) -> windows_core::Result<i32>;
    fn SetSourcePosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()>;
    fn GetSourcePosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn SetDefaultSourcePosition(&self) -> windows_core::Result<()>;
    fn SetDestinationPosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()>;
    fn GetDestinationPosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn SetDefaultDestinationPosition(&self) -> windows_core::Result<()>;
    fn GetVideoSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn GetVideoPaletteEntries(&self, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> windows_core::Result<()>;
    fn GetCurrentImage(&self, pbuffersize: *mut i32, pdibimage: *mut i32) -> windows_core::Result<()>;
    fn IsUsingDefaultSource(&self) -> windows_core::Result<()>;
    fn IsUsingDefaultDestination(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IBasicVideo_Vtbl {
    pub const fn new<Identity: IBasicVideo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AvgTimePerFrame<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pavgtimeperframe: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::AvgTimePerFrame(this) {
                    Ok(ok__) => {
                        pavgtimeperframe.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn BitRate<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbitrate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::BitRate(this) {
                    Ok(ok__) => {
                        pbitrate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn BitErrorRate<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbiterrorrate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::BitErrorRate(this) {
                    Ok(ok__) => {
                        pbiterrorrate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn VideoWidth<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideowidth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::VideoWidth(this) {
                    Ok(ok__) => {
                        pvideowidth.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn VideoHeight<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideoheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::VideoHeight(this) {
                    Ok(ok__) => {
                        pvideoheight.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourceLeft<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sourceleft: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetSourceLeft(this, core::mem::transmute_copy(&sourceleft)).into()
            }
        }
        unsafe extern "system" fn SourceLeft<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourceleft: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::SourceLeft(this) {
                    Ok(ok__) => {
                        psourceleft.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourceWidth<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sourcewidth: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetSourceWidth(this, core::mem::transmute_copy(&sourcewidth)).into()
            }
        }
        unsafe extern "system" fn SourceWidth<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcewidth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::SourceWidth(this) {
                    Ok(ok__) => {
                        psourcewidth.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourceTop<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sourcetop: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetSourceTop(this, core::mem::transmute_copy(&sourcetop)).into()
            }
        }
        unsafe extern "system" fn SourceTop<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcetop: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::SourceTop(this) {
                    Ok(ok__) => {
                        psourcetop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourceHeight<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sourceheight: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetSourceHeight(this, core::mem::transmute_copy(&sourceheight)).into()
            }
        }
        unsafe extern "system" fn SourceHeight<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourceheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::SourceHeight(this) {
                    Ok(ok__) => {
                        psourceheight.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDestinationLeft<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destinationleft: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDestinationLeft(this, core::mem::transmute_copy(&destinationleft)).into()
            }
        }
        unsafe extern "system" fn DestinationLeft<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdestinationleft: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::DestinationLeft(this) {
                    Ok(ok__) => {
                        pdestinationleft.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDestinationWidth<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destinationwidth: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDestinationWidth(this, core::mem::transmute_copy(&destinationwidth)).into()
            }
        }
        unsafe extern "system" fn DestinationWidth<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdestinationwidth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::DestinationWidth(this) {
                    Ok(ok__) => {
                        pdestinationwidth.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDestinationTop<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destinationtop: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDestinationTop(this, core::mem::transmute_copy(&destinationtop)).into()
            }
        }
        unsafe extern "system" fn DestinationTop<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdestinationtop: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::DestinationTop(this) {
                    Ok(ok__) => {
                        pdestinationtop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDestinationHeight<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destinationheight: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDestinationHeight(this, core::mem::transmute_copy(&destinationheight)).into()
            }
        }
        unsafe extern "system" fn DestinationHeight<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdestinationheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBasicVideo_Impl::DestinationHeight(this) {
                    Ok(ok__) => {
                        pdestinationheight.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourcePosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetSourcePosition(this, core::mem::transmute_copy(&left), core::mem::transmute_copy(&top), core::mem::transmute_copy(&width), core::mem::transmute_copy(&height)).into()
            }
        }
        unsafe extern "system" fn GetSourcePosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::GetSourcePosition(this, core::mem::transmute_copy(&pleft), core::mem::transmute_copy(&ptop), core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn SetDefaultSourcePosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDefaultSourcePosition(this).into()
            }
        }
        unsafe extern "system" fn SetDestinationPosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDestinationPosition(this, core::mem::transmute_copy(&left), core::mem::transmute_copy(&top), core::mem::transmute_copy(&width), core::mem::transmute_copy(&height)).into()
            }
        }
        unsafe extern "system" fn GetDestinationPosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::GetDestinationPosition(this, core::mem::transmute_copy(&pleft), core::mem::transmute_copy(&ptop), core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn SetDefaultDestinationPosition<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::SetDefaultDestinationPosition(this).into()
            }
        }
        unsafe extern "system" fn GetVideoSize<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::GetVideoSize(this, core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn GetVideoPaletteEntries<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::GetVideoPaletteEntries(this, core::mem::transmute_copy(&startindex), core::mem::transmute_copy(&entries), core::mem::transmute_copy(&pretrieved), core::mem::transmute_copy(&ppalette)).into()
            }
        }
        unsafe extern "system" fn GetCurrentImage<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffersize: *mut i32, pdibimage: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::GetCurrentImage(this, core::mem::transmute_copy(&pbuffersize), core::mem::transmute_copy(&pdibimage)).into()
            }
        }
        unsafe extern "system" fn IsUsingDefaultSource<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::IsUsingDefaultSource(this).into()
            }
        }
        unsafe extern "system" fn IsUsingDefaultDestination<Identity: IBasicVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo_Impl::IsUsingDefaultDestination(this).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            AvgTimePerFrame: AvgTimePerFrame::<Identity, OFFSET>,
            BitRate: BitRate::<Identity, OFFSET>,
            BitErrorRate: BitErrorRate::<Identity, OFFSET>,
            VideoWidth: VideoWidth::<Identity, OFFSET>,
            VideoHeight: VideoHeight::<Identity, OFFSET>,
            SetSourceLeft: SetSourceLeft::<Identity, OFFSET>,
            SourceLeft: SourceLeft::<Identity, OFFSET>,
            SetSourceWidth: SetSourceWidth::<Identity, OFFSET>,
            SourceWidth: SourceWidth::<Identity, OFFSET>,
            SetSourceTop: SetSourceTop::<Identity, OFFSET>,
            SourceTop: SourceTop::<Identity, OFFSET>,
            SetSourceHeight: SetSourceHeight::<Identity, OFFSET>,
            SourceHeight: SourceHeight::<Identity, OFFSET>,
            SetDestinationLeft: SetDestinationLeft::<Identity, OFFSET>,
            DestinationLeft: DestinationLeft::<Identity, OFFSET>,
            SetDestinationWidth: SetDestinationWidth::<Identity, OFFSET>,
            DestinationWidth: DestinationWidth::<Identity, OFFSET>,
            SetDestinationTop: SetDestinationTop::<Identity, OFFSET>,
            DestinationTop: DestinationTop::<Identity, OFFSET>,
            SetDestinationHeight: SetDestinationHeight::<Identity, OFFSET>,
            DestinationHeight: DestinationHeight::<Identity, OFFSET>,
            SetSourcePosition: SetSourcePosition::<Identity, OFFSET>,
            GetSourcePosition: GetSourcePosition::<Identity, OFFSET>,
            SetDefaultSourcePosition: SetDefaultSourcePosition::<Identity, OFFSET>,
            SetDestinationPosition: SetDestinationPosition::<Identity, OFFSET>,
            GetDestinationPosition: GetDestinationPosition::<Identity, OFFSET>,
            SetDefaultDestinationPosition: SetDefaultDestinationPosition::<Identity, OFFSET>,
            GetVideoSize: GetVideoSize::<Identity, OFFSET>,
            GetVideoPaletteEntries: GetVideoPaletteEntries::<Identity, OFFSET>,
            GetCurrentImage: GetCurrentImage::<Identity, OFFSET>,
            IsUsingDefaultSource: IsUsingDefaultSource::<Identity, OFFSET>,
            IsUsingDefaultDestination: IsUsingDefaultDestination::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBasicVideo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IBasicVideo {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IBasicVideo2, IBasicVideo2_Vtbl, 0x329bb360_f6ea_11d1_9038_00a0c9697298);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IBasicVideo2 {
    type Target = IBasicVideo;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IBasicVideo2, windows_core::IUnknown, super::super::System::Com::IDispatch, IBasicVideo);
#[cfg(feature = "Win32_System_Com")]
impl IBasicVideo2 {
    pub unsafe fn GetPreferredAspectRatio(&self, plaspectx: *mut i32, plaspecty: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPreferredAspectRatio)(windows_core::Interface::as_raw(self), plaspectx as _, plaspecty as _).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IBasicVideo2_Vtbl {
    pub base__: IBasicVideo_Vtbl,
    pub GetPreferredAspectRatio: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IBasicVideo2_Impl: IBasicVideo_Impl {
    fn GetPreferredAspectRatio(&self, plaspectx: *mut i32, plaspecty: *mut i32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IBasicVideo2_Vtbl {
    pub const fn new<Identity: IBasicVideo2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPreferredAspectRatio<Identity: IBasicVideo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plaspectx: *mut i32, plaspecty: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBasicVideo2_Impl::GetPreferredAspectRatio(this, core::mem::transmute_copy(&plaspectx), core::mem::transmute_copy(&plaspecty)).into()
            }
        }
        Self { base__: IBasicVideo_Vtbl::new::<Identity, OFFSET>(), GetPreferredAspectRatio: GetPreferredAspectRatio::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBasicVideo2 as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID || iid == &<IBasicVideo as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IBasicVideo2 {}
windows_core::imp::define_interface!(IBroadcastEvent, IBroadcastEvent_Vtbl, 0x3b21263f_26e8_489d_aac4_924f7efd9511);
windows_core::imp::interface_hierarchy!(IBroadcastEvent, windows_core::IUnknown);
impl IBroadcastEvent {
    pub unsafe fn Fire(&self, eventid: windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Fire)(windows_core::Interface::as_raw(self), core::mem::transmute(eventid)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBroadcastEvent_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Fire: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IBroadcastEvent_Impl: windows_core::IUnknownImpl {
    fn Fire(&self, eventid: &windows_core::GUID) -> windows_core::Result<()>;
}
impl IBroadcastEvent_Vtbl {
    pub const fn new<Identity: IBroadcastEvent_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Fire<Identity: IBroadcastEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eventid: windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBroadcastEvent_Impl::Fire(this, core::mem::transmute(&eventid)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Fire: Fire::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBroadcastEvent as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBroadcastEvent {}
windows_core::imp::define_interface!(IBroadcastEventEx, IBroadcastEventEx_Vtbl, 0x3d9e3887_1929_423f_8021_43682de95448);
impl core::ops::Deref for IBroadcastEventEx {
    type Target = IBroadcastEvent;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IBroadcastEventEx, windows_core::IUnknown, IBroadcastEvent);
impl IBroadcastEventEx {
    pub unsafe fn FireEx(&self, eventid: windows_core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FireEx)(windows_core::Interface::as_raw(self), core::mem::transmute(eventid), param1, param2, param3, param4).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBroadcastEventEx_Vtbl {
    pub base__: IBroadcastEvent_Vtbl,
    pub FireEx: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, u32, u32, u32, u32) -> windows_core::HRESULT,
}
pub trait IBroadcastEventEx_Impl: IBroadcastEvent_Impl {
    fn FireEx(&self, eventid: &windows_core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> windows_core::Result<()>;
}
impl IBroadcastEventEx_Vtbl {
    pub const fn new<Identity: IBroadcastEventEx_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FireEx<Identity: IBroadcastEventEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eventid: windows_core::GUID, param1: u32, param2: u32, param3: u32, param4: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBroadcastEventEx_Impl::FireEx(this, core::mem::transmute(&eventid), core::mem::transmute_copy(&param1), core::mem::transmute_copy(&param2), core::mem::transmute_copy(&param3), core::mem::transmute_copy(&param4)).into()
            }
        }
        Self { base__: IBroadcastEvent_Vtbl::new::<Identity, OFFSET>(), FireEx: FireEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBroadcastEventEx as windows_core::Interface>::IID || iid == &<IBroadcastEvent as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBroadcastEventEx {}
windows_core::imp::define_interface!(IBufferingTime, IBufferingTime_Vtbl, 0x1e00486a_78dd_11d2_8dd3_006097c9a2b2);
windows_core::imp::interface_hierarchy!(IBufferingTime, windows_core::IUnknown);
impl IBufferingTime {
    pub unsafe fn GetBufferingTime(&self, pdwmilliseconds: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBufferingTime)(windows_core::Interface::as_raw(self), pdwmilliseconds as _).ok() }
    }
    pub unsafe fn SetBufferingTime(&self, dwmilliseconds: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBufferingTime)(windows_core::Interface::as_raw(self), dwmilliseconds).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBufferingTime_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetBufferingTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetBufferingTime: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IBufferingTime_Impl: windows_core::IUnknownImpl {
    fn GetBufferingTime(&self, pdwmilliseconds: *mut u32) -> windows_core::Result<()>;
    fn SetBufferingTime(&self, dwmilliseconds: u32) -> windows_core::Result<()>;
}
impl IBufferingTime_Vtbl {
    pub const fn new<Identity: IBufferingTime_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetBufferingTime<Identity: IBufferingTime_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmilliseconds: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBufferingTime_Impl::GetBufferingTime(this, core::mem::transmute_copy(&pdwmilliseconds)).into()
            }
        }
        unsafe extern "system" fn SetBufferingTime<Identity: IBufferingTime_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmilliseconds: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBufferingTime_Impl::SetBufferingTime(this, core::mem::transmute_copy(&dwmilliseconds)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetBufferingTime: GetBufferingTime::<Identity, OFFSET>,
            SetBufferingTime: SetBufferingTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBufferingTime as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IBufferingTime {}
windows_core::imp::define_interface!(ICCSubStreamFiltering, ICCSubStreamFiltering_Vtbl, 0x4b2bd7ea_8347_467b_8dbf_62f784929cc3);
windows_core::imp::interface_hierarchy!(ICCSubStreamFiltering, windows_core::IUnknown);
impl ICCSubStreamFiltering {
    pub unsafe fn SubstreamTypes(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SubstreamTypes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSubstreamTypes(&self, types: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSubstreamTypes)(windows_core::Interface::as_raw(self), types).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICCSubStreamFiltering_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SubstreamTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetSubstreamTypes: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait ICCSubStreamFiltering_Impl: windows_core::IUnknownImpl {
    fn SubstreamTypes(&self) -> windows_core::Result<i32>;
    fn SetSubstreamTypes(&self, types: i32) -> windows_core::Result<()>;
}
impl ICCSubStreamFiltering_Vtbl {
    pub const fn new<Identity: ICCSubStreamFiltering_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SubstreamTypes<Identity: ICCSubStreamFiltering_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptypes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICCSubStreamFiltering_Impl::SubstreamTypes(this) {
                    Ok(ok__) => {
                        ptypes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSubstreamTypes<Identity: ICCSubStreamFiltering_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, types: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICCSubStreamFiltering_Impl::SetSubstreamTypes(this, core::mem::transmute_copy(&types)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SubstreamTypes: SubstreamTypes::<Identity, OFFSET>,
            SetSubstreamTypes: SetSubstreamTypes::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICCSubStreamFiltering as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for ICCSubStreamFiltering {}
windows_core::imp::define_interface!(ICameraControl, ICameraControl_Vtbl, 0x2ba1785d_4d1b_44ef_85e8_c7f1d3f20184);
windows_core::imp::interface_hierarchy!(ICameraControl, windows_core::IUnknown);
impl ICameraControl {
    pub unsafe fn get_Exposure(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Exposure)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Exposure(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Exposure)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Exposure(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Exposure)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Focus(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Focus)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Focus(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Focus)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Focus(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Focus)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Iris(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Iris)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Iris(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Iris)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Iris(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Iris)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Zoom(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Zoom)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Zoom(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Zoom)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Zoom(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Zoom)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_FocalLengths(&self, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_FocalLengths)(windows_core::Interface::as_raw(self), plocularfocallength as _, plobjectivefocallengthmin as _, plobjectivefocallengthmax as _).ok() }
    }
    pub unsafe fn get_Pan(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Pan)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Pan(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Pan)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Pan(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Pan)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Tilt(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Tilt)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Tilt(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Tilt)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Tilt(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Tilt)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_PanTilt(&self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PanTilt)(windows_core::Interface::as_raw(self), ppanvalue as _, ptiltvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_PanTilt(&self, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_PanTilt)(windows_core::Interface::as_raw(self), panvalue, tiltvalue, flags).ok() }
    }
    pub unsafe fn get_Roll(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Roll)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Roll(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Roll)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Roll(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Roll)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_ExposureRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_ExposureRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_ExposureRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_ExposureRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_ExposureRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_ExposureRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_FocusRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_FocusRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_FocusRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_FocusRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_FocusRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_FocusRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_IrisRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_IrisRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_IrisRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_IrisRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_IrisRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_IrisRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_ZoomRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_ZoomRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_ZoomRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_ZoomRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_ZoomRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_ZoomRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_PanRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PanRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_PanRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_PanRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn get_TiltRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_TiltRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_TiltRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_TiltRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_TiltRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_TiltRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_PanTiltRelative(&self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PanTiltRelative)(windows_core::Interface::as_raw(self), ppanvalue as _, ptiltvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_PanTiltRelative(&self, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_PanTiltRelative)(windows_core::Interface::as_raw(self), panvalue, tiltvalue, flags).ok() }
    }
    pub unsafe fn getRange_PanRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_PanRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_RollRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_RollRelative)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_RollRelative(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_RollRelative)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_RollRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_RollRelative)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_ScanMode(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_ScanMode)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_ScanMode(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_ScanMode)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn get_PrivacyMode(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PrivacyMode)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_PrivacyMode(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_PrivacyMode)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICameraControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_Exposure: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Exposure: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Exposure: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Focus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Focus: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Focus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Iris: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Iris: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Iris: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Zoom: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Zoom: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Zoom: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_FocalLengths: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Pan: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Pan: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Pan: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Tilt: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Tilt: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Tilt: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_PanTilt: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_PanTilt: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub get_Roll: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Roll: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Roll: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_ExposureRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_ExposureRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_ExposureRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_FocusRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_FocusRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_FocusRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_IrisRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_IrisRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_IrisRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_ZoomRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_ZoomRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_ZoomRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_PanRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_PanRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub get_TiltRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_TiltRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_TiltRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_PanTiltRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_PanTiltRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub getRange_PanRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_RollRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_RollRelative: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_RollRelative: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_ScanMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_ScanMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub get_PrivacyMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_PrivacyMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
}
pub trait ICameraControl_Impl: windows_core::IUnknownImpl {
    fn get_Exposure(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Exposure(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Exposure(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Focus(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Focus(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Focus(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Iris(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Iris(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Iris(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Zoom(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Zoom(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Zoom(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_FocalLengths(&self, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> windows_core::Result<()>;
    fn get_Pan(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Pan(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Pan(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Tilt(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Tilt(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Tilt(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_PanTilt(&self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_PanTilt(&self, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::Result<()>;
    fn get_Roll(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Roll(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Roll(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_ExposureRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_ExposureRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_ExposureRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_FocusRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_FocusRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_FocusRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_IrisRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_IrisRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_IrisRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_ZoomRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_ZoomRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_ZoomRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_PanRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_PanRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn get_TiltRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_TiltRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_TiltRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_PanTiltRelative(&self, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_PanTiltRelative(&self, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_PanRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_RollRelative(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_RollRelative(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_RollRelative(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_ScanMode(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_ScanMode(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn get_PrivacyMode(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_PrivacyMode(&self, value: i32, flags: i32) -> windows_core::Result<()>;
}
impl ICameraControl_Vtbl {
    pub const fn new<Identity: ICameraControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_Exposure<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Exposure(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Exposure<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Exposure(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Exposure<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Exposure(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Focus<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Focus(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Focus<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Focus(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Focus<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Focus(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Iris<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Iris(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Iris<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Iris(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Iris<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Iris(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Zoom<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Zoom(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Zoom<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Zoom(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Zoom<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Zoom(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_FocalLengths<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plocularfocallength: *mut i32, plobjectivefocallengthmin: *mut i32, plobjectivefocallengthmax: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_FocalLengths(this, core::mem::transmute_copy(&plocularfocallength), core::mem::transmute_copy(&plobjectivefocallengthmin), core::mem::transmute_copy(&plobjectivefocallengthmax)).into()
            }
        }
        unsafe extern "system" fn get_Pan<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Pan(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Pan<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Pan(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Pan<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Pan(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Tilt<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Tilt(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Tilt<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Tilt(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Tilt<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Tilt(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_PanTilt<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_PanTilt(this, core::mem::transmute_copy(&ppanvalue), core::mem::transmute_copy(&ptiltvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_PanTilt<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_PanTilt(this, core::mem::transmute_copy(&panvalue), core::mem::transmute_copy(&tiltvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn get_Roll<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_Roll(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Roll<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_Roll(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Roll<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_Roll(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_ExposureRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_ExposureRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_ExposureRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_ExposureRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_ExposureRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_ExposureRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_FocusRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_FocusRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_FocusRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_FocusRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_FocusRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_FocusRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_IrisRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_IrisRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_IrisRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_IrisRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_IrisRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_IrisRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_ZoomRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_ZoomRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_ZoomRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_ZoomRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_ZoomRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_ZoomRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_PanRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_PanRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_PanRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_PanRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn get_TiltRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_TiltRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_TiltRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_TiltRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_TiltRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_TiltRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_PanTiltRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppanvalue: *mut i32, ptiltvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_PanTiltRelative(this, core::mem::transmute_copy(&ppanvalue), core::mem::transmute_copy(&ptiltvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_PanTiltRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, panvalue: i32, tiltvalue: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_PanTiltRelative(this, core::mem::transmute_copy(&panvalue), core::mem::transmute_copy(&tiltvalue), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_PanRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_PanRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_RollRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_RollRelative(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_RollRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_RollRelative(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_RollRelative<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::getRange_RollRelative(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_ScanMode<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_ScanMode(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_ScanMode<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_ScanMode(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn get_PrivacyMode<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::get_PrivacyMode(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_PrivacyMode<Identity: ICameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICameraControl_Impl::put_PrivacyMode(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_Exposure: get_Exposure::<Identity, OFFSET>,
            put_Exposure: put_Exposure::<Identity, OFFSET>,
            getRange_Exposure: getRange_Exposure::<Identity, OFFSET>,
            get_Focus: get_Focus::<Identity, OFFSET>,
            put_Focus: put_Focus::<Identity, OFFSET>,
            getRange_Focus: getRange_Focus::<Identity, OFFSET>,
            get_Iris: get_Iris::<Identity, OFFSET>,
            put_Iris: put_Iris::<Identity, OFFSET>,
            getRange_Iris: getRange_Iris::<Identity, OFFSET>,
            get_Zoom: get_Zoom::<Identity, OFFSET>,
            put_Zoom: put_Zoom::<Identity, OFFSET>,
            getRange_Zoom: getRange_Zoom::<Identity, OFFSET>,
            get_FocalLengths: get_FocalLengths::<Identity, OFFSET>,
            get_Pan: get_Pan::<Identity, OFFSET>,
            put_Pan: put_Pan::<Identity, OFFSET>,
            getRange_Pan: getRange_Pan::<Identity, OFFSET>,
            get_Tilt: get_Tilt::<Identity, OFFSET>,
            put_Tilt: put_Tilt::<Identity, OFFSET>,
            getRange_Tilt: getRange_Tilt::<Identity, OFFSET>,
            get_PanTilt: get_PanTilt::<Identity, OFFSET>,
            put_PanTilt: put_PanTilt::<Identity, OFFSET>,
            get_Roll: get_Roll::<Identity, OFFSET>,
            put_Roll: put_Roll::<Identity, OFFSET>,
            getRange_Roll: getRange_Roll::<Identity, OFFSET>,
            get_ExposureRelative: get_ExposureRelative::<Identity, OFFSET>,
            put_ExposureRelative: put_ExposureRelative::<Identity, OFFSET>,
            getRange_ExposureRelative: getRange_ExposureRelative::<Identity, OFFSET>,
            get_FocusRelative: get_FocusRelative::<Identity, OFFSET>,
            put_FocusRelative: put_FocusRelative::<Identity, OFFSET>,
            getRange_FocusRelative: getRange_FocusRelative::<Identity, OFFSET>,
            get_IrisRelative: get_IrisRelative::<Identity, OFFSET>,
            put_IrisRelative: put_IrisRelative::<Identity, OFFSET>,
            getRange_IrisRelative: getRange_IrisRelative::<Identity, OFFSET>,
            get_ZoomRelative: get_ZoomRelative::<Identity, OFFSET>,
            put_ZoomRelative: put_ZoomRelative::<Identity, OFFSET>,
            getRange_ZoomRelative: getRange_ZoomRelative::<Identity, OFFSET>,
            get_PanRelative: get_PanRelative::<Identity, OFFSET>,
            put_PanRelative: put_PanRelative::<Identity, OFFSET>,
            get_TiltRelative: get_TiltRelative::<Identity, OFFSET>,
            put_TiltRelative: put_TiltRelative::<Identity, OFFSET>,
            getRange_TiltRelative: getRange_TiltRelative::<Identity, OFFSET>,
            get_PanTiltRelative: get_PanTiltRelative::<Identity, OFFSET>,
            put_PanTiltRelative: put_PanTiltRelative::<Identity, OFFSET>,
            getRange_PanRelative: getRange_PanRelative::<Identity, OFFSET>,
            get_RollRelative: get_RollRelative::<Identity, OFFSET>,
            put_RollRelative: put_RollRelative::<Identity, OFFSET>,
            getRange_RollRelative: getRange_RollRelative::<Identity, OFFSET>,
            get_ScanMode: get_ScanMode::<Identity, OFFSET>,
            put_ScanMode: put_ScanMode::<Identity, OFFSET>,
            get_PrivacyMode: get_PrivacyMode::<Identity, OFFSET>,
            put_PrivacyMode: put_PrivacyMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICameraControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for ICameraControl {}
windows_core::imp::define_interface!(ICaptureGraphBuilder, ICaptureGraphBuilder_Vtbl, 0xbf87b6e0_8c27_11d0_b3f0_00aa003761c5);
windows_core::imp::interface_hierarchy!(ICaptureGraphBuilder, windows_core::IUnknown);
impl ICaptureGraphBuilder {
    pub unsafe fn SetFiltergraph<P0>(&self, pfg: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IGraphBuilder>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFiltergraph)(windows_core::Interface::as_raw(self), pfg.param().abi()).ok() }
    }
    pub unsafe fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFiltergraph)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetOutputFileName<P1>(&self, ptype: *const windows_core::GUID, lpstrfile: P1, ppf: *mut Option<IBaseFilter>, ppsink: *mut Option<IFileSinkFilter>) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetOutputFileName)(windows_core::Interface::as_raw(self), ptype, lpstrfile.param().abi(), core::mem::transmute(ppf), core::mem::transmute(ppsink)).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindInterface<P1>(&self, pcategory: Option<*const windows_core::GUID>, pf: P1, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).FindInterface)(windows_core::Interface::as_raw(self), pcategory.unwrap_or(core::mem::zeroed()) as _, pf.param().abi(), riid, ppint as _).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RenderStream<P1, P2, P3>(&self, pcategory: Option<*const windows_core::GUID>, psource: P1, pfcompressor: P2, pfrenderer: P3) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
        P2: windows_core::Param<IBaseFilter>,
        P3: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RenderStream)(windows_core::Interface::as_raw(self), pcategory.unwrap_or(core::mem::zeroed()) as _, psource.param().abi(), pfcompressor.param().abi(), pfrenderer.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ControlStream<P1>(&self, pcategory: Option<*const windows_core::GUID>, pfilter: P1, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).ControlStream)(windows_core::Interface::as_raw(self), pcategory.unwrap_or(core::mem::zeroed()) as _, pfilter.param().abi(), pstart, pstop, wstartcookie, wstopcookie).ok() }
    }
    pub unsafe fn AllocCapFile<P0>(&self, lpstr: P0, dwlsize: u64) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).AllocCapFile)(windows_core::Interface::as_raw(self), lpstr.param().abi(), dwlsize).ok() }
    }
    pub unsafe fn CopyCaptureFile<P0, P1, P3>(&self, lpwstrold: P0, lpwstrnew: P1, fallowescabort: i32, pcallback: P3) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
        P1: windows_core::Param<windows_core::PCWSTR>,
        P3: windows_core::Param<IAMCopyCaptureFileProgress>,
    {
        unsafe { (windows_core::Interface::vtable(self).CopyCaptureFile)(windows_core::Interface::as_raw(self), lpwstrold.param().abi(), lpwstrnew.param().abi(), fallowescabort, pcallback.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICaptureGraphBuilder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetFiltergraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetFiltergraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub SetOutputFileName: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, windows_core::PCWSTR, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetOutputFileName: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub FindInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    FindInterface: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub RenderStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RenderStream: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub ControlStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut core::ffi::c_void, *const i64, *const i64, u16, u16) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    ControlStream: usize,
    pub AllocCapFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, u64) -> windows_core::HRESULT,
    pub CopyCaptureFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, windows_core::PCWSTR, i32, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait ICaptureGraphBuilder_Impl: windows_core::IUnknownImpl {
    fn SetFiltergraph(&self, pfg: windows_core::Ref<IGraphBuilder>) -> windows_core::Result<()>;
    fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder>;
    fn SetOutputFileName(&self, ptype: *const windows_core::GUID, lpstrfile: &windows_core::PCWSTR, ppf: windows_core::OutRef<IBaseFilter>, ppsink: windows_core::OutRef<IFileSinkFilter>) -> windows_core::Result<()>;
    fn FindInterface(&self, pcategory: *const windows_core::GUID, pf: windows_core::Ref<IBaseFilter>, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn RenderStream(&self, pcategory: *const windows_core::GUID, psource: windows_core::Ref<windows_core::IUnknown>, pfcompressor: windows_core::Ref<IBaseFilter>, pfrenderer: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn ControlStream(&self, pcategory: *const windows_core::GUID, pfilter: windows_core::Ref<IBaseFilter>, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> windows_core::Result<()>;
    fn AllocCapFile(&self, lpstr: &windows_core::PCWSTR, dwlsize: u64) -> windows_core::Result<()>;
    fn CopyCaptureFile(&self, lpwstrold: &windows_core::PCWSTR, lpwstrnew: &windows_core::PCWSTR, fallowescabort: i32, pcallback: windows_core::Ref<IAMCopyCaptureFileProgress>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl ICaptureGraphBuilder_Vtbl {
    pub const fn new<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetFiltergraph<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfg: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::SetFiltergraph(this, core::mem::transmute_copy(&pfg)).into()
            }
        }
        unsafe extern "system" fn GetFiltergraph<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppfg: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICaptureGraphBuilder_Impl::GetFiltergraph(this) {
                    Ok(ok__) => {
                        ppfg.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputFileName<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *const windows_core::GUID, lpstrfile: windows_core::PCWSTR, ppf: *mut *mut core::ffi::c_void, ppsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::SetOutputFileName(this, core::mem::transmute_copy(&ptype), core::mem::transmute(&lpstrfile), core::mem::transmute_copy(&ppf), core::mem::transmute_copy(&ppsink)).into()
            }
        }
        unsafe extern "system" fn FindInterface<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, pf: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::FindInterface(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&pf), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppint)).into()
            }
        }
        unsafe extern "system" fn RenderStream<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, psource: *mut core::ffi::c_void, pfcompressor: *mut core::ffi::c_void, pfrenderer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::RenderStream(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&psource), core::mem::transmute_copy(&pfcompressor), core::mem::transmute_copy(&pfrenderer)).into()
            }
        }
        unsafe extern "system" fn ControlStream<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, pfilter: *mut core::ffi::c_void, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::ControlStream(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&pfilter), core::mem::transmute_copy(&pstart), core::mem::transmute_copy(&pstop), core::mem::transmute_copy(&wstartcookie), core::mem::transmute_copy(&wstopcookie)).into()
            }
        }
        unsafe extern "system" fn AllocCapFile<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpstr: windows_core::PCWSTR, dwlsize: u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::AllocCapFile(this, core::mem::transmute(&lpstr), core::mem::transmute_copy(&dwlsize)).into()
            }
        }
        unsafe extern "system" fn CopyCaptureFile<Identity: ICaptureGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwstrold: windows_core::PCWSTR, lpwstrnew: windows_core::PCWSTR, fallowescabort: i32, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder_Impl::CopyCaptureFile(this, core::mem::transmute(&lpwstrold), core::mem::transmute(&lpwstrnew), core::mem::transmute_copy(&fallowescabort), core::mem::transmute_copy(&pcallback)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFiltergraph: SetFiltergraph::<Identity, OFFSET>,
            GetFiltergraph: GetFiltergraph::<Identity, OFFSET>,
            SetOutputFileName: SetOutputFileName::<Identity, OFFSET>,
            FindInterface: FindInterface::<Identity, OFFSET>,
            RenderStream: RenderStream::<Identity, OFFSET>,
            ControlStream: ControlStream::<Identity, OFFSET>,
            AllocCapFile: AllocCapFile::<Identity, OFFSET>,
            CopyCaptureFile: CopyCaptureFile::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICaptureGraphBuilder as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for ICaptureGraphBuilder {}
windows_core::imp::define_interface!(ICaptureGraphBuilder2, ICaptureGraphBuilder2_Vtbl, 0x93e5a4e0_2d50_11d2_abfa_00a0c9c6e38d);
windows_core::imp::interface_hierarchy!(ICaptureGraphBuilder2, windows_core::IUnknown);
impl ICaptureGraphBuilder2 {
    pub unsafe fn SetFiltergraph<P0>(&self, pfg: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IGraphBuilder>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFiltergraph)(windows_core::Interface::as_raw(self), pfg.param().abi()).ok() }
    }
    pub unsafe fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFiltergraph)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetOutputFileName<P1>(&self, ptype: *const windows_core::GUID, lpstrfile: P1, ppf: *mut Option<IBaseFilter>, ppsink: Option<*mut Option<IFileSinkFilter>>) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetOutputFileName)(windows_core::Interface::as_raw(self), ptype, lpstrfile.param().abi(), core::mem::transmute(ppf), ppsink.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindInterface<P2>(&self, pcategory: Option<*const windows_core::GUID>, ptype: Option<*const windows_core::GUID>, pf: P2, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::Result<()>
    where
        P2: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).FindInterface)(windows_core::Interface::as_raw(self), pcategory.unwrap_or(core::mem::zeroed()) as _, ptype.unwrap_or(core::mem::zeroed()) as _, pf.param().abi(), riid, ppint as _).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RenderStream<P2, P3, P4>(&self, pcategory: Option<*const windows_core::GUID>, ptype: *const windows_core::GUID, psource: P2, pfcompressor: P3, pfrenderer: P4) -> windows_core::Result<()>
    where
        P2: windows_core::Param<windows_core::IUnknown>,
        P3: windows_core::Param<IBaseFilter>,
        P4: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RenderStream)(windows_core::Interface::as_raw(self), pcategory.unwrap_or(core::mem::zeroed()) as _, ptype, psource.param().abi(), pfcompressor.param().abi(), pfrenderer.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ControlStream<P2>(&self, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, pfilter: P2, pstart: Option<*const i64>, pstop: Option<*const i64>, wstartcookie: u16, wstopcookie: u16) -> windows_core::Result<()>
    where
        P2: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).ControlStream)(windows_core::Interface::as_raw(self), pcategory, ptype, pfilter.param().abi(), pstart.unwrap_or(core::mem::zeroed()) as _, pstop.unwrap_or(core::mem::zeroed()) as _, wstartcookie, wstopcookie).ok() }
    }
    pub unsafe fn AllocCapFile<P0>(&self, lpstr: P0, dwlsize: u64) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).AllocCapFile)(windows_core::Interface::as_raw(self), lpstr.param().abi(), dwlsize).ok() }
    }
    pub unsafe fn CopyCaptureFile<P0, P1, P3>(&self, lpwstrold: P0, lpwstrnew: P1, fallowescabort: i32, pcallback: P3) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
        P1: windows_core::Param<windows_core::PCWSTR>,
        P3: windows_core::Param<IAMCopyCaptureFileProgress>,
    {
        unsafe { (windows_core::Interface::vtable(self).CopyCaptureFile)(windows_core::Interface::as_raw(self), lpwstrold.param().abi(), lpwstrnew.param().abi(), fallowescabort, pcallback.param().abi()).ok() }
    }
    pub unsafe fn FindPin<P0>(&self, psource: P0, pindir: PIN_DIRECTION, pcategory: Option<*const windows_core::GUID>, ptype: Option<*const windows_core::GUID>, funconnected: bool, num: i32) -> windows_core::Result<IPin>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FindPin)(windows_core::Interface::as_raw(self), psource.param().abi(), pindir, pcategory.unwrap_or(core::mem::zeroed()) as _, ptype.unwrap_or(core::mem::zeroed()) as _, funconnected.into(), num, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICaptureGraphBuilder2_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetFiltergraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetFiltergraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub SetOutputFileName: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, windows_core::PCWSTR, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetOutputFileName: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub FindInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const windows_core::GUID, *mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    FindInterface: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub RenderStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const windows_core::GUID, *mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RenderStream: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub ControlStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const windows_core::GUID, *mut core::ffi::c_void, *const i64, *const i64, u16, u16) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    ControlStream: usize,
    pub AllocCapFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, u64) -> windows_core::HRESULT,
    pub CopyCaptureFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, windows_core::PCWSTR, i32, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub FindPin: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, PIN_DIRECTION, *const windows_core::GUID, *const windows_core::GUID, windows_core::BOOL, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait ICaptureGraphBuilder2_Impl: windows_core::IUnknownImpl {
    fn SetFiltergraph(&self, pfg: windows_core::Ref<IGraphBuilder>) -> windows_core::Result<()>;
    fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder>;
    fn SetOutputFileName(&self, ptype: *const windows_core::GUID, lpstrfile: &windows_core::PCWSTR, ppf: windows_core::OutRef<IBaseFilter>, ppsink: windows_core::OutRef<IFileSinkFilter>) -> windows_core::Result<()>;
    fn FindInterface(&self, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, pf: windows_core::Ref<IBaseFilter>, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn RenderStream(&self, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, psource: windows_core::Ref<windows_core::IUnknown>, pfcompressor: windows_core::Ref<IBaseFilter>, pfrenderer: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn ControlStream(&self, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, pfilter: windows_core::Ref<IBaseFilter>, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> windows_core::Result<()>;
    fn AllocCapFile(&self, lpstr: &windows_core::PCWSTR, dwlsize: u64) -> windows_core::Result<()>;
    fn CopyCaptureFile(&self, lpwstrold: &windows_core::PCWSTR, lpwstrnew: &windows_core::PCWSTR, fallowescabort: i32, pcallback: windows_core::Ref<IAMCopyCaptureFileProgress>) -> windows_core::Result<()>;
    fn FindPin(&self, psource: windows_core::Ref<windows_core::IUnknown>, pindir: PIN_DIRECTION, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, funconnected: windows_core::BOOL, num: i32) -> windows_core::Result<IPin>;
}
#[cfg(feature = "Win32_System_Com")]
impl ICaptureGraphBuilder2_Vtbl {
    pub const fn new<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetFiltergraph<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfg: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::SetFiltergraph(this, core::mem::transmute_copy(&pfg)).into()
            }
        }
        unsafe extern "system" fn GetFiltergraph<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppfg: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICaptureGraphBuilder2_Impl::GetFiltergraph(this) {
                    Ok(ok__) => {
                        ppfg.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputFileName<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *const windows_core::GUID, lpstrfile: windows_core::PCWSTR, ppf: *mut *mut core::ffi::c_void, ppsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::SetOutputFileName(this, core::mem::transmute_copy(&ptype), core::mem::transmute(&lpstrfile), core::mem::transmute_copy(&ppf), core::mem::transmute_copy(&ppsink)).into()
            }
        }
        unsafe extern "system" fn FindInterface<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, pf: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppint: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::FindInterface(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&pf), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppint)).into()
            }
        }
        unsafe extern "system" fn RenderStream<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, psource: *mut core::ffi::c_void, pfcompressor: *mut core::ffi::c_void, pfrenderer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::RenderStream(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&psource), core::mem::transmute_copy(&pfcompressor), core::mem::transmute_copy(&pfrenderer)).into()
            }
        }
        unsafe extern "system" fn ControlStream<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, pfilter: *mut core::ffi::c_void, pstart: *const i64, pstop: *const i64, wstartcookie: u16, wstopcookie: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::ControlStream(this, core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&pfilter), core::mem::transmute_copy(&pstart), core::mem::transmute_copy(&pstop), core::mem::transmute_copy(&wstartcookie), core::mem::transmute_copy(&wstopcookie)).into()
            }
        }
        unsafe extern "system" fn AllocCapFile<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpstr: windows_core::PCWSTR, dwlsize: u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::AllocCapFile(this, core::mem::transmute(&lpstr), core::mem::transmute_copy(&dwlsize)).into()
            }
        }
        unsafe extern "system" fn CopyCaptureFile<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwstrold: windows_core::PCWSTR, lpwstrnew: windows_core::PCWSTR, fallowescabort: i32, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICaptureGraphBuilder2_Impl::CopyCaptureFile(this, core::mem::transmute(&lpwstrold), core::mem::transmute(&lpwstrnew), core::mem::transmute_copy(&fallowescabort), core::mem::transmute_copy(&pcallback)).into()
            }
        }
        unsafe extern "system" fn FindPin<Identity: ICaptureGraphBuilder2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psource: *mut core::ffi::c_void, pindir: PIN_DIRECTION, pcategory: *const windows_core::GUID, ptype: *const windows_core::GUID, funconnected: windows_core::BOOL, num: i32, pppin: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICaptureGraphBuilder2_Impl::FindPin(this, core::mem::transmute_copy(&psource), core::mem::transmute_copy(&pindir), core::mem::transmute_copy(&pcategory), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&funconnected), core::mem::transmute_copy(&num)) {
                    Ok(ok__) => {
                        pppin.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFiltergraph: SetFiltergraph::<Identity, OFFSET>,
            GetFiltergraph: GetFiltergraph::<Identity, OFFSET>,
            SetOutputFileName: SetOutputFileName::<Identity, OFFSET>,
            FindInterface: FindInterface::<Identity, OFFSET>,
            RenderStream: RenderStream::<Identity, OFFSET>,
            ControlStream: ControlStream::<Identity, OFFSET>,
            AllocCapFile: AllocCapFile::<Identity, OFFSET>,
            CopyCaptureFile: CopyCaptureFile::<Identity, OFFSET>,
            FindPin: FindPin::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICaptureGraphBuilder2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for ICaptureGraphBuilder2 {}
windows_core::imp::define_interface!(IConfigAsfWriter, IConfigAsfWriter_Vtbl, 0x45086030_f7e4_486a_b504_826bb5792a3b);
windows_core::imp::interface_hierarchy!(IConfigAsfWriter, windows_core::IUnknown);
impl IConfigAsfWriter {
    pub unsafe fn ConfigureFilterUsingProfileId(&self, dwprofileid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ConfigureFilterUsingProfileId)(windows_core::Interface::as_raw(self), dwprofileid).ok() }
    }
    pub unsafe fn GetCurrentProfileId(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentProfileId)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn ConfigureFilterUsingProfileGuid(&self, guidprofile: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ConfigureFilterUsingProfileGuid)(windows_core::Interface::as_raw(self), guidprofile).ok() }
    }
    pub unsafe fn GetCurrentProfileGuid(&self) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentProfileGuid)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn ConfigureFilterUsingProfile<P0>(&self, pprofile: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::WindowsMediaFormat::IWMProfile>,
    {
        unsafe { (windows_core::Interface::vtable(self).ConfigureFilterUsingProfile)(windows_core::Interface::as_raw(self), pprofile.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn GetCurrentProfile(&self) -> windows_core::Result<super::WindowsMediaFormat::IWMProfile> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentProfile)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SetIndexMode(&self, bindexfile: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetIndexMode)(windows_core::Interface::as_raw(self), bindexfile.into()).ok() }
    }
    pub unsafe fn GetIndexMode(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetIndexMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IConfigAsfWriter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub ConfigureFilterUsingProfileId: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetCurrentProfileId: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub ConfigureFilterUsingProfileGuid: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetCurrentProfileGuid: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub ConfigureFilterUsingProfile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_WindowsMediaFormat"))]
    ConfigureFilterUsingProfile: usize,
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub GetCurrentProfile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_WindowsMediaFormat"))]
    GetCurrentProfile: usize,
    pub SetIndexMode: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetIndexMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
pub trait IConfigAsfWriter_Impl: windows_core::IUnknownImpl {
    fn ConfigureFilterUsingProfileId(&self, dwprofileid: u32) -> windows_core::Result<()>;
    fn GetCurrentProfileId(&self) -> windows_core::Result<u32>;
    fn ConfigureFilterUsingProfileGuid(&self, guidprofile: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetCurrentProfileGuid(&self) -> windows_core::Result<windows_core::GUID>;
    fn ConfigureFilterUsingProfile(&self, pprofile: windows_core::Ref<super::WindowsMediaFormat::IWMProfile>) -> windows_core::Result<()>;
    fn GetCurrentProfile(&self) -> windows_core::Result<super::WindowsMediaFormat::IWMProfile>;
    fn SetIndexMode(&self, bindexfile: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetIndexMode(&self) -> windows_core::Result<windows_core::BOOL>;
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl IConfigAsfWriter_Vtbl {
    pub const fn new<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ConfigureFilterUsingProfileId<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwprofileid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter_Impl::ConfigureFilterUsingProfileId(this, core::mem::transmute_copy(&dwprofileid)).into()
            }
        }
        unsafe extern "system" fn GetCurrentProfileId<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwprofileid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAsfWriter_Impl::GetCurrentProfileId(this) {
                    Ok(ok__) => {
                        pdwprofileid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfileGuid<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidprofile: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter_Impl::ConfigureFilterUsingProfileGuid(this, core::mem::transmute_copy(&guidprofile)).into()
            }
        }
        unsafe extern "system" fn GetCurrentProfileGuid<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprofileguid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAsfWriter_Impl::GetCurrentProfileGuid(this) {
                    Ok(ok__) => {
                        pprofileguid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConfigureFilterUsingProfile<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprofile: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter_Impl::ConfigureFilterUsingProfile(this, core::mem::transmute_copy(&pprofile)).into()
            }
        }
        unsafe extern "system" fn GetCurrentProfile<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppprofile: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAsfWriter_Impl::GetCurrentProfile(this) {
                    Ok(ok__) => {
                        ppprofile.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIndexMode<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bindexfile: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter_Impl::SetIndexMode(this, core::mem::transmute_copy(&bindexfile)).into()
            }
        }
        unsafe extern "system" fn GetIndexMode<Identity: IConfigAsfWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbindexfile: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAsfWriter_Impl::GetIndexMode(this) {
                    Ok(ok__) => {
                        pbindexfile.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ConfigureFilterUsingProfileId: ConfigureFilterUsingProfileId::<Identity, OFFSET>,
            GetCurrentProfileId: GetCurrentProfileId::<Identity, OFFSET>,
            ConfigureFilterUsingProfileGuid: ConfigureFilterUsingProfileGuid::<Identity, OFFSET>,
            GetCurrentProfileGuid: GetCurrentProfileGuid::<Identity, OFFSET>,
            ConfigureFilterUsingProfile: ConfigureFilterUsingProfile::<Identity, OFFSET>,
            GetCurrentProfile: GetCurrentProfile::<Identity, OFFSET>,
            SetIndexMode: SetIndexMode::<Identity, OFFSET>,
            GetIndexMode: GetIndexMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IConfigAsfWriter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl windows_core::RuntimeName for IConfigAsfWriter {}
windows_core::imp::define_interface!(IConfigAsfWriter2, IConfigAsfWriter2_Vtbl, 0x7989ccaa_53f0_44f0_884a_f3b03f6ae066);
impl core::ops::Deref for IConfigAsfWriter2 {
    type Target = IConfigAsfWriter;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IConfigAsfWriter2, windows_core::IUnknown, IConfigAsfWriter);
impl IConfigAsfWriter2 {
    pub unsafe fn StreamNumFromPin<P0>(&self, ppin: P0) -> windows_core::Result<u16>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).StreamNumFromPin)(windows_core::Interface::as_raw(self), ppin.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetParam(&self, dwparam: u32, dwparam1: u32, dwparam2: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetParam)(windows_core::Interface::as_raw(self), dwparam, dwparam1, dwparam2).ok() }
    }
    pub unsafe fn GetParam(&self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetParam)(windows_core::Interface::as_raw(self), dwparam, pdwparam1 as _, pdwparam2 as _).ok() }
    }
    pub unsafe fn ResetMultiPassState(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ResetMultiPassState)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IConfigAsfWriter2_Vtbl {
    pub base__: IConfigAsfWriter_Vtbl,
    pub StreamNumFromPin: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut u16) -> windows_core::HRESULT,
    pub SetParam: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32) -> windows_core::HRESULT,
    pub GetParam: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub ResetMultiPassState: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
pub trait IConfigAsfWriter2_Impl: IConfigAsfWriter_Impl {
    fn StreamNumFromPin(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<u16>;
    fn SetParam(&self, dwparam: u32, dwparam1: u32, dwparam2: u32) -> windows_core::Result<()>;
    fn GetParam(&self, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::Result<()>;
    fn ResetMultiPassState(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl IConfigAsfWriter2_Vtbl {
    pub const fn new<Identity: IConfigAsfWriter2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StreamNumFromPin<Identity: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, pwstreamnum: *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAsfWriter2_Impl::StreamNumFromPin(this, core::mem::transmute_copy(&ppin)) {
                    Ok(ok__) => {
                        pwstreamnum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetParam<Identity: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparam: u32, dwparam1: u32, dwparam2: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter2_Impl::SetParam(this, core::mem::transmute_copy(&dwparam), core::mem::transmute_copy(&dwparam1), core::mem::transmute_copy(&dwparam2)).into()
            }
        }
        unsafe extern "system" fn GetParam<Identity: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparam: u32, pdwparam1: *mut u32, pdwparam2: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter2_Impl::GetParam(this, core::mem::transmute_copy(&dwparam), core::mem::transmute_copy(&pdwparam1), core::mem::transmute_copy(&pdwparam2)).into()
            }
        }
        unsafe extern "system" fn ResetMultiPassState<Identity: IConfigAsfWriter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAsfWriter2_Impl::ResetMultiPassState(this).into()
            }
        }
        Self {
            base__: IConfigAsfWriter_Vtbl::new::<Identity, OFFSET>(),
            StreamNumFromPin: StreamNumFromPin::<Identity, OFFSET>,
            SetParam: SetParam::<Identity, OFFSET>,
            GetParam: GetParam::<Identity, OFFSET>,
            ResetMultiPassState: ResetMultiPassState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IConfigAsfWriter2 as windows_core::Interface>::IID || iid == &<IConfigAsfWriter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_WindowsMediaFormat")]
impl windows_core::RuntimeName for IConfigAsfWriter2 {}
windows_core::imp::define_interface!(IConfigAviMux, IConfigAviMux_Vtbl, 0x5acd6aa0_f482_11ce_8b67_00aa00a3f1a6);
windows_core::imp::interface_hierarchy!(IConfigAviMux, windows_core::IUnknown);
impl IConfigAviMux {
    pub unsafe fn SetMasterStream(&self, istream: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMasterStream)(windows_core::Interface::as_raw(self), istream).ok() }
    }
    pub unsafe fn GetMasterStream(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMasterStream)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOutputCompatibilityIndex(&self, foldindex: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputCompatibilityIndex)(windows_core::Interface::as_raw(self), foldindex.into()).ok() }
    }
    pub unsafe fn GetOutputCompatibilityIndex(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetOutputCompatibilityIndex)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IConfigAviMux_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetMasterStream: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetMasterStream: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetOutputCompatibilityIndex: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetOutputCompatibilityIndex: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IConfigAviMux_Impl: windows_core::IUnknownImpl {
    fn SetMasterStream(&self, istream: i32) -> windows_core::Result<()>;
    fn GetMasterStream(&self) -> windows_core::Result<i32>;
    fn SetOutputCompatibilityIndex(&self, foldindex: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetOutputCompatibilityIndex(&self) -> windows_core::Result<windows_core::BOOL>;
}
impl IConfigAviMux_Vtbl {
    pub const fn new<Identity: IConfigAviMux_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetMasterStream<Identity: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, istream: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAviMux_Impl::SetMasterStream(this, core::mem::transmute_copy(&istream)).into()
            }
        }
        unsafe extern "system" fn GetMasterStream<Identity: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstream: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAviMux_Impl::GetMasterStream(this) {
                    Ok(ok__) => {
                        pstream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputCompatibilityIndex<Identity: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, foldindex: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigAviMux_Impl::SetOutputCompatibilityIndex(this, core::mem::transmute_copy(&foldindex)).into()
            }
        }
        unsafe extern "system" fn GetOutputCompatibilityIndex<Identity: IConfigAviMux_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfoldindex: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigAviMux_Impl::GetOutputCompatibilityIndex(this) {
                    Ok(ok__) => {
                        pfoldindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMasterStream: SetMasterStream::<Identity, OFFSET>,
            GetMasterStream: GetMasterStream::<Identity, OFFSET>,
            SetOutputCompatibilityIndex: SetOutputCompatibilityIndex::<Identity, OFFSET>,
            GetOutputCompatibilityIndex: GetOutputCompatibilityIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IConfigAviMux as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IConfigAviMux {}
windows_core::imp::define_interface!(IConfigInterleaving, IConfigInterleaving_Vtbl, 0xbee3d220_157b_11d0_bd23_00a0c911ce86);
windows_core::imp::interface_hierarchy!(IConfigInterleaving, windows_core::IUnknown);
impl IConfigInterleaving {
    pub unsafe fn SetMode(&self, mode: InterleavingMode) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn Mode(&self) -> windows_core::Result<InterleavingMode> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Mode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn put_Interleaving(&self, prtinterleave: *const i64, prtpreroll: *const i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Interleaving)(windows_core::Interface::as_raw(self), prtinterleave, prtpreroll).ok() }
    }
    pub unsafe fn get_Interleaving(&self, prtinterleave: *mut i64, prtpreroll: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Interleaving)(windows_core::Interface::as_raw(self), prtinterleave as _, prtpreroll as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IConfigInterleaving_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetMode: unsafe extern "system" fn(*mut core::ffi::c_void, InterleavingMode) -> windows_core::HRESULT,
    pub Mode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut InterleavingMode) -> windows_core::HRESULT,
    pub put_Interleaving: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
    pub get_Interleaving: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
}
pub trait IConfigInterleaving_Impl: windows_core::IUnknownImpl {
    fn SetMode(&self, mode: InterleavingMode) -> windows_core::Result<()>;
    fn Mode(&self) -> windows_core::Result<InterleavingMode>;
    fn put_Interleaving(&self, prtinterleave: *const i64, prtpreroll: *const i64) -> windows_core::Result<()>;
    fn get_Interleaving(&self, prtinterleave: *mut i64, prtpreroll: *mut i64) -> windows_core::Result<()>;
}
impl IConfigInterleaving_Vtbl {
    pub const fn new<Identity: IConfigInterleaving_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetMode<Identity: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: InterleavingMode) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigInterleaving_Impl::SetMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn Mode<Identity: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut InterleavingMode) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IConfigInterleaving_Impl::Mode(this) {
                    Ok(ok__) => {
                        pmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn put_Interleaving<Identity: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtinterleave: *const i64, prtpreroll: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigInterleaving_Impl::put_Interleaving(this, core::mem::transmute_copy(&prtinterleave), core::mem::transmute_copy(&prtpreroll)).into()
            }
        }
        unsafe extern "system" fn get_Interleaving<Identity: IConfigInterleaving_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtinterleave: *mut i64, prtpreroll: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IConfigInterleaving_Impl::get_Interleaving(this, core::mem::transmute_copy(&prtinterleave), core::mem::transmute_copy(&prtpreroll)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMode: SetMode::<Identity, OFFSET>,
            Mode: Mode::<Identity, OFFSET>,
            put_Interleaving: put_Interleaving::<Identity, OFFSET>,
            get_Interleaving: get_Interleaving::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IConfigInterleaving as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IConfigInterleaving {}
windows_core::imp::define_interface!(ICreateDevEnum, ICreateDevEnum_Vtbl, 0x29840822_5b84_11d0_bd3b_00a0c911ce86);
windows_core::imp::interface_hierarchy!(ICreateDevEnum, windows_core::IUnknown);
impl ICreateDevEnum {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateClassEnumerator(&self, clsiddeviceclass: *const windows_core::GUID, ppenummoniker: *mut Option<super::super::System::Com::IEnumMoniker>, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CreateClassEnumerator)(windows_core::Interface::as_raw(self), clsiddeviceclass, core::mem::transmute(ppenummoniker), dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICreateDevEnum_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub CreateClassEnumerator: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    CreateClassEnumerator: usize,
}
#[cfg(feature = "Win32_System_Com")]
pub trait ICreateDevEnum_Impl: windows_core::IUnknownImpl {
    fn CreateClassEnumerator(&self, clsiddeviceclass: *const windows_core::GUID, ppenummoniker: windows_core::OutRef<super::super::System::Com::IEnumMoniker>, dwflags: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl ICreateDevEnum_Vtbl {
    pub const fn new<Identity: ICreateDevEnum_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateClassEnumerator<Identity: ICreateDevEnum_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsiddeviceclass: *const windows_core::GUID, ppenummoniker: *mut *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICreateDevEnum_Impl::CreateClassEnumerator(this, core::mem::transmute_copy(&clsiddeviceclass), core::mem::transmute_copy(&ppenummoniker), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateClassEnumerator: CreateClassEnumerator::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICreateDevEnum as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for ICreateDevEnum {}
windows_core::imp::define_interface!(IDDrawExclModeVideo, IDDrawExclModeVideo_Vtbl, 0x153acc21_d83b_11d1_82bf_00a0c9696c8f);
windows_core::imp::interface_hierarchy!(IDDrawExclModeVideo, windows_core::IUnknown);
impl IDDrawExclModeVideo {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetDDrawObject<P0>(&self, pddrawobject: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDDrawObject)(windows_core::Interface::as_raw(self), pddrawobject.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetDDrawObject(&self, ppddrawobject: *mut Option<super::super::Graphics::DirectDraw::IDirectDraw>, pbusingexternal: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDDrawObject)(windows_core::Interface::as_raw(self), core::mem::transmute(ppddrawobject), pbusingexternal as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetDDrawSurface<P0>(&self, pddrawsurface: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDDrawSurface)(windows_core::Interface::as_raw(self), pddrawsurface.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetDDrawSurface(&self, ppddrawsurface: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, pbusingexternal: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDDrawSurface)(windows_core::Interface::as_raw(self), core::mem::transmute(ppddrawsurface), pbusingexternal as _).ok() }
    }
    pub unsafe fn SetDrawParameters(&self, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDrawParameters)(windows_core::Interface::as_raw(self), prcsource, prctarget).ok() }
    }
    pub unsafe fn GetNativeVideoProps(&self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNativeVideoProps)(windows_core::Interface::as_raw(self), pdwvideowidth as _, pdwvideoheight as _, pdwpictaspectratiox as _, pdwpictaspectratioy as _).ok() }
    }
    pub unsafe fn SetCallbackInterface<P0>(&self, pcallback: P0, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IDDrawExclModeVideoCallback>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetCallbackInterface)(windows_core::Interface::as_raw(self), pcallback.param().abi(), dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDDrawExclModeVideo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetDDrawObject: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetDDrawObject: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetDDrawObject: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetDDrawObject: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetDDrawSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetDDrawSurface: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetDDrawSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetDDrawSurface: usize,
    pub SetDrawParameters: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub GetNativeVideoProps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub SetCallbackInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDDrawExclModeVideo_Impl: windows_core::IUnknownImpl {
    fn SetDDrawObject(&self, pddrawobject: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw>) -> windows_core::Result<()>;
    fn GetDDrawObject(&self, ppddrawobject: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDraw>, pbusingexternal: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetDDrawSurface(&self, pddrawsurface: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface>) -> windows_core::Result<()>;
    fn GetDDrawSurface(&self, ppddrawsurface: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawSurface>, pbusingexternal: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetDrawParameters(&self, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetNativeVideoProps(&self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::Result<()>;
    fn SetCallbackInterface(&self, pcallback: windows_core::Ref<IDDrawExclModeVideoCallback>, dwflags: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDDrawExclModeVideo_Vtbl {
    pub const fn new<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetDDrawObject<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pddrawobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::SetDDrawObject(this, core::mem::transmute_copy(&pddrawobject)).into()
            }
        }
        unsafe extern "system" fn GetDDrawObject<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppddrawobject: *mut *mut core::ffi::c_void, pbusingexternal: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::GetDDrawObject(this, core::mem::transmute_copy(&ppddrawobject), core::mem::transmute_copy(&pbusingexternal)).into()
            }
        }
        unsafe extern "system" fn SetDDrawSurface<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pddrawsurface: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::SetDDrawSurface(this, core::mem::transmute_copy(&pddrawsurface)).into()
            }
        }
        unsafe extern "system" fn GetDDrawSurface<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppddrawsurface: *mut *mut core::ffi::c_void, pbusingexternal: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::GetDDrawSurface(this, core::mem::transmute_copy(&ppddrawsurface), core::mem::transmute_copy(&pbusingexternal)).into()
            }
        }
        unsafe extern "system" fn SetDrawParameters<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prcsource: *const super::super::Foundation::RECT, prctarget: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::SetDrawParameters(this, core::mem::transmute_copy(&prcsource), core::mem::transmute_copy(&prctarget)).into()
            }
        }
        unsafe extern "system" fn GetNativeVideoProps<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::GetNativeVideoProps(this, core::mem::transmute_copy(&pdwvideowidth), core::mem::transmute_copy(&pdwvideoheight), core::mem::transmute_copy(&pdwpictaspectratiox), core::mem::transmute_copy(&pdwpictaspectratioy)).into()
            }
        }
        unsafe extern "system" fn SetCallbackInterface<Identity: IDDrawExclModeVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideo_Impl::SetCallbackInterface(this, core::mem::transmute_copy(&pcallback), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDDrawObject: SetDDrawObject::<Identity, OFFSET>,
            GetDDrawObject: GetDDrawObject::<Identity, OFFSET>,
            SetDDrawSurface: SetDDrawSurface::<Identity, OFFSET>,
            GetDDrawSurface: GetDDrawSurface::<Identity, OFFSET>,
            SetDrawParameters: SetDrawParameters::<Identity, OFFSET>,
            GetNativeVideoProps: GetNativeVideoProps::<Identity, OFFSET>,
            SetCallbackInterface: SetCallbackInterface::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDDrawExclModeVideo as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDDrawExclModeVideo {}
windows_core::imp::define_interface!(IDDrawExclModeVideoCallback, IDDrawExclModeVideoCallback_Vtbl, 0x913c24a0_20ab_11d2_9038_00a0c9697298);
windows_core::imp::interface_hierarchy!(IDDrawExclModeVideoCallback, windows_core::IUnknown);
impl IDDrawExclModeVideoCallback {
    pub unsafe fn OnUpdateOverlay(&self, bbefore: bool, dwflags: u32, boldvisible: bool, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: bool, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnUpdateOverlay)(windows_core::Interface::as_raw(self), bbefore.into(), dwflags, boldvisible.into(), prcoldsrc, prcolddest, bnewvisible.into(), prcnewsrc, prcnewdest).ok() }
    }
    pub unsafe fn OnUpdateColorKey(&self, pkey: *const COLORKEY, dwcolor: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnUpdateColorKey)(windows_core::Interface::as_raw(self), pkey, dwcolor).ok() }
    }
    pub unsafe fn OnUpdateSize(&self, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnUpdateSize)(windows_core::Interface::as_raw(self), dwwidth, dwheight, dwarwidth, dwarheight).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDDrawExclModeVideoCallback_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnUpdateOverlay: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL, u32, windows_core::BOOL, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT, windows_core::BOOL, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub OnUpdateColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *const COLORKEY, u32) -> windows_core::HRESULT,
    pub OnUpdateSize: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, u32) -> windows_core::HRESULT,
}
pub trait IDDrawExclModeVideoCallback_Impl: windows_core::IUnknownImpl {
    fn OnUpdateOverlay(&self, bbefore: windows_core::BOOL, dwflags: u32, boldvisible: windows_core::BOOL, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: windows_core::BOOL, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn OnUpdateColorKey(&self, pkey: *const COLORKEY, dwcolor: u32) -> windows_core::Result<()>;
    fn OnUpdateSize(&self, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> windows_core::Result<()>;
}
impl IDDrawExclModeVideoCallback_Vtbl {
    pub const fn new<Identity: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnUpdateOverlay<Identity: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bbefore: windows_core::BOOL, dwflags: u32, boldvisible: windows_core::BOOL, prcoldsrc: *const super::super::Foundation::RECT, prcolddest: *const super::super::Foundation::RECT, bnewvisible: windows_core::BOOL, prcnewsrc: *const super::super::Foundation::RECT, prcnewdest: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideoCallback_Impl::OnUpdateOverlay(this, core::mem::transmute_copy(&bbefore), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&boldvisible), core::mem::transmute_copy(&prcoldsrc), core::mem::transmute_copy(&prcolddest), core::mem::transmute_copy(&bnewvisible), core::mem::transmute_copy(&prcnewsrc), core::mem::transmute_copy(&prcnewdest)).into()
            }
        }
        unsafe extern "system" fn OnUpdateColorKey<Identity: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkey: *const COLORKEY, dwcolor: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideoCallback_Impl::OnUpdateColorKey(this, core::mem::transmute_copy(&pkey), core::mem::transmute_copy(&dwcolor)).into()
            }
        }
        unsafe extern "system" fn OnUpdateSize<Identity: IDDrawExclModeVideoCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwwidth: u32, dwheight: u32, dwarwidth: u32, dwarheight: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDDrawExclModeVideoCallback_Impl::OnUpdateSize(this, core::mem::transmute_copy(&dwwidth), core::mem::transmute_copy(&dwheight), core::mem::transmute_copy(&dwarwidth), core::mem::transmute_copy(&dwarheight)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnUpdateOverlay: OnUpdateOverlay::<Identity, OFFSET>,
            OnUpdateColorKey: OnUpdateColorKey::<Identity, OFFSET>,
            OnUpdateSize: OnUpdateSize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDDrawExclModeVideoCallback as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDDrawExclModeVideoCallback {}
windows_core::imp::define_interface!(IDMOWrapperFilter, IDMOWrapperFilter_Vtbl, 0x52d6f586_9f0f_4824_8fc8_e32ca04930c2);
windows_core::imp::interface_hierarchy!(IDMOWrapperFilter, windows_core::IUnknown);
impl IDMOWrapperFilter {
    pub unsafe fn Init(&self, clsiddmo: *const windows_core::GUID, catdmo: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Init)(windows_core::Interface::as_raw(self), clsiddmo, catdmo).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDMOWrapperFilter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Init: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IDMOWrapperFilter_Impl: windows_core::IUnknownImpl {
    fn Init(&self, clsiddmo: *const windows_core::GUID, catdmo: *const windows_core::GUID) -> windows_core::Result<()>;
}
impl IDMOWrapperFilter_Vtbl {
    pub const fn new<Identity: IDMOWrapperFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Init<Identity: IDMOWrapperFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsiddmo: *const windows_core::GUID, catdmo: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDMOWrapperFilter_Impl::Init(this, core::mem::transmute_copy(&clsiddmo), core::mem::transmute_copy(&catdmo)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Init: Init::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDMOWrapperFilter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDMOWrapperFilter {}
windows_core::imp::define_interface!(IDShowPlugin, IDShowPlugin_Vtbl, 0x4746b7c8_700e_11d1_becc_00c04fb6e937);
windows_core::imp::interface_hierarchy!(IDShowPlugin, windows_core::IUnknown);
impl IDShowPlugin {
    pub unsafe fn URL(&self, purl: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).URL)(windows_core::Interface::as_raw(self), core::mem::transmute(purl)).ok() }
    }
    pub unsafe fn UserAgent(&self, puseragent: *mut windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UserAgent)(windows_core::Interface::as_raw(self), core::mem::transmute(puseragent)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDShowPlugin_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub URL: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub UserAgent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IDShowPlugin_Impl: windows_core::IUnknownImpl {
    fn URL(&self, purl: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn UserAgent(&self, puseragent: *mut windows_core::BSTR) -> windows_core::Result<()>;
}
impl IDShowPlugin_Vtbl {
    pub const fn new<Identity: IDShowPlugin_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn URL<Identity: IDShowPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, purl: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDShowPlugin_Impl::URL(this, core::mem::transmute_copy(&purl)).into()
            }
        }
        unsafe extern "system" fn UserAgent<Identity: IDShowPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puseragent: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDShowPlugin_Impl::UserAgent(this, core::mem::transmute_copy(&puseragent)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), URL: URL::<Identity, OFFSET>, UserAgent: UserAgent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDShowPlugin as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDShowPlugin {}
windows_core::imp::define_interface!(IDVEnc, IDVEnc_Vtbl, 0xd18e17a0_aacb_11d0_afb0_00aa00b67a42);
windows_core::imp::interface_hierarchy!(IDVEnc, windows_core::IUnknown);
impl IDVEnc {
    pub unsafe fn get_IFormatResolution(&self, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_IFormatResolution)(windows_core::Interface::as_raw(self), videoformat as _, dvformat as _, resolution as _, fdvinfo, sdvinfo as _).ok() }
    }
    pub unsafe fn put_IFormatResolution(&self, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_IFormatResolution)(windows_core::Interface::as_raw(self), videoformat, dvformat, resolution, fdvinfo, sdvinfo).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDVEnc_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_IFormatResolution: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, u8, *mut DVINFO) -> windows_core::HRESULT,
    pub put_IFormatResolution: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32, u8, *const DVINFO) -> windows_core::HRESULT,
}
pub trait IDVEnc_Impl: windows_core::IUnknownImpl {
    fn get_IFormatResolution(&self, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> windows_core::Result<()>;
    fn put_IFormatResolution(&self, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> windows_core::Result<()>;
}
impl IDVEnc_Vtbl {
    pub const fn new<Identity: IDVEnc_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_IFormatResolution<Identity: IDVEnc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoformat: *mut i32, dvformat: *mut i32, resolution: *mut i32, fdvinfo: u8, sdvinfo: *mut DVINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDVEnc_Impl::get_IFormatResolution(this, core::mem::transmute_copy(&videoformat), core::mem::transmute_copy(&dvformat), core::mem::transmute_copy(&resolution), core::mem::transmute_copy(&fdvinfo), core::mem::transmute_copy(&sdvinfo)).into()
            }
        }
        unsafe extern "system" fn put_IFormatResolution<Identity: IDVEnc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoformat: i32, dvformat: i32, resolution: i32, fdvinfo: u8, sdvinfo: *const DVINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDVEnc_Impl::put_IFormatResolution(this, core::mem::transmute_copy(&videoformat), core::mem::transmute_copy(&dvformat), core::mem::transmute_copy(&resolution), core::mem::transmute_copy(&fdvinfo), core::mem::transmute_copy(&sdvinfo)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_IFormatResolution: get_IFormatResolution::<Identity, OFFSET>,
            put_IFormatResolution: put_IFormatResolution::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDVEnc as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDVEnc {}
windows_core::imp::define_interface!(IDVRGB219, IDVRGB219_Vtbl, 0x58473a19_2bc8_4663_8012_25f81babddd1);
windows_core::imp::interface_hierarchy!(IDVRGB219, windows_core::IUnknown);
impl IDVRGB219 {
    pub unsafe fn SetRGB219(&self, bstate: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRGB219)(windows_core::Interface::as_raw(self), bstate.into()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDVRGB219_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetRGB219: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IDVRGB219_Impl: windows_core::IUnknownImpl {
    fn SetRGB219(&self, bstate: windows_core::BOOL) -> windows_core::Result<()>;
}
impl IDVRGB219_Vtbl {
    pub const fn new<Identity: IDVRGB219_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetRGB219<Identity: IDVRGB219_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstate: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDVRGB219_Impl::SetRGB219(this, core::mem::transmute_copy(&bstate)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetRGB219: SetRGB219::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDVRGB219 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDVRGB219 {}
windows_core::imp::define_interface!(IDVSplitter, IDVSplitter_Vtbl, 0x92a3a302_da7c_4a1f_ba7e_1802bb5d2d02);
windows_core::imp::interface_hierarchy!(IDVSplitter, windows_core::IUnknown);
impl IDVSplitter {
    pub unsafe fn DiscardAlternateVideoFrames(&self, ndiscard: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DiscardAlternateVideoFrames)(windows_core::Interface::as_raw(self), ndiscard).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDVSplitter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub DiscardAlternateVideoFrames: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IDVSplitter_Impl: windows_core::IUnknownImpl {
    fn DiscardAlternateVideoFrames(&self, ndiscard: i32) -> windows_core::Result<()>;
}
impl IDVSplitter_Vtbl {
    pub const fn new<Identity: IDVSplitter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DiscardAlternateVideoFrames<Identity: IDVSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ndiscard: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDVSplitter_Impl::DiscardAlternateVideoFrames(this, core::mem::transmute_copy(&ndiscard)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), DiscardAlternateVideoFrames: DiscardAlternateVideoFrames::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDVSplitter as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDVSplitter {}
windows_core::imp::define_interface!(IDecimateVideoImage, IDecimateVideoImage_Vtbl, 0x2e5ea3e0_e924_11d2_b6da_00a0c995e8df);
windows_core::imp::interface_hierarchy!(IDecimateVideoImage, windows_core::IUnknown);
impl IDecimateVideoImage {
    pub unsafe fn SetDecimationImageSize(&self, lwidth: i32, lheight: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDecimationImageSize)(windows_core::Interface::as_raw(self), lwidth, lheight).ok() }
    }
    pub unsafe fn ResetDecimationImageSize(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ResetDecimationImageSize)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDecimateVideoImage_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetDecimationImageSize: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub ResetDecimationImageSize: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IDecimateVideoImage_Impl: windows_core::IUnknownImpl {
    fn SetDecimationImageSize(&self, lwidth: i32, lheight: i32) -> windows_core::Result<()>;
    fn ResetDecimationImageSize(&self) -> windows_core::Result<()>;
}
impl IDecimateVideoImage_Vtbl {
    pub const fn new<Identity: IDecimateVideoImage_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetDecimationImageSize<Identity: IDecimateVideoImage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lwidth: i32, lheight: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDecimateVideoImage_Impl::SetDecimationImageSize(this, core::mem::transmute_copy(&lwidth), core::mem::transmute_copy(&lheight)).into()
            }
        }
        unsafe extern "system" fn ResetDecimationImageSize<Identity: IDecimateVideoImage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDecimateVideoImage_Impl::ResetDecimationImageSize(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDecimationImageSize: SetDecimationImageSize::<Identity, OFFSET>,
            ResetDecimationImageSize: ResetDecimationImageSize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDecimateVideoImage as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDecimateVideoImage {}
windows_core::imp::define_interface!(IDeferredCommand, IDeferredCommand_Vtbl, 0x56a868b8_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IDeferredCommand, windows_core::IUnknown);
impl IDeferredCommand {
    pub unsafe fn Cancel(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Cancel)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Confidence(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Confidence)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Postpone(&self, newtime: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Postpone)(windows_core::Interface::as_raw(self), newtime).ok() }
    }
    pub unsafe fn GetHResult(&self) -> windows_core::Result<windows_core::HRESULT> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetHResult)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDeferredCommand_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Cancel: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Confidence: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Postpone: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GetHResult: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::HRESULT) -> windows_core::HRESULT,
}
pub trait IDeferredCommand_Impl: windows_core::IUnknownImpl {
    fn Cancel(&self) -> windows_core::Result<()>;
    fn Confidence(&self) -> windows_core::Result<i32>;
    fn Postpone(&self, newtime: f64) -> windows_core::Result<()>;
    fn GetHResult(&self) -> windows_core::Result<windows_core::HRESULT>;
}
impl IDeferredCommand_Vtbl {
    pub const fn new<Identity: IDeferredCommand_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Cancel<Identity: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDeferredCommand_Impl::Cancel(this).into()
            }
        }
        unsafe extern "system" fn Confidence<Identity: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pconfidence: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDeferredCommand_Impl::Confidence(this) {
                    Ok(ok__) => {
                        pconfidence.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Postpone<Identity: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, newtime: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDeferredCommand_Impl::Postpone(this, core::mem::transmute_copy(&newtime)).into()
            }
        }
        unsafe extern "system" fn GetHResult<Identity: IDeferredCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phrresult: *mut windows_core::HRESULT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDeferredCommand_Impl::GetHResult(this) {
                    Ok(ok__) => {
                        phrresult.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Cancel: Cancel::<Identity, OFFSET>,
            Confidence: Confidence::<Identity, OFFSET>,
            Postpone: Postpone::<Identity, OFFSET>,
            GetHResult: GetHResult::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDeferredCommand as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDeferredCommand {}
windows_core::imp::define_interface!(IDirectDrawMediaSample, IDirectDrawMediaSample_Vtbl, 0xab6b4afe_f6e4_11d0_900d_00c04fd9189d);
windows_core::imp::interface_hierarchy!(IDirectDrawMediaSample, windows_core::IUnknown);
impl IDirectDrawMediaSample {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetSurfaceAndReleaseLock(&self, ppdirectdrawsurface: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSurfaceAndReleaseLock)(windows_core::Interface::as_raw(self), core::mem::transmute(ppdirectdrawsurface), prect as _).ok() }
    }
    pub unsafe fn LockMediaSamplePointer(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LockMediaSamplePointer)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectDrawMediaSample_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetSurfaceAndReleaseLock: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetSurfaceAndReleaseLock: usize,
    pub LockMediaSamplePointer: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawMediaSample_Impl: windows_core::IUnknownImpl {
    fn GetSurfaceAndReleaseLock(&self, ppdirectdrawsurface: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn LockMediaSamplePointer(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawMediaSample_Vtbl {
    pub const fn new<Identity: IDirectDrawMediaSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetSurfaceAndReleaseLock<Identity: IDirectDrawMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirectdrawsurface: *mut *mut core::ffi::c_void, prect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawMediaSample_Impl::GetSurfaceAndReleaseLock(this, core::mem::transmute_copy(&ppdirectdrawsurface), core::mem::transmute_copy(&prect)).into()
            }
        }
        unsafe extern "system" fn LockMediaSamplePointer<Identity: IDirectDrawMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawMediaSample_Impl::LockMediaSamplePointer(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSurfaceAndReleaseLock: GetSurfaceAndReleaseLock::<Identity, OFFSET>,
            LockMediaSamplePointer: LockMediaSamplePointer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectDrawMediaSample as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDirectDrawMediaSample {}
windows_core::imp::define_interface!(IDirectDrawMediaSampleAllocator, IDirectDrawMediaSampleAllocator_Vtbl, 0xab6b4afc_f6e4_11d0_900d_00c04fd9189d);
windows_core::imp::interface_hierarchy!(IDirectDrawMediaSampleAllocator, windows_core::IUnknown);
impl IDirectDrawMediaSampleAllocator {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDirectDraw)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectDrawMediaSampleAllocator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetDirectDraw: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetDirectDraw: usize,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawMediaSampleAllocator_Impl: windows_core::IUnknownImpl {
    fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawMediaSampleAllocator_Vtbl {
    pub const fn new<Identity: IDirectDrawMediaSampleAllocator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDirectDraw<Identity: IDirectDrawMediaSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirectdraw: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawMediaSampleAllocator_Impl::GetDirectDraw(this) {
                    Ok(ok__) => {
                        ppdirectdraw.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetDirectDraw: GetDirectDraw::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectDrawMediaSampleAllocator as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDirectDrawMediaSampleAllocator {}
windows_core::imp::define_interface!(IDirectDrawMediaStream, IDirectDrawMediaStream_Vtbl, 0xf4104fce_9a70_11d0_8fde_00c04fd9189d);
impl core::ops::Deref for IDirectDrawMediaStream {
    type Target = IMediaStream;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IDirectDrawMediaStream, windows_core::IUnknown, IMediaStream);
impl IDirectDrawMediaStream {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetFormat(&self, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawPalette>, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFormat)(windows_core::Interface::as_raw(self), pddsdcurrent as _, core::mem::transmute(ppdirectdrawpalette), pddsddesired as _, pdwflags as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetFormat<P1>(&self, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawPalette>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFormat)(windows_core::Interface::as_raw(self), pddsurfacedesc, pdirectdrawpalette.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDirectDraw)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetDirectDraw<P0>(&self, pdirectdraw: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDirectDraw)(windows_core::Interface::as_raw(self), pdirectdraw.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn CreateSample<P0>(&self, psurface: P0, prect: *const super::super::Foundation::RECT, dwflags: u32) -> windows_core::Result<IDirectDrawStreamSample>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateSample)(windows_core::Interface::as_raw(self), psurface.param().abi(), prect, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetTimePerFrame(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTimePerFrame)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectDrawMediaStream_Vtbl {
    pub base__: IMediaStream_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, *mut *mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetFormat: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Graphics::DirectDraw::DDSURFACEDESC, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetFormat: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetDirectDraw: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetDirectDraw: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetDirectDraw: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetDirectDraw: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub CreateSample: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const super::super::Foundation::RECT, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    CreateSample: usize,
    pub GetTimePerFrame: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawMediaStream_Impl: IMediaStream_Impl {
    fn GetFormat(&self, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawPalette>, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> windows_core::Result<()>;
    fn SetFormat(&self, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawPalette>) -> windows_core::Result<()>;
    fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
    fn SetDirectDraw(&self, pdirectdraw: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw>) -> windows_core::Result<()>;
    fn CreateSample(&self, psurface: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *const super::super::Foundation::RECT, dwflags: u32) -> windows_core::Result<IDirectDrawStreamSample>;
    fn GetTimePerFrame(&self) -> windows_core::Result<i64>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawMediaStream_Vtbl {
    pub const fn new<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFormat<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pddsdcurrent: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, ppdirectdrawpalette: *mut *mut core::ffi::c_void, pddsddesired: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawMediaStream_Impl::GetFormat(this, core::mem::transmute_copy(&pddsdcurrent), core::mem::transmute_copy(&ppdirectdrawpalette), core::mem::transmute_copy(&pddsddesired), core::mem::transmute_copy(&pdwflags)).into()
            }
        }
        unsafe extern "system" fn SetFormat<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pddsurfacedesc: *const super::super::Graphics::DirectDraw::DDSURFACEDESC, pdirectdrawpalette: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawMediaStream_Impl::SetFormat(this, core::mem::transmute_copy(&pddsurfacedesc), core::mem::transmute_copy(&pdirectdrawpalette)).into()
            }
        }
        unsafe extern "system" fn GetDirectDraw<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirectdraw: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawMediaStream_Impl::GetDirectDraw(this) {
                    Ok(ok__) => {
                        ppdirectdraw.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDirectDraw<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdirectdraw: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawMediaStream_Impl::SetDirectDraw(this, core::mem::transmute_copy(&pdirectdraw)).into()
            }
        }
        unsafe extern "system" fn CreateSample<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psurface: *mut core::ffi::c_void, prect: *const super::super::Foundation::RECT, dwflags: u32, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawMediaStream_Impl::CreateSample(this, core::mem::transmute_copy(&psurface), core::mem::transmute_copy(&prect), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppsample.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTimePerFrame<Identity: IDirectDrawMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pframetime: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawMediaStream_Impl::GetTimePerFrame(this) {
                    Ok(ok__) => {
                        pframetime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IMediaStream_Vtbl::new::<Identity, OFFSET>(),
            GetFormat: GetFormat::<Identity, OFFSET>,
            SetFormat: SetFormat::<Identity, OFFSET>,
            GetDirectDraw: GetDirectDraw::<Identity, OFFSET>,
            SetDirectDraw: SetDirectDraw::<Identity, OFFSET>,
            CreateSample: CreateSample::<Identity, OFFSET>,
            GetTimePerFrame: GetTimePerFrame::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectDrawMediaStream as windows_core::Interface>::IID || iid == &<IMediaStream as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDirectDrawMediaStream {}
windows_core::imp::define_interface!(IDirectDrawStreamSample, IDirectDrawStreamSample_Vtbl, 0xf4104fcf_9a70_11d0_8fde_00c04fd9189d);
impl core::ops::Deref for IDirectDrawStreamSample {
    type Target = IStreamSample;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IDirectDrawStreamSample, windows_core::IUnknown, IStreamSample);
impl IDirectDrawStreamSample {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetSurface(&self, ppdirectdrawsurface: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSurface)(windows_core::Interface::as_raw(self), core::mem::transmute(ppdirectdrawsurface), prect as _).ok() }
    }
    pub unsafe fn SetRect(&self, prect: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRect)(windows_core::Interface::as_raw(self), prect).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectDrawStreamSample_Vtbl {
    pub base__: IStreamSample_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetSurface: usize,
    pub SetRect: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawStreamSample_Impl: IStreamSample_Impl {
    fn GetSurface(&self, ppdirectdrawsurface: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawSurface>, prect: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn SetRect(&self, prect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawStreamSample_Vtbl {
    pub const fn new<Identity: IDirectDrawStreamSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetSurface<Identity: IDirectDrawStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirectdrawsurface: *mut *mut core::ffi::c_void, prect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawStreamSample_Impl::GetSurface(this, core::mem::transmute_copy(&ppdirectdrawsurface), core::mem::transmute_copy(&prect)).into()
            }
        }
        unsafe extern "system" fn SetRect<Identity: IDirectDrawStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawStreamSample_Impl::SetRect(this, core::mem::transmute_copy(&prect)).into()
            }
        }
        Self { base__: IStreamSample_Vtbl::new::<Identity, OFFSET>(), GetSurface: GetSurface::<Identity, OFFSET>, SetRect: SetRect::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectDrawStreamSample as windows_core::Interface>::IID || iid == &<IStreamSample as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDirectDrawStreamSample {}
windows_core::imp::define_interface!(IDirectDrawVideo, IDirectDrawVideo_Vtbl, 0x36d39eb0_dd75_11ce_bf0e_00aa0055595a);
windows_core::imp::interface_hierarchy!(IDirectDrawVideo, windows_core::IUnknown);
impl IDirectDrawVideo {
    pub unsafe fn GetSwitches(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSwitches)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSwitches(&self, switches: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSwitches)(windows_core::Interface::as_raw(self), switches).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetCaps(&self, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCaps)(windows_core::Interface::as_raw(self), pcaps as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetEmulatedCaps(&self, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetEmulatedCaps)(windows_core::Interface::as_raw(self), pcaps as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetSurfaceDesc(&self, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSurfaceDesc)(windows_core::Interface::as_raw(self), psurfacedesc as _).ok() }
    }
    pub unsafe fn GetFourCCCodes(&self, pcount: *mut u32, pcodes: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetFourCCCodes)(windows_core::Interface::as_raw(self), pcount as _, pcodes as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetDirectDraw<P0>(&self, pdirectdraw: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDirectDraw)(windows_core::Interface::as_raw(self), pdirectdraw.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDirectDraw)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetSurfaceType(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSurfaceType)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDefault(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefault)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn UseScanLine(&self, usescanline: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UseScanLine)(windows_core::Interface::as_raw(self), usescanline).ok() }
    }
    pub unsafe fn CanUseScanLine(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CanUseScanLine)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn UseOverlayStretch(&self, useoverlaystretch: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UseOverlayStretch)(windows_core::Interface::as_raw(self), useoverlaystretch).ok() }
    }
    pub unsafe fn CanUseOverlayStretch(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CanUseOverlayStretch)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn UseWhenFullScreen(&self, usewhenfullscreen: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UseWhenFullScreen)(windows_core::Interface::as_raw(self), usewhenfullscreen).ok() }
    }
    pub unsafe fn WillUseFullScreen(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WillUseFullScreen)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectDrawVideo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetSwitches: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetSwitches: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetCaps: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetEmulatedCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetEmulatedCaps: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetSurfaceDesc: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetSurfaceDesc: usize,
    pub GetFourCCCodes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetDirectDraw: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetDirectDraw: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetDirectDraw: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetDirectDraw: usize,
    pub GetSurfaceType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDefault: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub UseScanLine: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub CanUseScanLine: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub UseOverlayStretch: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub CanUseOverlayStretch: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub UseWhenFullScreen: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub WillUseFullScreen: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IDirectDrawVideo_Impl: windows_core::IUnknownImpl {
    fn GetSwitches(&self) -> windows_core::Result<u32>;
    fn SetSwitches(&self, switches: u32) -> windows_core::Result<()>;
    fn GetCaps(&self, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::Result<()>;
    fn GetEmulatedCaps(&self, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::Result<()>;
    fn GetSurfaceDesc(&self, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> windows_core::Result<()>;
    fn GetFourCCCodes(&self, pcount: *mut u32, pcodes: *mut u32) -> windows_core::Result<()>;
    fn SetDirectDraw(&self, pdirectdraw: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw>) -> windows_core::Result<()>;
    fn GetDirectDraw(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDraw>;
    fn GetSurfaceType(&self) -> windows_core::Result<u32>;
    fn SetDefault(&self) -> windows_core::Result<()>;
    fn UseScanLine(&self, usescanline: i32) -> windows_core::Result<()>;
    fn CanUseScanLine(&self) -> windows_core::Result<i32>;
    fn UseOverlayStretch(&self, useoverlaystretch: i32) -> windows_core::Result<()>;
    fn CanUseOverlayStretch(&self) -> windows_core::Result<i32>;
    fn UseWhenFullScreen(&self, usewhenfullscreen: i32) -> windows_core::Result<()>;
    fn WillUseFullScreen(&self) -> windows_core::Result<i32>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IDirectDrawVideo_Vtbl {
    pub const fn new<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetSwitches<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pswitches: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::GetSwitches(this) {
                    Ok(ok__) => {
                        pswitches.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSwitches<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, switches: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::SetSwitches(this, core::mem::transmute_copy(&switches)).into()
            }
        }
        unsafe extern "system" fn GetCaps<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::GetCaps(this, core::mem::transmute_copy(&pcaps)).into()
            }
        }
        unsafe extern "system" fn GetEmulatedCaps<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcaps: *mut super::super::Graphics::DirectDraw::DDCAPS_DX7) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::GetEmulatedCaps(this, core::mem::transmute_copy(&pcaps)).into()
            }
        }
        unsafe extern "system" fn GetSurfaceDesc<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psurfacedesc: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::GetSurfaceDesc(this, core::mem::transmute_copy(&psurfacedesc)).into()
            }
        }
        unsafe extern "system" fn GetFourCCCodes<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcount: *mut u32, pcodes: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::GetFourCCCodes(this, core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pcodes)).into()
            }
        }
        unsafe extern "system" fn SetDirectDraw<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdirectdraw: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::SetDirectDraw(this, core::mem::transmute_copy(&pdirectdraw)).into()
            }
        }
        unsafe extern "system" fn GetDirectDraw<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirectdraw: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::GetDirectDraw(this) {
                    Ok(ok__) => {
                        ppdirectdraw.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSurfaceType<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psurfacetype: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::GetSurfaceType(this) {
                    Ok(ok__) => {
                        psurfacetype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDefault<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::SetDefault(this).into()
            }
        }
        unsafe extern "system" fn UseScanLine<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usescanline: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::UseScanLine(this, core::mem::transmute_copy(&usescanline)).into()
            }
        }
        unsafe extern "system" fn CanUseScanLine<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usescanline: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::CanUseScanLine(this) {
                    Ok(ok__) => {
                        usescanline.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn UseOverlayStretch<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, useoverlaystretch: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::UseOverlayStretch(this, core::mem::transmute_copy(&useoverlaystretch)).into()
            }
        }
        unsafe extern "system" fn CanUseOverlayStretch<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, useoverlaystretch: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::CanUseOverlayStretch(this) {
                    Ok(ok__) => {
                        useoverlaystretch.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn UseWhenFullScreen<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usewhenfullscreen: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDirectDrawVideo_Impl::UseWhenFullScreen(this, core::mem::transmute_copy(&usewhenfullscreen)).into()
            }
        }
        unsafe extern "system" fn WillUseFullScreen<Identity: IDirectDrawVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, usewhenfullscreen: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDirectDrawVideo_Impl::WillUseFullScreen(this) {
                    Ok(ok__) => {
                        usewhenfullscreen.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSwitches: GetSwitches::<Identity, OFFSET>,
            SetSwitches: SetSwitches::<Identity, OFFSET>,
            GetCaps: GetCaps::<Identity, OFFSET>,
            GetEmulatedCaps: GetEmulatedCaps::<Identity, OFFSET>,
            GetSurfaceDesc: GetSurfaceDesc::<Identity, OFFSET>,
            GetFourCCCodes: GetFourCCCodes::<Identity, OFFSET>,
            SetDirectDraw: SetDirectDraw::<Identity, OFFSET>,
            GetDirectDraw: GetDirectDraw::<Identity, OFFSET>,
            GetSurfaceType: GetSurfaceType::<Identity, OFFSET>,
            SetDefault: SetDefault::<Identity, OFFSET>,
            UseScanLine: UseScanLine::<Identity, OFFSET>,
            CanUseScanLine: CanUseScanLine::<Identity, OFFSET>,
            UseOverlayStretch: UseOverlayStretch::<Identity, OFFSET>,
            CanUseOverlayStretch: CanUseOverlayStretch::<Identity, OFFSET>,
            UseWhenFullScreen: UseWhenFullScreen::<Identity, OFFSET>,
            WillUseFullScreen: WillUseFullScreen::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectDrawVideo as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IDirectDrawVideo {}
windows_core::imp::define_interface!(IDistributorNotify, IDistributorNotify_Vtbl, 0x56a868af_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IDistributorNotify, windows_core::IUnknown);
impl IDistributorNotify {
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Pause(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Pause)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Run(&self, tstart: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Run)(windows_core::Interface::as_raw(self), tstart).ok() }
    }
    pub unsafe fn SetSyncSource<P0>(&self, pclock: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::IReferenceClock>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetSyncSource)(windows_core::Interface::as_raw(self), pclock.param().abi()).ok() }
    }
    pub unsafe fn NotifyGraphChange(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyGraphChange)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDistributorNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Pause: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Run: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub SetSyncSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NotifyGraphChange: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IDistributorNotify_Impl: windows_core::IUnknownImpl {
    fn Stop(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Run(&self, tstart: i64) -> windows_core::Result<()>;
    fn SetSyncSource(&self, pclock: windows_core::Ref<super::IReferenceClock>) -> windows_core::Result<()>;
    fn NotifyGraphChange(&self) -> windows_core::Result<()>;
}
impl IDistributorNotify_Vtbl {
    pub const fn new<Identity: IDistributorNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Stop<Identity: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDistributorNotify_Impl::Stop(this).into()
            }
        }
        unsafe extern "system" fn Pause<Identity: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDistributorNotify_Impl::Pause(this).into()
            }
        }
        unsafe extern "system" fn Run<Identity: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tstart: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDistributorNotify_Impl::Run(this, core::mem::transmute_copy(&tstart)).into()
            }
        }
        unsafe extern "system" fn SetSyncSource<Identity: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDistributorNotify_Impl::SetSyncSource(this, core::mem::transmute_copy(&pclock)).into()
            }
        }
        unsafe extern "system" fn NotifyGraphChange<Identity: IDistributorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDistributorNotify_Impl::NotifyGraphChange(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Stop: Stop::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Run: Run::<Identity, OFFSET>,
            SetSyncSource: SetSyncSource::<Identity, OFFSET>,
            NotifyGraphChange: NotifyGraphChange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDistributorNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDistributorNotify {}
windows_core::imp::define_interface!(IDrawVideoImage, IDrawVideoImage_Vtbl, 0x48efb120_ab49_11d2_aed2_00a0c995e8d5);
windows_core::imp::interface_hierarchy!(IDrawVideoImage, windows_core::IUnknown);
impl IDrawVideoImage {
    pub unsafe fn DrawVideoImageBegin(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DrawVideoImageBegin)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn DrawVideoImageEnd(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DrawVideoImageEnd)(windows_core::Interface::as_raw(self)).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn DrawVideoImageDraw(&self, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DrawVideoImageDraw)(windows_core::Interface::as_raw(self), hdc, lprcsrc, lprcdst).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDrawVideoImage_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub DrawVideoImageBegin: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub DrawVideoImageEnd: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub DrawVideoImageDraw: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Graphics::Gdi::HDC, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    DrawVideoImageDraw: usize,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IDrawVideoImage_Impl: windows_core::IUnknownImpl {
    fn DrawVideoImageBegin(&self) -> windows_core::Result<()>;
    fn DrawVideoImageEnd(&self) -> windows_core::Result<()>;
    fn DrawVideoImageDraw(&self, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IDrawVideoImage_Vtbl {
    pub const fn new<Identity: IDrawVideoImage_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DrawVideoImageBegin<Identity: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDrawVideoImage_Impl::DrawVideoImageBegin(this).into()
            }
        }
        unsafe extern "system" fn DrawVideoImageEnd<Identity: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDrawVideoImage_Impl::DrawVideoImageEnd(this).into()
            }
        }
        unsafe extern "system" fn DrawVideoImageDraw<Identity: IDrawVideoImage_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdc: super::super::Graphics::Gdi::HDC, lprcsrc: *const super::super::Foundation::RECT, lprcdst: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDrawVideoImage_Impl::DrawVideoImageDraw(this, core::mem::transmute_copy(&hdc), core::mem::transmute_copy(&lprcsrc), core::mem::transmute_copy(&lprcdst)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            DrawVideoImageBegin: DrawVideoImageBegin::<Identity, OFFSET>,
            DrawVideoImageEnd: DrawVideoImageEnd::<Identity, OFFSET>,
            DrawVideoImageDraw: DrawVideoImageDraw::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDrawVideoImage as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IDrawVideoImage {}
windows_core::imp::define_interface!(IDvdCmd, IDvdCmd_Vtbl, 0x5a4a97e4_94ee_4a55_9751_74b5643aa27d);
windows_core::imp::interface_hierarchy!(IDvdCmd, windows_core::IUnknown);
impl IDvdCmd {
    pub unsafe fn WaitForStart(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WaitForStart)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn WaitForEnd(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WaitForEnd)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdCmd_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub WaitForStart: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub WaitForEnd: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IDvdCmd_Impl: windows_core::IUnknownImpl {
    fn WaitForStart(&self) -> windows_core::Result<()>;
    fn WaitForEnd(&self) -> windows_core::Result<()>;
}
impl IDvdCmd_Vtbl {
    pub const fn new<Identity: IDvdCmd_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn WaitForStart<Identity: IDvdCmd_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdCmd_Impl::WaitForStart(this).into()
            }
        }
        unsafe extern "system" fn WaitForEnd<Identity: IDvdCmd_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdCmd_Impl::WaitForEnd(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            WaitForStart: WaitForStart::<Identity, OFFSET>,
            WaitForEnd: WaitForEnd::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdCmd as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdCmd {}
windows_core::imp::define_interface!(IDvdControl, IDvdControl_Vtbl, 0xa70efe61_e2a3_11d0_a9be_00aa0061be93);
windows_core::imp::interface_hierarchy!(IDvdControl, windows_core::IUnknown);
impl IDvdControl {
    pub unsafe fn TitlePlay(&self, ultitle: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TitlePlay)(windows_core::Interface::as_raw(self), ultitle).ok() }
    }
    pub unsafe fn ChapterPlay(&self, ultitle: u32, ulchapter: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChapterPlay)(windows_core::Interface::as_raw(self), ultitle, ulchapter).ok() }
    }
    pub unsafe fn TimePlay(&self, ultitle: u32, bcdtime: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TimePlay)(windows_core::Interface::as_raw(self), ultitle, bcdtime).ok() }
    }
    pub unsafe fn StopForResume(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StopForResume)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GoUp(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GoUp)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn TimeSearch(&self, bcdtime: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TimeSearch)(windows_core::Interface::as_raw(self), bcdtime).ok() }
    }
    pub unsafe fn ChapterSearch(&self, ulchapter: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChapterSearch)(windows_core::Interface::as_raw(self), ulchapter).ok() }
    }
    pub unsafe fn PrevPGSearch(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PrevPGSearch)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn TopPGSearch(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TopPGSearch)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn NextPGSearch(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NextPGSearch)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ForwardScan(&self, dwspeed: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ForwardScan)(windows_core::Interface::as_raw(self), dwspeed).ok() }
    }
    pub unsafe fn BackwardScan(&self, dwspeed: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BackwardScan)(windows_core::Interface::as_raw(self), dwspeed).ok() }
    }
    pub unsafe fn MenuCall(&self, menuid: DVD_MENU_ID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MenuCall)(windows_core::Interface::as_raw(self), menuid).ok() }
    }
    pub unsafe fn Resume(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Resume)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn UpperButtonSelect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UpperButtonSelect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn LowerButtonSelect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LowerButtonSelect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn LeftButtonSelect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).LeftButtonSelect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn RightButtonSelect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RightButtonSelect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ButtonActivate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ButtonActivate)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ButtonSelectAndActivate(&self, ulbutton: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ButtonSelectAndActivate)(windows_core::Interface::as_raw(self), ulbutton).ok() }
    }
    pub unsafe fn StillOff(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StillOff)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn PauseOn(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PauseOn)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn PauseOff(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PauseOff)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn MenuLanguageSelect(&self, language: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MenuLanguageSelect)(windows_core::Interface::as_raw(self), language).ok() }
    }
    pub unsafe fn AudioStreamChange(&self, ulaudio: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AudioStreamChange)(windows_core::Interface::as_raw(self), ulaudio).ok() }
    }
    pub unsafe fn SubpictureStreamChange(&self, ulsubpicture: u32, bdisplay: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SubpictureStreamChange)(windows_core::Interface::as_raw(self), ulsubpicture, bdisplay.into()).ok() }
    }
    pub unsafe fn AngleChange(&self, ulangle: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AngleChange)(windows_core::Interface::as_raw(self), ulangle).ok() }
    }
    pub unsafe fn ParentalLevelSelect(&self, ulparentallevel: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ParentalLevelSelect)(windows_core::Interface::as_raw(self), ulparentallevel).ok() }
    }
    pub unsafe fn ParentalCountrySelect(&self, wcountry: u16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ParentalCountrySelect)(windows_core::Interface::as_raw(self), wcountry).ok() }
    }
    pub unsafe fn KaraokeAudioPresentationModeChange(&self, ulmode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).KaraokeAudioPresentationModeChange)(windows_core::Interface::as_raw(self), ulmode).ok() }
    }
    pub unsafe fn VideoModePreferrence(&self, ulpreferreddisplaymode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).VideoModePreferrence)(windows_core::Interface::as_raw(self), ulpreferreddisplaymode).ok() }
    }
    pub unsafe fn SetRoot<P0>(&self, pszpath: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetRoot)(windows_core::Interface::as_raw(self), pszpath.param().abi()).ok() }
    }
    pub unsafe fn MouseActivate(&self, point: super::super::Foundation::POINT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MouseActivate)(windows_core::Interface::as_raw(self), core::mem::transmute(point)).ok() }
    }
    pub unsafe fn MouseSelect(&self, point: super::super::Foundation::POINT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MouseSelect)(windows_core::Interface::as_raw(self), core::mem::transmute(point)).ok() }
    }
    pub unsafe fn ChapterPlayAutoStop(&self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ChapterPlayAutoStop)(windows_core::Interface::as_raw(self), ultitle, ulchapter, ulchapterstoplay).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub TitlePlay: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub ChapterPlay: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub TimePlay: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub StopForResume: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GoUp: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub TimeSearch: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub ChapterSearch: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub PrevPGSearch: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub TopPGSearch: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NextPGSearch: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ForwardScan: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub BackwardScan: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub MenuCall: unsafe extern "system" fn(*mut core::ffi::c_void, DVD_MENU_ID) -> windows_core::HRESULT,
    pub Resume: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub UpperButtonSelect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LowerButtonSelect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LeftButtonSelect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RightButtonSelect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ButtonActivate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ButtonSelectAndActivate: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub StillOff: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PauseOn: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PauseOff: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MenuLanguageSelect: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub AudioStreamChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SubpictureStreamChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32, windows_core::BOOL) -> windows_core::HRESULT,
    pub AngleChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub ParentalLevelSelect: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub ParentalCountrySelect: unsafe extern "system" fn(*mut core::ffi::c_void, u16) -> windows_core::HRESULT,
    pub KaraokeAudioPresentationModeChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub VideoModePreferrence: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetRoot: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub MouseActivate: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::POINT) -> windows_core::HRESULT,
    pub MouseSelect: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::POINT) -> windows_core::HRESULT,
    pub ChapterPlayAutoStop: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32) -> windows_core::HRESULT,
}
pub trait IDvdControl_Impl: windows_core::IUnknownImpl {
    fn TitlePlay(&self, ultitle: u32) -> windows_core::Result<()>;
    fn ChapterPlay(&self, ultitle: u32, ulchapter: u32) -> windows_core::Result<()>;
    fn TimePlay(&self, ultitle: u32, bcdtime: u32) -> windows_core::Result<()>;
    fn StopForResume(&self) -> windows_core::Result<()>;
    fn GoUp(&self) -> windows_core::Result<()>;
    fn TimeSearch(&self, bcdtime: u32) -> windows_core::Result<()>;
    fn ChapterSearch(&self, ulchapter: u32) -> windows_core::Result<()>;
    fn PrevPGSearch(&self) -> windows_core::Result<()>;
    fn TopPGSearch(&self) -> windows_core::Result<()>;
    fn NextPGSearch(&self) -> windows_core::Result<()>;
    fn ForwardScan(&self, dwspeed: f64) -> windows_core::Result<()>;
    fn BackwardScan(&self, dwspeed: f64) -> windows_core::Result<()>;
    fn MenuCall(&self, menuid: DVD_MENU_ID) -> windows_core::Result<()>;
    fn Resume(&self) -> windows_core::Result<()>;
    fn UpperButtonSelect(&self) -> windows_core::Result<()>;
    fn LowerButtonSelect(&self) -> windows_core::Result<()>;
    fn LeftButtonSelect(&self) -> windows_core::Result<()>;
    fn RightButtonSelect(&self) -> windows_core::Result<()>;
    fn ButtonActivate(&self) -> windows_core::Result<()>;
    fn ButtonSelectAndActivate(&self, ulbutton: u32) -> windows_core::Result<()>;
    fn StillOff(&self) -> windows_core::Result<()>;
    fn PauseOn(&self) -> windows_core::Result<()>;
    fn PauseOff(&self) -> windows_core::Result<()>;
    fn MenuLanguageSelect(&self, language: u32) -> windows_core::Result<()>;
    fn AudioStreamChange(&self, ulaudio: u32) -> windows_core::Result<()>;
    fn SubpictureStreamChange(&self, ulsubpicture: u32, bdisplay: windows_core::BOOL) -> windows_core::Result<()>;
    fn AngleChange(&self, ulangle: u32) -> windows_core::Result<()>;
    fn ParentalLevelSelect(&self, ulparentallevel: u32) -> windows_core::Result<()>;
    fn ParentalCountrySelect(&self, wcountry: u16) -> windows_core::Result<()>;
    fn KaraokeAudioPresentationModeChange(&self, ulmode: u32) -> windows_core::Result<()>;
    fn VideoModePreferrence(&self, ulpreferreddisplaymode: u32) -> windows_core::Result<()>;
    fn SetRoot(&self, pszpath: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn MouseActivate(&self, point: &super::super::Foundation::POINT) -> windows_core::Result<()>;
    fn MouseSelect(&self, point: &super::super::Foundation::POINT) -> windows_core::Result<()>;
    fn ChapterPlayAutoStop(&self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> windows_core::Result<()>;
}
impl IDvdControl_Vtbl {
    pub const fn new<Identity: IDvdControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn TitlePlay<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::TitlePlay(this, core::mem::transmute_copy(&ultitle)).into()
            }
        }
        unsafe extern "system" fn ChapterPlay<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, ulchapter: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ChapterPlay(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&ulchapter)).into()
            }
        }
        unsafe extern "system" fn TimePlay<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, bcdtime: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::TimePlay(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&bcdtime)).into()
            }
        }
        unsafe extern "system" fn StopForResume<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::StopForResume(this).into()
            }
        }
        unsafe extern "system" fn GoUp<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::GoUp(this).into()
            }
        }
        unsafe extern "system" fn TimeSearch<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bcdtime: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::TimeSearch(this, core::mem::transmute_copy(&bcdtime)).into()
            }
        }
        unsafe extern "system" fn ChapterSearch<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulchapter: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ChapterSearch(this, core::mem::transmute_copy(&ulchapter)).into()
            }
        }
        unsafe extern "system" fn PrevPGSearch<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::PrevPGSearch(this).into()
            }
        }
        unsafe extern "system" fn TopPGSearch<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::TopPGSearch(this).into()
            }
        }
        unsafe extern "system" fn NextPGSearch<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::NextPGSearch(this).into()
            }
        }
        unsafe extern "system" fn ForwardScan<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwspeed: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ForwardScan(this, core::mem::transmute_copy(&dwspeed)).into()
            }
        }
        unsafe extern "system" fn BackwardScan<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwspeed: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::BackwardScan(this, core::mem::transmute_copy(&dwspeed)).into()
            }
        }
        unsafe extern "system" fn MenuCall<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, menuid: DVD_MENU_ID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::MenuCall(this, core::mem::transmute_copy(&menuid)).into()
            }
        }
        unsafe extern "system" fn Resume<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::Resume(this).into()
            }
        }
        unsafe extern "system" fn UpperButtonSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::UpperButtonSelect(this).into()
            }
        }
        unsafe extern "system" fn LowerButtonSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::LowerButtonSelect(this).into()
            }
        }
        unsafe extern "system" fn LeftButtonSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::LeftButtonSelect(this).into()
            }
        }
        unsafe extern "system" fn RightButtonSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::RightButtonSelect(this).into()
            }
        }
        unsafe extern "system" fn ButtonActivate<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ButtonActivate(this).into()
            }
        }
        unsafe extern "system" fn ButtonSelectAndActivate<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbutton: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ButtonSelectAndActivate(this, core::mem::transmute_copy(&ulbutton)).into()
            }
        }
        unsafe extern "system" fn StillOff<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::StillOff(this).into()
            }
        }
        unsafe extern "system" fn PauseOn<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::PauseOn(this).into()
            }
        }
        unsafe extern "system" fn PauseOff<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::PauseOff(this).into()
            }
        }
        unsafe extern "system" fn MenuLanguageSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, language: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::MenuLanguageSelect(this, core::mem::transmute_copy(&language)).into()
            }
        }
        unsafe extern "system" fn AudioStreamChange<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulaudio: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::AudioStreamChange(this, core::mem::transmute_copy(&ulaudio)).into()
            }
        }
        unsafe extern "system" fn SubpictureStreamChange<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulsubpicture: u32, bdisplay: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::SubpictureStreamChange(this, core::mem::transmute_copy(&ulsubpicture), core::mem::transmute_copy(&bdisplay)).into()
            }
        }
        unsafe extern "system" fn AngleChange<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulangle: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::AngleChange(this, core::mem::transmute_copy(&ulangle)).into()
            }
        }
        unsafe extern "system" fn ParentalLevelSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulparentallevel: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ParentalLevelSelect(this, core::mem::transmute_copy(&ulparentallevel)).into()
            }
        }
        unsafe extern "system" fn ParentalCountrySelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wcountry: u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ParentalCountrySelect(this, core::mem::transmute_copy(&wcountry)).into()
            }
        }
        unsafe extern "system" fn KaraokeAudioPresentationModeChange<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::KaraokeAudioPresentationModeChange(this, core::mem::transmute_copy(&ulmode)).into()
            }
        }
        unsafe extern "system" fn VideoModePreferrence<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpreferreddisplaymode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::VideoModePreferrence(this, core::mem::transmute_copy(&ulpreferreddisplaymode)).into()
            }
        }
        unsafe extern "system" fn SetRoot<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszpath: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::SetRoot(this, core::mem::transmute(&pszpath)).into()
            }
        }
        unsafe extern "system" fn MouseActivate<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, point: super::super::Foundation::POINT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::MouseActivate(this, core::mem::transmute(&point)).into()
            }
        }
        unsafe extern "system" fn MouseSelect<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, point: super::super::Foundation::POINT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::MouseSelect(this, core::mem::transmute(&point)).into()
            }
        }
        unsafe extern "system" fn ChapterPlayAutoStop<Identity: IDvdControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl_Impl::ChapterPlayAutoStop(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&ulchapter), core::mem::transmute_copy(&ulchapterstoplay)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            TitlePlay: TitlePlay::<Identity, OFFSET>,
            ChapterPlay: ChapterPlay::<Identity, OFFSET>,
            TimePlay: TimePlay::<Identity, OFFSET>,
            StopForResume: StopForResume::<Identity, OFFSET>,
            GoUp: GoUp::<Identity, OFFSET>,
            TimeSearch: TimeSearch::<Identity, OFFSET>,
            ChapterSearch: ChapterSearch::<Identity, OFFSET>,
            PrevPGSearch: PrevPGSearch::<Identity, OFFSET>,
            TopPGSearch: TopPGSearch::<Identity, OFFSET>,
            NextPGSearch: NextPGSearch::<Identity, OFFSET>,
            ForwardScan: ForwardScan::<Identity, OFFSET>,
            BackwardScan: BackwardScan::<Identity, OFFSET>,
            MenuCall: MenuCall::<Identity, OFFSET>,
            Resume: Resume::<Identity, OFFSET>,
            UpperButtonSelect: UpperButtonSelect::<Identity, OFFSET>,
            LowerButtonSelect: LowerButtonSelect::<Identity, OFFSET>,
            LeftButtonSelect: LeftButtonSelect::<Identity, OFFSET>,
            RightButtonSelect: RightButtonSelect::<Identity, OFFSET>,
            ButtonActivate: ButtonActivate::<Identity, OFFSET>,
            ButtonSelectAndActivate: ButtonSelectAndActivate::<Identity, OFFSET>,
            StillOff: StillOff::<Identity, OFFSET>,
            PauseOn: PauseOn::<Identity, OFFSET>,
            PauseOff: PauseOff::<Identity, OFFSET>,
            MenuLanguageSelect: MenuLanguageSelect::<Identity, OFFSET>,
            AudioStreamChange: AudioStreamChange::<Identity, OFFSET>,
            SubpictureStreamChange: SubpictureStreamChange::<Identity, OFFSET>,
            AngleChange: AngleChange::<Identity, OFFSET>,
            ParentalLevelSelect: ParentalLevelSelect::<Identity, OFFSET>,
            ParentalCountrySelect: ParentalCountrySelect::<Identity, OFFSET>,
            KaraokeAudioPresentationModeChange: KaraokeAudioPresentationModeChange::<Identity, OFFSET>,
            VideoModePreferrence: VideoModePreferrence::<Identity, OFFSET>,
            SetRoot: SetRoot::<Identity, OFFSET>,
            MouseActivate: MouseActivate::<Identity, OFFSET>,
            MouseSelect: MouseSelect::<Identity, OFFSET>,
            ChapterPlayAutoStop: ChapterPlayAutoStop::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdControl {}
windows_core::imp::define_interface!(IDvdControl2, IDvdControl2_Vtbl, 0x33bc7430_eec0_11d2_8201_00a0c9d74842);
windows_core::imp::interface_hierarchy!(IDvdControl2, windows_core::IUnknown);
impl IDvdControl2 {
    pub unsafe fn PlayTitle(&self, ultitle: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayTitle)(windows_core::Interface::as_raw(self), ultitle, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayChapterInTitle(&self, ultitle: u32, ulchapter: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayChapterInTitle)(windows_core::Interface::as_raw(self), ultitle, ulchapter, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayAtTimeInTitle(&self, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayAtTimeInTitle)(windows_core::Interface::as_raw(self), ultitle, pstarttime, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ReturnFromSubmenu(&self, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ReturnFromSubmenu)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayAtTime(&self, ptime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayAtTime)(windows_core::Interface::as_raw(self), ptime, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayChapter(&self, ulchapter: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayChapter)(windows_core::Interface::as_raw(self), ulchapter, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayPrevChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayPrevChapter)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn ReplayChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ReplayChapter)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayNextChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayNextChapter)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayForwards(&self, dspeed: f64, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayForwards)(windows_core::Interface::as_raw(self), dspeed, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayBackwards(&self, dspeed: f64, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayBackwards)(windows_core::Interface::as_raw(self), dspeed, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn ShowMenu(&self, menuid: DVD_MENU_ID, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ShowMenu)(windows_core::Interface::as_raw(self), menuid, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Resume(&self, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Resume)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SelectRelativeButton(&self, buttondir: DVD_RELATIVE_BUTTON) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectRelativeButton)(windows_core::Interface::as_raw(self), buttondir).ok() }
    }
    pub unsafe fn ActivateButton(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ActivateButton)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SelectButton(&self, ulbutton: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectButton)(windows_core::Interface::as_raw(self), ulbutton).ok() }
    }
    pub unsafe fn SelectAndActivateButton(&self, ulbutton: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectAndActivateButton)(windows_core::Interface::as_raw(self), ulbutton).ok() }
    }
    pub unsafe fn StillOff(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StillOff)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Pause(&self, bstate: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Pause)(windows_core::Interface::as_raw(self), bstate.into()).ok() }
    }
    pub unsafe fn SelectAudioStream(&self, ulaudio: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SelectAudioStream)(windows_core::Interface::as_raw(self), ulaudio, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SelectSubpictureStream(&self, ulsubpicture: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SelectSubpictureStream)(windows_core::Interface::as_raw(self), ulsubpicture, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SetSubpictureState(&self, bstate: bool, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SetSubpictureState)(windows_core::Interface::as_raw(self), bstate.into(), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SelectAngle(&self, ulangle: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SelectAngle)(windows_core::Interface::as_raw(self), ulangle, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SelectParentalLevel(&self, ulparentallevel: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectParentalLevel)(windows_core::Interface::as_raw(self), ulparentallevel).ok() }
    }
    pub unsafe fn SelectParentalCountry(&self, bcountry: &[u8; 2]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectParentalCountry)(windows_core::Interface::as_raw(self), core::mem::transmute(bcountry.as_ptr())).ok() }
    }
    pub unsafe fn SelectKaraokeAudioPresentationMode(&self, ulmode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectKaraokeAudioPresentationMode)(windows_core::Interface::as_raw(self), ulmode).ok() }
    }
    pub unsafe fn SelectVideoModePreference(&self, ulpreferreddisplaymode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectVideoModePreference)(windows_core::Interface::as_raw(self), ulpreferreddisplaymode).ok() }
    }
    pub unsafe fn SetDVDDirectory<P0>(&self, pszwpath: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDVDDirectory)(windows_core::Interface::as_raw(self), pszwpath.param().abi()).ok() }
    }
    pub unsafe fn ActivateAtPosition(&self, point: super::super::Foundation::POINT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ActivateAtPosition)(windows_core::Interface::as_raw(self), core::mem::transmute(point)).ok() }
    }
    pub unsafe fn SelectAtPosition(&self, point: super::super::Foundation::POINT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectAtPosition)(windows_core::Interface::as_raw(self), core::mem::transmute(point)).ok() }
    }
    pub unsafe fn PlayChaptersAutoStop(&self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayChaptersAutoStop)(windows_core::Interface::as_raw(self), ultitle, ulchapter, ulchapterstoplay, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn AcceptParentalLevelChange(&self, baccept: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AcceptParentalLevelChange)(windows_core::Interface::as_raw(self), baccept.into()).ok() }
    }
    pub unsafe fn SetOption(&self, flag: DVD_OPTION_FLAG, fstate: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOption)(windows_core::Interface::as_raw(self), flag, fstate.into()).ok() }
    }
    pub unsafe fn SetState<P0>(&self, pstate: P0, dwflags: u32) -> windows_core::Result<IDvdCmd>
    where
        P0: windows_core::Param<IDvdState>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SetState)(windows_core::Interface::as_raw(self), pstate.param().abi(), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn PlayPeriodInTitleAutoStop(&self, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, pendtime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PlayPeriodInTitleAutoStop)(windows_core::Interface::as_raw(self), ultitle, pstarttime, pendtime, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SetGPRM(&self, ulindex: u32, wvalue: u16, dwflags: u32) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SetGPRM)(windows_core::Interface::as_raw(self), ulindex, wvalue, dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SelectDefaultMenuLanguage(&self, language: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectDefaultMenuLanguage)(windows_core::Interface::as_raw(self), language).ok() }
    }
    pub unsafe fn SelectDefaultAudioLanguage(&self, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectDefaultAudioLanguage)(windows_core::Interface::as_raw(self), language, audioextension).ok() }
    }
    pub unsafe fn SelectDefaultSubpictureLanguage(&self, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SelectDefaultSubpictureLanguage)(windows_core::Interface::as_raw(self), language, subpictureextension).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdControl2_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub PlayTitle: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayChapterInTitle: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayAtTimeInTitle: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const DVD_HMSF_TIMECODE, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ReturnFromSubmenu: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayAtTime: unsafe extern "system" fn(*mut core::ffi::c_void, *const DVD_HMSF_TIMECODE, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayChapter: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayPrevChapter: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ReplayChapter: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayNextChapter: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayForwards: unsafe extern "system" fn(*mut core::ffi::c_void, f64, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayBackwards: unsafe extern "system" fn(*mut core::ffi::c_void, f64, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ShowMenu: unsafe extern "system" fn(*mut core::ffi::c_void, DVD_MENU_ID, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Resume: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectRelativeButton: unsafe extern "system" fn(*mut core::ffi::c_void, DVD_RELATIVE_BUTTON) -> windows_core::HRESULT,
    pub ActivateButton: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectButton: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SelectAndActivateButton: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub StillOff: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Pause: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub SelectAudioStream: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectSubpictureStream: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetSubpictureState: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectAngle: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectParentalLevel: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SelectParentalCountry: unsafe extern "system" fn(*mut core::ffi::c_void, *const u8) -> windows_core::HRESULT,
    pub SelectKaraokeAudioPresentationMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SelectVideoModePreference: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetDVDDirectory: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub ActivateAtPosition: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::POINT) -> windows_core::HRESULT,
    pub SelectAtPosition: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::POINT) -> windows_core::HRESULT,
    pub PlayChaptersAutoStop: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub AcceptParentalLevelChange: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub SetOption: unsafe extern "system" fn(*mut core::ffi::c_void, DVD_OPTION_FLAG, windows_core::BOOL) -> windows_core::HRESULT,
    pub SetState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub PlayPeriodInTitleAutoStop: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const DVD_HMSF_TIMECODE, *const DVD_HMSF_TIMECODE, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetGPRM: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u16, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SelectDefaultMenuLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SelectDefaultAudioLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, DVD_AUDIO_LANG_EXT) -> windows_core::HRESULT,
    pub SelectDefaultSubpictureLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, DVD_SUBPICTURE_LANG_EXT) -> windows_core::HRESULT,
}
pub trait IDvdControl2_Impl: windows_core::IUnknownImpl {
    fn PlayTitle(&self, ultitle: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayChapterInTitle(&self, ultitle: u32, ulchapter: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayAtTimeInTitle(&self, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn ReturnFromSubmenu(&self, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayAtTime(&self, ptime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayChapter(&self, ulchapter: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayPrevChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn ReplayChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayNextChapter(&self, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayForwards(&self, dspeed: f64, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayBackwards(&self, dspeed: f64, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn ShowMenu(&self, menuid: DVD_MENU_ID, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn Resume(&self, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SelectRelativeButton(&self, buttondir: DVD_RELATIVE_BUTTON) -> windows_core::Result<()>;
    fn ActivateButton(&self) -> windows_core::Result<()>;
    fn SelectButton(&self, ulbutton: u32) -> windows_core::Result<()>;
    fn SelectAndActivateButton(&self, ulbutton: u32) -> windows_core::Result<()>;
    fn StillOff(&self) -> windows_core::Result<()>;
    fn Pause(&self, bstate: windows_core::BOOL) -> windows_core::Result<()>;
    fn SelectAudioStream(&self, ulaudio: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SelectSubpictureStream(&self, ulsubpicture: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SetSubpictureState(&self, bstate: windows_core::BOOL, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SelectAngle(&self, ulangle: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SelectParentalLevel(&self, ulparentallevel: u32) -> windows_core::Result<()>;
    fn SelectParentalCountry(&self, bcountry: *const u8) -> windows_core::Result<()>;
    fn SelectKaraokeAudioPresentationMode(&self, ulmode: u32) -> windows_core::Result<()>;
    fn SelectVideoModePreference(&self, ulpreferreddisplaymode: u32) -> windows_core::Result<()>;
    fn SetDVDDirectory(&self, pszwpath: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn ActivateAtPosition(&self, point: &super::super::Foundation::POINT) -> windows_core::Result<()>;
    fn SelectAtPosition(&self, point: &super::super::Foundation::POINT) -> windows_core::Result<()>;
    fn PlayChaptersAutoStop(&self, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn AcceptParentalLevelChange(&self, baccept: windows_core::BOOL) -> windows_core::Result<()>;
    fn SetOption(&self, flag: DVD_OPTION_FLAG, fstate: windows_core::BOOL) -> windows_core::Result<()>;
    fn SetState(&self, pstate: windows_core::Ref<IDvdState>, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn PlayPeriodInTitleAutoStop(&self, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, pendtime: *const DVD_HMSF_TIMECODE, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SetGPRM(&self, ulindex: u32, wvalue: u16, dwflags: u32) -> windows_core::Result<IDvdCmd>;
    fn SelectDefaultMenuLanguage(&self, language: u32) -> windows_core::Result<()>;
    fn SelectDefaultAudioLanguage(&self, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> windows_core::Result<()>;
    fn SelectDefaultSubpictureLanguage(&self, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> windows_core::Result<()>;
}
impl IDvdControl2_Vtbl {
    pub const fn new<Identity: IDvdControl2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PlayTitle<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayTitle(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayChapterInTitle<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, ulchapter: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayChapterInTitle(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&ulchapter), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayAtTimeInTitle<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayAtTimeInTitle(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&pstarttime), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Stop<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::Stop(this).into()
            }
        }
        unsafe extern "system" fn ReturnFromSubmenu<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::ReturnFromSubmenu(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayAtTime<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptime: *const DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayAtTime(this, core::mem::transmute_copy(&ptime), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayChapter<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulchapter: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayChapter(this, core::mem::transmute_copy(&ulchapter), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayPrevChapter<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayPrevChapter(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ReplayChapter<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::ReplayChapter(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayNextChapter<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayNextChapter(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayForwards<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayForwards(this, core::mem::transmute_copy(&dspeed), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayBackwards<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dspeed: f64, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayBackwards(this, core::mem::transmute_copy(&dspeed), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ShowMenu<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, menuid: DVD_MENU_ID, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::ShowMenu(this, core::mem::transmute_copy(&menuid), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Resume<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::Resume(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SelectRelativeButton<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, buttondir: DVD_RELATIVE_BUTTON) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectRelativeButton(this, core::mem::transmute_copy(&buttondir)).into()
            }
        }
        unsafe extern "system" fn ActivateButton<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::ActivateButton(this).into()
            }
        }
        unsafe extern "system" fn SelectButton<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbutton: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectButton(this, core::mem::transmute_copy(&ulbutton)).into()
            }
        }
        unsafe extern "system" fn SelectAndActivateButton<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbutton: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectAndActivateButton(this, core::mem::transmute_copy(&ulbutton)).into()
            }
        }
        unsafe extern "system" fn StillOff<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::StillOff(this).into()
            }
        }
        unsafe extern "system" fn Pause<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstate: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::Pause(this, core::mem::transmute_copy(&bstate)).into()
            }
        }
        unsafe extern "system" fn SelectAudioStream<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulaudio: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SelectAudioStream(this, core::mem::transmute_copy(&ulaudio), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SelectSubpictureStream<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulsubpicture: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SelectSubpictureStream(this, core::mem::transmute_copy(&ulsubpicture), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSubpictureState<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstate: windows_core::BOOL, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SetSubpictureState(this, core::mem::transmute_copy(&bstate), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SelectAngle<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulangle: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SelectAngle(this, core::mem::transmute_copy(&ulangle), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SelectParentalLevel<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulparentallevel: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectParentalLevel(this, core::mem::transmute_copy(&ulparentallevel)).into()
            }
        }
        unsafe extern "system" fn SelectParentalCountry<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bcountry: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectParentalCountry(this, core::mem::transmute_copy(&bcountry)).into()
            }
        }
        unsafe extern "system" fn SelectKaraokeAudioPresentationMode<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulmode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectKaraokeAudioPresentationMode(this, core::mem::transmute_copy(&ulmode)).into()
            }
        }
        unsafe extern "system" fn SelectVideoModePreference<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulpreferreddisplaymode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectVideoModePreference(this, core::mem::transmute_copy(&ulpreferreddisplaymode)).into()
            }
        }
        unsafe extern "system" fn SetDVDDirectory<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszwpath: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SetDVDDirectory(this, core::mem::transmute(&pszwpath)).into()
            }
        }
        unsafe extern "system" fn ActivateAtPosition<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, point: super::super::Foundation::POINT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::ActivateAtPosition(this, core::mem::transmute(&point)).into()
            }
        }
        unsafe extern "system" fn SelectAtPosition<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, point: super::super::Foundation::POINT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectAtPosition(this, core::mem::transmute(&point)).into()
            }
        }
        unsafe extern "system" fn PlayChaptersAutoStop<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, ulchapter: u32, ulchapterstoplay: u32, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayChaptersAutoStop(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&ulchapter), core::mem::transmute_copy(&ulchapterstoplay), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AcceptParentalLevelChange<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, baccept: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::AcceptParentalLevelChange(this, core::mem::transmute_copy(&baccept)).into()
            }
        }
        unsafe extern "system" fn SetOption<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flag: DVD_OPTION_FLAG, fstate: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SetOption(this, core::mem::transmute_copy(&flag), core::mem::transmute_copy(&fstate)).into()
            }
        }
        unsafe extern "system" fn SetState<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SetState(this, core::mem::transmute_copy(&pstate), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PlayPeriodInTitleAutoStop<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pstarttime: *const DVD_HMSF_TIMECODE, pendtime: *const DVD_HMSF_TIMECODE, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::PlayPeriodInTitleAutoStop(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&pstarttime), core::mem::transmute_copy(&pendtime), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGPRM<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulindex: u32, wvalue: u16, dwflags: u32, ppcmd: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdControl2_Impl::SetGPRM(this, core::mem::transmute_copy(&ulindex), core::mem::transmute_copy(&wvalue), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppcmd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SelectDefaultMenuLanguage<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, language: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectDefaultMenuLanguage(this, core::mem::transmute_copy(&language)).into()
            }
        }
        unsafe extern "system" fn SelectDefaultAudioLanguage<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, language: u32, audioextension: DVD_AUDIO_LANG_EXT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectDefaultAudioLanguage(this, core::mem::transmute_copy(&language), core::mem::transmute_copy(&audioextension)).into()
            }
        }
        unsafe extern "system" fn SelectDefaultSubpictureLanguage<Identity: IDvdControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, language: u32, subpictureextension: DVD_SUBPICTURE_LANG_EXT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdControl2_Impl::SelectDefaultSubpictureLanguage(this, core::mem::transmute_copy(&language), core::mem::transmute_copy(&subpictureextension)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            PlayTitle: PlayTitle::<Identity, OFFSET>,
            PlayChapterInTitle: PlayChapterInTitle::<Identity, OFFSET>,
            PlayAtTimeInTitle: PlayAtTimeInTitle::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            ReturnFromSubmenu: ReturnFromSubmenu::<Identity, OFFSET>,
            PlayAtTime: PlayAtTime::<Identity, OFFSET>,
            PlayChapter: PlayChapter::<Identity, OFFSET>,
            PlayPrevChapter: PlayPrevChapter::<Identity, OFFSET>,
            ReplayChapter: ReplayChapter::<Identity, OFFSET>,
            PlayNextChapter: PlayNextChapter::<Identity, OFFSET>,
            PlayForwards: PlayForwards::<Identity, OFFSET>,
            PlayBackwards: PlayBackwards::<Identity, OFFSET>,
            ShowMenu: ShowMenu::<Identity, OFFSET>,
            Resume: Resume::<Identity, OFFSET>,
            SelectRelativeButton: SelectRelativeButton::<Identity, OFFSET>,
            ActivateButton: ActivateButton::<Identity, OFFSET>,
            SelectButton: SelectButton::<Identity, OFFSET>,
            SelectAndActivateButton: SelectAndActivateButton::<Identity, OFFSET>,
            StillOff: StillOff::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            SelectAudioStream: SelectAudioStream::<Identity, OFFSET>,
            SelectSubpictureStream: SelectSubpictureStream::<Identity, OFFSET>,
            SetSubpictureState: SetSubpictureState::<Identity, OFFSET>,
            SelectAngle: SelectAngle::<Identity, OFFSET>,
            SelectParentalLevel: SelectParentalLevel::<Identity, OFFSET>,
            SelectParentalCountry: SelectParentalCountry::<Identity, OFFSET>,
            SelectKaraokeAudioPresentationMode: SelectKaraokeAudioPresentationMode::<Identity, OFFSET>,
            SelectVideoModePreference: SelectVideoModePreference::<Identity, OFFSET>,
            SetDVDDirectory: SetDVDDirectory::<Identity, OFFSET>,
            ActivateAtPosition: ActivateAtPosition::<Identity, OFFSET>,
            SelectAtPosition: SelectAtPosition::<Identity, OFFSET>,
            PlayChaptersAutoStop: PlayChaptersAutoStop::<Identity, OFFSET>,
            AcceptParentalLevelChange: AcceptParentalLevelChange::<Identity, OFFSET>,
            SetOption: SetOption::<Identity, OFFSET>,
            SetState: SetState::<Identity, OFFSET>,
            PlayPeriodInTitleAutoStop: PlayPeriodInTitleAutoStop::<Identity, OFFSET>,
            SetGPRM: SetGPRM::<Identity, OFFSET>,
            SelectDefaultMenuLanguage: SelectDefaultMenuLanguage::<Identity, OFFSET>,
            SelectDefaultAudioLanguage: SelectDefaultAudioLanguage::<Identity, OFFSET>,
            SelectDefaultSubpictureLanguage: SelectDefaultSubpictureLanguage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdControl2 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdControl2 {}
windows_core::imp::define_interface!(IDvdGraphBuilder, IDvdGraphBuilder_Vtbl, 0xfcc152b6_f372_11d0_8e00_00c04fd7c08b);
windows_core::imp::interface_hierarchy!(IDvdGraphBuilder, windows_core::IUnknown);
impl IDvdGraphBuilder {
    pub unsafe fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFiltergraph)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetDvdInterface(&self, riid: *const windows_core::GUID, ppvif: *mut *mut core::ffi::c_void) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDvdInterface)(windows_core::Interface::as_raw(self), riid, ppvif as _).ok() }
    }
    pub unsafe fn RenderDvdVideoVolume<P0>(&self, lpcwszpathname: P0, dwflags: u32, pstatus: *mut AM_DVD_RENDERSTATUS) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RenderDvdVideoVolume)(windows_core::Interface::as_raw(self), lpcwszpathname.param().abi(), dwflags, pstatus as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdGraphBuilder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetFiltergraph: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetDvdInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RenderDvdVideoVolume: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, u32, *mut AM_DVD_RENDERSTATUS) -> windows_core::HRESULT,
}
pub trait IDvdGraphBuilder_Impl: windows_core::IUnknownImpl {
    fn GetFiltergraph(&self) -> windows_core::Result<IGraphBuilder>;
    fn GetDvdInterface(&self, riid: *const windows_core::GUID, ppvif: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn RenderDvdVideoVolume(&self, lpcwszpathname: &windows_core::PCWSTR, dwflags: u32, pstatus: *mut AM_DVD_RENDERSTATUS) -> windows_core::Result<()>;
}
impl IDvdGraphBuilder_Vtbl {
    pub const fn new<Identity: IDvdGraphBuilder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetFiltergraph<Identity: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppgb: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdGraphBuilder_Impl::GetFiltergraph(this) {
                    Ok(ok__) => {
                        ppgb.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDvdInterface<Identity: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvif: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdGraphBuilder_Impl::GetDvdInterface(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvif)).into()
            }
        }
        unsafe extern "system" fn RenderDvdVideoVolume<Identity: IDvdGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpcwszpathname: windows_core::PCWSTR, dwflags: u32, pstatus: *mut AM_DVD_RENDERSTATUS) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdGraphBuilder_Impl::RenderDvdVideoVolume(this, core::mem::transmute(&lpcwszpathname), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&pstatus)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFiltergraph: GetFiltergraph::<Identity, OFFSET>,
            GetDvdInterface: GetDvdInterface::<Identity, OFFSET>,
            RenderDvdVideoVolume: RenderDvdVideoVolume::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdGraphBuilder as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdGraphBuilder {}
windows_core::imp::define_interface!(IDvdInfo, IDvdInfo_Vtbl, 0xa70efe60_e2a3_11d0_a9be_00aa0061be93);
windows_core::imp::interface_hierarchy!(IDvdInfo, windows_core::IUnknown);
impl IDvdInfo {
    pub unsafe fn GetCurrentDomain(&self) -> windows_core::Result<DVD_DOMAIN> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentDomain)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentLocation(&self) -> windows_core::Result<DVD_PLAYBACK_LOCATION> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentLocation)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTotalTitleTime(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTotalTitleTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentButton(&self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentButton)(windows_core::Interface::as_raw(self), pulbuttonsavailable as _, pulcurrentbutton as _).ok() }
    }
    pub unsafe fn GetCurrentAngle(&self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentAngle)(windows_core::Interface::as_raw(self), pulanglesavailable as _, pulcurrentangle as _).ok() }
    }
    pub unsafe fn GetCurrentAudio(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentAudio)(windows_core::Interface::as_raw(self), pulstreamsavailable as _, pulcurrentstream as _).ok() }
    }
    pub unsafe fn GetCurrentSubpicture(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentSubpicture)(windows_core::Interface::as_raw(self), pulstreamsavailable as _, pulcurrentstream as _, pisdisabled as _).ok() }
    }
    pub unsafe fn GetCurrentUOPS(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentUOPS)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAllSPRMs(&self) -> windows_core::Result<*mut u16> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllSPRMs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAllGPRMs(&self) -> windows_core::Result<*mut u16> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllGPRMs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAudioLanguage(&self, ulstream: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAudioLanguage)(windows_core::Interface::as_raw(self), ulstream, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSubpictureLanguage(&self, ulstream: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSubpictureLanguage)(windows_core::Interface::as_raw(self), ulstream, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTitleAttributes(&self, ultitle: u32, patr: *mut DVD_ATR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTitleAttributes)(windows_core::Interface::as_raw(self), ultitle, patr as _).ok() }
    }
    pub unsafe fn GetVMGAttributes(&self, patr: *mut DVD_ATR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVMGAttributes)(windows_core::Interface::as_raw(self), patr as _).ok() }
    }
    pub unsafe fn GetCurrentVideoAttributes(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentVideoAttributes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentAudioAttributes(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentAudioAttributes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentSubpictureAttributes(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentSubpictureAttributes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentVolumeInfo(&self, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentVolumeInfo)(windows_core::Interface::as_raw(self), pulnumofvol as _, pulthisvolnum as _, pside as _, pulnumoftitles as _).ok() }
    }
    pub unsafe fn GetDVDTextInfo(&self, ptextmanager: &mut [u8], pulactualsize: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDTextInfo)(windows_core::Interface::as_raw(self), core::mem::transmute(ptextmanager.as_ptr()), ptextmanager.len().try_into().unwrap(), pulactualsize as _).ok() }
    }
    pub unsafe fn GetPlayerParentalLevel(&self, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPlayerParentalLevel)(windows_core::Interface::as_raw(self), pulparentallevel as _, pulcountrycode as _).ok() }
    }
    pub unsafe fn GetNumberOfChapters(&self, ultitle: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumberOfChapters)(windows_core::Interface::as_raw(self), ultitle, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTitleParentalLevels(&self, ultitle: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTitleParentalLevels)(windows_core::Interface::as_raw(self), ultitle, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetRoot(&self, proot: &mut [u8], pulactualsize: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRoot)(windows_core::Interface::as_raw(self), core::mem::transmute(proot.as_ptr()), proot.len().try_into().unwrap(), pulactualsize as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCurrentDomain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_DOMAIN) -> windows_core::HRESULT,
    pub GetCurrentLocation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_PLAYBACK_LOCATION) -> windows_core::HRESULT,
    pub GetTotalTitleTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentButton: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentAngle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentAudio: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentSubpicture: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub GetCurrentUOPS: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetAllSPRMs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u16) -> windows_core::HRESULT,
    pub GetAllGPRMs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u16) -> windows_core::HRESULT,
    pub GetAudioLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetSubpictureLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetTitleAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut DVD_ATR) -> windows_core::HRESULT,
    pub GetVMGAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_ATR) -> windows_core::HRESULT,
    pub GetCurrentVideoAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub GetCurrentAudioAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub GetCurrentSubpictureAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub GetCurrentVolumeInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut DVD_DISC_SIDE, *mut u32) -> windows_core::HRESULT,
    pub GetDVDTextInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u8, u32, *mut u32) -> windows_core::HRESULT,
    pub GetPlayerParentalLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetNumberOfChapters: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetTitleParentalLevels: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetRoot: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PSTR, u32, *mut u32) -> windows_core::HRESULT,
}
pub trait IDvdInfo_Impl: windows_core::IUnknownImpl {
    fn GetCurrentDomain(&self) -> windows_core::Result<DVD_DOMAIN>;
    fn GetCurrentLocation(&self) -> windows_core::Result<DVD_PLAYBACK_LOCATION>;
    fn GetTotalTitleTime(&self) -> windows_core::Result<u32>;
    fn GetCurrentButton(&self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentAngle(&self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentAudio(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentSubpicture(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn GetCurrentUOPS(&self) -> windows_core::Result<u32>;
    fn GetAllSPRMs(&self) -> windows_core::Result<*mut u16>;
    fn GetAllGPRMs(&self) -> windows_core::Result<*mut u16>;
    fn GetAudioLanguage(&self, ulstream: u32) -> windows_core::Result<u32>;
    fn GetSubpictureLanguage(&self, ulstream: u32) -> windows_core::Result<u32>;
    fn GetTitleAttributes(&self, ultitle: u32, patr: *mut DVD_ATR) -> windows_core::Result<()>;
    fn GetVMGAttributes(&self, patr: *mut DVD_ATR) -> windows_core::Result<()>;
    fn GetCurrentVideoAttributes(&self) -> windows_core::Result<*mut u8>;
    fn GetCurrentAudioAttributes(&self) -> windows_core::Result<*mut u8>;
    fn GetCurrentSubpictureAttributes(&self) -> windows_core::Result<*mut u8>;
    fn GetCurrentVolumeInfo(&self, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::Result<()>;
    fn GetDVDTextInfo(&self, ptextmanager: *mut u8, ulbufsize: u32, pulactualsize: *mut u32) -> windows_core::Result<()>;
    fn GetPlayerParentalLevel(&self, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> windows_core::Result<()>;
    fn GetNumberOfChapters(&self, ultitle: u32) -> windows_core::Result<u32>;
    fn GetTitleParentalLevels(&self, ultitle: u32) -> windows_core::Result<u32>;
    fn GetRoot(&self, proot: windows_core::PSTR, ulbufsize: u32, pulactualsize: *mut u32) -> windows_core::Result<()>;
}
impl IDvdInfo_Vtbl {
    pub const fn new<Identity: IDvdInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCurrentDomain<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentDomain(this) {
                    Ok(ok__) => {
                        pdomain.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentLocation<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentLocation(this) {
                    Ok(ok__) => {
                        plocation.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pultotaltime: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetTotalTitleTime(this) {
                    Ok(ok__) => {
                        pultotaltime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentButton<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetCurrentButton(this, core::mem::transmute_copy(&pulbuttonsavailable), core::mem::transmute_copy(&pulcurrentbutton)).into()
            }
        }
        unsafe extern "system" fn GetCurrentAngle<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetCurrentAngle(this, core::mem::transmute_copy(&pulanglesavailable), core::mem::transmute_copy(&pulcurrentangle)).into()
            }
        }
        unsafe extern "system" fn GetCurrentAudio<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetCurrentAudio(this, core::mem::transmute_copy(&pulstreamsavailable), core::mem::transmute_copy(&pulcurrentstream)).into()
            }
        }
        unsafe extern "system" fn GetCurrentSubpicture<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pisdisabled: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetCurrentSubpicture(this, core::mem::transmute_copy(&pulstreamsavailable), core::mem::transmute_copy(&pulcurrentstream), core::mem::transmute_copy(&pisdisabled)).into()
            }
        }
        unsafe extern "system" fn GetCurrentUOPS<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puop: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentUOPS(this) {
                    Ok(ok__) => {
                        puop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pregisterarray: *mut *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetAllSPRMs(this) {
                    Ok(ok__) => {
                        pregisterarray.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pregisterarray: *mut *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetAllGPRMs(this) {
                    Ok(ok__) => {
                        pregisterarray.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetAudioLanguage(this, core::mem::transmute_copy(&ulstream)) {
                    Ok(ok__) => {
                        planguage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetSubpictureLanguage(this, core::mem::transmute_copy(&ulstream)) {
                    Ok(ok__) => {
                        planguage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, patr: *mut DVD_ATR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetTitleAttributes(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&patr)).into()
            }
        }
        unsafe extern "system" fn GetVMGAttributes<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut DVD_ATR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetVMGAttributes(this, core::mem::transmute_copy(&patr)).into()
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentVideoAttributes(this) {
                    Ok(ok__) => {
                        patr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentAudioAttributes<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentAudioAttributes(this) {
                    Ok(ok__) => {
                        patr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentSubpictureAttributes<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetCurrentSubpictureAttributes(this) {
                    Ok(ok__) => {
                        patr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentVolumeInfo<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulnumofvol: *mut u32, pulthisvolnum: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetCurrentVolumeInfo(this, core::mem::transmute_copy(&pulnumofvol), core::mem::transmute_copy(&pulthisvolnum), core::mem::transmute_copy(&pside), core::mem::transmute_copy(&pulnumoftitles)).into()
            }
        }
        unsafe extern "system" fn GetDVDTextInfo<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptextmanager: *mut u8, ulbufsize: u32, pulactualsize: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetDVDTextInfo(this, core::mem::transmute_copy(&ptextmanager), core::mem::transmute_copy(&ulbufsize), core::mem::transmute_copy(&pulactualsize)).into()
            }
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulparentallevel: *mut u32, pulcountrycode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetPlayerParentalLevel(this, core::mem::transmute_copy(&pulparentallevel), core::mem::transmute_copy(&pulcountrycode)).into()
            }
        }
        unsafe extern "system" fn GetNumberOfChapters<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pulnumberofchapters: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetNumberOfChapters(this, core::mem::transmute_copy(&ultitle)) {
                    Ok(ok__) => {
                        pulnumberofchapters.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo_Impl::GetTitleParentalLevels(this, core::mem::transmute_copy(&ultitle)) {
                    Ok(ok__) => {
                        pulparentallevels.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetRoot<Identity: IDvdInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, proot: windows_core::PSTR, ulbufsize: u32, pulactualsize: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo_Impl::GetRoot(this, core::mem::transmute_copy(&proot), core::mem::transmute_copy(&ulbufsize), core::mem::transmute_copy(&pulactualsize)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCurrentDomain: GetCurrentDomain::<Identity, OFFSET>,
            GetCurrentLocation: GetCurrentLocation::<Identity, OFFSET>,
            GetTotalTitleTime: GetTotalTitleTime::<Identity, OFFSET>,
            GetCurrentButton: GetCurrentButton::<Identity, OFFSET>,
            GetCurrentAngle: GetCurrentAngle::<Identity, OFFSET>,
            GetCurrentAudio: GetCurrentAudio::<Identity, OFFSET>,
            GetCurrentSubpicture: GetCurrentSubpicture::<Identity, OFFSET>,
            GetCurrentUOPS: GetCurrentUOPS::<Identity, OFFSET>,
            GetAllSPRMs: GetAllSPRMs::<Identity, OFFSET>,
            GetAllGPRMs: GetAllGPRMs::<Identity, OFFSET>,
            GetAudioLanguage: GetAudioLanguage::<Identity, OFFSET>,
            GetSubpictureLanguage: GetSubpictureLanguage::<Identity, OFFSET>,
            GetTitleAttributes: GetTitleAttributes::<Identity, OFFSET>,
            GetVMGAttributes: GetVMGAttributes::<Identity, OFFSET>,
            GetCurrentVideoAttributes: GetCurrentVideoAttributes::<Identity, OFFSET>,
            GetCurrentAudioAttributes: GetCurrentAudioAttributes::<Identity, OFFSET>,
            GetCurrentSubpictureAttributes: GetCurrentSubpictureAttributes::<Identity, OFFSET>,
            GetCurrentVolumeInfo: GetCurrentVolumeInfo::<Identity, OFFSET>,
            GetDVDTextInfo: GetDVDTextInfo::<Identity, OFFSET>,
            GetPlayerParentalLevel: GetPlayerParentalLevel::<Identity, OFFSET>,
            GetNumberOfChapters: GetNumberOfChapters::<Identity, OFFSET>,
            GetTitleParentalLevels: GetTitleParentalLevels::<Identity, OFFSET>,
            GetRoot: GetRoot::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdInfo {}
windows_core::imp::define_interface!(IDvdInfo2, IDvdInfo2_Vtbl, 0x34151510_eec0_11d2_8201_00a0c9d74842);
windows_core::imp::interface_hierarchy!(IDvdInfo2, windows_core::IUnknown);
impl IDvdInfo2 {
    pub unsafe fn GetCurrentDomain(&self) -> windows_core::Result<DVD_DOMAIN> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentDomain)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentLocation(&self) -> windows_core::Result<DVD_PLAYBACK_LOCATION2> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentLocation)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTotalTitleTime(&self, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTotalTitleTime)(windows_core::Interface::as_raw(self), ptotaltime as _, ultimecodeflags as _).ok() }
    }
    pub unsafe fn GetCurrentButton(&self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentButton)(windows_core::Interface::as_raw(self), pulbuttonsavailable as _, pulcurrentbutton as _).ok() }
    }
    pub unsafe fn GetCurrentAngle(&self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentAngle)(windows_core::Interface::as_raw(self), pulanglesavailable as _, pulcurrentangle as _).ok() }
    }
    pub unsafe fn GetCurrentAudio(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentAudio)(windows_core::Interface::as_raw(self), pulstreamsavailable as _, pulcurrentstream as _).ok() }
    }
    pub unsafe fn GetCurrentSubpicture(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentSubpicture)(windows_core::Interface::as_raw(self), pulstreamsavailable as _, pulcurrentstream as _, pbisdisabled as _).ok() }
    }
    pub unsafe fn GetCurrentUOPS(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentUOPS)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAllSPRMs(&self) -> windows_core::Result<*mut u16> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllSPRMs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAllGPRMs(&self) -> windows_core::Result<*mut u16> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllGPRMs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetAudioLanguage(&self, ulstream: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAudioLanguage)(windows_core::Interface::as_raw(self), ulstream, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSubpictureLanguage(&self, ulstream: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSubpictureLanguage)(windows_core::Interface::as_raw(self), ulstream, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTitleAttributes(&self, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTitleAttributes)(windows_core::Interface::as_raw(self), ultitle, pmenu as _, ptitle as _).ok() }
    }
    pub unsafe fn GetVMGAttributes(&self, patr: *mut DVD_MenuAttributes) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVMGAttributes)(windows_core::Interface::as_raw(self), patr as _).ok() }
    }
    pub unsafe fn GetCurrentVideoAttributes(&self, patr: *mut DVD_VideoAttributes) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentVideoAttributes)(windows_core::Interface::as_raw(self), patr as _).ok() }
    }
    pub unsafe fn GetAudioAttributes(&self, ulstream: u32, patr: *mut DVD_AudioAttributes) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAudioAttributes)(windows_core::Interface::as_raw(self), ulstream, patr as _).ok() }
    }
    pub unsafe fn GetKaraokeAttributes(&self, ulstream: u32, pattributes: *mut DVD_KaraokeAttributes) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetKaraokeAttributes)(windows_core::Interface::as_raw(self), ulstream, pattributes as _).ok() }
    }
    pub unsafe fn GetSubpictureAttributes(&self, ulstream: u32) -> windows_core::Result<DVD_SubpictureAttributes> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSubpictureAttributes)(windows_core::Interface::as_raw(self), ulstream, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDVDVolumeInfo(&self, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDVolumeInfo)(windows_core::Interface::as_raw(self), pulnumofvolumes as _, pulvolume as _, pside as _, pulnumoftitles as _).ok() }
    }
    pub unsafe fn GetDVDTextNumberOfLanguages(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDVDTextNumberOfLanguages)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDVDTextLanguageInfo(&self, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDTextLanguageInfo)(windows_core::Interface::as_raw(self), ullangindex, pulnumofstrings as _, plangcode as _, pbcharacterset as _).ok() }
    }
    pub unsafe fn GetDVDTextStringAsNative(&self, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDTextStringAsNative)(windows_core::Interface::as_raw(self), ullangindex, ulstringindex, pbbuffer as _, ulmaxbuffersize, pulactualsize as _, ptype as _).ok() }
    }
    pub unsafe fn GetDVDTextStringAsUnicode(&self, ullangindex: u32, ulstringindex: u32, pchwbuffer: windows_core::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDTextStringAsUnicode)(windows_core::Interface::as_raw(self), ullangindex, ulstringindex, core::mem::transmute(pchwbuffer), ulmaxbuffersize, pulactualsize as _, ptype as _).ok() }
    }
    pub unsafe fn GetPlayerParentalLevel(&self, pulparentallevel: *mut u32, pbcountrycode: &mut [u8; 2]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPlayerParentalLevel)(windows_core::Interface::as_raw(self), pulparentallevel as _, core::mem::transmute(pbcountrycode.as_ptr())).ok() }
    }
    pub unsafe fn GetNumberOfChapters(&self, ultitle: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumberOfChapters)(windows_core::Interface::as_raw(self), ultitle, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTitleParentalLevels(&self, ultitle: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTitleParentalLevels)(windows_core::Interface::as_raw(self), ultitle, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDVDDirectory(&self, pszwpath: &mut [u16], pulactualsize: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDVDDirectory)(windows_core::Interface::as_raw(self), core::mem::transmute(pszwpath.as_ptr()), pszwpath.len().try_into().unwrap(), pulactualsize as _).ok() }
    }
    pub unsafe fn IsAudioStreamEnabled(&self, ulstreamnum: u32) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsAudioStreamEnabled)(windows_core::Interface::as_raw(self), ulstreamnum, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDiscID<P0>(&self, pszwpath: P0) -> windows_core::Result<u64>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDiscID)(windows_core::Interface::as_raw(self), pszwpath.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetState(&self) -> windows_core::Result<IDvdState> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetMenuLanguages(&self, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMenuLanguages)(windows_core::Interface::as_raw(self), planguages as _, ulmaxlanguages, pulactuallanguages as _).ok() }
    }
    pub unsafe fn GetButtonAtPosition(&self, point: super::super::Foundation::POINT) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetButtonAtPosition)(windows_core::Interface::as_raw(self), core::mem::transmute(point), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCmdFromEvent(&self, lparam1: isize) -> windows_core::Result<IDvdCmd> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCmdFromEvent)(windows_core::Interface::as_raw(self), lparam1, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetDefaultMenuLanguage(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDefaultMenuLanguage)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDefaultAudioLanguage(&self, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDefaultAudioLanguage)(windows_core::Interface::as_raw(self), planguage as _, paudioextension as _).ok() }
    }
    pub unsafe fn GetDefaultSubpictureLanguage(&self, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDefaultSubpictureLanguage)(windows_core::Interface::as_raw(self), planguage as _, psubpictureextension as _).ok() }
    }
    pub unsafe fn GetDecoderCaps(&self, pcaps: *mut DVD_DECODER_CAPS) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDecoderCaps)(windows_core::Interface::as_raw(self), pcaps as _).ok() }
    }
    pub unsafe fn GetButtonRect(&self, ulbutton: u32) -> windows_core::Result<super::super::Foundation::RECT> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetButtonRect)(windows_core::Interface::as_raw(self), ulbutton, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn IsSubpictureStreamEnabled(&self, ulstreamnum: u32) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsSubpictureStreamEnabled)(windows_core::Interface::as_raw(self), ulstreamnum, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdInfo2_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCurrentDomain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_DOMAIN) -> windows_core::HRESULT,
    pub GetCurrentLocation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_PLAYBACK_LOCATION2) -> windows_core::HRESULT,
    pub GetTotalTitleTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_HMSF_TIMECODE, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentButton: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentAngle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentAudio: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetCurrentSubpicture: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub GetCurrentUOPS: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetAllSPRMs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u16) -> windows_core::HRESULT,
    pub GetAllGPRMs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u16) -> windows_core::HRESULT,
    pub GetAudioLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetSubpictureLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetTitleAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut DVD_MenuAttributes, *mut DVD_TitleAttributes) -> windows_core::HRESULT,
    pub GetVMGAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_MenuAttributes) -> windows_core::HRESULT,
    pub GetCurrentVideoAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_VideoAttributes) -> windows_core::HRESULT,
    pub GetAudioAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut DVD_AudioAttributes) -> windows_core::HRESULT,
    pub GetKaraokeAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut DVD_KaraokeAttributes) -> windows_core::HRESULT,
    pub GetSubpictureAttributes: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut DVD_SubpictureAttributes) -> windows_core::HRESULT,
    pub GetDVDVolumeInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut DVD_DISC_SIDE, *mut u32) -> windows_core::HRESULT,
    pub GetDVDTextNumberOfLanguages: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetDVDTextLanguageInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut u32, *mut DVD_TextCharSet) -> windows_core::HRESULT,
    pub GetDVDTextStringAsNative: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *mut u8, u32, *mut u32, *mut DVD_TextStringType) -> windows_core::HRESULT,
    pub GetDVDTextStringAsUnicode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, windows_core::PWSTR, u32, *mut u32, *mut DVD_TextStringType) -> windows_core::HRESULT,
    pub GetPlayerParentalLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u8) -> windows_core::HRESULT,
    pub GetNumberOfChapters: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetTitleParentalLevels: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub GetDVDDirectory: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PWSTR, u32, *mut u32) -> windows_core::HRESULT,
    pub IsAudioStreamEnabled: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub GetDiscID: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *mut u64) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetMenuLanguages: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, u32, *mut u32) -> windows_core::HRESULT,
    pub GetButtonAtPosition: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::POINT, *mut u32) -> windows_core::HRESULT,
    pub GetCmdFromEvent: unsafe extern "system" fn(*mut core::ffi::c_void, isize, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetDefaultMenuLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetDefaultAudioLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut DVD_AUDIO_LANG_EXT) -> windows_core::HRESULT,
    pub GetDefaultSubpictureLanguage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut DVD_SUBPICTURE_LANG_EXT) -> windows_core::HRESULT,
    pub GetDecoderCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *mut DVD_DECODER_CAPS) -> windows_core::HRESULT,
    pub GetButtonRect: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub IsSubpictureStreamEnabled: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IDvdInfo2_Impl: windows_core::IUnknownImpl {
    fn GetCurrentDomain(&self) -> windows_core::Result<DVD_DOMAIN>;
    fn GetCurrentLocation(&self) -> windows_core::Result<DVD_PLAYBACK_LOCATION2>;
    fn GetTotalTitleTime(&self, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentButton(&self, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentAngle(&self, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentAudio(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::Result<()>;
    fn GetCurrentSubpicture(&self, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn GetCurrentUOPS(&self) -> windows_core::Result<u32>;
    fn GetAllSPRMs(&self) -> windows_core::Result<*mut u16>;
    fn GetAllGPRMs(&self) -> windows_core::Result<*mut u16>;
    fn GetAudioLanguage(&self, ulstream: u32) -> windows_core::Result<u32>;
    fn GetSubpictureLanguage(&self, ulstream: u32) -> windows_core::Result<u32>;
    fn GetTitleAttributes(&self, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> windows_core::Result<()>;
    fn GetVMGAttributes(&self, patr: *mut DVD_MenuAttributes) -> windows_core::Result<()>;
    fn GetCurrentVideoAttributes(&self, patr: *mut DVD_VideoAttributes) -> windows_core::Result<()>;
    fn GetAudioAttributes(&self, ulstream: u32, patr: *mut DVD_AudioAttributes) -> windows_core::Result<()>;
    fn GetKaraokeAttributes(&self, ulstream: u32, pattributes: *mut DVD_KaraokeAttributes) -> windows_core::Result<()>;
    fn GetSubpictureAttributes(&self, ulstream: u32) -> windows_core::Result<DVD_SubpictureAttributes>;
    fn GetDVDVolumeInfo(&self, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::Result<()>;
    fn GetDVDTextNumberOfLanguages(&self) -> windows_core::Result<u32>;
    fn GetDVDTextLanguageInfo(&self, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> windows_core::Result<()>;
    fn GetDVDTextStringAsNative(&self, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::Result<()>;
    fn GetDVDTextStringAsUnicode(&self, ullangindex: u32, ulstringindex: u32, pchwbuffer: windows_core::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::Result<()>;
    fn GetPlayerParentalLevel(&self, pulparentallevel: *mut u32, pbcountrycode: *mut u8) -> windows_core::Result<()>;
    fn GetNumberOfChapters(&self, ultitle: u32) -> windows_core::Result<u32>;
    fn GetTitleParentalLevels(&self, ultitle: u32) -> windows_core::Result<u32>;
    fn GetDVDDirectory(&self, pszwpath: windows_core::PWSTR, ulmaxsize: u32, pulactualsize: *mut u32) -> windows_core::Result<()>;
    fn IsAudioStreamEnabled(&self, ulstreamnum: u32) -> windows_core::Result<windows_core::BOOL>;
    fn GetDiscID(&self, pszwpath: &windows_core::PCWSTR) -> windows_core::Result<u64>;
    fn GetState(&self) -> windows_core::Result<IDvdState>;
    fn GetMenuLanguages(&self, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> windows_core::Result<()>;
    fn GetButtonAtPosition(&self, point: &super::super::Foundation::POINT) -> windows_core::Result<u32>;
    fn GetCmdFromEvent(&self, lparam1: isize) -> windows_core::Result<IDvdCmd>;
    fn GetDefaultMenuLanguage(&self) -> windows_core::Result<u32>;
    fn GetDefaultAudioLanguage(&self, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> windows_core::Result<()>;
    fn GetDefaultSubpictureLanguage(&self, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> windows_core::Result<()>;
    fn GetDecoderCaps(&self, pcaps: *mut DVD_DECODER_CAPS) -> windows_core::Result<()>;
    fn GetButtonRect(&self, ulbutton: u32) -> windows_core::Result<super::super::Foundation::RECT>;
    fn IsSubpictureStreamEnabled(&self, ulstreamnum: u32) -> windows_core::Result<windows_core::BOOL>;
}
impl IDvdInfo2_Vtbl {
    pub const fn new<Identity: IDvdInfo2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCurrentDomain<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdomain: *mut DVD_DOMAIN) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetCurrentDomain(this) {
                    Ok(ok__) => {
                        pdomain.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentLocation<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plocation: *mut DVD_PLAYBACK_LOCATION2) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetCurrentLocation(this) {
                    Ok(ok__) => {
                        plocation.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTotalTitleTime<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptotaltime: *mut DVD_HMSF_TIMECODE, ultimecodeflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetTotalTitleTime(this, core::mem::transmute_copy(&ptotaltime), core::mem::transmute_copy(&ultimecodeflags)).into()
            }
        }
        unsafe extern "system" fn GetCurrentButton<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulbuttonsavailable: *mut u32, pulcurrentbutton: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetCurrentButton(this, core::mem::transmute_copy(&pulbuttonsavailable), core::mem::transmute_copy(&pulcurrentbutton)).into()
            }
        }
        unsafe extern "system" fn GetCurrentAngle<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulanglesavailable: *mut u32, pulcurrentangle: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetCurrentAngle(this, core::mem::transmute_copy(&pulanglesavailable), core::mem::transmute_copy(&pulcurrentangle)).into()
            }
        }
        unsafe extern "system" fn GetCurrentAudio<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetCurrentAudio(this, core::mem::transmute_copy(&pulstreamsavailable), core::mem::transmute_copy(&pulcurrentstream)).into()
            }
        }
        unsafe extern "system" fn GetCurrentSubpicture<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulstreamsavailable: *mut u32, pulcurrentstream: *mut u32, pbisdisabled: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetCurrentSubpicture(this, core::mem::transmute_copy(&pulstreamsavailable), core::mem::transmute_copy(&pulcurrentstream), core::mem::transmute_copy(&pbisdisabled)).into()
            }
        }
        unsafe extern "system" fn GetCurrentUOPS<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puluops: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetCurrentUOPS(this) {
                    Ok(ok__) => {
                        puluops.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAllSPRMs<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pregisterarray: *mut *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetAllSPRMs(this) {
                    Ok(ok__) => {
                        pregisterarray.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAllGPRMs<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pregisterarray: *mut *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetAllGPRMs(this) {
                    Ok(ok__) => {
                        pregisterarray.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAudioLanguage<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetAudioLanguage(this, core::mem::transmute_copy(&ulstream)) {
                    Ok(ok__) => {
                        planguage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSubpictureLanguage<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, planguage: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetSubpictureLanguage(this, core::mem::transmute_copy(&ulstream)) {
                    Ok(ok__) => {
                        planguage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTitleAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pmenu: *mut DVD_MenuAttributes, ptitle: *mut DVD_TitleAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetTitleAttributes(this, core::mem::transmute_copy(&ultitle), core::mem::transmute_copy(&pmenu), core::mem::transmute_copy(&ptitle)).into()
            }
        }
        unsafe extern "system" fn GetVMGAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut DVD_MenuAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetVMGAttributes(this, core::mem::transmute_copy(&patr)).into()
            }
        }
        unsafe extern "system" fn GetCurrentVideoAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, patr: *mut DVD_VideoAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetCurrentVideoAttributes(this, core::mem::transmute_copy(&patr)).into()
            }
        }
        unsafe extern "system" fn GetAudioAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, patr: *mut DVD_AudioAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetAudioAttributes(this, core::mem::transmute_copy(&ulstream), core::mem::transmute_copy(&patr)).into()
            }
        }
        unsafe extern "system" fn GetKaraokeAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, pattributes: *mut DVD_KaraokeAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetKaraokeAttributes(this, core::mem::transmute_copy(&ulstream), core::mem::transmute_copy(&pattributes)).into()
            }
        }
        unsafe extern "system" fn GetSubpictureAttributes<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstream: u32, patr: *mut DVD_SubpictureAttributes) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetSubpictureAttributes(this, core::mem::transmute_copy(&ulstream)) {
                    Ok(ok__) => {
                        patr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDVDVolumeInfo<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulnumofvolumes: *mut u32, pulvolume: *mut u32, pside: *mut DVD_DISC_SIDE, pulnumoftitles: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDVDVolumeInfo(this, core::mem::transmute_copy(&pulnumofvolumes), core::mem::transmute_copy(&pulvolume), core::mem::transmute_copy(&pside), core::mem::transmute_copy(&pulnumoftitles)).into()
            }
        }
        unsafe extern "system" fn GetDVDTextNumberOfLanguages<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulnumoflangs: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetDVDTextNumberOfLanguages(this) {
                    Ok(ok__) => {
                        pulnumoflangs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDVDTextLanguageInfo<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullangindex: u32, pulnumofstrings: *mut u32, plangcode: *mut u32, pbcharacterset: *mut DVD_TextCharSet) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDVDTextLanguageInfo(this, core::mem::transmute_copy(&ullangindex), core::mem::transmute_copy(&pulnumofstrings), core::mem::transmute_copy(&plangcode), core::mem::transmute_copy(&pbcharacterset)).into()
            }
        }
        unsafe extern "system" fn GetDVDTextStringAsNative<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pbbuffer: *mut u8, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDVDTextStringAsNative(this, core::mem::transmute_copy(&ullangindex), core::mem::transmute_copy(&ulstringindex), core::mem::transmute_copy(&pbbuffer), core::mem::transmute_copy(&ulmaxbuffersize), core::mem::transmute_copy(&pulactualsize), core::mem::transmute_copy(&ptype)).into()
            }
        }
        unsafe extern "system" fn GetDVDTextStringAsUnicode<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullangindex: u32, ulstringindex: u32, pchwbuffer: windows_core::PWSTR, ulmaxbuffersize: u32, pulactualsize: *mut u32, ptype: *mut DVD_TextStringType) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDVDTextStringAsUnicode(this, core::mem::transmute_copy(&ullangindex), core::mem::transmute_copy(&ulstringindex), core::mem::transmute_copy(&pchwbuffer), core::mem::transmute_copy(&ulmaxbuffersize), core::mem::transmute_copy(&pulactualsize), core::mem::transmute_copy(&ptype)).into()
            }
        }
        unsafe extern "system" fn GetPlayerParentalLevel<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulparentallevel: *mut u32, pbcountrycode: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetPlayerParentalLevel(this, core::mem::transmute_copy(&pulparentallevel), core::mem::transmute_copy(&pbcountrycode)).into()
            }
        }
        unsafe extern "system" fn GetNumberOfChapters<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pulnumofchapters: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetNumberOfChapters(this, core::mem::transmute_copy(&ultitle)) {
                    Ok(ok__) => {
                        pulnumofchapters.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTitleParentalLevels<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ultitle: u32, pulparentallevels: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetTitleParentalLevels(this, core::mem::transmute_copy(&ultitle)) {
                    Ok(ok__) => {
                        pulparentallevels.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDVDDirectory<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszwpath: windows_core::PWSTR, ulmaxsize: u32, pulactualsize: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDVDDirectory(this, core::mem::transmute_copy(&pszwpath), core::mem::transmute_copy(&ulmaxsize), core::mem::transmute_copy(&pulactualsize)).into()
            }
        }
        unsafe extern "system" fn IsAudioStreamEnabled<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::IsAudioStreamEnabled(this, core::mem::transmute_copy(&ulstreamnum)) {
                    Ok(ok__) => {
                        pbenabled.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDiscID<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszwpath: windows_core::PCWSTR, pulldiscid: *mut u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetDiscID(this, core::mem::transmute(&pszwpath)) {
                    Ok(ok__) => {
                        pulldiscid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetState<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatedata: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetState(this) {
                    Ok(ok__) => {
                        pstatedata.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetMenuLanguages<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planguages: *mut u32, ulmaxlanguages: u32, pulactuallanguages: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetMenuLanguages(this, core::mem::transmute_copy(&planguages), core::mem::transmute_copy(&ulmaxlanguages), core::mem::transmute_copy(&pulactuallanguages)).into()
            }
        }
        unsafe extern "system" fn GetButtonAtPosition<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, point: super::super::Foundation::POINT, pulbuttonindex: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetButtonAtPosition(this, core::mem::transmute(&point)) {
                    Ok(ok__) => {
                        pulbuttonindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCmdFromEvent<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lparam1: isize, pcmdobj: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetCmdFromEvent(this, core::mem::transmute_copy(&lparam1)) {
                    Ok(ok__) => {
                        pcmdobj.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDefaultMenuLanguage<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planguage: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetDefaultMenuLanguage(this) {
                    Ok(ok__) => {
                        planguage.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDefaultAudioLanguage<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planguage: *mut u32, paudioextension: *mut DVD_AUDIO_LANG_EXT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDefaultAudioLanguage(this, core::mem::transmute_copy(&planguage), core::mem::transmute_copy(&paudioextension)).into()
            }
        }
        unsafe extern "system" fn GetDefaultSubpictureLanguage<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, planguage: *mut u32, psubpictureextension: *mut DVD_SUBPICTURE_LANG_EXT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDefaultSubpictureLanguage(this, core::mem::transmute_copy(&planguage), core::mem::transmute_copy(&psubpictureextension)).into()
            }
        }
        unsafe extern "system" fn GetDecoderCaps<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcaps: *mut DVD_DECODER_CAPS) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDvdInfo2_Impl::GetDecoderCaps(this, core::mem::transmute_copy(&pcaps)).into()
            }
        }
        unsafe extern "system" fn GetButtonRect<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbutton: u32, prect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::GetButtonRect(this, core::mem::transmute_copy(&ulbutton)) {
                    Ok(ok__) => {
                        prect.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsSubpictureStreamEnabled<Identity: IDvdInfo2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstreamnum: u32, pbenabled: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdInfo2_Impl::IsSubpictureStreamEnabled(this, core::mem::transmute_copy(&ulstreamnum)) {
                    Ok(ok__) => {
                        pbenabled.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCurrentDomain: GetCurrentDomain::<Identity, OFFSET>,
            GetCurrentLocation: GetCurrentLocation::<Identity, OFFSET>,
            GetTotalTitleTime: GetTotalTitleTime::<Identity, OFFSET>,
            GetCurrentButton: GetCurrentButton::<Identity, OFFSET>,
            GetCurrentAngle: GetCurrentAngle::<Identity, OFFSET>,
            GetCurrentAudio: GetCurrentAudio::<Identity, OFFSET>,
            GetCurrentSubpicture: GetCurrentSubpicture::<Identity, OFFSET>,
            GetCurrentUOPS: GetCurrentUOPS::<Identity, OFFSET>,
            GetAllSPRMs: GetAllSPRMs::<Identity, OFFSET>,
            GetAllGPRMs: GetAllGPRMs::<Identity, OFFSET>,
            GetAudioLanguage: GetAudioLanguage::<Identity, OFFSET>,
            GetSubpictureLanguage: GetSubpictureLanguage::<Identity, OFFSET>,
            GetTitleAttributes: GetTitleAttributes::<Identity, OFFSET>,
            GetVMGAttributes: GetVMGAttributes::<Identity, OFFSET>,
            GetCurrentVideoAttributes: GetCurrentVideoAttributes::<Identity, OFFSET>,
            GetAudioAttributes: GetAudioAttributes::<Identity, OFFSET>,
            GetKaraokeAttributes: GetKaraokeAttributes::<Identity, OFFSET>,
            GetSubpictureAttributes: GetSubpictureAttributes::<Identity, OFFSET>,
            GetDVDVolumeInfo: GetDVDVolumeInfo::<Identity, OFFSET>,
            GetDVDTextNumberOfLanguages: GetDVDTextNumberOfLanguages::<Identity, OFFSET>,
            GetDVDTextLanguageInfo: GetDVDTextLanguageInfo::<Identity, OFFSET>,
            GetDVDTextStringAsNative: GetDVDTextStringAsNative::<Identity, OFFSET>,
            GetDVDTextStringAsUnicode: GetDVDTextStringAsUnicode::<Identity, OFFSET>,
            GetPlayerParentalLevel: GetPlayerParentalLevel::<Identity, OFFSET>,
            GetNumberOfChapters: GetNumberOfChapters::<Identity, OFFSET>,
            GetTitleParentalLevels: GetTitleParentalLevels::<Identity, OFFSET>,
            GetDVDDirectory: GetDVDDirectory::<Identity, OFFSET>,
            IsAudioStreamEnabled: IsAudioStreamEnabled::<Identity, OFFSET>,
            GetDiscID: GetDiscID::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            GetMenuLanguages: GetMenuLanguages::<Identity, OFFSET>,
            GetButtonAtPosition: GetButtonAtPosition::<Identity, OFFSET>,
            GetCmdFromEvent: GetCmdFromEvent::<Identity, OFFSET>,
            GetDefaultMenuLanguage: GetDefaultMenuLanguage::<Identity, OFFSET>,
            GetDefaultAudioLanguage: GetDefaultAudioLanguage::<Identity, OFFSET>,
            GetDefaultSubpictureLanguage: GetDefaultSubpictureLanguage::<Identity, OFFSET>,
            GetDecoderCaps: GetDecoderCaps::<Identity, OFFSET>,
            GetButtonRect: GetButtonRect::<Identity, OFFSET>,
            IsSubpictureStreamEnabled: IsSubpictureStreamEnabled::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdInfo2 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdInfo2 {}
windows_core::imp::define_interface!(IDvdState, IDvdState_Vtbl, 0x86303d6d_1c4a_4087_ab42_f711167048ef);
windows_core::imp::interface_hierarchy!(IDvdState, windows_core::IUnknown);
impl IDvdState {
    pub unsafe fn GetDiscID(&self) -> windows_core::Result<u64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDiscID)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetParentalLevel(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetParentalLevel)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDvdState_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetDiscID: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u64) -> windows_core::HRESULT,
    pub GetParentalLevel: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IDvdState_Impl: windows_core::IUnknownImpl {
    fn GetDiscID(&self) -> windows_core::Result<u64>;
    fn GetParentalLevel(&self) -> windows_core::Result<u32>;
}
impl IDvdState_Vtbl {
    pub const fn new<Identity: IDvdState_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDiscID<Identity: IDvdState_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulluniqueid: *mut u64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdState_Impl::GetDiscID(this) {
                    Ok(ok__) => {
                        pulluniqueid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetParentalLevel<Identity: IDvdState_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulparentallevel: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDvdState_Impl::GetParentalLevel(this) {
                    Ok(ok__) => {
                        pulparentallevel.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDiscID: GetDiscID::<Identity, OFFSET>,
            GetParentalLevel: GetParentalLevel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDvdState as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IDvdState {}
windows_core::imp::define_interface!(IESEvent, IESEvent_Vtbl, 0x1f0e5357_af43_44e6_8547_654c645145d2);
windows_core::imp::interface_hierarchy!(IESEvent, windows_core::IUnknown);
impl IESEvent {
    pub unsafe fn GetEventId(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEventId)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetEventType(&self) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEventType)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCompletionStatus)(windows_core::Interface::as_raw(self), dwresult).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> windows_core::Result<*mut super::super::System::Com::SAFEARRAY> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetData)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetStringData(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStringData)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IESEvent_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetEventId: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetEventType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetCompletionStatus: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub GetData: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut super::super::System::Com::SAFEARRAY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    GetData: usize,
    pub GetStringData: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IESEvent_Impl: windows_core::IUnknownImpl {
    fn GetEventId(&self) -> windows_core::Result<u32>;
    fn GetEventType(&self) -> windows_core::Result<windows_core::GUID>;
    fn SetCompletionStatus(&self, dwresult: u32) -> windows_core::Result<()>;
    fn GetData(&self) -> windows_core::Result<*mut super::super::System::Com::SAFEARRAY>;
    fn GetStringData(&self) -> windows_core::Result<windows_core::BSTR>;
}
#[cfg(feature = "Win32_System_Com")]
impl IESEvent_Vtbl {
    pub const fn new<Identity: IESEvent_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetEventId<Identity: IESEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdweventid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IESEvent_Impl::GetEventId(this) {
                    Ok(ok__) => {
                        pdweventid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetEventType<Identity: IESEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguideventtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IESEvent_Impl::GetEventType(this) {
                    Ok(ok__) => {
                        pguideventtype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCompletionStatus<Identity: IESEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwresult: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IESEvent_Impl::SetCompletionStatus(this, core::mem::transmute_copy(&dwresult)).into()
            }
        }
        unsafe extern "system" fn GetData<Identity: IESEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *mut *mut super::super::System::Com::SAFEARRAY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IESEvent_Impl::GetData(this) {
                    Ok(ok__) => {
                        pbdata.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetStringData<Identity: IESEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstrdata: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IESEvent_Impl::GetStringData(this) {
                    Ok(ok__) => {
                        pbstrdata.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEventId: GetEventId::<Identity, OFFSET>,
            GetEventType: GetEventType::<Identity, OFFSET>,
            SetCompletionStatus: SetCompletionStatus::<Identity, OFFSET>,
            GetData: GetData::<Identity, OFFSET>,
            GetStringData: GetStringData::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IESEvent as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IESEvent {}
windows_core::imp::define_interface!(IESEvents, IESEvents_Vtbl, 0xabd414bf_cfe5_4e5e_af5b_4b4e49c5bfeb);
windows_core::imp::interface_hierarchy!(IESEvents, windows_core::IUnknown);
impl IESEvents {
    pub unsafe fn OnESEventReceived<P1>(&self, guideventtype: windows_core::GUID, pesevent: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IESEvent>,
    {
        unsafe { (windows_core::Interface::vtable(self).OnESEventReceived)(windows_core::Interface::as_raw(self), core::mem::transmute(guideventtype), pesevent.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IESEvents_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnESEventReceived: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IESEvents_Impl: windows_core::IUnknownImpl {
    fn OnESEventReceived(&self, guideventtype: &windows_core::GUID, pesevent: windows_core::Ref<IESEvent>) -> windows_core::Result<()>;
}
impl IESEvents_Vtbl {
    pub const fn new<Identity: IESEvents_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnESEventReceived<Identity: IESEvents_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guideventtype: windows_core::GUID, pesevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IESEvents_Impl::OnESEventReceived(this, core::mem::transmute(&guideventtype), core::mem::transmute_copy(&pesevent)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnESEventReceived: OnESEventReceived::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IESEvents as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IESEvents {}
windows_core::imp::define_interface!(IEncoderAPI, IEncoderAPI_Vtbl, 0x70423839_6acc_4b23_b079_21dbf08156a5);
windows_core::imp::interface_hierarchy!(IEncoderAPI, windows_core::IUnknown);
impl IEncoderAPI {
    pub unsafe fn IsSupported(&self, api: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsSupported)(windows_core::Interface::as_raw(self), api).ok() }
    }
    pub unsafe fn IsAvailable(&self, api: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsAvailable)(windows_core::Interface::as_raw(self), api).ok() }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn GetParameterRange(&self, api: *const windows_core::GUID, valuemin: *mut super::super::System::Variant::VARIANT, valuemax: *mut super::super::System::Variant::VARIANT, steppingdelta: *mut super::super::System::Variant::VARIANT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetParameterRange)(windows_core::Interface::as_raw(self), api, core::mem::transmute(valuemin), core::mem::transmute(valuemax), core::mem::transmute(steppingdelta)).ok() }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn GetParameterValues(&self, api: *const windows_core::GUID, values: *mut *mut super::super::System::Variant::VARIANT, valuescount: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetParameterValues)(windows_core::Interface::as_raw(self), api, values as _, valuescount as _).ok() }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn GetDefaultValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDefaultValue)(windows_core::Interface::as_raw(self), api, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn GetValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetValue)(windows_core::Interface::as_raw(self), api, &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn SetValue(&self, api: *const windows_core::GUID, value: *const super::super::System::Variant::VARIANT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetValue)(windows_core::Interface::as_raw(self), api, core::mem::transmute(value)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEncoderAPI_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub IsSupported: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub IsAvailable: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub GetParameterRange: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut super::super::System::Variant::VARIANT, *mut super::super::System::Variant::VARIANT, *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    GetParameterRange: usize,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub GetParameterValues: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut *mut super::super::System::Variant::VARIANT, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    GetParameterValues: usize,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub GetDefaultValue: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    GetDefaultValue: usize,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub GetValue: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    GetValue: usize,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub SetValue: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const super::super::System::Variant::VARIANT) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    SetValue: usize,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IEncoderAPI_Impl: windows_core::IUnknownImpl {
    fn IsSupported(&self, api: *const windows_core::GUID) -> windows_core::Result<()>;
    fn IsAvailable(&self, api: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetParameterRange(&self, api: *const windows_core::GUID, valuemin: *mut super::super::System::Variant::VARIANT, valuemax: *mut super::super::System::Variant::VARIANT, steppingdelta: *mut super::super::System::Variant::VARIANT) -> windows_core::Result<()>;
    fn GetParameterValues(&self, api: *const windows_core::GUID, values: *mut *mut super::super::System::Variant::VARIANT, valuescount: *mut u32) -> windows_core::Result<()>;
    fn GetDefaultValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT>;
    fn GetValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT>;
    fn SetValue(&self, api: *const windows_core::GUID, value: *const super::super::System::Variant::VARIANT) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IEncoderAPI_Vtbl {
    pub const fn new<Identity: IEncoderAPI_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn IsSupported<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEncoderAPI_Impl::IsSupported(this, core::mem::transmute_copy(&api)).into()
            }
        }
        unsafe extern "system" fn IsAvailable<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEncoderAPI_Impl::IsAvailable(this, core::mem::transmute_copy(&api)).into()
            }
        }
        unsafe extern "system" fn GetParameterRange<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, valuemin: *mut super::super::System::Variant::VARIANT, valuemax: *mut super::super::System::Variant::VARIANT, steppingdelta: *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEncoderAPI_Impl::GetParameterRange(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&valuemin), core::mem::transmute_copy(&valuemax), core::mem::transmute_copy(&steppingdelta)).into()
            }
        }
        unsafe extern "system" fn GetParameterValues<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, values: *mut *mut super::super::System::Variant::VARIANT, valuescount: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEncoderAPI_Impl::GetParameterValues(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&values), core::mem::transmute_copy(&valuescount)).into()
            }
        }
        unsafe extern "system" fn GetDefaultValue<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEncoderAPI_Impl::GetDefaultValue(this, core::mem::transmute_copy(&api)) {
                    Ok(ok__) => {
                        value.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetValue<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEncoderAPI_Impl::GetValue(this, core::mem::transmute_copy(&api)) {
                    Ok(ok__) => {
                        value.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetValue<Identity: IEncoderAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *const super::super::System::Variant::VARIANT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEncoderAPI_Impl::SetValue(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsSupported: IsSupported::<Identity, OFFSET>,
            IsAvailable: IsAvailable::<Identity, OFFSET>,
            GetParameterRange: GetParameterRange::<Identity, OFFSET>,
            GetParameterValues: GetParameterValues::<Identity, OFFSET>,
            GetDefaultValue: GetDefaultValue::<Identity, OFFSET>,
            GetValue: GetValue::<Identity, OFFSET>,
            SetValue: SetValue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEncoderAPI as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IEncoderAPI {}
windows_core::imp::define_interface!(IEnumFilters, IEnumFilters_Vtbl, 0x56a86893_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IEnumFilters, windows_core::IUnknown);
impl IEnumFilters {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Next(&self, ppfilter: &mut [Option<IBaseFilter>], pcfetched: Option<*mut u32>) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), ppfilter.len().try_into().unwrap(), core::mem::transmute(ppfilter.as_ptr()), pcfetched.unwrap_or(core::mem::zeroed()) as _) }
    }
    pub unsafe fn Skip(&self, cfilters: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), cfilters).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumFilters> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumFilters_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    Next: usize,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IEnumFilters_Impl: windows_core::IUnknownImpl {
    fn Next(&self, cfilters: u32, ppfilter: *mut Option<IBaseFilter>, pcfetched: *mut u32) -> windows_core::HRESULT;
    fn Skip(&self, cfilters: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumFilters>;
}
#[cfg(feature = "Win32_System_Com")]
impl IEnumFilters_Vtbl {
    pub const fn new<Identity: IEnumFilters_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cfilters: u32, ppfilter: *mut *mut core::ffi::c_void, pcfetched: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumFilters_Impl::Next(this, core::mem::transmute_copy(&cfilters), core::mem::transmute_copy(&ppfilter), core::mem::transmute_copy(&pcfetched))
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cfilters: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumFilters_Impl::Skip(this, core::mem::transmute_copy(&cfilters)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumFilters_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumFilters_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumFilters as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IEnumFilters {}
windows_core::imp::define_interface!(IEnumMediaTypes, IEnumMediaTypes_Vtbl, 0x89c31040_846b_11ce_97d3_00aa0055595a);
windows_core::imp::interface_hierarchy!(IEnumMediaTypes, windows_core::IUnknown);
impl IEnumMediaTypes {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn Next(&self, ppmediatypes: &mut [*mut super::MediaFoundation::AM_MEDIA_TYPE], pcfetched: Option<*mut u32>) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), ppmediatypes.len().try_into().unwrap(), core::mem::transmute(ppmediatypes.as_ptr()), pcfetched.unwrap_or(core::mem::zeroed()) as _) }
    }
    pub unsafe fn Skip(&self, cmediatypes: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), cmediatypes).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumMediaTypes> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumMediaTypes_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    Next: usize,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IEnumMediaTypes_Impl: windows_core::IUnknownImpl {
    fn Next(&self, cmediatypes: u32, ppmediatypes: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pcfetched: *mut u32) -> windows_core::HRESULT;
    fn Skip(&self, cmediatypes: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumMediaTypes>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IEnumMediaTypes_Vtbl {
    pub const fn new<Identity: IEnumMediaTypes_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cmediatypes: u32, ppmediatypes: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE, pcfetched: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumMediaTypes_Impl::Next(this, core::mem::transmute_copy(&cmediatypes), core::mem::transmute_copy(&ppmediatypes), core::mem::transmute_copy(&pcfetched))
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cmediatypes: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumMediaTypes_Impl::Skip(this, core::mem::transmute_copy(&cmediatypes)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumMediaTypes_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumMediaTypes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumMediaTypes_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumMediaTypes as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IEnumMediaTypes {}
windows_core::imp::define_interface!(IEnumPIDMap, IEnumPIDMap_Vtbl, 0xafb6c2a2_2c41_11d3_8a60_0000f81e0e4a);
windows_core::imp::interface_hierarchy!(IEnumPIDMap, windows_core::IUnknown);
impl IEnumPIDMap {
    pub unsafe fn Next(&self, ppidmap: &mut [PID_MAP], pcreceived: *mut u32) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), ppidmap.len().try_into().unwrap(), core::mem::transmute(ppidmap.as_ptr()), pcreceived as _) }
    }
    pub unsafe fn Skip(&self, crecords: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), crecords).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumPIDMap> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumPIDMap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut PID_MAP, *mut u32) -> windows_core::HRESULT,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IEnumPIDMap_Impl: windows_core::IUnknownImpl {
    fn Next(&self, crequest: u32, ppidmap: *mut PID_MAP, pcreceived: *mut u32) -> windows_core::HRESULT;
    fn Skip(&self, crecords: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumPIDMap>;
}
impl IEnumPIDMap_Vtbl {
    pub const fn new<Identity: IEnumPIDMap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, crequest: u32, ppidmap: *mut PID_MAP, pcreceived: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPIDMap_Impl::Next(this, core::mem::transmute_copy(&crequest), core::mem::transmute_copy(&ppidmap), core::mem::transmute_copy(&pcreceived))
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, crecords: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPIDMap_Impl::Skip(this, core::mem::transmute_copy(&crecords)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPIDMap_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumPIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppienumpidmap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumPIDMap_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppienumpidmap.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumPIDMap as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IEnumPIDMap {}
windows_core::imp::define_interface!(IEnumPins, IEnumPins_Vtbl, 0x56a86892_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IEnumPins, windows_core::IUnknown);
impl IEnumPins {
    pub unsafe fn Next(&self, pppins: &mut [Option<IPin>], pcfetched: Option<*mut u32>) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), pppins.len().try_into().unwrap(), core::mem::transmute(pppins.as_ptr()), pcfetched.unwrap_or(core::mem::zeroed()) as _) }
    }
    pub unsafe fn Skip(&self, cpins: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), cpins).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumPins> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumPins_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IEnumPins_Impl: windows_core::IUnknownImpl {
    fn Next(&self, cpins: u32, pppins: *mut Option<IPin>, pcfetched: *mut u32) -> windows_core::HRESULT;
    fn Skip(&self, cpins: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumPins>;
}
impl IEnumPins_Vtbl {
    pub const fn new<Identity: IEnumPins_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumPins_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cpins: u32, pppins: *mut *mut core::ffi::c_void, pcfetched: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPins_Impl::Next(this, core::mem::transmute_copy(&cpins), core::mem::transmute_copy(&pppins), core::mem::transmute_copy(&pcfetched))
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumPins_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cpins: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPins_Impl::Skip(this, core::mem::transmute_copy(&cpins)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumPins_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumPins_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumPins_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumPins_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumPins as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IEnumPins {}
windows_core::imp::define_interface!(IEnumRegFilters, IEnumRegFilters_Vtbl, 0x56a868a4_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IEnumRegFilters, windows_core::IUnknown);
impl IEnumRegFilters {
    pub unsafe fn Next(&self, apregfilter: &mut [*mut REGFILTER], pcfetched: Option<*mut u32>) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), apregfilter.len().try_into().unwrap(), core::mem::transmute(apregfilter.as_ptr()), pcfetched.unwrap_or(core::mem::zeroed()) as _) }
    }
    pub unsafe fn Skip(&self, cfilters: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), cfilters).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumRegFilters> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumRegFilters_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut REGFILTER, *mut u32) -> windows_core::HRESULT,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IEnumRegFilters_Impl: windows_core::IUnknownImpl {
    fn Next(&self, cfilters: u32, apregfilter: *mut *mut REGFILTER, pcfetched: *mut u32) -> windows_core::HRESULT;
    fn Skip(&self, cfilters: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumRegFilters>;
}
impl IEnumRegFilters_Vtbl {
    pub const fn new<Identity: IEnumRegFilters_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cfilters: u32, apregfilter: *mut *mut REGFILTER, pcfetched: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumRegFilters_Impl::Next(this, core::mem::transmute_copy(&cfilters), core::mem::transmute_copy(&apregfilter), core::mem::transmute_copy(&pcfetched))
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cfilters: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumRegFilters_Impl::Skip(this, core::mem::transmute_copy(&cfilters)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumRegFilters_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumRegFilters_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumRegFilters_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumRegFilters as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IEnumRegFilters {}
windows_core::imp::define_interface!(IEnumStreamIdMap, IEnumStreamIdMap_Vtbl, 0x945c1566_6202_46fc_96c7_d87f289c6534);
windows_core::imp::interface_hierarchy!(IEnumStreamIdMap, windows_core::IUnknown);
impl IEnumStreamIdMap {
    pub unsafe fn Next(&self, pstreamidmap: &mut [STREAM_ID_MAP], pcreceived: Option<*mut u32>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Next)(windows_core::Interface::as_raw(self), pstreamidmap.len().try_into().unwrap(), core::mem::transmute(pstreamidmap.as_ptr()), pcreceived.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn Skip(&self, crecords: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Skip)(windows_core::Interface::as_raw(self), crecords).ok() }
    }
    pub unsafe fn Reset(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reset)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Clone(&self) -> windows_core::Result<IEnumStreamIdMap> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Clone)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEnumStreamIdMap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Next: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut STREAM_ID_MAP, *mut u32) -> windows_core::HRESULT,
    pub Skip: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Clone: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IEnumStreamIdMap_Impl: windows_core::IUnknownImpl {
    fn Next(&self, crequest: u32, pstreamidmap: *mut STREAM_ID_MAP, pcreceived: *mut u32) -> windows_core::Result<()>;
    fn Skip(&self, crecords: u32) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IEnumStreamIdMap>;
}
impl IEnumStreamIdMap_Vtbl {
    pub const fn new<Identity: IEnumStreamIdMap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Next<Identity: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, crequest: u32, pstreamidmap: *mut STREAM_ID_MAP, pcreceived: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumStreamIdMap_Impl::Next(this, core::mem::transmute_copy(&crequest), core::mem::transmute_copy(&pstreamidmap), core::mem::transmute_copy(&pcreceived)).into()
            }
        }
        unsafe extern "system" fn Skip<Identity: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, crecords: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumStreamIdMap_Impl::Skip(this, core::mem::transmute_copy(&crecords)).into()
            }
        }
        unsafe extern "system" fn Reset<Identity: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEnumStreamIdMap_Impl::Reset(this).into()
            }
        }
        unsafe extern "system" fn Clone<Identity: IEnumStreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppienumstreamidmap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEnumStreamIdMap_Impl::Clone(this) {
                    Ok(ok__) => {
                        ppienumstreamidmap.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, OFFSET>,
            Skip: Skip::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEnumStreamIdMap as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IEnumStreamIdMap {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct IFILTERMAPPER_MERIT(pub i32);
windows_core::imp::define_interface!(IFileSinkFilter, IFileSinkFilter_Vtbl, 0xa2104830_7c70_11cf_8bce_00aa00a3f1a6);
windows_core::imp::interface_hierarchy!(IFileSinkFilter, windows_core::IUnknown);
impl IFileSinkFilter {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetFileName<P0>(&self, pszfilename: P0, pmt: Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFileName)(windows_core::Interface::as_raw(self), pszfilename.param().abi(), pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetCurFile(&self, ppszfilename: *mut windows_core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurFile)(windows_core::Interface::as_raw(self), ppszfilename as _, core::mem::transmute(pmt)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFileSinkFilter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetFileName: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetFileName: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetCurFile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR, *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetCurFile: usize,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IFileSinkFilter_Impl: windows_core::IUnknownImpl {
    fn SetFileName(&self, pszfilename: &windows_core::PCWSTR, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn GetCurFile(&self, ppszfilename: *mut windows_core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IFileSinkFilter_Vtbl {
    pub const fn new<Identity: IFileSinkFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetFileName<Identity: IFileSinkFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszfilename: windows_core::PCWSTR, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFileSinkFilter_Impl::SetFileName(this, core::mem::transmute(&pszfilename), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn GetCurFile<Identity: IFileSinkFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszfilename: *mut windows_core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFileSinkFilter_Impl::GetCurFile(this, core::mem::transmute_copy(&ppszfilename), core::mem::transmute_copy(&pmt)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFileName: SetFileName::<Identity, OFFSET>,
            GetCurFile: GetCurFile::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFileSinkFilter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IFileSinkFilter {}
windows_core::imp::define_interface!(IFileSinkFilter2, IFileSinkFilter2_Vtbl, 0x00855b90_ce1b_11d0_bd4f_00a0c911ce86);
impl core::ops::Deref for IFileSinkFilter2 {
    type Target = IFileSinkFilter;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IFileSinkFilter2, windows_core::IUnknown, IFileSinkFilter);
impl IFileSinkFilter2 {
    pub unsafe fn SetMode(&self, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMode)(windows_core::Interface::as_raw(self), dwflags).ok() }
    }
    pub unsafe fn GetMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFileSinkFilter2_Vtbl {
    pub base__: IFileSinkFilter_Vtbl,
    pub SetMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IFileSinkFilter2_Impl: IFileSinkFilter_Impl {
    fn SetMode(&self, dwflags: u32) -> windows_core::Result<()>;
    fn GetMode(&self) -> windows_core::Result<u32>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IFileSinkFilter2_Vtbl {
    pub const fn new<Identity: IFileSinkFilter2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetMode<Identity: IFileSinkFilter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFileSinkFilter2_Impl::SetMode(this, core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn GetMode<Identity: IFileSinkFilter2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFileSinkFilter2_Impl::GetMode(this) {
                    Ok(ok__) => {
                        pdwflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: IFileSinkFilter_Vtbl::new::<Identity, OFFSET>(), SetMode: SetMode::<Identity, OFFSET>, GetMode: GetMode::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFileSinkFilter2 as windows_core::Interface>::IID || iid == &<IFileSinkFilter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IFileSinkFilter2 {}
windows_core::imp::define_interface!(IFileSourceFilter, IFileSourceFilter_Vtbl, 0x56a868a6_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IFileSourceFilter, windows_core::IUnknown);
impl IFileSourceFilter {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn Load<P0>(&self, pszfilename: P0, pmt: Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).Load)(windows_core::Interface::as_raw(self), pszfilename.param().abi(), pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetCurFile(&self, ppszfilename: *mut windows_core::PWSTR, pmt: Option<*mut super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurFile)(windows_core::Interface::as_raw(self), ppszfilename as _, pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFileSourceFilter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub Load: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    Load: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetCurFile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR, *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetCurFile: usize,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IFileSourceFilter_Impl: windows_core::IUnknownImpl {
    fn Load(&self, pszfilename: &windows_core::PCWSTR, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn GetCurFile(&self, ppszfilename: *mut windows_core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IFileSourceFilter_Vtbl {
    pub const fn new<Identity: IFileSourceFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Load<Identity: IFileSourceFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszfilename: windows_core::PCWSTR, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFileSourceFilter_Impl::Load(this, core::mem::transmute(&pszfilename), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn GetCurFile<Identity: IFileSourceFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszfilename: *mut windows_core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFileSourceFilter_Impl::GetCurFile(this, core::mem::transmute_copy(&ppszfilename), core::mem::transmute_copy(&pmt)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Load: Load::<Identity, OFFSET>, GetCurFile: GetCurFile::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFileSourceFilter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IFileSourceFilter {}
windows_core::imp::define_interface!(IFilterChain, IFilterChain_Vtbl, 0xdcfbdcf6_0dc2_45f5_9ab2_7c330ea09c29);
windows_core::imp::interface_hierarchy!(IFilterChain, windows_core::IUnknown);
impl IFilterChain {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StartChain<P0, P1>(&self, pstartfilter: P0, pendfilter: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).StartChain)(windows_core::Interface::as_raw(self), pstartfilter.param().abi(), pendfilter.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn PauseChain<P0, P1>(&self, pstartfilter: P0, pendfilter: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).PauseChain)(windows_core::Interface::as_raw(self), pstartfilter.param().abi(), pendfilter.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StopChain<P0, P1>(&self, pstartfilter: P0, pendfilter: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).StopChain)(windows_core::Interface::as_raw(self), pstartfilter.param().abi(), pendfilter.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveChain<P0, P1>(&self, pstartfilter: P0, pendfilter: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
        P1: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RemoveChain)(windows_core::Interface::as_raw(self), pstartfilter.param().abi(), pendfilter.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterChain_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub StartChain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    StartChain: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub PauseChain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    PauseChain: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub StopChain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    StopChain: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub RemoveChain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RemoveChain: usize,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IFilterChain_Impl: windows_core::IUnknownImpl {
    fn StartChain(&self, pstartfilter: windows_core::Ref<IBaseFilter>, pendfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn PauseChain(&self, pstartfilter: windows_core::Ref<IBaseFilter>, pendfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn StopChain(&self, pstartfilter: windows_core::Ref<IBaseFilter>, pendfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn RemoveChain(&self, pstartfilter: windows_core::Ref<IBaseFilter>, pendfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IFilterChain_Vtbl {
    pub const fn new<Identity: IFilterChain_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartChain<Identity: IFilterChain_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstartfilter: *mut core::ffi::c_void, pendfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterChain_Impl::StartChain(this, core::mem::transmute_copy(&pstartfilter), core::mem::transmute_copy(&pendfilter)).into()
            }
        }
        unsafe extern "system" fn PauseChain<Identity: IFilterChain_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstartfilter: *mut core::ffi::c_void, pendfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterChain_Impl::PauseChain(this, core::mem::transmute_copy(&pstartfilter), core::mem::transmute_copy(&pendfilter)).into()
            }
        }
        unsafe extern "system" fn StopChain<Identity: IFilterChain_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstartfilter: *mut core::ffi::c_void, pendfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterChain_Impl::StopChain(this, core::mem::transmute_copy(&pstartfilter), core::mem::transmute_copy(&pendfilter)).into()
            }
        }
        unsafe extern "system" fn RemoveChain<Identity: IFilterChain_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstartfilter: *mut core::ffi::c_void, pendfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterChain_Impl::RemoveChain(this, core::mem::transmute_copy(&pstartfilter), core::mem::transmute_copy(&pendfilter)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartChain: StartChain::<Identity, OFFSET>,
            PauseChain: PauseChain::<Identity, OFFSET>,
            StopChain: StopChain::<Identity, OFFSET>,
            RemoveChain: RemoveChain::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterChain as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IFilterChain {}
windows_core::imp::define_interface!(IFilterGraph, IFilterGraph_Vtbl, 0x56a8689f_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IFilterGraph, windows_core::IUnknown);
impl IFilterGraph {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddFilter<P0, P1>(&self, pfilter: P0, pname: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).AddFilter)(windows_core::Interface::as_raw(self), pfilter.param().abi(), pname.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilter<P0>(&self, pfilter: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RemoveFilter)(windows_core::Interface::as_raw(self), pfilter.param().abi()).ok() }
    }
    pub unsafe fn EnumFilters(&self) -> windows_core::Result<IEnumFilters> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumFilters)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindFilterByName<P0>(&self, pname: P0) -> windows_core::Result<IBaseFilter>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FindFilterByName)(windows_core::Interface::as_raw(self), pname.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn ConnectDirect<P0, P1>(&self, ppinout: P0, ppinin: P1, pmt: Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).ConnectDirect)(windows_core::Interface::as_raw(self), ppinout.param().abi(), ppinin.param().abi(), pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn Reconnect<P0>(&self, ppin: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Reconnect)(windows_core::Interface::as_raw(self), ppin.param().abi()).ok() }
    }
    pub unsafe fn Disconnect<P0>(&self, ppin: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Disconnect)(windows_core::Interface::as_raw(self), ppin.param().abi()).ok() }
    }
    pub unsafe fn SetDefaultSyncSource(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefaultSyncSource)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterGraph_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub AddFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    AddFilter: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub RemoveFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RemoveFilter: usize,
    pub EnumFilters: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub FindFilterByName: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    FindFilterByName: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub ConnectDirect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    ConnectDirect: usize,
    pub Reconnect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Disconnect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetDefaultSyncSource: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph_Impl: windows_core::IUnknownImpl {
    fn AddFilter(&self, pfilter: windows_core::Ref<IBaseFilter>, pname: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn RemoveFilter(&self, pfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn EnumFilters(&self) -> windows_core::Result<IEnumFilters>;
    fn FindFilterByName(&self, pname: &windows_core::PCWSTR) -> windows_core::Result<IBaseFilter>;
    fn ConnectDirect(&self, ppinout: windows_core::Ref<IPin>, ppinin: windows_core::Ref<IPin>, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn Reconnect(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<()>;
    fn Disconnect(&self, ppin: windows_core::Ref<IPin>) -> windows_core::Result<()>;
    fn SetDefaultSyncSource(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IFilterGraph_Vtbl {
    pub const fn new<Identity: IFilterGraph_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AddFilter<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void, pname: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::AddFilter(this, core::mem::transmute_copy(&pfilter), core::mem::transmute(&pname)).into()
            }
        }
        unsafe extern "system" fn RemoveFilter<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::RemoveFilter(this, core::mem::transmute_copy(&pfilter)).into()
            }
        }
        unsafe extern "system" fn EnumFilters<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterGraph_Impl::EnumFilters(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FindFilterByName<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pname: windows_core::PCWSTR, ppfilter: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterGraph_Impl::FindFilterByName(this, core::mem::transmute(&pname)) {
                    Ok(ok__) => {
                        ppfilter.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConnectDirect<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void, ppinin: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::ConnectDirect(this, core::mem::transmute_copy(&ppinout), core::mem::transmute_copy(&ppinin), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn Reconnect<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::Reconnect(this, core::mem::transmute_copy(&ppin)).into()
            }
        }
        unsafe extern "system" fn Disconnect<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::Disconnect(this, core::mem::transmute_copy(&ppin)).into()
            }
        }
        unsafe extern "system" fn SetDefaultSyncSource<Identity: IFilterGraph_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph_Impl::SetDefaultSyncSource(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AddFilter: AddFilter::<Identity, OFFSET>,
            RemoveFilter: RemoveFilter::<Identity, OFFSET>,
            EnumFilters: EnumFilters::<Identity, OFFSET>,
            FindFilterByName: FindFilterByName::<Identity, OFFSET>,
            ConnectDirect: ConnectDirect::<Identity, OFFSET>,
            Reconnect: Reconnect::<Identity, OFFSET>,
            Disconnect: Disconnect::<Identity, OFFSET>,
            SetDefaultSyncSource: SetDefaultSyncSource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterGraph as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IFilterGraph {}
windows_core::imp::define_interface!(IFilterGraph2, IFilterGraph2_Vtbl, 0x36b73882_c2c8_11cf_8b46_00805f6cef60);
impl core::ops::Deref for IFilterGraph2 {
    type Target = IGraphBuilder;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IFilterGraph2, windows_core::IUnknown, IFilterGraph, IGraphBuilder);
impl IFilterGraph2 {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddSourceFilterForMoniker<P0, P1, P2>(&self, pmoniker: P0, pctx: P1, lpcwstrfiltername: P2) -> windows_core::Result<IBaseFilter>
    where
        P0: windows_core::Param<super::super::System::Com::IMoniker>,
        P1: windows_core::Param<super::super::System::Com::IBindCtx>,
        P2: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddSourceFilterForMoniker)(windows_core::Interface::as_raw(self), pmoniker.param().abi(), pctx.param().abi(), lpcwstrfiltername.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn ReconnectEx<P0>(&self, ppin: P0, pmt: Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReconnectEx)(windows_core::Interface::as_raw(self), ppin.param().abi(), pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn RenderEx<P0>(&self, ppinout: P0, dwflags: u32, pvcontext: Option<*const u32>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).RenderEx)(windows_core::Interface::as_raw(self), ppinout.param().abi(), dwflags, pvcontext.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterGraph2_Vtbl {
    pub base__: IGraphBuilder_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub AddSourceFilterForMoniker: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, windows_core::PCWSTR, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    AddSourceFilterForMoniker: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub ReconnectEx: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    ReconnectEx: usize,
    pub RenderEx: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32, *const u32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph2_Impl: IGraphBuilder_Impl {
    fn AddSourceFilterForMoniker(&self, pmoniker: windows_core::Ref<super::super::System::Com::IMoniker>, pctx: windows_core::Ref<super::super::System::Com::IBindCtx>, lpcwstrfiltername: &windows_core::PCWSTR) -> windows_core::Result<IBaseFilter>;
    fn ReconnectEx(&self, ppin: windows_core::Ref<IPin>, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn RenderEx(&self, ppinout: windows_core::Ref<IPin>, dwflags: u32, pvcontext: *const u32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IFilterGraph2_Vtbl {
    pub const fn new<Identity: IFilterGraph2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AddSourceFilterForMoniker<Identity: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmoniker: *mut core::ffi::c_void, pctx: *mut core::ffi::c_void, lpcwstrfiltername: windows_core::PCWSTR, ppfilter: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterGraph2_Impl::AddSourceFilterForMoniker(this, core::mem::transmute_copy(&pmoniker), core::mem::transmute_copy(&pctx), core::mem::transmute(&lpcwstrfiltername)) {
                    Ok(ok__) => {
                        ppfilter.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ReconnectEx<Identity: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph2_Impl::ReconnectEx(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn RenderEx<Identity: IFilterGraph2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void, dwflags: u32, pvcontext: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph2_Impl::RenderEx(this, core::mem::transmute_copy(&ppinout), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&pvcontext)).into()
            }
        }
        Self {
            base__: IGraphBuilder_Vtbl::new::<Identity, OFFSET>(),
            AddSourceFilterForMoniker: AddSourceFilterForMoniker::<Identity, OFFSET>,
            ReconnectEx: ReconnectEx::<Identity, OFFSET>,
            RenderEx: RenderEx::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterGraph2 as windows_core::Interface>::IID || iid == &<IFilterGraph as windows_core::Interface>::IID || iid == &<IGraphBuilder as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IFilterGraph2 {}
windows_core::imp::define_interface!(IFilterGraph3, IFilterGraph3_Vtbl, 0xaaf38154_b80b_422f_91e6_b66467509a07);
impl core::ops::Deref for IFilterGraph3 {
    type Target = IFilterGraph2;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IFilterGraph3, windows_core::IUnknown, IFilterGraph, IGraphBuilder, IFilterGraph2);
impl IFilterGraph3 {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetSyncSourceEx<P0, P1, P2>(&self, pclockformostoffiltergraph: P0, pclockforfilter: P1, pfilter: P2) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::IReferenceClock>,
        P1: windows_core::Param<super::IReferenceClock>,
        P2: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetSyncSourceEx)(windows_core::Interface::as_raw(self), pclockformostoffiltergraph.param().abi(), pclockforfilter.param().abi(), pfilter.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterGraph3_Vtbl {
    pub base__: IFilterGraph2_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub SetSyncSourceEx: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetSyncSourceEx: usize,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IFilterGraph3_Impl: IFilterGraph2_Impl {
    fn SetSyncSourceEx(&self, pclockformostoffiltergraph: windows_core::Ref<super::IReferenceClock>, pclockforfilter: windows_core::Ref<super::IReferenceClock>, pfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IFilterGraph3_Vtbl {
    pub const fn new<Identity: IFilterGraph3_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetSyncSourceEx<Identity: IFilterGraph3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclockformostoffiltergraph: *mut core::ffi::c_void, pclockforfilter: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterGraph3_Impl::SetSyncSourceEx(this, core::mem::transmute_copy(&pclockformostoffiltergraph), core::mem::transmute_copy(&pclockforfilter), core::mem::transmute_copy(&pfilter)).into()
            }
        }
        Self { base__: IFilterGraph2_Vtbl::new::<Identity, OFFSET>(), SetSyncSourceEx: SetSyncSourceEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterGraph3 as windows_core::Interface>::IID || iid == &<IFilterGraph as windows_core::Interface>::IID || iid == &<IGraphBuilder as windows_core::Interface>::IID || iid == &<IFilterGraph2 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IFilterGraph3 {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IFilterInfo, IFilterInfo_Vtbl, 0x56a868ba_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IFilterInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IFilterInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IFilterInfo {
    pub unsafe fn FindPin(&self, strpinid: &windows_core::BSTR) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FindPin)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strpinid), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Name(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Name)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn VendorInfo(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).VendorInfo)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn Filter(&self) -> windows_core::Result<windows_core::IUnknown> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Filter)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Pins(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Pins)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn IsFileSource(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsFileSource)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Filename(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Filename)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn SetFilename(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFilename)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strfilename)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IFilterInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub FindPin: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Name: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub VendorInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Filter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Pins: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub IsFileSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Filename: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetFilename: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IFilterInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn FindPin(&self, strpinid: &windows_core::BSTR) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn Name(&self) -> windows_core::Result<windows_core::BSTR>;
    fn VendorInfo(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Filter(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn Pins(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn IsFileSource(&self) -> windows_core::Result<i32>;
    fn Filename(&self) -> windows_core::Result<windows_core::BSTR>;
    fn SetFilename(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IFilterInfo_Vtbl {
    pub const fn new<Identity: IFilterInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FindPin<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strpinid: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::FindPin(this, core::mem::transmute(&strpinid)) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Name<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::Name(this) {
                    Ok(ok__) => {
                        strname.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn VendorInfo<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strvendorinfo: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::VendorInfo(this) {
                    Ok(ok__) => {
                        strvendorinfo.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Filter<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::Filter(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Pins<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::Pins(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsFileSource<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbissource: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::IsFileSource(this) {
                    Ok(ok__) => {
                        pbissource.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Filename<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstrfilename: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterInfo_Impl::Filename(this) {
                    Ok(ok__) => {
                        pstrfilename.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFilename<Identity: IFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strfilename: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterInfo_Impl::SetFilename(this, core::mem::transmute(&strfilename)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            FindPin: FindPin::<Identity, OFFSET>,
            Name: Name::<Identity, OFFSET>,
            VendorInfo: VendorInfo::<Identity, OFFSET>,
            Filter: Filter::<Identity, OFFSET>,
            Pins: Pins::<Identity, OFFSET>,
            IsFileSource: IsFileSource::<Identity, OFFSET>,
            Filename: Filename::<Identity, OFFSET>,
            SetFilename: SetFilename::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IFilterInfo {}
windows_core::imp::define_interface!(IFilterMapper, IFilterMapper_Vtbl, 0x56a868a3_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IFilterMapper, windows_core::IUnknown);
impl IFilterMapper {
    pub unsafe fn RegisterFilter<P1>(&self, clsid: windows_core::GUID, name: P1, dwmerit: u32) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterFilter)(windows_core::Interface::as_raw(self), core::mem::transmute(clsid), name.param().abi(), dwmerit).ok() }
    }
    pub unsafe fn RegisterFilterInstance<P1>(&self, clsid: windows_core::GUID, name: P1) -> windows_core::Result<windows_core::GUID>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).RegisterFilterInstance)(windows_core::Interface::as_raw(self), core::mem::transmute(clsid), name.param().abi(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RegisterPin<P1, P7>(&self, filter: windows_core::GUID, name: P1, brendered: bool, boutput: bool, bzero: bool, bmany: bool, connectstofilter: windows_core::GUID, connectstopin: P7) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
        P7: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterPin)(windows_core::Interface::as_raw(self), core::mem::transmute(filter), name.param().abi(), brendered.into(), boutput.into(), bzero.into(), bmany.into(), core::mem::transmute(connectstofilter), connectstopin.param().abi()).ok() }
    }
    pub unsafe fn RegisterPinType<P1>(&self, clsfilter: windows_core::GUID, strname: P1, clsmajortype: windows_core::GUID, clssubtype: windows_core::GUID) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterPinType)(windows_core::Interface::as_raw(self), core::mem::transmute(clsfilter), strname.param().abi(), core::mem::transmute(clsmajortype), core::mem::transmute(clssubtype)).ok() }
    }
    pub unsafe fn UnregisterFilter(&self, filter: windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnregisterFilter)(windows_core::Interface::as_raw(self), core::mem::transmute(filter)).ok() }
    }
    pub unsafe fn UnregisterFilterInstance(&self, mrid: windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnregisterFilterInstance)(windows_core::Interface::as_raw(self), core::mem::transmute(mrid)).ok() }
    }
    pub unsafe fn UnregisterPin<P1>(&self, filter: windows_core::GUID, name: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).UnregisterPin)(windows_core::Interface::as_raw(self), core::mem::transmute(filter), name.param().abi()).ok() }
    }
    pub unsafe fn EnumMatchingFilters(&self, ppenum: *mut Option<IEnumRegFilters>, dwmerit: u32, binputneeded: bool, clsinmaj: windows_core::GUID, clsinsub: windows_core::GUID, brender: bool, boututneeded: bool, clsoutmaj: windows_core::GUID, clsoutsub: windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnumMatchingFilters)(windows_core::Interface::as_raw(self), core::mem::transmute(ppenum), dwmerit, binputneeded.into(), core::mem::transmute(clsinmaj), core::mem::transmute(clsinsub), brender.into(), boututneeded.into(), core::mem::transmute(clsoutmaj), core::mem::transmute(clsoutsub)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterMapper_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub RegisterFilter: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, windows_core::PCWSTR, u32) -> windows_core::HRESULT,
    pub RegisterFilterInstance: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, windows_core::PCWSTR, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub RegisterPin: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, windows_core::PCWSTR, windows_core::BOOL, windows_core::BOOL, windows_core::BOOL, windows_core::BOOL, windows_core::GUID, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub RegisterPinType: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, windows_core::PCWSTR, windows_core::GUID, windows_core::GUID) -> windows_core::HRESULT,
    pub UnregisterFilter: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID) -> windows_core::HRESULT,
    pub UnregisterFilterInstance: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID) -> windows_core::HRESULT,
    pub UnregisterPin: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub EnumMatchingFilters: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, u32, windows_core::BOOL, windows_core::GUID, windows_core::GUID, windows_core::BOOL, windows_core::BOOL, windows_core::GUID, windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IFilterMapper_Impl: windows_core::IUnknownImpl {
    fn RegisterFilter(&self, clsid: &windows_core::GUID, name: &windows_core::PCWSTR, dwmerit: u32) -> windows_core::Result<()>;
    fn RegisterFilterInstance(&self, clsid: &windows_core::GUID, name: &windows_core::PCWSTR) -> windows_core::Result<windows_core::GUID>;
    fn RegisterPin(&self, filter: &windows_core::GUID, name: &windows_core::PCWSTR, brendered: windows_core::BOOL, boutput: windows_core::BOOL, bzero: windows_core::BOOL, bmany: windows_core::BOOL, connectstofilter: &windows_core::GUID, connectstopin: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn RegisterPinType(&self, clsfilter: &windows_core::GUID, strname: &windows_core::PCWSTR, clsmajortype: &windows_core::GUID, clssubtype: &windows_core::GUID) -> windows_core::Result<()>;
    fn UnregisterFilter(&self, filter: &windows_core::GUID) -> windows_core::Result<()>;
    fn UnregisterFilterInstance(&self, mrid: &windows_core::GUID) -> windows_core::Result<()>;
    fn UnregisterPin(&self, filter: &windows_core::GUID, name: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn EnumMatchingFilters(&self, ppenum: windows_core::OutRef<IEnumRegFilters>, dwmerit: u32, binputneeded: windows_core::BOOL, clsinmaj: &windows_core::GUID, clsinsub: &windows_core::GUID, brender: windows_core::BOOL, boututneeded: windows_core::BOOL, clsoutmaj: &windows_core::GUID, clsoutsub: &windows_core::GUID) -> windows_core::Result<()>;
}
impl IFilterMapper_Vtbl {
    pub const fn new<Identity: IFilterMapper_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RegisterFilter<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: windows_core::GUID, name: windows_core::PCWSTR, dwmerit: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::RegisterFilter(this, core::mem::transmute(&clsid), core::mem::transmute(&name), core::mem::transmute_copy(&dwmerit)).into()
            }
        }
        unsafe extern "system" fn RegisterFilterInstance<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: windows_core::GUID, name: windows_core::PCWSTR, mrid: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterMapper_Impl::RegisterFilterInstance(this, core::mem::transmute(&clsid), core::mem::transmute(&name)) {
                    Ok(ok__) => {
                        mrid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RegisterPin<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filter: windows_core::GUID, name: windows_core::PCWSTR, brendered: windows_core::BOOL, boutput: windows_core::BOOL, bzero: windows_core::BOOL, bmany: windows_core::BOOL, connectstofilter: windows_core::GUID, connectstopin: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::RegisterPin(this, core::mem::transmute(&filter), core::mem::transmute(&name), core::mem::transmute_copy(&brendered), core::mem::transmute_copy(&boutput), core::mem::transmute_copy(&bzero), core::mem::transmute_copy(&bmany), core::mem::transmute(&connectstofilter), core::mem::transmute(&connectstopin)).into()
            }
        }
        unsafe extern "system" fn RegisterPinType<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsfilter: windows_core::GUID, strname: windows_core::PCWSTR, clsmajortype: windows_core::GUID, clssubtype: windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::RegisterPinType(this, core::mem::transmute(&clsfilter), core::mem::transmute(&strname), core::mem::transmute(&clsmajortype), core::mem::transmute(&clssubtype)).into()
            }
        }
        unsafe extern "system" fn UnregisterFilter<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filter: windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::UnregisterFilter(this, core::mem::transmute(&filter)).into()
            }
        }
        unsafe extern "system" fn UnregisterFilterInstance<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mrid: windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::UnregisterFilterInstance(this, core::mem::transmute(&mrid)).into()
            }
        }
        unsafe extern "system" fn UnregisterPin<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filter: windows_core::GUID, name: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::UnregisterPin(this, core::mem::transmute(&filter), core::mem::transmute(&name)).into()
            }
        }
        unsafe extern "system" fn EnumMatchingFilters<Identity: IFilterMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void, dwmerit: u32, binputneeded: windows_core::BOOL, clsinmaj: windows_core::GUID, clsinsub: windows_core::GUID, brender: windows_core::BOOL, boututneeded: windows_core::BOOL, clsoutmaj: windows_core::GUID, clsoutsub: windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper_Impl::EnumMatchingFilters(this, core::mem::transmute_copy(&ppenum), core::mem::transmute_copy(&dwmerit), core::mem::transmute_copy(&binputneeded), core::mem::transmute(&clsinmaj), core::mem::transmute(&clsinsub), core::mem::transmute_copy(&brender), core::mem::transmute_copy(&boututneeded), core::mem::transmute(&clsoutmaj), core::mem::transmute(&clsoutsub)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RegisterFilter: RegisterFilter::<Identity, OFFSET>,
            RegisterFilterInstance: RegisterFilterInstance::<Identity, OFFSET>,
            RegisterPin: RegisterPin::<Identity, OFFSET>,
            RegisterPinType: RegisterPinType::<Identity, OFFSET>,
            UnregisterFilter: UnregisterFilter::<Identity, OFFSET>,
            UnregisterFilterInstance: UnregisterFilterInstance::<Identity, OFFSET>,
            UnregisterPin: UnregisterPin::<Identity, OFFSET>,
            EnumMatchingFilters: EnumMatchingFilters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterMapper as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IFilterMapper {}
windows_core::imp::define_interface!(IFilterMapper2, IFilterMapper2_Vtbl, 0xb79bb0b0_33c1_11d1_abe1_00a0c905f375);
windows_core::imp::interface_hierarchy!(IFilterMapper2, windows_core::IUnknown);
impl IFilterMapper2 {
    pub unsafe fn CreateCategory<P2>(&self, clsidcategory: *const windows_core::GUID, dwcategorymerit: u32, description: P2) -> windows_core::Result<()>
    where
        P2: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).CreateCategory)(windows_core::Interface::as_raw(self), clsidcategory, dwcategorymerit, description.param().abi()).ok() }
    }
    pub unsafe fn UnregisterFilter<P1>(&self, pclsidcategory: *const windows_core::GUID, szinstance: P1, filter: *const windows_core::GUID) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).UnregisterFilter)(windows_core::Interface::as_raw(self), pclsidcategory, szinstance.param().abi(), filter).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RegisterFilter<P1, P4>(&self, clsidfilter: *const windows_core::GUID, name: P1, ppmoniker: Option<*mut Option<super::super::System::Com::IMoniker>>, pclsidcategory: *const windows_core::GUID, szinstance: P4, prf2: *const REGFILTER2) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
        P4: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterFilter)(windows_core::Interface::as_raw(self), clsidfilter, name.param().abi(), ppmoniker.unwrap_or(core::mem::zeroed()) as _, pclsidcategory, szinstance.param().abi(), prf2).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumMatchingFilters(&self, ppenum: *mut Option<super::super::System::Com::IEnumMoniker>, dwflags: u32, bexactmatch: bool, dwmerit: u32, binputneeded: bool, cinputtypes: u32, pinputtypes: Option<*const windows_core::GUID>, pmedin: Option<*const REGPINMEDIUM>, ppincategoryin: Option<*const windows_core::GUID>, brender: bool, boutputneeded: bool, coutputtypes: u32, poutputtypes: Option<*const windows_core::GUID>, pmedout: Option<*const REGPINMEDIUM>, ppincategoryout: Option<*const windows_core::GUID>) -> windows_core::Result<()> {
        unsafe {
            (windows_core::Interface::vtable(self).EnumMatchingFilters)(
                windows_core::Interface::as_raw(self),
                core::mem::transmute(ppenum),
                dwflags,
                bexactmatch.into(),
                dwmerit,
                binputneeded.into(),
                cinputtypes,
                pinputtypes.unwrap_or(core::mem::zeroed()) as _,
                pmedin.unwrap_or(core::mem::zeroed()) as _,
                ppincategoryin.unwrap_or(core::mem::zeroed()) as _,
                brender.into(),
                boutputneeded.into(),
                coutputtypes,
                poutputtypes.unwrap_or(core::mem::zeroed()) as _,
                pmedout.unwrap_or(core::mem::zeroed()) as _,
                ppincategoryout.unwrap_or(core::mem::zeroed()) as _,
            )
            .ok()
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterMapper2_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub CreateCategory: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, u32, windows_core::PCWSTR) -> windows_core::HRESULT,
    pub UnregisterFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, windows_core::PCWSTR, *const windows_core::GUID) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub RegisterFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, windows_core::PCWSTR, *mut *mut core::ffi::c_void, *const windows_core::GUID, windows_core::PCWSTR, *const REGFILTER2) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RegisterFilter: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub EnumMatchingFilters: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, u32, windows_core::BOOL, u32, windows_core::BOOL, u32, *const windows_core::GUID, *const REGPINMEDIUM, *const windows_core::GUID, windows_core::BOOL, windows_core::BOOL, u32, *const windows_core::GUID, *const REGPINMEDIUM, *const windows_core::GUID) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    EnumMatchingFilters: usize,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IFilterMapper2_Impl: windows_core::IUnknownImpl {
    fn CreateCategory(&self, clsidcategory: *const windows_core::GUID, dwcategorymerit: u32, description: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn UnregisterFilter(&self, pclsidcategory: *const windows_core::GUID, szinstance: &windows_core::PCWSTR, filter: *const windows_core::GUID) -> windows_core::Result<()>;
    fn RegisterFilter(&self, clsidfilter: *const windows_core::GUID, name: &windows_core::PCWSTR, ppmoniker: windows_core::OutRef<super::super::System::Com::IMoniker>, pclsidcategory: *const windows_core::GUID, szinstance: &windows_core::PCWSTR, prf2: *const REGFILTER2) -> windows_core::Result<()>;
    fn EnumMatchingFilters(&self, ppenum: windows_core::OutRef<super::super::System::Com::IEnumMoniker>, dwflags: u32, bexactmatch: windows_core::BOOL, dwmerit: u32, binputneeded: windows_core::BOOL, cinputtypes: u32, pinputtypes: *const windows_core::GUID, pmedin: *const REGPINMEDIUM, ppincategoryin: *const windows_core::GUID, brender: windows_core::BOOL, boutputneeded: windows_core::BOOL, coutputtypes: u32, poutputtypes: *const windows_core::GUID, pmedout: *const REGPINMEDIUM, ppincategoryout: *const windows_core::GUID) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IFilterMapper2_Vtbl {
    pub const fn new<Identity: IFilterMapper2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateCategory<Identity: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsidcategory: *const windows_core::GUID, dwcategorymerit: u32, description: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper2_Impl::CreateCategory(this, core::mem::transmute_copy(&clsidcategory), core::mem::transmute_copy(&dwcategorymerit), core::mem::transmute(&description)).into()
            }
        }
        unsafe extern "system" fn UnregisterFilter<Identity: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclsidcategory: *const windows_core::GUID, szinstance: windows_core::PCWSTR, filter: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper2_Impl::UnregisterFilter(this, core::mem::transmute_copy(&pclsidcategory), core::mem::transmute(&szinstance), core::mem::transmute_copy(&filter)).into()
            }
        }
        unsafe extern "system" fn RegisterFilter<Identity: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsidfilter: *const windows_core::GUID, name: windows_core::PCWSTR, ppmoniker: *mut *mut core::ffi::c_void, pclsidcategory: *const windows_core::GUID, szinstance: windows_core::PCWSTR, prf2: *const REGFILTER2) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper2_Impl::RegisterFilter(this, core::mem::transmute_copy(&clsidfilter), core::mem::transmute(&name), core::mem::transmute_copy(&ppmoniker), core::mem::transmute_copy(&pclsidcategory), core::mem::transmute(&szinstance), core::mem::transmute_copy(&prf2)).into()
            }
        }
        unsafe extern "system" fn EnumMatchingFilters<Identity: IFilterMapper2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void, dwflags: u32, bexactmatch: windows_core::BOOL, dwmerit: u32, binputneeded: windows_core::BOOL, cinputtypes: u32, pinputtypes: *const windows_core::GUID, pmedin: *const REGPINMEDIUM, ppincategoryin: *const windows_core::GUID, brender: windows_core::BOOL, boutputneeded: windows_core::BOOL, coutputtypes: u32, poutputtypes: *const windows_core::GUID, pmedout: *const REGPINMEDIUM, ppincategoryout: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFilterMapper2_Impl::EnumMatchingFilters(
                    this,
                    core::mem::transmute_copy(&ppenum),
                    core::mem::transmute_copy(&dwflags),
                    core::mem::transmute_copy(&bexactmatch),
                    core::mem::transmute_copy(&dwmerit),
                    core::mem::transmute_copy(&binputneeded),
                    core::mem::transmute_copy(&cinputtypes),
                    core::mem::transmute_copy(&pinputtypes),
                    core::mem::transmute_copy(&pmedin),
                    core::mem::transmute_copy(&ppincategoryin),
                    core::mem::transmute_copy(&brender),
                    core::mem::transmute_copy(&boutputneeded),
                    core::mem::transmute_copy(&coutputtypes),
                    core::mem::transmute_copy(&poutputtypes),
                    core::mem::transmute_copy(&pmedout),
                    core::mem::transmute_copy(&ppincategoryout),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateCategory: CreateCategory::<Identity, OFFSET>,
            UnregisterFilter: UnregisterFilter::<Identity, OFFSET>,
            RegisterFilter: RegisterFilter::<Identity, OFFSET>,
            EnumMatchingFilters: EnumMatchingFilters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterMapper2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IFilterMapper2 {}
windows_core::imp::define_interface!(IFilterMapper3, IFilterMapper3_Vtbl, 0xb79bb0b1_33c1_11d1_abe1_00a0c905f375);
impl core::ops::Deref for IFilterMapper3 {
    type Target = IFilterMapper2;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IFilterMapper3, windows_core::IUnknown, IFilterMapper2);
impl IFilterMapper3 {
    pub unsafe fn GetICreateDevEnum(&self) -> windows_core::Result<ICreateDevEnum> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetICreateDevEnum)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFilterMapper3_Vtbl {
    pub base__: IFilterMapper2_Vtbl,
    pub GetICreateDevEnum: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IFilterMapper3_Impl: IFilterMapper2_Impl {
    fn GetICreateDevEnum(&self) -> windows_core::Result<ICreateDevEnum>;
}
#[cfg(feature = "Win32_System_Com")]
impl IFilterMapper3_Vtbl {
    pub const fn new<Identity: IFilterMapper3_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetICreateDevEnum<Identity: IFilterMapper3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFilterMapper3_Impl::GetICreateDevEnum(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: IFilterMapper2_Vtbl::new::<Identity, OFFSET>(), GetICreateDevEnum: GetICreateDevEnum::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFilterMapper3 as windows_core::Interface>::IID || iid == &<IFilterMapper2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IFilterMapper3 {}
windows_core::imp::define_interface!(IFrequencyMap, IFrequencyMap_Vtbl, 0x06fb45c1_693c_4ea7_b79f_7a6a54d8def2);
windows_core::imp::interface_hierarchy!(IFrequencyMap, windows_core::IUnknown);
impl IFrequencyMap {
    pub unsafe fn get_FrequencyMapping(&self, ulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_FrequencyMapping)(windows_core::Interface::as_raw(self), ulcount as _, ppullist as _).ok() }
    }
    pub unsafe fn put_FrequencyMapping(&self, plist: &[u32]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_FrequencyMapping)(windows_core::Interface::as_raw(self), plist.len().try_into().unwrap(), core::mem::transmute(plist.as_ptr())).ok() }
    }
    pub unsafe fn CountryCode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CountryCode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCountryCode(&self, ulcountrycode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCountryCode)(windows_core::Interface::as_raw(self), ulcountrycode).ok() }
    }
    pub unsafe fn get_DefaultFrequencyMapping(&self, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_DefaultFrequencyMapping)(windows_core::Interface::as_raw(self), ulcountrycode, pulcount as _, ppullist as _).ok() }
    }
    pub unsafe fn get_CountryCodeList(&self, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_CountryCodeList)(windows_core::Interface::as_raw(self), pulcount as _, ppullist as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFrequencyMap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_FrequencyMapping: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u32) -> windows_core::HRESULT,
    pub put_FrequencyMapping: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u32) -> windows_core::HRESULT,
    pub CountryCode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetCountryCode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub get_DefaultFrequencyMapping: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32, *mut *mut u32) -> windows_core::HRESULT,
    pub get_CountryCodeList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u32) -> windows_core::HRESULT,
}
pub trait IFrequencyMap_Impl: windows_core::IUnknownImpl {
    fn get_FrequencyMapping(&self, ulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()>;
    fn put_FrequencyMapping(&self, ulcount: u32, plist: *const u32) -> windows_core::Result<()>;
    fn CountryCode(&self) -> windows_core::Result<u32>;
    fn SetCountryCode(&self, ulcountrycode: u32) -> windows_core::Result<()>;
    fn get_DefaultFrequencyMapping(&self, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()>;
    fn get_CountryCodeList(&self, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::Result<()>;
}
impl IFrequencyMap_Vtbl {
    pub const fn new<Identity: IFrequencyMap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_FrequencyMapping<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFrequencyMap_Impl::get_FrequencyMapping(this, core::mem::transmute_copy(&ulcount), core::mem::transmute_copy(&ppullist)).into()
            }
        }
        unsafe extern "system" fn put_FrequencyMapping<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcount: u32, plist: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFrequencyMap_Impl::put_FrequencyMapping(this, core::mem::transmute_copy(&ulcount), core::mem::transmute_copy(&plist)).into()
            }
        }
        unsafe extern "system" fn CountryCode<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcountrycode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFrequencyMap_Impl::CountryCode(this) {
                    Ok(ok__) => {
                        pulcountrycode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCountryCode<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcountrycode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFrequencyMap_Impl::SetCountryCode(this, core::mem::transmute_copy(&ulcountrycode)).into()
            }
        }
        unsafe extern "system" fn get_DefaultFrequencyMapping<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulcountrycode: u32, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFrequencyMap_Impl::get_DefaultFrequencyMapping(this, core::mem::transmute_copy(&ulcountrycode), core::mem::transmute_copy(&pulcount), core::mem::transmute_copy(&ppullist)).into()
            }
        }
        unsafe extern "system" fn get_CountryCodeList<Identity: IFrequencyMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulcount: *mut u32, ppullist: *mut *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFrequencyMap_Impl::get_CountryCodeList(this, core::mem::transmute_copy(&pulcount), core::mem::transmute_copy(&ppullist)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_FrequencyMapping: get_FrequencyMapping::<Identity, OFFSET>,
            put_FrequencyMapping: put_FrequencyMapping::<Identity, OFFSET>,
            CountryCode: CountryCode::<Identity, OFFSET>,
            SetCountryCode: SetCountryCode::<Identity, OFFSET>,
            get_DefaultFrequencyMapping: get_DefaultFrequencyMapping::<Identity, OFFSET>,
            get_CountryCodeList: get_CountryCodeList::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFrequencyMap as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IFrequencyMap {}
windows_core::imp::define_interface!(IFullScreenVideo, IFullScreenVideo_Vtbl, 0xdd1d7110_7836_11cf_bf47_00aa0055595a);
windows_core::imp::interface_hierarchy!(IFullScreenVideo, windows_core::IUnknown);
impl IFullScreenVideo {
    pub unsafe fn CountModes(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CountModes)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetModeInfo(&self, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetModeInfo)(windows_core::Interface::as_raw(self), mode, pwidth as _, pheight as _, pdepth as _).ok() }
    }
    pub unsafe fn GetCurrentMode(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn IsModeAvailable(&self, mode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsModeAvailable)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn IsModeEnabled(&self, mode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsModeEnabled)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn SetEnabled(&self, mode: i32, benabled: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetEnabled)(windows_core::Interface::as_raw(self), mode, benabled).ok() }
    }
    pub unsafe fn GetClipFactor(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetClipFactor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetClipFactor(&self, clipfactor: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetClipFactor)(windows_core::Interface::as_raw(self), clipfactor).ok() }
    }
    pub unsafe fn SetMessageDrain(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMessageDrain)(windows_core::Interface::as_raw(self), hwnd).ok() }
    }
    pub unsafe fn GetMessageDrain(&self) -> windows_core::Result<super::super::Foundation::HWND> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMessageDrain)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMonitor(&self, monitor: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMonitor)(windows_core::Interface::as_raw(self), monitor).ok() }
    }
    pub unsafe fn GetMonitor(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMonitor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn HideOnDeactivate(&self, hide: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HideOnDeactivate)(windows_core::Interface::as_raw(self), hide).ok() }
    }
    pub unsafe fn IsHideOnDeactivate(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsHideOnDeactivate)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn SetCaption(&self, strcaption: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCaption)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strcaption)).ok() }
    }
    pub unsafe fn GetCaption(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCaption)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn SetDefault(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefault)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFullScreenVideo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub CountModes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub GetModeInfo: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetCurrentMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub IsModeAvailable: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub IsModeEnabled: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SetEnabled: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub GetClipFactor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetClipFactor: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SetMessageDrain: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND) -> windows_core::HRESULT,
    pub GetMessageDrain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::HWND) -> windows_core::HRESULT,
    pub SetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub HideOnDeactivate: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub IsHideOnDeactivate: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetCaption: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetCaption: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetDefault: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IFullScreenVideo_Impl: windows_core::IUnknownImpl {
    fn CountModes(&self) -> windows_core::Result<i32>;
    fn GetModeInfo(&self, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> windows_core::Result<()>;
    fn GetCurrentMode(&self) -> windows_core::Result<i32>;
    fn IsModeAvailable(&self, mode: i32) -> windows_core::Result<()>;
    fn IsModeEnabled(&self, mode: i32) -> windows_core::Result<()>;
    fn SetEnabled(&self, mode: i32, benabled: i32) -> windows_core::Result<()>;
    fn GetClipFactor(&self) -> windows_core::Result<i32>;
    fn SetClipFactor(&self, clipfactor: i32) -> windows_core::Result<()>;
    fn SetMessageDrain(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn GetMessageDrain(&self) -> windows_core::Result<super::super::Foundation::HWND>;
    fn SetMonitor(&self, monitor: i32) -> windows_core::Result<()>;
    fn GetMonitor(&self) -> windows_core::Result<i32>;
    fn HideOnDeactivate(&self, hide: i32) -> windows_core::Result<()>;
    fn IsHideOnDeactivate(&self) -> windows_core::Result<()>;
    fn SetCaption(&self, strcaption: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetCaption(&self) -> windows_core::Result<windows_core::BSTR>;
    fn SetDefault(&self) -> windows_core::Result<()>;
}
impl IFullScreenVideo_Vtbl {
    pub const fn new<Identity: IFullScreenVideo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CountModes<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmodes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::CountModes(this) {
                    Ok(ok__) => {
                        pmodes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetModeInfo<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::GetModeInfo(this, core::mem::transmute_copy(&mode), core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight), core::mem::transmute_copy(&pdepth)).into()
            }
        }
        unsafe extern "system" fn GetCurrentMode<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::GetCurrentMode(this) {
                    Ok(ok__) => {
                        pmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsModeAvailable<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::IsModeAvailable(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn IsModeEnabled<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::IsModeEnabled(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn SetEnabled<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: i32, benabled: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetEnabled(this, core::mem::transmute_copy(&mode), core::mem::transmute_copy(&benabled)).into()
            }
        }
        unsafe extern "system" fn GetClipFactor<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclipfactor: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::GetClipFactor(this) {
                    Ok(ok__) => {
                        pclipfactor.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetClipFactor<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clipfactor: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetClipFactor(this, core::mem::transmute_copy(&clipfactor)).into()
            }
        }
        unsafe extern "system" fn SetMessageDrain<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetMessageDrain(this, core::mem::transmute_copy(&hwnd)).into()
            }
        }
        unsafe extern "system" fn GetMessageDrain<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: *mut super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::GetMessageDrain(this) {
                    Ok(ok__) => {
                        hwnd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMonitor<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, monitor: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetMonitor(this, core::mem::transmute_copy(&monitor)).into()
            }
        }
        unsafe extern "system" fn GetMonitor<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, monitor: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::GetMonitor(this) {
                    Ok(ok__) => {
                        monitor.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn HideOnDeactivate<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hide: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::HideOnDeactivate(this, core::mem::transmute_copy(&hide)).into()
            }
        }
        unsafe extern "system" fn IsHideOnDeactivate<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::IsHideOnDeactivate(this).into()
            }
        }
        unsafe extern "system" fn SetCaption<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strcaption: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetCaption(this, core::mem::transmute(&strcaption)).into()
            }
        }
        unsafe extern "system" fn GetCaption<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstrcaption: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideo_Impl::GetCaption(this) {
                    Ok(ok__) => {
                        pstrcaption.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDefault<Identity: IFullScreenVideo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideo_Impl::SetDefault(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CountModes: CountModes::<Identity, OFFSET>,
            GetModeInfo: GetModeInfo::<Identity, OFFSET>,
            GetCurrentMode: GetCurrentMode::<Identity, OFFSET>,
            IsModeAvailable: IsModeAvailable::<Identity, OFFSET>,
            IsModeEnabled: IsModeEnabled::<Identity, OFFSET>,
            SetEnabled: SetEnabled::<Identity, OFFSET>,
            GetClipFactor: GetClipFactor::<Identity, OFFSET>,
            SetClipFactor: SetClipFactor::<Identity, OFFSET>,
            SetMessageDrain: SetMessageDrain::<Identity, OFFSET>,
            GetMessageDrain: GetMessageDrain::<Identity, OFFSET>,
            SetMonitor: SetMonitor::<Identity, OFFSET>,
            GetMonitor: GetMonitor::<Identity, OFFSET>,
            HideOnDeactivate: HideOnDeactivate::<Identity, OFFSET>,
            IsHideOnDeactivate: IsHideOnDeactivate::<Identity, OFFSET>,
            SetCaption: SetCaption::<Identity, OFFSET>,
            GetCaption: GetCaption::<Identity, OFFSET>,
            SetDefault: SetDefault::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFullScreenVideo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IFullScreenVideo {}
windows_core::imp::define_interface!(IFullScreenVideoEx, IFullScreenVideoEx_Vtbl, 0x53479470_f1dd_11cf_bc42_00aa00ac74f6);
impl core::ops::Deref for IFullScreenVideoEx {
    type Target = IFullScreenVideo;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IFullScreenVideoEx, windows_core::IUnknown, IFullScreenVideo);
impl IFullScreenVideoEx {
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub unsafe fn SetAcceleratorTable(&self, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAcceleratorTable)(windows_core::Interface::as_raw(self), hwnd, haccel).ok() }
    }
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub unsafe fn GetAcceleratorTable(&self, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAcceleratorTable)(windows_core::Interface::as_raw(self), phwnd as _, phaccel as _).ok() }
    }
    pub unsafe fn KeepPixelAspectRatio(&self, keepaspect: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).KeepPixelAspectRatio)(windows_core::Interface::as_raw(self), keepaspect).ok() }
    }
    pub unsafe fn IsKeepPixelAspectRatio(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsKeepPixelAspectRatio)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFullScreenVideoEx_Vtbl {
    pub base__: IFullScreenVideo_Vtbl,
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub SetAcceleratorTable: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND, super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_UI_WindowsAndMessaging"))]
    SetAcceleratorTable: usize,
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub GetAcceleratorTable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::HWND, *mut super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_UI_WindowsAndMessaging"))]
    GetAcceleratorTable: usize,
    pub KeepPixelAspectRatio: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub IsKeepPixelAspectRatio: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_UI_WindowsAndMessaging")]
pub trait IFullScreenVideoEx_Impl: IFullScreenVideo_Impl {
    fn SetAcceleratorTable(&self, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::Result<()>;
    fn GetAcceleratorTable(&self, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::Result<()>;
    fn KeepPixelAspectRatio(&self, keepaspect: i32) -> windows_core::Result<()>;
    fn IsKeepPixelAspectRatio(&self) -> windows_core::Result<i32>;
}
#[cfg(feature = "Win32_UI_WindowsAndMessaging")]
impl IFullScreenVideoEx_Vtbl {
    pub const fn new<Identity: IFullScreenVideoEx_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAcceleratorTable<Identity: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND, haccel: super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideoEx_Impl::SetAcceleratorTable(this, core::mem::transmute_copy(&hwnd), core::mem::transmute_copy(&haccel)).into()
            }
        }
        unsafe extern "system" fn GetAcceleratorTable<Identity: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND, phaccel: *mut super::super::UI::WindowsAndMessaging::HACCEL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideoEx_Impl::GetAcceleratorTable(this, core::mem::transmute_copy(&phwnd), core::mem::transmute_copy(&phaccel)).into()
            }
        }
        unsafe extern "system" fn KeepPixelAspectRatio<Identity: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keepaspect: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IFullScreenVideoEx_Impl::KeepPixelAspectRatio(this, core::mem::transmute_copy(&keepaspect)).into()
            }
        }
        unsafe extern "system" fn IsKeepPixelAspectRatio<Identity: IFullScreenVideoEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkeepaspect: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFullScreenVideoEx_Impl::IsKeepPixelAspectRatio(this) {
                    Ok(ok__) => {
                        pkeepaspect.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IFullScreenVideo_Vtbl::new::<Identity, OFFSET>(),
            SetAcceleratorTable: SetAcceleratorTable::<Identity, OFFSET>,
            GetAcceleratorTable: GetAcceleratorTable::<Identity, OFFSET>,
            KeepPixelAspectRatio: KeepPixelAspectRatio::<Identity, OFFSET>,
            IsKeepPixelAspectRatio: IsKeepPixelAspectRatio::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFullScreenVideoEx as windows_core::Interface>::IID || iid == &<IFullScreenVideo as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_WindowsAndMessaging")]
impl windows_core::RuntimeName for IFullScreenVideoEx {}
windows_core::imp::define_interface!(IGetCapabilitiesKey, IGetCapabilitiesKey_Vtbl, 0xa8809222_07bb_48ea_951c_33158100625b);
windows_core::imp::interface_hierarchy!(IGetCapabilitiesKey, windows_core::IUnknown);
impl IGetCapabilitiesKey {
    #[cfg(feature = "Win32_System_Registry")]
    pub unsafe fn GetCapabilitiesKey(&self) -> windows_core::Result<super::super::System::Registry::HKEY> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCapabilitiesKey)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGetCapabilitiesKey_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Registry")]
    pub GetCapabilitiesKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::System::Registry::HKEY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Registry"))]
    GetCapabilitiesKey: usize,
}
#[cfg(feature = "Win32_System_Registry")]
pub trait IGetCapabilitiesKey_Impl: windows_core::IUnknownImpl {
    fn GetCapabilitiesKey(&self) -> windows_core::Result<super::super::System::Registry::HKEY>;
}
#[cfg(feature = "Win32_System_Registry")]
impl IGetCapabilitiesKey_Vtbl {
    pub const fn new<Identity: IGetCapabilitiesKey_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCapabilitiesKey<Identity: IGetCapabilitiesKey_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phkey: *mut super::super::System::Registry::HKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGetCapabilitiesKey_Impl::GetCapabilitiesKey(this) {
                    Ok(ok__) => {
                        phkey.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetCapabilitiesKey: GetCapabilitiesKey::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGetCapabilitiesKey as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Registry")]
impl windows_core::RuntimeName for IGetCapabilitiesKey {}
windows_core::imp::define_interface!(IGraphBuilder, IGraphBuilder_Vtbl, 0x56a868a9_0ad4_11ce_b03a_0020af0ba770);
impl core::ops::Deref for IGraphBuilder {
    type Target = IFilterGraph;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IGraphBuilder, windows_core::IUnknown, IFilterGraph);
impl IGraphBuilder {
    pub unsafe fn Connect<P0, P1>(&self, ppinout: P0, ppinin: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Connect)(windows_core::Interface::as_raw(self), ppinout.param().abi(), ppinin.param().abi()).ok() }
    }
    pub unsafe fn Render<P0>(&self, ppinout: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Render)(windows_core::Interface::as_raw(self), ppinout.param().abi()).ok() }
    }
    pub unsafe fn RenderFile<P0, P1>(&self, lpcwstrfile: P0, lpcwstrplaylist: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).RenderFile)(windows_core::Interface::as_raw(self), lpcwstrfile.param().abi(), lpcwstrplaylist.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddSourceFilter<P0, P1>(&self, lpcwstrfilename: P0, lpcwstrfiltername: P1) -> windows_core::Result<IBaseFilter>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddSourceFilter)(windows_core::Interface::as_raw(self), lpcwstrfilename.param().abi(), lpcwstrfiltername.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SetLogFile(&self, hfile: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLogFile)(windows_core::Interface::as_raw(self), hfile).ok() }
    }
    pub unsafe fn Abort(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Abort)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ShouldOperationContinue(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ShouldOperationContinue)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGraphBuilder_Vtbl {
    pub base__: IFilterGraph_Vtbl,
    pub Connect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Render: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RenderFile: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, windows_core::PCWSTR) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub AddSourceFilter: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, windows_core::PCWSTR, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    AddSourceFilter: usize,
    pub SetLogFile: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    pub Abort: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ShouldOperationContinue: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IGraphBuilder_Impl: IFilterGraph_Impl {
    fn Connect(&self, ppinout: windows_core::Ref<IPin>, ppinin: windows_core::Ref<IPin>) -> windows_core::Result<()>;
    fn Render(&self, ppinout: windows_core::Ref<IPin>) -> windows_core::Result<()>;
    fn RenderFile(&self, lpcwstrfile: &windows_core::PCWSTR, lpcwstrplaylist: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn AddSourceFilter(&self, lpcwstrfilename: &windows_core::PCWSTR, lpcwstrfiltername: &windows_core::PCWSTR) -> windows_core::Result<IBaseFilter>;
    fn SetLogFile(&self, hfile: usize) -> windows_core::Result<()>;
    fn Abort(&self) -> windows_core::Result<()>;
    fn ShouldOperationContinue(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IGraphBuilder_Vtbl {
    pub const fn new<Identity: IGraphBuilder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Connect<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void, ppinin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::Connect(this, core::mem::transmute_copy(&ppinout), core::mem::transmute_copy(&ppinin)).into()
            }
        }
        unsafe extern "system" fn Render<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::Render(this, core::mem::transmute_copy(&ppinout)).into()
            }
        }
        unsafe extern "system" fn RenderFile<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpcwstrfile: windows_core::PCWSTR, lpcwstrplaylist: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::RenderFile(this, core::mem::transmute(&lpcwstrfile), core::mem::transmute(&lpcwstrplaylist)).into()
            }
        }
        unsafe extern "system" fn AddSourceFilter<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpcwstrfilename: windows_core::PCWSTR, lpcwstrfiltername: windows_core::PCWSTR, ppfilter: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGraphBuilder_Impl::AddSourceFilter(this, core::mem::transmute(&lpcwstrfilename), core::mem::transmute(&lpcwstrfiltername)) {
                    Ok(ok__) => {
                        ppfilter.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLogFile<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hfile: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::SetLogFile(this, core::mem::transmute_copy(&hfile)).into()
            }
        }
        unsafe extern "system" fn Abort<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::Abort(this).into()
            }
        }
        unsafe extern "system" fn ShouldOperationContinue<Identity: IGraphBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphBuilder_Impl::ShouldOperationContinue(this).into()
            }
        }
        Self {
            base__: IFilterGraph_Vtbl::new::<Identity, OFFSET>(),
            Connect: Connect::<Identity, OFFSET>,
            Render: Render::<Identity, OFFSET>,
            RenderFile: RenderFile::<Identity, OFFSET>,
            AddSourceFilter: AddSourceFilter::<Identity, OFFSET>,
            SetLogFile: SetLogFile::<Identity, OFFSET>,
            Abort: Abort::<Identity, OFFSET>,
            ShouldOperationContinue: ShouldOperationContinue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGraphBuilder as windows_core::Interface>::IID || iid == &<IFilterGraph as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IGraphBuilder {}
windows_core::imp::define_interface!(IGraphConfig, IGraphConfig_Vtbl, 0x03a1eb8e_32bf_4245_8502_114d08a9cb88);
windows_core::imp::interface_hierarchy!(IGraphConfig, windows_core::IUnknown);
impl IGraphConfig {
    #[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
    pub unsafe fn Reconnect<P0, P1, P3>(&self, poutputpin: P0, pinputpin: P1, pmtfirstconnection: *const super::MediaFoundation::AM_MEDIA_TYPE, pusingfilter: P3, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IPin>,
        P3: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).Reconnect)(windows_core::Interface::as_raw(self), poutputpin.param().abi(), pinputpin.param().abi(), core::mem::transmute(pmtfirstconnection), pusingfilter.param().abi(), habortevent, dwflags).ok() }
    }
    pub unsafe fn Reconfigure<P0>(&self, pcallback: P0, pvcontext: *const core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IGraphConfigCallback>,
    {
        unsafe { (windows_core::Interface::vtable(self).Reconfigure)(windows_core::Interface::as_raw(self), pcallback.param().abi(), pvcontext, dwflags, habortevent).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddFilterToCache<P0>(&self, pfilter: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).AddFilterToCache)(windows_core::Interface::as_raw(self), pfilter.param().abi()).ok() }
    }
    pub unsafe fn EnumCacheFilter(&self) -> windows_core::Result<IEnumFilters> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumCacheFilter)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilterFromCache<P0>(&self, pfilter: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RemoveFilterFromCache)(windows_core::Interface::as_raw(self), pfilter.param().abi()).ok() }
    }
    pub unsafe fn GetStartTime(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStartTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn PushThroughData<P0, P1>(&self, poutputpin: P0, pconnection: P1, heventabort: super::super::Foundation::HANDLE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IPinConnection>,
    {
        unsafe { (windows_core::Interface::vtable(self).PushThroughData)(windows_core::Interface::as_raw(self), poutputpin.param().abi(), pconnection.param().abi(), heventabort).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetFilterFlags<P0>(&self, pfilter: P0, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFilterFlags)(windows_core::Interface::as_raw(self), pfilter.param().abi(), dwflags).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetFilterFlags<P0>(&self, pfilter: P0) -> windows_core::Result<u32>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFilterFlags)(windows_core::Interface::as_raw(self), pfilter.param().abi(), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilterEx<P0>(&self, pfilter: P0, flags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).RemoveFilterEx)(windows_core::Interface::as_raw(self), pfilter.param().abi(), flags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGraphConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
    pub Reconnect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE, *mut core::ffi::c_void, super::super::Foundation::HANDLE, u32) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com")))]
    Reconnect: usize,
    pub Reconfigure: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const core::ffi::c_void, u32, super::super::Foundation::HANDLE) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub AddFilterToCache: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    AddFilterToCache: usize,
    pub EnumCacheFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub RemoveFilterFromCache: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RemoveFilterFromCache: usize,
    pub GetStartTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub PushThroughData: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, super::super::Foundation::HANDLE) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub SetFilterFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetFilterFlags: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub GetFilterFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    GetFilterFlags: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub RemoveFilterEx: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    RemoveFilterEx: usize,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IGraphConfig_Impl: windows_core::IUnknownImpl {
    fn Reconnect(&self, poutputpin: windows_core::Ref<IPin>, pinputpin: windows_core::Ref<IPin>, pmtfirstconnection: *const super::MediaFoundation::AM_MEDIA_TYPE, pusingfilter: windows_core::Ref<IBaseFilter>, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> windows_core::Result<()>;
    fn Reconfigure(&self, pcallback: windows_core::Ref<IGraphConfigCallback>, pvcontext: *const core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn AddFilterToCache(&self, pfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn EnumCacheFilter(&self) -> windows_core::Result<IEnumFilters>;
    fn RemoveFilterFromCache(&self, pfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<()>;
    fn GetStartTime(&self) -> windows_core::Result<i64>;
    fn PushThroughData(&self, poutputpin: windows_core::Ref<IPin>, pconnection: windows_core::Ref<IPinConnection>, heventabort: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn SetFilterFlags(&self, pfilter: windows_core::Ref<IBaseFilter>, dwflags: u32) -> windows_core::Result<()>;
    fn GetFilterFlags(&self, pfilter: windows_core::Ref<IBaseFilter>) -> windows_core::Result<u32>;
    fn RemoveFilterEx(&self, pfilter: windows_core::Ref<IBaseFilter>, flags: u32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IGraphConfig_Vtbl {
    pub const fn new<Identity: IGraphConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Reconnect<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poutputpin: *mut core::ffi::c_void, pinputpin: *mut core::ffi::c_void, pmtfirstconnection: *const super::MediaFoundation::AM_MEDIA_TYPE, pusingfilter: *mut core::ffi::c_void, habortevent: super::super::Foundation::HANDLE, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::Reconnect(this, core::mem::transmute_copy(&poutputpin), core::mem::transmute_copy(&pinputpin), core::mem::transmute_copy(&pmtfirstconnection), core::mem::transmute_copy(&pusingfilter), core::mem::transmute_copy(&habortevent), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn Reconfigure<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, pvcontext: *const core::ffi::c_void, dwflags: u32, habortevent: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::Reconfigure(this, core::mem::transmute_copy(&pcallback), core::mem::transmute_copy(&pvcontext), core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&habortevent)).into()
            }
        }
        unsafe extern "system" fn AddFilterToCache<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::AddFilterToCache(this, core::mem::transmute_copy(&pfilter)).into()
            }
        }
        unsafe extern "system" fn EnumCacheFilter<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGraphConfig_Impl::EnumCacheFilter(this) {
                    Ok(ok__) => {
                        penum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveFilterFromCache<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::RemoveFilterFromCache(this, core::mem::transmute_copy(&pfilter)).into()
            }
        }
        unsafe extern "system" fn GetStartTime<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prtstart: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGraphConfig_Impl::GetStartTime(this) {
                    Ok(ok__) => {
                        prtstart.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PushThroughData<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poutputpin: *mut core::ffi::c_void, pconnection: *mut core::ffi::c_void, heventabort: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::PushThroughData(this, core::mem::transmute_copy(&poutputpin), core::mem::transmute_copy(&pconnection), core::mem::transmute_copy(&heventabort)).into()
            }
        }
        unsafe extern "system" fn SetFilterFlags<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::SetFilterFlags(this, core::mem::transmute_copy(&pfilter), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn GetFilterFlags<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGraphConfig_Impl::GetFilterFlags(this, core::mem::transmute_copy(&pfilter)) {
                    Ok(ok__) => {
                        pdwflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveFilterEx<Identity: IGraphConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfilter: *mut core::ffi::c_void, flags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfig_Impl::RemoveFilterEx(this, core::mem::transmute_copy(&pfilter), core::mem::transmute_copy(&flags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Reconnect: Reconnect::<Identity, OFFSET>,
            Reconfigure: Reconfigure::<Identity, OFFSET>,
            AddFilterToCache: AddFilterToCache::<Identity, OFFSET>,
            EnumCacheFilter: EnumCacheFilter::<Identity, OFFSET>,
            RemoveFilterFromCache: RemoveFilterFromCache::<Identity, OFFSET>,
            GetStartTime: GetStartTime::<Identity, OFFSET>,
            PushThroughData: PushThroughData::<Identity, OFFSET>,
            SetFilterFlags: SetFilterFlags::<Identity, OFFSET>,
            GetFilterFlags: GetFilterFlags::<Identity, OFFSET>,
            RemoveFilterEx: RemoveFilterEx::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGraphConfig as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IGraphConfig {}
windows_core::imp::define_interface!(IGraphConfigCallback, IGraphConfigCallback_Vtbl, 0xade0fd60_d19d_11d2_abf6_00a0c905f375);
windows_core::imp::interface_hierarchy!(IGraphConfigCallback, windows_core::IUnknown);
impl IGraphConfigCallback {
    pub unsafe fn Reconfigure(&self, pvcontext: *mut core::ffi::c_void, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Reconfigure)(windows_core::Interface::as_raw(self), pvcontext as _, dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGraphConfigCallback_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Reconfigure: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IGraphConfigCallback_Impl: windows_core::IUnknownImpl {
    fn Reconfigure(&self, pvcontext: *mut core::ffi::c_void, dwflags: u32) -> windows_core::Result<()>;
}
impl IGraphConfigCallback_Vtbl {
    pub const fn new<Identity: IGraphConfigCallback_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Reconfigure<Identity: IGraphConfigCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvcontext: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGraphConfigCallback_Impl::Reconfigure(this, core::mem::transmute_copy(&pvcontext), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Reconfigure: Reconfigure::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGraphConfigCallback as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IGraphConfigCallback {}
windows_core::imp::define_interface!(IGraphVersion, IGraphVersion_Vtbl, 0x56a868ab_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IGraphVersion, windows_core::IUnknown);
impl IGraphVersion {
    pub unsafe fn QueryVersion(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryVersion)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGraphVersion_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub QueryVersion: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IGraphVersion_Impl: windows_core::IUnknownImpl {
    fn QueryVersion(&self) -> windows_core::Result<i32>;
}
impl IGraphVersion_Vtbl {
    pub const fn new<Identity: IGraphVersion_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn QueryVersion<Identity: IGraphVersion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pversion: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGraphVersion_Impl::QueryVersion(this) {
                    Ok(ok__) => {
                        pversion.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), QueryVersion: QueryVersion::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGraphVersion as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IGraphVersion {}
windows_core::imp::define_interface!(IIPDVDec, IIPDVDec_Vtbl, 0xb8e8bd60_0bfe_11d0_af91_00aa00b67a42);
windows_core::imp::interface_hierarchy!(IIPDVDec, windows_core::IUnknown);
impl IIPDVDec {
    pub unsafe fn IPDisplay(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IPDisplay)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetIPDisplay(&self, displaypix: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetIPDisplay)(windows_core::Interface::as_raw(self), displaypix).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IIPDVDec_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub IPDisplay: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetIPDisplay: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IIPDVDec_Impl: windows_core::IUnknownImpl {
    fn IPDisplay(&self) -> windows_core::Result<i32>;
    fn SetIPDisplay(&self, displaypix: i32) -> windows_core::Result<()>;
}
impl IIPDVDec_Vtbl {
    pub const fn new<Identity: IIPDVDec_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn IPDisplay<Identity: IIPDVDec_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, displaypix: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IIPDVDec_Impl::IPDisplay(this) {
                    Ok(ok__) => {
                        displaypix.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIPDisplay<Identity: IIPDVDec_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, displaypix: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IIPDVDec_Impl::SetIPDisplay(this, core::mem::transmute_copy(&displaypix)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IPDisplay: IPDisplay::<Identity, OFFSET>,
            SetIPDisplay: SetIPDisplay::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IIPDVDec as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IIPDVDec {}
windows_core::imp::define_interface!(IMPEG2PIDMap, IMPEG2PIDMap_Vtbl, 0xafb6c2a1_2c41_11d3_8a60_0000f81e0e4a);
windows_core::imp::interface_hierarchy!(IMPEG2PIDMap, windows_core::IUnknown);
impl IMPEG2PIDMap {
    pub unsafe fn MapPID(&self, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MapPID)(windows_core::Interface::as_raw(self), culpid, pulpid, mediasamplecontent).ok() }
    }
    pub unsafe fn UnmapPID(&self, culpid: u32, pulpid: *const u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnmapPID)(windows_core::Interface::as_raw(self), culpid, pulpid).ok() }
    }
    pub unsafe fn EnumPIDMap(&self) -> windows_core::Result<IEnumPIDMap> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumPIDMap)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMPEG2PIDMap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub MapPID: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u32, MEDIA_SAMPLE_CONTENT) -> windows_core::HRESULT,
    pub UnmapPID: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u32) -> windows_core::HRESULT,
    pub EnumPIDMap: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMPEG2PIDMap_Impl: windows_core::IUnknownImpl {
    fn MapPID(&self, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> windows_core::Result<()>;
    fn UnmapPID(&self, culpid: u32, pulpid: *const u32) -> windows_core::Result<()>;
    fn EnumPIDMap(&self) -> windows_core::Result<IEnumPIDMap>;
}
impl IMPEG2PIDMap_Vtbl {
    pub const fn new<Identity: IMPEG2PIDMap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn MapPID<Identity: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, culpid: u32, pulpid: *const u32, mediasamplecontent: MEDIA_SAMPLE_CONTENT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMPEG2PIDMap_Impl::MapPID(this, core::mem::transmute_copy(&culpid), core::mem::transmute_copy(&pulpid), core::mem::transmute_copy(&mediasamplecontent)).into()
            }
        }
        unsafe extern "system" fn UnmapPID<Identity: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, culpid: u32, pulpid: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMPEG2PIDMap_Impl::UnmapPID(this, core::mem::transmute_copy(&culpid), core::mem::transmute_copy(&pulpid)).into()
            }
        }
        unsafe extern "system" fn EnumPIDMap<Identity: IMPEG2PIDMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pienumpidmap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMPEG2PIDMap_Impl::EnumPIDMap(this) {
                    Ok(ok__) => {
                        pienumpidmap.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            MapPID: MapPID::<Identity, OFFSET>,
            UnmapPID: UnmapPID::<Identity, OFFSET>,
            EnumPIDMap: EnumPIDMap::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMPEG2PIDMap as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMPEG2PIDMap {}
windows_core::imp::define_interface!(IMPEG2StreamIdMap, IMPEG2StreamIdMap_Vtbl, 0xd0e04c47_25b8_4369_925a_362a01d95444);
windows_core::imp::interface_hierarchy!(IMPEG2StreamIdMap, windows_core::IUnknown);
impl IMPEG2StreamIdMap {
    pub unsafe fn MapStreamId(&self, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).MapStreamId)(windows_core::Interface::as_raw(self), ulstreamid, mediasamplecontent, ulsubstreamfiltervalue, idataoffset).ok() }
    }
    pub unsafe fn UnmapStreamId(&self, pulstreamid: &[u32]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnmapStreamId)(windows_core::Interface::as_raw(self), pulstreamid.len().try_into().unwrap(), core::mem::transmute(pulstreamid.as_ptr())).ok() }
    }
    pub unsafe fn EnumStreamIdMap(&self) -> windows_core::Result<IEnumStreamIdMap> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumStreamIdMap)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMPEG2StreamIdMap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub MapStreamId: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, i32) -> windows_core::HRESULT,
    pub UnmapStreamId: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u32) -> windows_core::HRESULT,
    pub EnumStreamIdMap: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMPEG2StreamIdMap_Impl: windows_core::IUnknownImpl {
    fn MapStreamId(&self, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> windows_core::Result<()>;
    fn UnmapStreamId(&self, culstreamid: u32, pulstreamid: *const u32) -> windows_core::Result<()>;
    fn EnumStreamIdMap(&self) -> windows_core::Result<IEnumStreamIdMap>;
}
impl IMPEG2StreamIdMap_Vtbl {
    pub const fn new<Identity: IMPEG2StreamIdMap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn MapStreamId<Identity: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstreamid: u32, mediasamplecontent: u32, ulsubstreamfiltervalue: u32, idataoffset: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMPEG2StreamIdMap_Impl::MapStreamId(this, core::mem::transmute_copy(&ulstreamid), core::mem::transmute_copy(&mediasamplecontent), core::mem::transmute_copy(&ulsubstreamfiltervalue), core::mem::transmute_copy(&idataoffset)).into()
            }
        }
        unsafe extern "system" fn UnmapStreamId<Identity: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, culstreamid: u32, pulstreamid: *const u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMPEG2StreamIdMap_Impl::UnmapStreamId(this, core::mem::transmute_copy(&culstreamid), core::mem::transmute_copy(&pulstreamid)).into()
            }
        }
        unsafe extern "system" fn EnumStreamIdMap<Identity: IMPEG2StreamIdMap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppienumstreamidmap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMPEG2StreamIdMap_Impl::EnumStreamIdMap(this) {
                    Ok(ok__) => {
                        ppienumstreamidmap.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            MapStreamId: MapStreamId::<Identity, OFFSET>,
            UnmapStreamId: UnmapStreamId::<Identity, OFFSET>,
            EnumStreamIdMap: EnumStreamIdMap::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMPEG2StreamIdMap as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMPEG2StreamIdMap {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaControl, IMediaControl_Vtbl, 0x56a868b1_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaControl {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaControl, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IMediaControl {
    pub unsafe fn Run(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Run)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Pause(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Pause)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetState(&self, mstimeout: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), mstimeout, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RenderFile(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RenderFile)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strfilename)).ok() }
    }
    pub unsafe fn AddSourceFilter(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AddSourceFilter)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strfilename), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn FilterCollection(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FilterCollection)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn RegFilterCollection(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).RegFilterCollection)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn StopWhenReady(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StopWhenReady)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaControl_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Run: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Pause: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub RenderFile: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub AddSourceFilter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub FilterCollection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RegFilterCollection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub StopWhenReady: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaControl_Impl: super::super::System::Com::IDispatch_Impl {
    fn Run(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn GetState(&self, mstimeout: i32) -> windows_core::Result<i32>;
    fn RenderFile(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<()>;
    fn AddSourceFilter(&self, strfilename: &windows_core::BSTR) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn FilterCollection(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn RegFilterCollection(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn StopWhenReady(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaControl_Vtbl {
    pub const fn new<Identity: IMediaControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Run<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaControl_Impl::Run(this).into()
            }
        }
        unsafe extern "system" fn Pause<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaControl_Impl::Pause(this).into()
            }
        }
        unsafe extern "system" fn Stop<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaControl_Impl::Stop(this).into()
            }
        }
        unsafe extern "system" fn GetState<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mstimeout: i32, pfs: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaControl_Impl::GetState(this, core::mem::transmute_copy(&mstimeout)) {
                    Ok(ok__) => {
                        pfs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RenderFile<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strfilename: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaControl_Impl::RenderFile(this, core::mem::transmute(&strfilename)).into()
            }
        }
        unsafe extern "system" fn AddSourceFilter<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strfilename: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaControl_Impl::AddSourceFilter(this, core::mem::transmute(&strfilename)) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FilterCollection<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaControl_Impl::FilterCollection(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RegFilterCollection<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaControl_Impl::RegFilterCollection(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StopWhenReady<Identity: IMediaControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaControl_Impl::StopWhenReady(this).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Run: Run::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            RenderFile: RenderFile::<Identity, OFFSET>,
            AddSourceFilter: AddSourceFilter::<Identity, OFFSET>,
            FilterCollection: FilterCollection::<Identity, OFFSET>,
            RegFilterCollection: RegFilterCollection::<Identity, OFFSET>,
            StopWhenReady: StopWhenReady::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaControl as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaControl {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaEvent, IMediaEvent_Vtbl, 0x56a868b6_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaEvent {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaEvent, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IMediaEvent {
    pub unsafe fn GetEventHandle(&self) -> windows_core::Result<isize> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEventHandle)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetEvent(&self, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetEvent)(windows_core::Interface::as_raw(self), leventcode as _, lparam1 as _, lparam2 as _, mstimeout).ok() }
    }
    pub unsafe fn WaitForCompletion(&self, mstimeout: i32) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WaitForCompletion)(windows_core::Interface::as_raw(self), mstimeout, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn CancelDefaultHandling(&self, levcode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CancelDefaultHandling)(windows_core::Interface::as_raw(self), levcode).ok() }
    }
    pub unsafe fn RestoreDefaultHandling(&self, levcode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RestoreDefaultHandling)(windows_core::Interface::as_raw(self), levcode).ok() }
    }
    pub unsafe fn FreeEventParams(&self, levcode: i32, lparam1: isize, lparam2: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FreeEventParams)(windows_core::Interface::as_raw(self), levcode, lparam1, lparam2).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaEvent_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub GetEventHandle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut isize) -> windows_core::HRESULT,
    pub GetEvent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut isize, *mut isize, i32) -> windows_core::HRESULT,
    pub WaitForCompletion: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub CancelDefaultHandling: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub RestoreDefaultHandling: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub FreeEventParams: unsafe extern "system" fn(*mut core::ffi::c_void, i32, isize, isize) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaEvent_Impl: super::super::System::Com::IDispatch_Impl {
    fn GetEventHandle(&self) -> windows_core::Result<isize>;
    fn GetEvent(&self, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> windows_core::Result<()>;
    fn WaitForCompletion(&self, mstimeout: i32) -> windows_core::Result<i32>;
    fn CancelDefaultHandling(&self, levcode: i32) -> windows_core::Result<()>;
    fn RestoreDefaultHandling(&self, levcode: i32) -> windows_core::Result<()>;
    fn FreeEventParams(&self, levcode: i32, lparam1: isize, lparam2: isize) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaEvent_Vtbl {
    pub const fn new<Identity: IMediaEvent_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetEventHandle<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hevent: *mut isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaEvent_Impl::GetEventHandle(this) {
                    Ok(ok__) => {
                        hevent.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetEvent<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEvent_Impl::GetEvent(this, core::mem::transmute_copy(&leventcode), core::mem::transmute_copy(&lparam1), core::mem::transmute_copy(&lparam2), core::mem::transmute_copy(&mstimeout)).into()
            }
        }
        unsafe extern "system" fn WaitForCompletion<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mstimeout: i32, pevcode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaEvent_Impl::WaitForCompletion(this, core::mem::transmute_copy(&mstimeout)) {
                    Ok(ok__) => {
                        pevcode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CancelDefaultHandling<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, levcode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEvent_Impl::CancelDefaultHandling(this, core::mem::transmute_copy(&levcode)).into()
            }
        }
        unsafe extern "system" fn RestoreDefaultHandling<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, levcode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEvent_Impl::RestoreDefaultHandling(this, core::mem::transmute_copy(&levcode)).into()
            }
        }
        unsafe extern "system" fn FreeEventParams<Identity: IMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, levcode: i32, lparam1: isize, lparam2: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEvent_Impl::FreeEventParams(this, core::mem::transmute_copy(&levcode), core::mem::transmute_copy(&lparam1), core::mem::transmute_copy(&lparam2)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            GetEventHandle: GetEventHandle::<Identity, OFFSET>,
            GetEvent: GetEvent::<Identity, OFFSET>,
            WaitForCompletion: WaitForCompletion::<Identity, OFFSET>,
            CancelDefaultHandling: CancelDefaultHandling::<Identity, OFFSET>,
            RestoreDefaultHandling: RestoreDefaultHandling::<Identity, OFFSET>,
            FreeEventParams: FreeEventParams::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaEvent as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaEvent {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaEventEx, IMediaEventEx_Vtbl, 0x56a868c0_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaEventEx {
    type Target = IMediaEvent;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaEventEx, windows_core::IUnknown, super::super::System::Com::IDispatch, IMediaEvent);
#[cfg(feature = "Win32_System_Com")]
impl IMediaEventEx {
    pub unsafe fn SetNotifyWindow(&self, hwnd: isize, lmsg: i32, linstancedata: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetNotifyWindow)(windows_core::Interface::as_raw(self), hwnd, lmsg, linstancedata).ok() }
    }
    pub unsafe fn SetNotifyFlags(&self, lnonotifyflags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetNotifyFlags)(windows_core::Interface::as_raw(self), lnonotifyflags).ok() }
    }
    pub unsafe fn GetNotifyFlags(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNotifyFlags)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaEventEx_Vtbl {
    pub base__: IMediaEvent_Vtbl,
    pub SetNotifyWindow: unsafe extern "system" fn(*mut core::ffi::c_void, isize, i32, isize) -> windows_core::HRESULT,
    pub SetNotifyFlags: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub GetNotifyFlags: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaEventEx_Impl: IMediaEvent_Impl {
    fn SetNotifyWindow(&self, hwnd: isize, lmsg: i32, linstancedata: isize) -> windows_core::Result<()>;
    fn SetNotifyFlags(&self, lnonotifyflags: i32) -> windows_core::Result<()>;
    fn GetNotifyFlags(&self) -> windows_core::Result<i32>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaEventEx_Vtbl {
    pub const fn new<Identity: IMediaEventEx_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetNotifyWindow<Identity: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: isize, lmsg: i32, linstancedata: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEventEx_Impl::SetNotifyWindow(this, core::mem::transmute_copy(&hwnd), core::mem::transmute_copy(&lmsg), core::mem::transmute_copy(&linstancedata)).into()
            }
        }
        unsafe extern "system" fn SetNotifyFlags<Identity: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lnonotifyflags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEventEx_Impl::SetNotifyFlags(this, core::mem::transmute_copy(&lnonotifyflags)).into()
            }
        }
        unsafe extern "system" fn GetNotifyFlags<Identity: IMediaEventEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplnonotifyflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaEventEx_Impl::GetNotifyFlags(this) {
                    Ok(ok__) => {
                        lplnonotifyflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: IMediaEvent_Vtbl::new::<Identity, OFFSET>(),
            SetNotifyWindow: SetNotifyWindow::<Identity, OFFSET>,
            SetNotifyFlags: SetNotifyFlags::<Identity, OFFSET>,
            GetNotifyFlags: GetNotifyFlags::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaEventEx as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID || iid == &<IMediaEvent as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaEventEx {}
windows_core::imp::define_interface!(IMediaEventSink, IMediaEventSink_Vtbl, 0x56a868a2_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IMediaEventSink, windows_core::IUnknown);
impl IMediaEventSink {
    pub unsafe fn Notify(&self, eventcode: i32, eventparam1: isize, eventparam2: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Notify)(windows_core::Interface::as_raw(self), eventcode, eventparam1, eventparam2).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaEventSink_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Notify: unsafe extern "system" fn(*mut core::ffi::c_void, i32, isize, isize) -> windows_core::HRESULT,
}
pub trait IMediaEventSink_Impl: windows_core::IUnknownImpl {
    fn Notify(&self, eventcode: i32, eventparam1: isize, eventparam2: isize) -> windows_core::Result<()>;
}
impl IMediaEventSink_Vtbl {
    pub const fn new<Identity: IMediaEventSink_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Notify<Identity: IMediaEventSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eventcode: i32, eventparam1: isize, eventparam2: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaEventSink_Impl::Notify(this, core::mem::transmute_copy(&eventcode), core::mem::transmute_copy(&eventparam1), core::mem::transmute_copy(&eventparam2)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Notify: Notify::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaEventSink as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaEventSink {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaFilter, IMediaFilter_Vtbl, 0x56a86899_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaFilter {
    type Target = super::super::System::Com::IPersist;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaFilter, windows_core::IUnknown, super::super::System::Com::IPersist);
#[cfg(feature = "Win32_System_Com")]
impl IMediaFilter {
    pub unsafe fn Stop(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Stop)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Pause(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Pause)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Run(&self, tstart: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Run)(windows_core::Interface::as_raw(self), tstart).ok() }
    }
    pub unsafe fn GetState(&self, dwmillisecstimeout: u32) -> windows_core::Result<FILTER_STATE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), dwmillisecstimeout, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSyncSource<P0>(&self, pclock: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::IReferenceClock>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetSyncSource)(windows_core::Interface::as_raw(self), pclock.param().abi()).ok() }
    }
    pub unsafe fn GetSyncSource(&self) -> windows_core::Result<super::IReferenceClock> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSyncSource)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaFilter_Vtbl {
    pub base__: super::super::System::Com::IPersist_Vtbl,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Pause: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Run: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut FILTER_STATE) -> windows_core::HRESULT,
    pub SetSyncSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetSyncSource: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaFilter_Impl: super::super::System::Com::IPersist_Impl {
    fn Stop(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Run(&self, tstart: i64) -> windows_core::Result<()>;
    fn GetState(&self, dwmillisecstimeout: u32) -> windows_core::Result<FILTER_STATE>;
    fn SetSyncSource(&self, pclock: windows_core::Ref<super::IReferenceClock>) -> windows_core::Result<()>;
    fn GetSyncSource(&self) -> windows_core::Result<super::IReferenceClock>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaFilter_Vtbl {
    pub const fn new<Identity: IMediaFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Stop<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaFilter_Impl::Stop(this).into()
            }
        }
        unsafe extern "system" fn Pause<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaFilter_Impl::Pause(this).into()
            }
        }
        unsafe extern "system" fn Run<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tstart: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaFilter_Impl::Run(this, core::mem::transmute_copy(&tstart)).into()
            }
        }
        unsafe extern "system" fn GetState<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmillisecstimeout: u32, state: *mut FILTER_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaFilter_Impl::GetState(this, core::mem::transmute_copy(&dwmillisecstimeout)) {
                    Ok(ok__) => {
                        state.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSyncSource<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaFilter_Impl::SetSyncSource(this, core::mem::transmute_copy(&pclock)).into()
            }
        }
        unsafe extern "system" fn GetSyncSource<Identity: IMediaFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclock: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaFilter_Impl::GetSyncSource(this) {
                    Ok(ok__) => {
                        pclock.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IPersist_Vtbl::new::<Identity, OFFSET>(),
            Stop: Stop::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Run: Run::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            SetSyncSource: SetSyncSource::<Identity, OFFSET>,
            GetSyncSource: GetSyncSource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaFilter as windows_core::Interface>::IID || iid == &<super::super::System::Com::IPersist as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IMediaFilter {}
windows_core::imp::define_interface!(IMediaParamInfo, IMediaParamInfo_Vtbl, 0x6d6cbb60_a223_44aa_842f_a2f06750be6d);
windows_core::imp::interface_hierarchy!(IMediaParamInfo, windows_core::IUnknown);
impl IMediaParamInfo {
    pub unsafe fn GetParamCount(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetParamCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetParamInfo(&self, dwparamindex: u32, pinfo: *mut MP_PARAMINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetParamInfo)(windows_core::Interface::as_raw(self), dwparamindex, pinfo as _).ok() }
    }
    pub unsafe fn GetParamText(&self, dwparamindex: u32) -> windows_core::Result<*mut u16> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetParamText)(windows_core::Interface::as_raw(self), dwparamindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetNumTimeFormats(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumTimeFormats)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSupportedTimeFormat(&self, dwformatindex: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSupportedTimeFormat)(windows_core::Interface::as_raw(self), dwformatindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentTimeFormat(&self, pguidtimeformat: *mut windows_core::GUID, ptimedata: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetCurrentTimeFormat)(windows_core::Interface::as_raw(self), pguidtimeformat as _, ptimedata as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaParamInfo_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetParamCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetParamInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut MP_PARAMINFO) -> windows_core::HRESULT,
    pub GetParamText: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut u16) -> windows_core::HRESULT,
    pub GetNumTimeFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub GetSupportedTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetCurrentTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID, *mut u32) -> windows_core::HRESULT,
}
pub trait IMediaParamInfo_Impl: windows_core::IUnknownImpl {
    fn GetParamCount(&self) -> windows_core::Result<u32>;
    fn GetParamInfo(&self, dwparamindex: u32, pinfo: *mut MP_PARAMINFO) -> windows_core::Result<()>;
    fn GetParamText(&self, dwparamindex: u32) -> windows_core::Result<*mut u16>;
    fn GetNumTimeFormats(&self) -> windows_core::Result<u32>;
    fn GetSupportedTimeFormat(&self, dwformatindex: u32) -> windows_core::Result<windows_core::GUID>;
    fn GetCurrentTimeFormat(&self, pguidtimeformat: *mut windows_core::GUID, ptimedata: *mut u32) -> windows_core::Result<()>;
}
impl IMediaParamInfo_Vtbl {
    pub const fn new<Identity: IMediaParamInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetParamCount<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwparams: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaParamInfo_Impl::GetParamCount(this) {
                    Ok(ok__) => {
                        pdwparams.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetParamInfo<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, pinfo: *mut MP_PARAMINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParamInfo_Impl::GetParamInfo(this, core::mem::transmute_copy(&dwparamindex), core::mem::transmute_copy(&pinfo)).into()
            }
        }
        unsafe extern "system" fn GetParamText<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, ppwchtext: *mut *mut u16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaParamInfo_Impl::GetParamText(this, core::mem::transmute_copy(&dwparamindex)) {
                    Ok(ok__) => {
                        ppwchtext.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetNumTimeFormats<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumtimeformats: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaParamInfo_Impl::GetNumTimeFormats(this) {
                    Ok(ok__) => {
                        pdwnumtimeformats.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSupportedTimeFormat<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwformatindex: u32, pguidtimeformat: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaParamInfo_Impl::GetSupportedTimeFormat(this, core::mem::transmute_copy(&dwformatindex)) {
                    Ok(ok__) => {
                        pguidtimeformat.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentTimeFormat<Identity: IMediaParamInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtimeformat: *mut windows_core::GUID, ptimedata: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParamInfo_Impl::GetCurrentTimeFormat(this, core::mem::transmute_copy(&pguidtimeformat), core::mem::transmute_copy(&ptimedata)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetParamCount: GetParamCount::<Identity, OFFSET>,
            GetParamInfo: GetParamInfo::<Identity, OFFSET>,
            GetParamText: GetParamText::<Identity, OFFSET>,
            GetNumTimeFormats: GetNumTimeFormats::<Identity, OFFSET>,
            GetSupportedTimeFormat: GetSupportedTimeFormat::<Identity, OFFSET>,
            GetCurrentTimeFormat: GetCurrentTimeFormat::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaParamInfo as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaParamInfo {}
windows_core::imp::define_interface!(IMediaParams, IMediaParams_Vtbl, 0x6d6cbb61_a223_44aa_842f_a2f06750be6e);
windows_core::imp::interface_hierarchy!(IMediaParams, windows_core::IUnknown);
impl IMediaParams {
    pub unsafe fn GetParam(&self, dwparamindex: u32) -> windows_core::Result<f32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetParam)(windows_core::Interface::as_raw(self), dwparamindex, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetParam(&self, dwparamindex: u32, value: f32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetParam)(windows_core::Interface::as_raw(self), dwparamindex, value).ok() }
    }
    pub unsafe fn AddEnvelope(&self, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AddEnvelope)(windows_core::Interface::as_raw(self), dwparamindex, csegments, penvelopesegments).ok() }
    }
    pub unsafe fn FlushEnvelope(&self, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FlushEnvelope)(windows_core::Interface::as_raw(self), dwparamindex, reftimestart, reftimeend).ok() }
    }
    pub unsafe fn SetTimeFormat(&self, guidtimeformat: windows_core::GUID, mptimedata: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTimeFormat)(windows_core::Interface::as_raw(self), core::mem::transmute(guidtimeformat), mptimedata).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaParams_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetParam: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut f32) -> windows_core::HRESULT,
    pub SetParam: unsafe extern "system" fn(*mut core::ffi::c_void, u32, f32) -> windows_core::HRESULT,
    pub AddEnvelope: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, *const MP_ENVELOPE_SEGMENT) -> windows_core::HRESULT,
    pub FlushEnvelope: unsafe extern "system" fn(*mut core::ffi::c_void, u32, i64, i64) -> windows_core::HRESULT,
    pub SetTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::GUID, u32) -> windows_core::HRESULT,
}
pub trait IMediaParams_Impl: windows_core::IUnknownImpl {
    fn GetParam(&self, dwparamindex: u32) -> windows_core::Result<f32>;
    fn SetParam(&self, dwparamindex: u32, value: f32) -> windows_core::Result<()>;
    fn AddEnvelope(&self, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> windows_core::Result<()>;
    fn FlushEnvelope(&self, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> windows_core::Result<()>;
    fn SetTimeFormat(&self, guidtimeformat: &windows_core::GUID, mptimedata: u32) -> windows_core::Result<()>;
}
impl IMediaParams_Vtbl {
    pub const fn new<Identity: IMediaParams_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetParam<Identity: IMediaParams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, pvalue: *mut f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaParams_Impl::GetParam(this, core::mem::transmute_copy(&dwparamindex)) {
                    Ok(ok__) => {
                        pvalue.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetParam<Identity: IMediaParams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, value: f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParams_Impl::SetParam(this, core::mem::transmute_copy(&dwparamindex), core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn AddEnvelope<Identity: IMediaParams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, csegments: u32, penvelopesegments: *const MP_ENVELOPE_SEGMENT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParams_Impl::AddEnvelope(this, core::mem::transmute_copy(&dwparamindex), core::mem::transmute_copy(&csegments), core::mem::transmute_copy(&penvelopesegments)).into()
            }
        }
        unsafe extern "system" fn FlushEnvelope<Identity: IMediaParams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwparamindex: u32, reftimestart: i64, reftimeend: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParams_Impl::FlushEnvelope(this, core::mem::transmute_copy(&dwparamindex), core::mem::transmute_copy(&reftimestart), core::mem::transmute_copy(&reftimeend)).into()
            }
        }
        unsafe extern "system" fn SetTimeFormat<Identity: IMediaParams_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidtimeformat: windows_core::GUID, mptimedata: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaParams_Impl::SetTimeFormat(this, core::mem::transmute(&guidtimeformat), core::mem::transmute_copy(&mptimedata)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetParam: GetParam::<Identity, OFFSET>,
            SetParam: SetParam::<Identity, OFFSET>,
            AddEnvelope: AddEnvelope::<Identity, OFFSET>,
            FlushEnvelope: FlushEnvelope::<Identity, OFFSET>,
            SetTimeFormat: SetTimeFormat::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaParams as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaParams {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaPosition, IMediaPosition_Vtbl, 0x56a868b2_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaPosition {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaPosition, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IMediaPosition {
    pub unsafe fn Duration(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Duration)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetCurrentPosition(&self, lltime: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCurrentPosition)(windows_core::Interface::as_raw(self), lltime).ok() }
    }
    pub unsafe fn CurrentPosition(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CurrentPosition)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn StopTime(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).StopTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetStopTime(&self, lltime: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStopTime)(windows_core::Interface::as_raw(self), lltime).ok() }
    }
    pub unsafe fn PrerollTime(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PrerollTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetPrerollTime(&self, lltime: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPrerollTime)(windows_core::Interface::as_raw(self), lltime).ok() }
    }
    pub unsafe fn SetRate(&self, drate: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRate)(windows_core::Interface::as_raw(self), drate).ok() }
    }
    pub unsafe fn Rate(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Rate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn CanSeekForward(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CanSeekForward)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn CanSeekBackward(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CanSeekBackward)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaPosition_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Duration: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCurrentPosition: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CurrentPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub StopTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetStopTime: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub PrerollTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetPrerollTime: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub SetRate: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Rate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub CanSeekForward: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub CanSeekBackward: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaPosition_Impl: super::super::System::Com::IDispatch_Impl {
    fn Duration(&self) -> windows_core::Result<f64>;
    fn SetCurrentPosition(&self, lltime: f64) -> windows_core::Result<()>;
    fn CurrentPosition(&self) -> windows_core::Result<f64>;
    fn StopTime(&self) -> windows_core::Result<f64>;
    fn SetStopTime(&self, lltime: f64) -> windows_core::Result<()>;
    fn PrerollTime(&self) -> windows_core::Result<f64>;
    fn SetPrerollTime(&self, lltime: f64) -> windows_core::Result<()>;
    fn SetRate(&self, drate: f64) -> windows_core::Result<()>;
    fn Rate(&self) -> windows_core::Result<f64>;
    fn CanSeekForward(&self) -> windows_core::Result<i32>;
    fn CanSeekBackward(&self) -> windows_core::Result<i32>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaPosition_Vtbl {
    pub const fn new<Identity: IMediaPosition_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Duration<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plength: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::Duration(this) {
                    Ok(ok__) => {
                        plength.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lltime: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaPosition_Impl::SetCurrentPosition(this, core::mem::transmute_copy(&lltime)).into()
            }
        }
        unsafe extern "system" fn CurrentPosition<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plltime: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::CurrentPosition(this) {
                    Ok(ok__) => {
                        plltime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StopTime<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plltime: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::StopTime(this) {
                    Ok(ok__) => {
                        plltime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStopTime<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lltime: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaPosition_Impl::SetStopTime(this, core::mem::transmute_copy(&lltime)).into()
            }
        }
        unsafe extern "system" fn PrerollTime<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plltime: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::PrerollTime(this) {
                    Ok(ok__) => {
                        plltime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPrerollTime<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lltime: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaPosition_Impl::SetPrerollTime(this, core::mem::transmute_copy(&lltime)).into()
            }
        }
        unsafe extern "system" fn SetRate<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, drate: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaPosition_Impl::SetRate(this, core::mem::transmute_copy(&drate)).into()
            }
        }
        unsafe extern "system" fn Rate<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdrate: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::Rate(this) {
                    Ok(ok__) => {
                        pdrate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CanSeekForward<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcanseekforward: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::CanSeekForward(this) {
                    Ok(ok__) => {
                        pcanseekforward.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CanSeekBackward<Identity: IMediaPosition_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcanseekbackward: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaPosition_Impl::CanSeekBackward(this) {
                    Ok(ok__) => {
                        pcanseekbackward.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Duration: Duration::<Identity, OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Identity, OFFSET>,
            CurrentPosition: CurrentPosition::<Identity, OFFSET>,
            StopTime: StopTime::<Identity, OFFSET>,
            SetStopTime: SetStopTime::<Identity, OFFSET>,
            PrerollTime: PrerollTime::<Identity, OFFSET>,
            SetPrerollTime: SetPrerollTime::<Identity, OFFSET>,
            SetRate: SetRate::<Identity, OFFSET>,
            Rate: Rate::<Identity, OFFSET>,
            CanSeekForward: CanSeekForward::<Identity, OFFSET>,
            CanSeekBackward: CanSeekBackward::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaPosition as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaPosition {}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
windows_core::imp::define_interface!(IMediaPropertyBag, IMediaPropertyBag_Vtbl, 0x6025a880_c0d5_11d0_bd4e_00a0c911ce86);
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl core::ops::Deref for IMediaPropertyBag {
    type Target = super::super::System::Com::StructuredStorage::IPropertyBag;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
windows_core::imp::interface_hierarchy!(IMediaPropertyBag, windows_core::IUnknown, super::super::System::Com::StructuredStorage::IPropertyBag);
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IMediaPropertyBag {
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn EnumProperty(&self, iproperty: u32, pvarpropertyname: *mut super::super::System::Variant::VARIANT, pvarpropertyvalue: *mut super::super::System::Variant::VARIANT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EnumProperty)(windows_core::Interface::as_raw(self), iproperty, core::mem::transmute(pvarpropertyname), core::mem::transmute(pvarpropertyvalue)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaPropertyBag_Vtbl {
    pub base__: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub EnumProperty: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut super::super::System::Variant::VARIANT, *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    EnumProperty: usize,
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaPropertyBag_Impl: super::super::System::Com::StructuredStorage::IPropertyBag_Impl {
    fn EnumProperty(&self, iproperty: u32, pvarpropertyname: *mut super::super::System::Variant::VARIANT, pvarpropertyvalue: *mut super::super::System::Variant::VARIANT) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaPropertyBag_Vtbl {
    pub const fn new<Identity: IMediaPropertyBag_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn EnumProperty<Identity: IMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, iproperty: u32, pvarpropertyname: *mut super::super::System::Variant::VARIANT, pvarpropertyvalue: *mut super::super::System::Variant::VARIANT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaPropertyBag_Impl::EnumProperty(this, core::mem::transmute_copy(&iproperty), core::mem::transmute_copy(&pvarpropertyname), core::mem::transmute_copy(&pvarpropertyvalue)).into()
            }
        }
        Self {
            base__: super::super::System::Com::StructuredStorage::IPropertyBag_Vtbl::new::<Identity, OFFSET>(),
            EnumProperty: EnumProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaPropertyBag as windows_core::Interface>::IID || iid == &<super::super::System::Com::StructuredStorage::IPropertyBag as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaPropertyBag {}
windows_core::imp::define_interface!(IMediaSample, IMediaSample_Vtbl, 0x56a8689a_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IMediaSample, windows_core::IUnknown);
impl IMediaSample {
    pub unsafe fn GetPointer(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPointer)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetSize(&self) -> i32 {
        unsafe { (windows_core::Interface::vtable(self).GetSize)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn GetTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetTime)(windows_core::Interface::as_raw(self), ptimestart as _, ptimeend as _).ok() }
    }
    pub unsafe fn SetTime(&self, ptimestart: Option<*const i64>, ptimeend: Option<*const i64>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTime)(windows_core::Interface::as_raw(self), ptimestart.unwrap_or(core::mem::zeroed()) as _, ptimeend.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn IsSyncPoint(&self) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).IsSyncPoint)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn SetSyncPoint(&self, bissyncpoint: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSyncPoint)(windows_core::Interface::as_raw(self), bissyncpoint.into()).ok() }
    }
    pub unsafe fn IsPreroll(&self) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).IsPreroll)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn SetPreroll(&self, bispreroll: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPreroll)(windows_core::Interface::as_raw(self), bispreroll.into()).ok() }
    }
    pub unsafe fn GetActualDataLength(&self) -> i32 {
        unsafe { (windows_core::Interface::vtable(self).GetActualDataLength)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn SetActualDataLength(&self, __midl__imediasample0000: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetActualDataLength)(windows_core::Interface::as_raw(self), __midl__imediasample0000).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn GetMediaType(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMediaType)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetMediaType(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaType)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype)).ok() }
    }
    pub unsafe fn IsDiscontinuity(&self) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).IsDiscontinuity)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn SetDiscontinuity(&self, bdiscontinuity: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDiscontinuity)(windows_core::Interface::as_raw(self), bdiscontinuity.into()).ok() }
    }
    pub unsafe fn GetMediaTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMediaTime)(windows_core::Interface::as_raw(self), ptimestart as _, ptimeend as _).ok() }
    }
    pub unsafe fn SetMediaTime(&self, ptimestart: Option<*const i64>, ptimeend: Option<*const i64>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMediaTime)(windows_core::Interface::as_raw(self), ptimestart.unwrap_or(core::mem::zeroed()) as _, ptimeend.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaSample_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetPointer: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub GetSize: unsafe extern "system" fn(*mut core::ffi::c_void) -> i32,
    pub GetTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetTime: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
    pub IsSyncPoint: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetSyncPoint: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub IsPreroll: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetPreroll: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetActualDataLength: unsafe extern "system" fn(*mut core::ffi::c_void) -> i32,
    pub SetActualDataLength: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub GetMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    GetMediaType: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetMediaType: usize,
    pub IsDiscontinuity: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetDiscontinuity: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetMediaTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetMediaTime: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IMediaSample_Impl: windows_core::IUnknownImpl {
    fn GetPointer(&self) -> windows_core::Result<*mut u8>;
    fn GetSize(&self) -> i32;
    fn GetTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()>;
    fn SetTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()>;
    fn IsSyncPoint(&self) -> windows_core::HRESULT;
    fn SetSyncPoint(&self, bissyncpoint: windows_core::BOOL) -> windows_core::Result<()>;
    fn IsPreroll(&self) -> windows_core::HRESULT;
    fn SetPreroll(&self, bispreroll: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetActualDataLength(&self) -> i32;
    fn SetActualDataLength(&self, __midl__imediasample0000: i32) -> windows_core::Result<()>;
    fn GetMediaType(&self) -> windows_core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE>;
    fn SetMediaType(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn IsDiscontinuity(&self) -> windows_core::HRESULT;
    fn SetDiscontinuity(&self, bdiscontinuity: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetMediaTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::Result<()>;
    fn SetMediaTime(&self, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IMediaSample_Vtbl {
    pub const fn new<Identity: IMediaSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPointer<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffer: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSample_Impl::GetPointer(this) {
                    Ok(ok__) => {
                        ppbuffer.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetSize<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> i32 {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::GetSize(this)
            }
        }
        unsafe extern "system" fn GetTime<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::GetTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn SetTime<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn IsSyncPoint<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::IsSyncPoint(this)
            }
        }
        unsafe extern "system" fn SetSyncPoint<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bissyncpoint: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetSyncPoint(this, core::mem::transmute_copy(&bissyncpoint)).into()
            }
        }
        unsafe extern "system" fn IsPreroll<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::IsPreroll(this)
            }
        }
        unsafe extern "system" fn SetPreroll<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bispreroll: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetPreroll(this, core::mem::transmute_copy(&bispreroll)).into()
            }
        }
        unsafe extern "system" fn GetActualDataLength<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> i32 {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::GetActualDataLength(this)
            }
        }
        unsafe extern "system" fn SetActualDataLength<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__imediasample0000: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetActualDataLength(this, core::mem::transmute_copy(&__midl__imediasample0000)).into()
            }
        }
        unsafe extern "system" fn GetMediaType<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediatype: *mut *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSample_Impl::GetMediaType(this) {
                    Ok(ok__) => {
                        ppmediatype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMediaType<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetMediaType(this, core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn IsDiscontinuity<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::IsDiscontinuity(this)
            }
        }
        unsafe extern "system" fn SetDiscontinuity<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bdiscontinuity: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetDiscontinuity(this, core::mem::transmute_copy(&bdiscontinuity)).into()
            }
        }
        unsafe extern "system" fn GetMediaTime<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *mut i64, ptimeend: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::GetMediaTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        unsafe extern "system" fn SetMediaTime<Identity: IMediaSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimestart: *const i64, ptimeend: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample_Impl::SetMediaTime(this, core::mem::transmute_copy(&ptimestart), core::mem::transmute_copy(&ptimeend)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPointer: GetPointer::<Identity, OFFSET>,
            GetSize: GetSize::<Identity, OFFSET>,
            GetTime: GetTime::<Identity, OFFSET>,
            SetTime: SetTime::<Identity, OFFSET>,
            IsSyncPoint: IsSyncPoint::<Identity, OFFSET>,
            SetSyncPoint: SetSyncPoint::<Identity, OFFSET>,
            IsPreroll: IsPreroll::<Identity, OFFSET>,
            SetPreroll: SetPreroll::<Identity, OFFSET>,
            GetActualDataLength: GetActualDataLength::<Identity, OFFSET>,
            SetActualDataLength: SetActualDataLength::<Identity, OFFSET>,
            GetMediaType: GetMediaType::<Identity, OFFSET>,
            SetMediaType: SetMediaType::<Identity, OFFSET>,
            IsDiscontinuity: IsDiscontinuity::<Identity, OFFSET>,
            SetDiscontinuity: SetDiscontinuity::<Identity, OFFSET>,
            GetMediaTime: GetMediaTime::<Identity, OFFSET>,
            SetMediaTime: SetMediaTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaSample as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IMediaSample {}
windows_core::imp::define_interface!(IMediaSample2, IMediaSample2_Vtbl, 0x36b73884_c2c8_11cf_8b46_00805f6cef60);
impl core::ops::Deref for IMediaSample2 {
    type Target = IMediaSample;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IMediaSample2, windows_core::IUnknown, IMediaSample);
impl IMediaSample2 {
    pub unsafe fn GetProperties(&self, pbproperties: &mut [u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetProperties)(windows_core::Interface::as_raw(self), pbproperties.len().try_into().unwrap(), core::mem::transmute(pbproperties.as_ptr())).ok() }
    }
    pub unsafe fn SetProperties(&self, pbproperties: &[u8]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetProperties)(windows_core::Interface::as_raw(self), pbproperties.len().try_into().unwrap(), core::mem::transmute(pbproperties.as_ptr())).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaSample2_Vtbl {
    pub base__: IMediaSample_Vtbl,
    pub GetProperties: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u8) -> windows_core::HRESULT,
    pub SetProperties: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IMediaSample2_Impl: IMediaSample_Impl {
    fn GetProperties(&self, cbproperties: u32, pbproperties: *mut u8) -> windows_core::Result<()>;
    fn SetProperties(&self, cbproperties: u32, pbproperties: *const u8) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IMediaSample2_Vtbl {
    pub const fn new<Identity: IMediaSample2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetProperties<Identity: IMediaSample2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbproperties: u32, pbproperties: *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample2_Impl::GetProperties(this, core::mem::transmute_copy(&cbproperties), core::mem::transmute_copy(&pbproperties)).into()
            }
        }
        unsafe extern "system" fn SetProperties<Identity: IMediaSample2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbproperties: u32, pbproperties: *const u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSample2_Impl::SetProperties(this, core::mem::transmute_copy(&cbproperties), core::mem::transmute_copy(&pbproperties)).into()
            }
        }
        Self {
            base__: IMediaSample_Vtbl::new::<Identity, OFFSET>(),
            GetProperties: GetProperties::<Identity, OFFSET>,
            SetProperties: SetProperties::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaSample2 as windows_core::Interface>::IID || iid == &<IMediaSample as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IMediaSample2 {}
windows_core::imp::define_interface!(IMediaSample2Config, IMediaSample2Config_Vtbl, 0x68961e68_832b_41ea_bc91_63593f3e70e3);
windows_core::imp::interface_hierarchy!(IMediaSample2Config, windows_core::IUnknown);
impl IMediaSample2Config {
    pub unsafe fn GetSurface(&self) -> windows_core::Result<windows_core::IUnknown> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSurface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaSample2Config_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMediaSample2Config_Impl: windows_core::IUnknownImpl {
    fn GetSurface(&self) -> windows_core::Result<windows_core::IUnknown>;
}
impl IMediaSample2Config_Vtbl {
    pub const fn new<Identity: IMediaSample2Config_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetSurface<Identity: IMediaSample2Config_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirect3dsurface9: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSample2Config_Impl::GetSurface(this) {
                    Ok(ok__) => {
                        ppdirect3dsurface9.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetSurface: GetSurface::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaSample2Config as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaSample2Config {}
windows_core::imp::define_interface!(IMediaSeeking, IMediaSeeking_Vtbl, 0x36b73880_c2c8_11cf_8b46_00805f6cef60);
windows_core::imp::interface_hierarchy!(IMediaSeeking, windows_core::IUnknown);
impl IMediaSeeking {
    pub unsafe fn GetCapabilities(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCapabilities)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn CheckCapabilities(&self, pcapabilities: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CheckCapabilities)(windows_core::Interface::as_raw(self), pcapabilities as _).ok() }
    }
    pub unsafe fn IsFormatSupported(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsFormatSupported)(windows_core::Interface::as_raw(self), pformat).ok() }
    }
    pub unsafe fn QueryPreferredFormat(&self) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryPreferredFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetTimeFormat(&self) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTimeFormat)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn IsUsingTimeFormat(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsUsingTimeFormat)(windows_core::Interface::as_raw(self), pformat).ok() }
    }
    pub unsafe fn SetTimeFormat(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTimeFormat)(windows_core::Interface::as_raw(self), pformat).ok() }
    }
    pub unsafe fn GetDuration(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDuration)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetStopPosition(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStopPosition)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetCurrentPosition(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentPosition)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn ConvertTimeFormat(&self, ptarget: *mut i64, ptargetformat: Option<*const windows_core::GUID>, source: i64, psourceformat: Option<*const windows_core::GUID>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ConvertTimeFormat)(windows_core::Interface::as_raw(self), ptarget as _, ptargetformat.unwrap_or(core::mem::zeroed()) as _, source, psourceformat.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn SetPositions(&self, pcurrent: Option<*mut i64>, dwcurrentflags: u32, pstop: Option<*mut i64>, dwstopflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPositions)(windows_core::Interface::as_raw(self), pcurrent.unwrap_or(core::mem::zeroed()) as _, dwcurrentflags, pstop.unwrap_or(core::mem::zeroed()) as _, dwstopflags).ok() }
    }
    pub unsafe fn GetPositions(&self, pcurrent: Option<*mut i64>, pstop: Option<*mut i64>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPositions)(windows_core::Interface::as_raw(self), pcurrent.unwrap_or(core::mem::zeroed()) as _, pstop.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn GetAvailable(&self, pearliest: Option<*mut i64>, platest: Option<*mut i64>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAvailable)(windows_core::Interface::as_raw(self), pearliest.unwrap_or(core::mem::zeroed()) as _, platest.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn SetRate(&self, drate: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRate)(windows_core::Interface::as_raw(self), drate).ok() }
    }
    pub unsafe fn GetRate(&self) -> windows_core::Result<f64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetPreroll(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPreroll)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaSeeking_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub CheckCapabilities: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub IsFormatSupported: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub QueryPreferredFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub IsUsingTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub SetTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetDuration: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetStopPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetCurrentPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub ConvertTimeFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *const windows_core::GUID, i64, *const windows_core::GUID) -> windows_core::HRESULT,
    pub SetPositions: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, u32, *mut i64, u32) -> windows_core::HRESULT,
    pub GetPositions: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub GetAvailable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetRate: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GetRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub GetPreroll: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
}
pub trait IMediaSeeking_Impl: windows_core::IUnknownImpl {
    fn GetCapabilities(&self) -> windows_core::Result<u32>;
    fn CheckCapabilities(&self, pcapabilities: *mut u32) -> windows_core::Result<()>;
    fn IsFormatSupported(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()>;
    fn QueryPreferredFormat(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetTimeFormat(&self) -> windows_core::Result<windows_core::GUID>;
    fn IsUsingTimeFormat(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()>;
    fn SetTimeFormat(&self, pformat: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDuration(&self) -> windows_core::Result<i64>;
    fn GetStopPosition(&self) -> windows_core::Result<i64>;
    fn GetCurrentPosition(&self) -> windows_core::Result<i64>;
    fn ConvertTimeFormat(&self, ptarget: *mut i64, ptargetformat: *const windows_core::GUID, source: i64, psourceformat: *const windows_core::GUID) -> windows_core::Result<()>;
    fn SetPositions(&self, pcurrent: *mut i64, dwcurrentflags: u32, pstop: *mut i64, dwstopflags: u32) -> windows_core::Result<()>;
    fn GetPositions(&self, pcurrent: *mut i64, pstop: *mut i64) -> windows_core::Result<()>;
    fn GetAvailable(&self, pearliest: *mut i64, platest: *mut i64) -> windows_core::Result<()>;
    fn SetRate(&self, drate: f64) -> windows_core::Result<()>;
    fn GetRate(&self) -> windows_core::Result<f64>;
    fn GetPreroll(&self) -> windows_core::Result<i64>;
}
impl IMediaSeeking_Vtbl {
    pub const fn new<Identity: IMediaSeeking_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetCapabilities<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcapabilities: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetCapabilities(this) {
                    Ok(ok__) => {
                        pcapabilities.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CheckCapabilities<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcapabilities: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::CheckCapabilities(this, core::mem::transmute_copy(&pcapabilities)).into()
            }
        }
        unsafe extern "system" fn IsFormatSupported<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pformat: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::IsFormatSupported(this, core::mem::transmute_copy(&pformat)).into()
            }
        }
        unsafe extern "system" fn QueryPreferredFormat<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pformat: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::QueryPreferredFormat(this) {
                    Ok(ok__) => {
                        pformat.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetTimeFormat<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pformat: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetTimeFormat(this) {
                    Ok(ok__) => {
                        pformat.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsUsingTimeFormat<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pformat: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::IsUsingTimeFormat(this, core::mem::transmute_copy(&pformat)).into()
            }
        }
        unsafe extern "system" fn SetTimeFormat<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pformat: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::SetTimeFormat(this, core::mem::transmute_copy(&pformat)).into()
            }
        }
        unsafe extern "system" fn GetDuration<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pduration: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetDuration(this) {
                    Ok(ok__) => {
                        pduration.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetStopPosition<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstop: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetStopPosition(this) {
                    Ok(ok__) => {
                        pstop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetCurrentPosition<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrent: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetCurrentPosition(this) {
                    Ok(ok__) => {
                        pcurrent.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConvertTimeFormat<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptarget: *mut i64, ptargetformat: *const windows_core::GUID, source: i64, psourceformat: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::ConvertTimeFormat(this, core::mem::transmute_copy(&ptarget), core::mem::transmute_copy(&ptargetformat), core::mem::transmute_copy(&source), core::mem::transmute_copy(&psourceformat)).into()
            }
        }
        unsafe extern "system" fn SetPositions<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrent: *mut i64, dwcurrentflags: u32, pstop: *mut i64, dwstopflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::SetPositions(this, core::mem::transmute_copy(&pcurrent), core::mem::transmute_copy(&dwcurrentflags), core::mem::transmute_copy(&pstop), core::mem::transmute_copy(&dwstopflags)).into()
            }
        }
        unsafe extern "system" fn GetPositions<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrent: *mut i64, pstop: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::GetPositions(this, core::mem::transmute_copy(&pcurrent), core::mem::transmute_copy(&pstop)).into()
            }
        }
        unsafe extern "system" fn GetAvailable<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pearliest: *mut i64, platest: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::GetAvailable(this, core::mem::transmute_copy(&pearliest), core::mem::transmute_copy(&platest)).into()
            }
        }
        unsafe extern "system" fn SetRate<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, drate: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaSeeking_Impl::SetRate(this, core::mem::transmute_copy(&drate)).into()
            }
        }
        unsafe extern "system" fn GetRate<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdrate: *mut f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetRate(this) {
                    Ok(ok__) => {
                        pdrate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetPreroll<Identity: IMediaSeeking_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pllpreroll: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaSeeking_Impl::GetPreroll(this) {
                    Ok(ok__) => {
                        pllpreroll.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCapabilities: GetCapabilities::<Identity, OFFSET>,
            CheckCapabilities: CheckCapabilities::<Identity, OFFSET>,
            IsFormatSupported: IsFormatSupported::<Identity, OFFSET>,
            QueryPreferredFormat: QueryPreferredFormat::<Identity, OFFSET>,
            GetTimeFormat: GetTimeFormat::<Identity, OFFSET>,
            IsUsingTimeFormat: IsUsingTimeFormat::<Identity, OFFSET>,
            SetTimeFormat: SetTimeFormat::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            GetStopPosition: GetStopPosition::<Identity, OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Identity, OFFSET>,
            ConvertTimeFormat: ConvertTimeFormat::<Identity, OFFSET>,
            SetPositions: SetPositions::<Identity, OFFSET>,
            GetPositions: GetPositions::<Identity, OFFSET>,
            GetAvailable: GetAvailable::<Identity, OFFSET>,
            SetRate: SetRate::<Identity, OFFSET>,
            GetRate: GetRate::<Identity, OFFSET>,
            GetPreroll: GetPreroll::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaSeeking as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaSeeking {}
windows_core::imp::define_interface!(IMediaStream, IMediaStream_Vtbl, 0xb502d1bd_9a57_11d0_8fde_00c04fd9189d);
windows_core::imp::interface_hierarchy!(IMediaStream, windows_core::IUnknown);
impl IMediaStream {
    pub unsafe fn GetMultiMediaStream(&self) -> windows_core::Result<IMultiMediaStream> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMultiMediaStream)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetInformation(&self, ppurposeid: *mut windows_core::GUID, ptype: *mut STREAM_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInformation)(windows_core::Interface::as_raw(self), ppurposeid as _, ptype as _).ok() }
    }
    pub unsafe fn SetSameFormat<P0>(&self, pstreamthathasdesiredformat: P0, dwflags: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaStream>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetSameFormat)(windows_core::Interface::as_raw(self), pstreamthathasdesiredformat.param().abi(), dwflags).ok() }
    }
    pub unsafe fn AllocateSample(&self, dwflags: u32) -> windows_core::Result<IStreamSample> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AllocateSample)(windows_core::Interface::as_raw(self), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn CreateSharedSample<P0>(&self, pexistingsample: P0, dwflags: u32) -> windows_core::Result<IStreamSample>
    where
        P0: windows_core::Param<IStreamSample>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateSharedSample)(windows_core::Interface::as_raw(self), pexistingsample.param().abi(), dwflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SendEndOfStream(&self, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SendEndOfStream)(windows_core::Interface::as_raw(self), dwflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaStream_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMultiMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetInformation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::GUID, *mut STREAM_TYPE) -> windows_core::HRESULT,
    pub SetSameFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub AllocateSample: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CreateSharedSample: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SendEndOfStream: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IMediaStream_Impl: windows_core::IUnknownImpl {
    fn GetMultiMediaStream(&self) -> windows_core::Result<IMultiMediaStream>;
    fn GetInformation(&self, ppurposeid: *mut windows_core::GUID, ptype: *mut STREAM_TYPE) -> windows_core::Result<()>;
    fn SetSameFormat(&self, pstreamthathasdesiredformat: windows_core::Ref<IMediaStream>, dwflags: u32) -> windows_core::Result<()>;
    fn AllocateSample(&self, dwflags: u32) -> windows_core::Result<IStreamSample>;
    fn CreateSharedSample(&self, pexistingsample: windows_core::Ref<IStreamSample>, dwflags: u32) -> windows_core::Result<IStreamSample>;
    fn SendEndOfStream(&self, dwflags: u32) -> windows_core::Result<()>;
}
impl IMediaStream_Vtbl {
    pub const fn new<Identity: IMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMultiMediaStream<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmultimediastream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStream_Impl::GetMultiMediaStream(this) {
                    Ok(ok__) => {
                        ppmultimediastream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetInformation<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppurposeid: *mut windows_core::GUID, ptype: *mut STREAM_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStream_Impl::GetInformation(this, core::mem::transmute_copy(&ppurposeid), core::mem::transmute_copy(&ptype)).into()
            }
        }
        unsafe extern "system" fn SetSameFormat<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstreamthathasdesiredformat: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStream_Impl::SetSameFormat(this, core::mem::transmute_copy(&pstreamthathasdesiredformat), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn AllocateSample<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStream_Impl::AllocateSample(this, core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppsample.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CreateSharedSample<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pexistingsample: *mut core::ffi::c_void, dwflags: u32, ppnewsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStream_Impl::CreateSharedSample(this, core::mem::transmute_copy(&pexistingsample), core::mem::transmute_copy(&dwflags)) {
                    Ok(ok__) => {
                        ppnewsample.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SendEndOfStream<Identity: IMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStream_Impl::SendEndOfStream(this, core::mem::transmute_copy(&dwflags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMultiMediaStream: GetMultiMediaStream::<Identity, OFFSET>,
            GetInformation: GetInformation::<Identity, OFFSET>,
            SetSameFormat: SetSameFormat::<Identity, OFFSET>,
            AllocateSample: AllocateSample::<Identity, OFFSET>,
            CreateSharedSample: CreateSharedSample::<Identity, OFFSET>,
            SendEndOfStream: SendEndOfStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaStream as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMediaStream {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaStreamFilter, IMediaStreamFilter_Vtbl, 0xbebe595e_9a6f_11d0_8fde_00c04fd9189d);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaStreamFilter {
    type Target = IBaseFilter;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaStreamFilter, windows_core::IUnknown, super::super::System::Com::IPersist, IMediaFilter, IBaseFilter);
#[cfg(feature = "Win32_System_Com")]
impl IMediaStreamFilter {
    pub unsafe fn AddMediaStream<P0>(&self, pammediastream: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMMediaStream>,
    {
        unsafe { (windows_core::Interface::vtable(self).AddMediaStream)(windows_core::Interface::as_raw(self), pammediastream.param().abi()).ok() }
    }
    pub unsafe fn GetMediaStream(&self, idpurpose: *const windows_core::GUID) -> windows_core::Result<IMediaStream> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMediaStream)(windows_core::Interface::as_raw(self), idpurpose, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn EnumMediaStreams(&self, index: i32) -> windows_core::Result<IMediaStream> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumMediaStreams)(windows_core::Interface::as_raw(self), index, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SupportSeeking(&self, brenderer: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SupportSeeking)(windows_core::Interface::as_raw(self), brenderer.into()).ok() }
    }
    pub unsafe fn ReferenceTimeToStreamTime(&self, ptime: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReferenceTimeToStreamTime)(windows_core::Interface::as_raw(self), ptime as _).ok() }
    }
    pub unsafe fn GetCurrentStreamTime(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentStreamTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn WaitUntil(&self, waitstreamtime: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).WaitUntil)(windows_core::Interface::as_raw(self), waitstreamtime).ok() }
    }
    pub unsafe fn Flush(&self, bcanceleos: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Flush)(windows_core::Interface::as_raw(self), bcanceleos.into()).ok() }
    }
    pub unsafe fn EndOfStream(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EndOfStream)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaStreamFilter_Vtbl {
    pub base__: IBaseFilter_Vtbl,
    pub AddMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub EnumMediaStreams: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SupportSeeking: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub ReferenceTimeToStreamTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetCurrentStreamTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub WaitUntil: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub Flush: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub EndOfStream: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMediaStreamFilter_Impl: IBaseFilter_Impl {
    fn AddMediaStream(&self, pammediastream: windows_core::Ref<IAMMediaStream>) -> windows_core::Result<()>;
    fn GetMediaStream(&self, idpurpose: *const windows_core::GUID) -> windows_core::Result<IMediaStream>;
    fn EnumMediaStreams(&self, index: i32) -> windows_core::Result<IMediaStream>;
    fn SupportSeeking(&self, brenderer: windows_core::BOOL) -> windows_core::Result<()>;
    fn ReferenceTimeToStreamTime(&self, ptime: *mut i64) -> windows_core::Result<()>;
    fn GetCurrentStreamTime(&self) -> windows_core::Result<i64>;
    fn WaitUntil(&self, waitstreamtime: i64) -> windows_core::Result<()>;
    fn Flush(&self, bcanceleos: windows_core::BOOL) -> windows_core::Result<()>;
    fn EndOfStream(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaStreamFilter_Vtbl {
    pub const fn new<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AddMediaStream<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pammediastream: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::AddMediaStream(this, core::mem::transmute_copy(&pammediastream)).into()
            }
        }
        unsafe extern "system" fn GetMediaStream<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idpurpose: *const windows_core::GUID, ppmediastream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStreamFilter_Impl::GetMediaStream(this, core::mem::transmute_copy(&idpurpose)) {
                    Ok(ok__) => {
                        ppmediastream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: i32, ppmediastream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStreamFilter_Impl::EnumMediaStreams(this, core::mem::transmute_copy(&index)) {
                    Ok(ok__) => {
                        ppmediastream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SupportSeeking<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, brenderer: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::SupportSeeking(this, core::mem::transmute_copy(&brenderer)).into()
            }
        }
        unsafe extern "system" fn ReferenceTimeToStreamTime<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptime: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::ReferenceTimeToStreamTime(this, core::mem::transmute_copy(&ptime)).into()
            }
        }
        unsafe extern "system" fn GetCurrentStreamTime<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrentstreamtime: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaStreamFilter_Impl::GetCurrentStreamTime(this) {
                    Ok(ok__) => {
                        pcurrentstreamtime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn WaitUntil<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, waitstreamtime: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::WaitUntil(this, core::mem::transmute_copy(&waitstreamtime)).into()
            }
        }
        unsafe extern "system" fn Flush<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bcanceleos: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::Flush(this, core::mem::transmute_copy(&bcanceleos)).into()
            }
        }
        unsafe extern "system" fn EndOfStream<Identity: IMediaStreamFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaStreamFilter_Impl::EndOfStream(this).into()
            }
        }
        Self {
            base__: IBaseFilter_Vtbl::new::<Identity, OFFSET>(),
            AddMediaStream: AddMediaStream::<Identity, OFFSET>,
            GetMediaStream: GetMediaStream::<Identity, OFFSET>,
            EnumMediaStreams: EnumMediaStreams::<Identity, OFFSET>,
            SupportSeeking: SupportSeeking::<Identity, OFFSET>,
            ReferenceTimeToStreamTime: ReferenceTimeToStreamTime::<Identity, OFFSET>,
            GetCurrentStreamTime: GetCurrentStreamTime::<Identity, OFFSET>,
            WaitUntil: WaitUntil::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            EndOfStream: EndOfStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaStreamFilter as windows_core::Interface>::IID || iid == &<super::super::System::Com::IPersist as windows_core::Interface>::IID || iid == &<IMediaFilter as windows_core::Interface>::IID || iid == &<IBaseFilter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IMediaStreamFilter {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IMediaTypeInfo, IMediaTypeInfo_Vtbl, 0x56a868bc_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IMediaTypeInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IMediaTypeInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IMediaTypeInfo {
    pub unsafe fn Type(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Type)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn Subtype(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Subtype)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IMediaTypeInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Type: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Subtype: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IMediaTypeInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn Type(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Subtype(&self) -> windows_core::Result<windows_core::BSTR>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IMediaTypeInfo_Vtbl {
    pub const fn new<Identity: IMediaTypeInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Type<Identity: IMediaTypeInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strtype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaTypeInfo_Impl::Type(this) {
                    Ok(ok__) => {
                        strtype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Subtype<Identity: IMediaTypeInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strtype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaTypeInfo_Impl::Subtype(this) {
                    Ok(ok__) => {
                        strtype.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Type: Type::<Identity, OFFSET>,
            Subtype: Subtype::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaTypeInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMediaTypeInfo {}
windows_core::imp::define_interface!(IMemAllocator, IMemAllocator_Vtbl, 0x56a8689c_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IMemAllocator, windows_core::IUnknown);
impl IMemAllocator {
    pub unsafe fn SetProperties(&self, prequest: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<ALLOCATOR_PROPERTIES> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SetProperties)(windows_core::Interface::as_raw(self), prequest, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetProperties(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetProperties)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Commit(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Commit)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Decommit(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Decommit)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetBuffer(&self, ppbuffer: *mut Option<IMediaSample>, pstarttime: Option<*const i64>, pendtime: Option<*const i64>, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBuffer)(windows_core::Interface::as_raw(self), core::mem::transmute(ppbuffer), pstarttime.unwrap_or(core::mem::zeroed()) as _, pendtime.unwrap_or(core::mem::zeroed()) as _, dwflags).ok() }
    }
    pub unsafe fn ReleaseBuffer<P0>(&self, pbuffer: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaSample>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReleaseBuffer)(windows_core::Interface::as_raw(self), pbuffer.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMemAllocator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetProperties: unsafe extern "system" fn(*mut core::ffi::c_void, *const ALLOCATOR_PROPERTIES, *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
    pub GetProperties: unsafe extern "system" fn(*mut core::ffi::c_void, *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
    pub Commit: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Decommit: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetBuffer: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *const i64, *const i64, u32) -> windows_core::HRESULT,
    pub ReleaseBuffer: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMemAllocator_Impl: windows_core::IUnknownImpl {
    fn SetProperties(&self, prequest: *const ALLOCATOR_PROPERTIES) -> windows_core::Result<ALLOCATOR_PROPERTIES>;
    fn GetProperties(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES>;
    fn Commit(&self) -> windows_core::Result<()>;
    fn Decommit(&self) -> windows_core::Result<()>;
    fn GetBuffer(&self, ppbuffer: windows_core::OutRef<IMediaSample>, pstarttime: *const i64, pendtime: *const i64, dwflags: u32) -> windows_core::Result<()>;
    fn ReleaseBuffer(&self, pbuffer: windows_core::Ref<IMediaSample>) -> windows_core::Result<()>;
}
impl IMemAllocator_Vtbl {
    pub const fn new<Identity: IMemAllocator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetProperties<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prequest: *const ALLOCATOR_PROPERTIES, pactual: *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemAllocator_Impl::SetProperties(this, core::mem::transmute_copy(&prequest)) {
                    Ok(ok__) => {
                        pactual.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetProperties<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemAllocator_Impl::GetProperties(this) {
                    Ok(ok__) => {
                        pprops.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Commit<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocator_Impl::Commit(this).into()
            }
        }
        unsafe extern "system" fn Decommit<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocator_Impl::Decommit(this).into()
            }
        }
        unsafe extern "system" fn GetBuffer<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffer: *mut *mut core::ffi::c_void, pstarttime: *const i64, pendtime: *const i64, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocator_Impl::GetBuffer(this, core::mem::transmute_copy(&ppbuffer), core::mem::transmute_copy(&pstarttime), core::mem::transmute_copy(&pendtime), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn ReleaseBuffer<Identity: IMemAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocator_Impl::ReleaseBuffer(this, core::mem::transmute_copy(&pbuffer)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetProperties: SetProperties::<Identity, OFFSET>,
            GetProperties: GetProperties::<Identity, OFFSET>,
            Commit: Commit::<Identity, OFFSET>,
            Decommit: Decommit::<Identity, OFFSET>,
            GetBuffer: GetBuffer::<Identity, OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMemAllocator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMemAllocator {}
windows_core::imp::define_interface!(IMemAllocatorCallbackTemp, IMemAllocatorCallbackTemp_Vtbl, 0x379a0cf0_c1de_11d2_abf5_00a0c905f375);
impl core::ops::Deref for IMemAllocatorCallbackTemp {
    type Target = IMemAllocator;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IMemAllocatorCallbackTemp, windows_core::IUnknown, IMemAllocator);
impl IMemAllocatorCallbackTemp {
    pub unsafe fn SetNotify<P0>(&self, pnotify: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMemAllocatorNotifyCallbackTemp>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetNotify)(windows_core::Interface::as_raw(self), pnotify.param().abi()).ok() }
    }
    pub unsafe fn GetFreeCount(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetFreeCount)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMemAllocatorCallbackTemp_Vtbl {
    pub base__: IMemAllocator_Vtbl,
    pub SetNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetFreeCount: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IMemAllocatorCallbackTemp_Impl: IMemAllocator_Impl {
    fn SetNotify(&self, pnotify: windows_core::Ref<IMemAllocatorNotifyCallbackTemp>) -> windows_core::Result<()>;
    fn GetFreeCount(&self) -> windows_core::Result<i32>;
}
impl IMemAllocatorCallbackTemp_Vtbl {
    pub const fn new<Identity: IMemAllocatorCallbackTemp_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetNotify<Identity: IMemAllocatorCallbackTemp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocatorCallbackTemp_Impl::SetNotify(this, core::mem::transmute_copy(&pnotify)).into()
            }
        }
        unsafe extern "system" fn GetFreeCount<Identity: IMemAllocatorCallbackTemp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plbuffersfree: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemAllocatorCallbackTemp_Impl::GetFreeCount(this) {
                    Ok(ok__) => {
                        plbuffersfree.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: IMemAllocator_Vtbl::new::<Identity, OFFSET>(), SetNotify: SetNotify::<Identity, OFFSET>, GetFreeCount: GetFreeCount::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMemAllocatorCallbackTemp as windows_core::Interface>::IID || iid == &<IMemAllocator as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMemAllocatorCallbackTemp {}
windows_core::imp::define_interface!(IMemAllocatorNotifyCallbackTemp, IMemAllocatorNotifyCallbackTemp_Vtbl, 0x92980b30_c1de_11d2_abf5_00a0c905f375);
windows_core::imp::interface_hierarchy!(IMemAllocatorNotifyCallbackTemp, windows_core::IUnknown);
impl IMemAllocatorNotifyCallbackTemp {
    pub unsafe fn NotifyRelease(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyRelease)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMemAllocatorNotifyCallbackTemp_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub NotifyRelease: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMemAllocatorNotifyCallbackTemp_Impl: windows_core::IUnknownImpl {
    fn NotifyRelease(&self) -> windows_core::Result<()>;
}
impl IMemAllocatorNotifyCallbackTemp_Vtbl {
    pub const fn new<Identity: IMemAllocatorNotifyCallbackTemp_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn NotifyRelease<Identity: IMemAllocatorNotifyCallbackTemp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemAllocatorNotifyCallbackTemp_Impl::NotifyRelease(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), NotifyRelease: NotifyRelease::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMemAllocatorNotifyCallbackTemp as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMemAllocatorNotifyCallbackTemp {}
windows_core::imp::define_interface!(IMemInputPin, IMemInputPin_Vtbl, 0x56a8689d_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IMemInputPin, windows_core::IUnknown);
impl IMemInputPin {
    pub unsafe fn GetAllocator(&self) -> windows_core::Result<IMemAllocator> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllocator)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn NotifyAllocator<P0>(&self, pallocator: P0, breadonly: bool) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMemAllocator>,
    {
        unsafe { (windows_core::Interface::vtable(self).NotifyAllocator)(windows_core::Interface::as_raw(self), pallocator.param().abi(), breadonly.into()).ok() }
    }
    pub unsafe fn GetAllocatorRequirements(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAllocatorRequirements)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Receive<P0>(&self, psample: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaSample>,
    {
        unsafe { (windows_core::Interface::vtable(self).Receive)(windows_core::Interface::as_raw(self), psample.param().abi()).ok() }
    }
    pub unsafe fn ReceiveMultiple(&self, psamples: &[Option<IMediaSample>]) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ReceiveMultiple)(windows_core::Interface::as_raw(self), core::mem::transmute(psamples.as_ptr()), psamples.len().try_into().unwrap(), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn ReceiveCanBlock(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReceiveCanBlock)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMemInputPin_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetAllocator: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NotifyAllocator: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetAllocatorRequirements: unsafe extern "system" fn(*mut core::ffi::c_void, *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT,
    pub Receive: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ReceiveMultiple: unsafe extern "system" fn(*mut core::ffi::c_void, *const *mut core::ffi::c_void, i32, *mut i32) -> windows_core::HRESULT,
    pub ReceiveCanBlock: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IMemInputPin_Impl: windows_core::IUnknownImpl {
    fn GetAllocator(&self) -> windows_core::Result<IMemAllocator>;
    fn NotifyAllocator(&self, pallocator: windows_core::Ref<IMemAllocator>, breadonly: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetAllocatorRequirements(&self) -> windows_core::Result<ALLOCATOR_PROPERTIES>;
    fn Receive(&self, psample: windows_core::Ref<IMediaSample>) -> windows_core::Result<()>;
    fn ReceiveMultiple(&self, psamples: *const Option<IMediaSample>, nsamples: i32) -> windows_core::Result<i32>;
    fn ReceiveCanBlock(&self) -> windows_core::Result<()>;
}
impl IMemInputPin_Vtbl {
    pub const fn new<Identity: IMemInputPin_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetAllocator<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppallocator: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemInputPin_Impl::GetAllocator(this) {
                    Ok(ok__) => {
                        ppallocator.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn NotifyAllocator<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pallocator: *mut core::ffi::c_void, breadonly: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemInputPin_Impl::NotifyAllocator(this, core::mem::transmute_copy(&pallocator), core::mem::transmute_copy(&breadonly)).into()
            }
        }
        unsafe extern "system" fn GetAllocatorRequirements<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprops: *mut ALLOCATOR_PROPERTIES) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemInputPin_Impl::GetAllocatorRequirements(this) {
                    Ok(ok__) => {
                        pprops.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Receive<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemInputPin_Impl::Receive(this, core::mem::transmute_copy(&psample)).into()
            }
        }
        unsafe extern "system" fn ReceiveMultiple<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psamples: *const *mut core::ffi::c_void, nsamples: i32, nsamplesprocessed: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMemInputPin_Impl::ReceiveMultiple(this, core::mem::transmute_copy(&psamples), core::mem::transmute_copy(&nsamples)) {
                    Ok(ok__) => {
                        nsamplesprocessed.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ReceiveCanBlock<Identity: IMemInputPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemInputPin_Impl::ReceiveCanBlock(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAllocator: GetAllocator::<Identity, OFFSET>,
            NotifyAllocator: NotifyAllocator::<Identity, OFFSET>,
            GetAllocatorRequirements: GetAllocatorRequirements::<Identity, OFFSET>,
            Receive: Receive::<Identity, OFFSET>,
            ReceiveMultiple: ReceiveMultiple::<Identity, OFFSET>,
            ReceiveCanBlock: ReceiveCanBlock::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMemInputPin as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMemInputPin {}
windows_core::imp::define_interface!(IMemoryData, IMemoryData_Vtbl, 0x327fc560_af60_11d0_8212_00c04fc32c45);
windows_core::imp::interface_hierarchy!(IMemoryData, windows_core::IUnknown);
impl IMemoryData {
    pub unsafe fn SetBuffer(&self, cbsize: u32, pbdata: *const u8, dwflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBuffer)(windows_core::Interface::as_raw(self), cbsize, pbdata, dwflags).ok() }
    }
    pub unsafe fn GetInfo(&self, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInfo)(windows_core::Interface::as_raw(self), pdwlength as _, ppbdata as _, pcbactualdata as _).ok() }
    }
    pub unsafe fn SetActual(&self, cbdatavalid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetActual)(windows_core::Interface::as_raw(self), cbdatavalid).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMemoryData_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetBuffer: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const u8, u32) -> windows_core::HRESULT,
    pub GetInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut u8, *mut u32) -> windows_core::HRESULT,
    pub SetActual: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IMemoryData_Impl: windows_core::IUnknownImpl {
    fn SetBuffer(&self, cbsize: u32, pbdata: *const u8, dwflags: u32) -> windows_core::Result<()>;
    fn GetInfo(&self, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> windows_core::Result<()>;
    fn SetActual(&self, cbdatavalid: u32) -> windows_core::Result<()>;
}
impl IMemoryData_Vtbl {
    pub const fn new<Identity: IMemoryData_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetBuffer<Identity: IMemoryData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbsize: u32, pbdata: *const u8, dwflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemoryData_Impl::SetBuffer(this, core::mem::transmute_copy(&cbsize), core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&dwflags)).into()
            }
        }
        unsafe extern "system" fn GetInfo<Identity: IMemoryData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemoryData_Impl::GetInfo(this, core::mem::transmute_copy(&pdwlength), core::mem::transmute_copy(&ppbdata), core::mem::transmute_copy(&pcbactualdata)).into()
            }
        }
        unsafe extern "system" fn SetActual<Identity: IMemoryData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbdatavalid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMemoryData_Impl::SetActual(this, core::mem::transmute_copy(&cbdatavalid)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetBuffer: SetBuffer::<Identity, OFFSET>,
            GetInfo: GetInfo::<Identity, OFFSET>,
            SetActual: SetActual::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMemoryData as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMemoryData {}
windows_core::imp::define_interface!(IMixerOCX, IMixerOCX_Vtbl, 0x81a3bd32_dee1_11d1_8508_00a0c91f9ca0);
windows_core::imp::interface_hierarchy!(IMixerOCX, windows_core::IUnknown);
impl IMixerOCX {
    pub unsafe fn OnDisplayChange(&self, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnDisplayChange)(windows_core::Interface::as_raw(self), ulbitsperpixel, ulscreenwidth, ulscreenheight).ok() }
    }
    pub unsafe fn GetAspectRatio(&self, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAspectRatio)(windows_core::Interface::as_raw(self), pdwpictaspectratiox as _, pdwpictaspectratioy as _).ok() }
    }
    pub unsafe fn GetVideoSize(&self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoSize)(windows_core::Interface::as_raw(self), pdwvideowidth as _, pdwvideoheight as _).ok() }
    }
    pub unsafe fn GetStatus(&self) -> windows_core::Result<*mut u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStatus)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn OnDraw(&self, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnDraw)(windows_core::Interface::as_raw(self), hdcdraw, prcdraw).ok() }
    }
    pub unsafe fn SetDrawRegion(&self, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDrawRegion)(windows_core::Interface::as_raw(self), lppttopleftsc, prcdrawcc, lprcclip).ok() }
    }
    pub unsafe fn Advise<P0>(&self, pmdns: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMixerOCXNotify>,
    {
        unsafe { (windows_core::Interface::vtable(self).Advise)(windows_core::Interface::as_raw(self), pmdns.param().abi()).ok() }
    }
    pub unsafe fn UnAdvise(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnAdvise)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMixerOCX_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnDisplayChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32) -> windows_core::HRESULT,
    pub GetAspectRatio: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub GetStatus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub OnDraw: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Graphics::Gdi::HDC, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    OnDraw: usize,
    pub SetDrawRegion: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::POINT, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub Advise: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub UnAdvise: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IMixerOCX_Impl: windows_core::IUnknownImpl {
    fn OnDisplayChange(&self, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> windows_core::Result<()>;
    fn GetAspectRatio(&self, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::Result<()>;
    fn GetVideoSize(&self, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> windows_core::Result<()>;
    fn GetStatus(&self) -> windows_core::Result<*mut u32>;
    fn OnDraw(&self, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn SetDrawRegion(&self, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn Advise(&self, pmdns: windows_core::Ref<IMixerOCXNotify>) -> windows_core::Result<()>;
    fn UnAdvise(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IMixerOCX_Vtbl {
    pub const fn new<Identity: IMixerOCX_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnDisplayChange<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbitsperpixel: u32, ulscreenwidth: u32, ulscreenheight: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::OnDisplayChange(this, core::mem::transmute_copy(&ulbitsperpixel), core::mem::transmute_copy(&ulscreenwidth), core::mem::transmute_copy(&ulscreenheight)).into()
            }
        }
        unsafe extern "system" fn GetAspectRatio<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwpictaspectratiox: *mut u32, pdwpictaspectratioy: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::GetAspectRatio(this, core::mem::transmute_copy(&pdwpictaspectratiox), core::mem::transmute_copy(&pdwpictaspectratioy)).into()
            }
        }
        unsafe extern "system" fn GetVideoSize<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwvideowidth: *mut u32, pdwvideoheight: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::GetVideoSize(this, core::mem::transmute_copy(&pdwvideowidth), core::mem::transmute_copy(&pdwvideoheight)).into()
            }
        }
        unsafe extern "system" fn GetStatus<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstatus: *mut *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMixerOCX_Impl::GetStatus(this) {
                    Ok(ok__) => {
                        pdwstatus.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn OnDraw<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdcdraw: super::super::Graphics::Gdi::HDC, prcdraw: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::OnDraw(this, core::mem::transmute_copy(&hdcdraw), core::mem::transmute_copy(&prcdraw)).into()
            }
        }
        unsafe extern "system" fn SetDrawRegion<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lppttopleftsc: *const super::super::Foundation::POINT, prcdrawcc: *const super::super::Foundation::RECT, lprcclip: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::SetDrawRegion(this, core::mem::transmute_copy(&lppttopleftsc), core::mem::transmute_copy(&prcdrawcc), core::mem::transmute_copy(&lprcclip)).into()
            }
        }
        unsafe extern "system" fn Advise<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmdns: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::Advise(this, core::mem::transmute_copy(&pmdns)).into()
            }
        }
        unsafe extern "system" fn UnAdvise<Identity: IMixerOCX_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCX_Impl::UnAdvise(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnDisplayChange: OnDisplayChange::<Identity, OFFSET>,
            GetAspectRatio: GetAspectRatio::<Identity, OFFSET>,
            GetVideoSize: GetVideoSize::<Identity, OFFSET>,
            GetStatus: GetStatus::<Identity, OFFSET>,
            OnDraw: OnDraw::<Identity, OFFSET>,
            SetDrawRegion: SetDrawRegion::<Identity, OFFSET>,
            Advise: Advise::<Identity, OFFSET>,
            UnAdvise: UnAdvise::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMixerOCX as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IMixerOCX {}
windows_core::imp::define_interface!(IMixerOCXNotify, IMixerOCXNotify_Vtbl, 0x81a3bd31_dee1_11d1_8508_00a0c91f9ca0);
windows_core::imp::interface_hierarchy!(IMixerOCXNotify, windows_core::IUnknown);
impl IMixerOCXNotify {
    pub unsafe fn OnInvalidateRect(&self, lpcrect: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnInvalidateRect)(windows_core::Interface::as_raw(self), lpcrect).ok() }
    }
    pub unsafe fn OnStatusChange(&self, ulstatusflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnStatusChange)(windows_core::Interface::as_raw(self), ulstatusflags).ok() }
    }
    pub unsafe fn OnDataChange(&self, uldataflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnDataChange)(windows_core::Interface::as_raw(self), uldataflags).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMixerOCXNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub OnInvalidateRect: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub OnStatusChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub OnDataChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IMixerOCXNotify_Impl: windows_core::IUnknownImpl {
    fn OnInvalidateRect(&self, lpcrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn OnStatusChange(&self, ulstatusflags: u32) -> windows_core::Result<()>;
    fn OnDataChange(&self, uldataflags: u32) -> windows_core::Result<()>;
}
impl IMixerOCXNotify_Vtbl {
    pub const fn new<Identity: IMixerOCXNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnInvalidateRect<Identity: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpcrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCXNotify_Impl::OnInvalidateRect(this, core::mem::transmute_copy(&lpcrect)).into()
            }
        }
        unsafe extern "system" fn OnStatusChange<Identity: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulstatusflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCXNotify_Impl::OnStatusChange(this, core::mem::transmute_copy(&ulstatusflags)).into()
            }
        }
        unsafe extern "system" fn OnDataChange<Identity: IMixerOCXNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uldataflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerOCXNotify_Impl::OnDataChange(this, core::mem::transmute_copy(&uldataflags)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnInvalidateRect: OnInvalidateRect::<Identity, OFFSET>,
            OnStatusChange: OnStatusChange::<Identity, OFFSET>,
            OnDataChange: OnDataChange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMixerOCXNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMixerOCXNotify {}
windows_core::imp::define_interface!(IMixerPinConfig, IMixerPinConfig_Vtbl, 0x593cdde1_0759_11d1_9e69_00c04fd7c15b);
windows_core::imp::interface_hierarchy!(IMixerPinConfig, windows_core::IUnknown);
impl IMixerPinConfig {
    pub unsafe fn SetRelativePosition(&self, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRelativePosition)(windows_core::Interface::as_raw(self), dwleft, dwtop, dwright, dwbottom).ok() }
    }
    pub unsafe fn GetRelativePosition(&self, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRelativePosition)(windows_core::Interface::as_raw(self), pdwleft as _, pdwtop as _, pdwright as _, pdwbottom as _).ok() }
    }
    pub unsafe fn SetZOrder(&self, dwzorder: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetZOrder)(windows_core::Interface::as_raw(self), dwzorder).ok() }
    }
    pub unsafe fn GetZOrder(&self, pdwzorder: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetZOrder)(windows_core::Interface::as_raw(self), pdwzorder as _).ok() }
    }
    pub unsafe fn SetColorKey(&self, pcolorkey: *mut COLORKEY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetColorKey)(windows_core::Interface::as_raw(self), pcolorkey as _).ok() }
    }
    pub unsafe fn GetColorKey(&self, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetColorKey)(windows_core::Interface::as_raw(self), pcolorkey as _, pcolor as _).ok() }
    }
    pub unsafe fn SetBlendingParameter(&self, dwblendingparameter: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBlendingParameter)(windows_core::Interface::as_raw(self), dwblendingparameter).ok() }
    }
    pub unsafe fn GetBlendingParameter(&self, pdwblendingparameter: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBlendingParameter)(windows_core::Interface::as_raw(self), pdwblendingparameter as _).ok() }
    }
    pub unsafe fn SetAspectRatioMode(&self, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAspectRatioMode)(windows_core::Interface::as_raw(self), amaspectratiomode).ok() }
    }
    pub unsafe fn GetAspectRatioMode(&self, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAspectRatioMode)(windows_core::Interface::as_raw(self), pamaspectratiomode as _).ok() }
    }
    pub unsafe fn SetStreamTransparent(&self, bstreamtransparent: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamTransparent)(windows_core::Interface::as_raw(self), bstreamtransparent.into()).ok() }
    }
    pub unsafe fn GetStreamTransparent(&self, pbstreamtransparent: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetStreamTransparent)(windows_core::Interface::as_raw(self), pbstreamtransparent as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMixerPinConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetRelativePosition: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32, u32) -> windows_core::HRESULT,
    pub GetRelativePosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut u32, *mut u32, *mut u32) -> windows_core::HRESULT,
    pub SetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut COLORKEY) -> windows_core::HRESULT,
    pub GetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut COLORKEY, *mut u32) -> windows_core::HRESULT,
    pub SetBlendingParameter: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetBlendingParameter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, AM_ASPECT_RATIO_MODE) -> windows_core::HRESULT,
    pub GetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AM_ASPECT_RATIO_MODE) -> windows_core::HRESULT,
    pub SetStreamTransparent: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetStreamTransparent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IMixerPinConfig_Impl: windows_core::IUnknownImpl {
    fn SetRelativePosition(&self, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> windows_core::Result<()>;
    fn GetRelativePosition(&self, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> windows_core::Result<()>;
    fn SetZOrder(&self, dwzorder: u32) -> windows_core::Result<()>;
    fn GetZOrder(&self, pdwzorder: *mut u32) -> windows_core::Result<()>;
    fn SetColorKey(&self, pcolorkey: *mut COLORKEY) -> windows_core::Result<()>;
    fn GetColorKey(&self, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> windows_core::Result<()>;
    fn SetBlendingParameter(&self, dwblendingparameter: u32) -> windows_core::Result<()>;
    fn GetBlendingParameter(&self, pdwblendingparameter: *mut u32) -> windows_core::Result<()>;
    fn SetAspectRatioMode(&self, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> windows_core::Result<()>;
    fn GetAspectRatioMode(&self, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> windows_core::Result<()>;
    fn SetStreamTransparent(&self, bstreamtransparent: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetStreamTransparent(&self, pbstreamtransparent: *mut windows_core::BOOL) -> windows_core::Result<()>;
}
impl IMixerPinConfig_Vtbl {
    pub const fn new<Identity: IMixerPinConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetRelativePosition<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetRelativePosition(this, core::mem::transmute_copy(&dwleft), core::mem::transmute_copy(&dwtop), core::mem::transmute_copy(&dwright), core::mem::transmute_copy(&dwbottom)).into()
            }
        }
        unsafe extern "system" fn GetRelativePosition<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetRelativePosition(this, core::mem::transmute_copy(&pdwleft), core::mem::transmute_copy(&pdwtop), core::mem::transmute_copy(&pdwright), core::mem::transmute_copy(&pdwbottom)).into()
            }
        }
        unsafe extern "system" fn SetZOrder<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwzorder: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetZOrder(this, core::mem::transmute_copy(&dwzorder)).into()
            }
        }
        unsafe extern "system" fn GetZOrder<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwzorder: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetZOrder(this, core::mem::transmute_copy(&pdwzorder)).into()
            }
        }
        unsafe extern "system" fn SetColorKey<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *mut COLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetColorKey(this, core::mem::transmute_copy(&pcolorkey)).into()
            }
        }
        unsafe extern "system" fn GetColorKey<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetColorKey(this, core::mem::transmute_copy(&pcolorkey), core::mem::transmute_copy(&pcolor)).into()
            }
        }
        unsafe extern "system" fn SetBlendingParameter<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwblendingparameter: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetBlendingParameter(this, core::mem::transmute_copy(&dwblendingparameter)).into()
            }
        }
        unsafe extern "system" fn GetBlendingParameter<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwblendingparameter: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetBlendingParameter(this, core::mem::transmute_copy(&pdwblendingparameter)).into()
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&amaspectratiomode)).into()
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetAspectRatioMode(this, core::mem::transmute_copy(&pamaspectratiomode)).into()
            }
        }
        unsafe extern "system" fn SetStreamTransparent<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstreamtransparent: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::SetStreamTransparent(this, core::mem::transmute_copy(&bstreamtransparent)).into()
            }
        }
        unsafe extern "system" fn GetStreamTransparent<Identity: IMixerPinConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbstreamtransparent: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig_Impl::GetStreamTransparent(this, core::mem::transmute_copy(&pbstreamtransparent)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetRelativePosition: SetRelativePosition::<Identity, OFFSET>,
            GetRelativePosition: GetRelativePosition::<Identity, OFFSET>,
            SetZOrder: SetZOrder::<Identity, OFFSET>,
            GetZOrder: GetZOrder::<Identity, OFFSET>,
            SetColorKey: SetColorKey::<Identity, OFFSET>,
            GetColorKey: GetColorKey::<Identity, OFFSET>,
            SetBlendingParameter: SetBlendingParameter::<Identity, OFFSET>,
            GetBlendingParameter: GetBlendingParameter::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetStreamTransparent: SetStreamTransparent::<Identity, OFFSET>,
            GetStreamTransparent: GetStreamTransparent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMixerPinConfig as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMixerPinConfig {}
windows_core::imp::define_interface!(IMixerPinConfig2, IMixerPinConfig2_Vtbl, 0xebf47182_8764_11d1_9e69_00c04fd7c15b);
impl core::ops::Deref for IMixerPinConfig2 {
    type Target = IMixerPinConfig;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IMixerPinConfig2, windows_core::IUnknown, IMixerPinConfig);
impl IMixerPinConfig2 {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetOverlaySurfaceColorControls(&self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOverlaySurfaceColorControls)(windows_core::Interface::as_raw(self), pcolorcontrol as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetOverlaySurfaceColorControls(&self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetOverlaySurfaceColorControls)(windows_core::Interface::as_raw(self), pcolorcontrol as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMixerPinConfig2_Vtbl {
    pub base__: IMixerPinConfig_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetOverlaySurfaceColorControls: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetOverlaySurfaceColorControls: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetOverlaySurfaceColorControls: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetOverlaySurfaceColorControls: usize,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IMixerPinConfig2_Impl: IMixerPinConfig_Impl {
    fn SetOverlaySurfaceColorControls(&self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::Result<()>;
    fn GetOverlaySurfaceColorControls(&self, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IMixerPinConfig2_Vtbl {
    pub const fn new<Identity: IMixerPinConfig2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetOverlaySurfaceColorControls<Identity: IMixerPinConfig2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig2_Impl::SetOverlaySurfaceColorControls(this, core::mem::transmute_copy(&pcolorcontrol)).into()
            }
        }
        unsafe extern "system" fn GetOverlaySurfaceColorControls<Identity: IMixerPinConfig2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorcontrol: *mut super::super::Graphics::DirectDraw::DDCOLORCONTROL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMixerPinConfig2_Impl::GetOverlaySurfaceColorControls(this, core::mem::transmute_copy(&pcolorcontrol)).into()
            }
        }
        Self {
            base__: IMixerPinConfig_Vtbl::new::<Identity, OFFSET>(),
            SetOverlaySurfaceColorControls: SetOverlaySurfaceColorControls::<Identity, OFFSET>,
            GetOverlaySurfaceColorControls: GetOverlaySurfaceColorControls::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMixerPinConfig2 as windows_core::Interface>::IID || iid == &<IMixerPinConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IMixerPinConfig2 {}
windows_core::imp::define_interface!(IMpeg2Demultiplexer, IMpeg2Demultiplexer_Vtbl, 0x436eee9c_264f_4242_90e1_4e330c107512);
windows_core::imp::interface_hierarchy!(IMpeg2Demultiplexer, windows_core::IUnknown);
impl IMpeg2Demultiplexer {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn CreateOutputPin<P1>(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, pszpinname: P1) -> windows_core::Result<IPin>
    where
        P1: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).CreateOutputPin)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype), pszpinname.param().abi(), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetOutputPinMediaType<P0>(&self, pszpinname: P0, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetOutputPinMediaType)(windows_core::Interface::as_raw(self), pszpinname.param().abi(), core::mem::transmute(pmediatype)).ok() }
    }
    pub unsafe fn DeleteOutputPin<P0>(&self, pszpinname: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe { (windows_core::Interface::vtable(self).DeleteOutputPin)(windows_core::Interface::as_raw(self), pszpinname.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMpeg2Demultiplexer_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub CreateOutputPin: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE, windows_core::PCWSTR, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    CreateOutputPin: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetOutputPinMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetOutputPinMediaType: usize,
    pub DeleteOutputPin: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IMpeg2Demultiplexer_Impl: windows_core::IUnknownImpl {
    fn CreateOutputPin(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, pszpinname: &windows_core::PCWSTR) -> windows_core::Result<IPin>;
    fn SetOutputPinMediaType(&self, pszpinname: &windows_core::PCWSTR, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn DeleteOutputPin(&self, pszpinname: &windows_core::PCWSTR) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IMpeg2Demultiplexer_Vtbl {
    pub const fn new<Identity: IMpeg2Demultiplexer_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateOutputPin<Identity: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE, pszpinname: windows_core::PCWSTR, ppipin: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpeg2Demultiplexer_Impl::CreateOutputPin(this, core::mem::transmute_copy(&pmediatype), core::mem::transmute(&pszpinname)) {
                    Ok(ok__) => {
                        ppipin.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputPinMediaType<Identity: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszpinname: windows_core::PCWSTR, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpeg2Demultiplexer_Impl::SetOutputPinMediaType(this, core::mem::transmute(&pszpinname), core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn DeleteOutputPin<Identity: IMpeg2Demultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszpinname: windows_core::PCWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpeg2Demultiplexer_Impl::DeleteOutputPin(this, core::mem::transmute(&pszpinname)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateOutputPin: CreateOutputPin::<Identity, OFFSET>,
            SetOutputPinMediaType: SetOutputPinMediaType::<Identity, OFFSET>,
            DeleteOutputPin: DeleteOutputPin::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMpeg2Demultiplexer as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IMpeg2Demultiplexer {}
windows_core::imp::define_interface!(IMpegAudioDecoder, IMpegAudioDecoder_Vtbl, 0xb45dd570_3c77_11d1_abe1_00a0c905f375);
windows_core::imp::interface_hierarchy!(IMpegAudioDecoder, windows_core::IUnknown);
impl IMpegAudioDecoder {
    pub unsafe fn FrequencyDivider(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FrequencyDivider)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetFrequencyDivider(&self, divider: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFrequencyDivider)(windows_core::Interface::as_raw(self), divider).ok() }
    }
    pub unsafe fn DecoderAccuracy(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DecoderAccuracy)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDecoderAccuracy(&self, accuracy: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDecoderAccuracy)(windows_core::Interface::as_raw(self), accuracy).ok() }
    }
    pub unsafe fn Stereo(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Stereo)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetStereo(&self, stereo: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStereo)(windows_core::Interface::as_raw(self), stereo).ok() }
    }
    pub unsafe fn DecoderWordSize(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DecoderWordSize)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDecoderWordSize(&self, wordsize: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDecoderWordSize)(windows_core::Interface::as_raw(self), wordsize).ok() }
    }
    pub unsafe fn IntegerDecode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IntegerDecode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetIntegerDecode(&self, intdecode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetIntegerDecode)(windows_core::Interface::as_raw(self), intdecode).ok() }
    }
    pub unsafe fn DualMode(&self, pintdecode: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DualMode)(windows_core::Interface::as_raw(self), pintdecode as _).ok() }
    }
    pub unsafe fn SetDualMode(&self, intdecode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDualMode)(windows_core::Interface::as_raw(self), intdecode).ok() }
    }
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn AudioFormat(&self, lpfmt: *mut MPEG1WAVEFORMAT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AudioFormat)(windows_core::Interface::as_raw(self), lpfmt as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMpegAudioDecoder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub FrequencyDivider: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetFrequencyDivider: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub DecoderAccuracy: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDecoderAccuracy: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Stereo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetStereo: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub DecoderWordSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDecoderWordSize: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub IntegerDecode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetIntegerDecode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub DualMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDualMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_Audio")]
    pub AudioFormat: unsafe extern "system" fn(*mut core::ffi::c_void, *mut MPEG1WAVEFORMAT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    AudioFormat: usize,
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IMpegAudioDecoder_Impl: windows_core::IUnknownImpl {
    fn FrequencyDivider(&self) -> windows_core::Result<u32>;
    fn SetFrequencyDivider(&self, divider: u32) -> windows_core::Result<()>;
    fn DecoderAccuracy(&self) -> windows_core::Result<u32>;
    fn SetDecoderAccuracy(&self, accuracy: u32) -> windows_core::Result<()>;
    fn Stereo(&self) -> windows_core::Result<u32>;
    fn SetStereo(&self, stereo: u32) -> windows_core::Result<()>;
    fn DecoderWordSize(&self) -> windows_core::Result<u32>;
    fn SetDecoderWordSize(&self, wordsize: u32) -> windows_core::Result<()>;
    fn IntegerDecode(&self) -> windows_core::Result<u32>;
    fn SetIntegerDecode(&self, intdecode: u32) -> windows_core::Result<()>;
    fn DualMode(&self, pintdecode: *mut u32) -> windows_core::Result<()>;
    fn SetDualMode(&self, intdecode: u32) -> windows_core::Result<()>;
    fn AudioFormat(&self, lpfmt: *mut MPEG1WAVEFORMAT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IMpegAudioDecoder_Vtbl {
    pub const fn new<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FrequencyDivider<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdivider: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpegAudioDecoder_Impl::FrequencyDivider(this) {
                    Ok(ok__) => {
                        pdivider.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFrequencyDivider<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, divider: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetFrequencyDivider(this, core::mem::transmute_copy(&divider)).into()
            }
        }
        unsafe extern "system" fn DecoderAccuracy<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, paccuracy: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpegAudioDecoder_Impl::DecoderAccuracy(this) {
                    Ok(ok__) => {
                        paccuracy.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDecoderAccuracy<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, accuracy: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetDecoderAccuracy(this, core::mem::transmute_copy(&accuracy)).into()
            }
        }
        unsafe extern "system" fn Stereo<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstereo: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpegAudioDecoder_Impl::Stereo(this) {
                    Ok(ok__) => {
                        pstereo.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStereo<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, stereo: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetStereo(this, core::mem::transmute_copy(&stereo)).into()
            }
        }
        unsafe extern "system" fn DecoderWordSize<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwordsize: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpegAudioDecoder_Impl::DecoderWordSize(this) {
                    Ok(ok__) => {
                        pwordsize.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDecoderWordSize<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wordsize: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetDecoderWordSize(this, core::mem::transmute_copy(&wordsize)).into()
            }
        }
        unsafe extern "system" fn IntegerDecode<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pintdecode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMpegAudioDecoder_Impl::IntegerDecode(this) {
                    Ok(ok__) => {
                        pintdecode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIntegerDecode<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, intdecode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetIntegerDecode(this, core::mem::transmute_copy(&intdecode)).into()
            }
        }
        unsafe extern "system" fn DualMode<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pintdecode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::DualMode(this, core::mem::transmute_copy(&pintdecode)).into()
            }
        }
        unsafe extern "system" fn SetDualMode<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, intdecode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::SetDualMode(this, core::mem::transmute_copy(&intdecode)).into()
            }
        }
        unsafe extern "system" fn AudioFormat<Identity: IMpegAudioDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpfmt: *mut MPEG1WAVEFORMAT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMpegAudioDecoder_Impl::AudioFormat(this, core::mem::transmute_copy(&lpfmt)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            FrequencyDivider: FrequencyDivider::<Identity, OFFSET>,
            SetFrequencyDivider: SetFrequencyDivider::<Identity, OFFSET>,
            DecoderAccuracy: DecoderAccuracy::<Identity, OFFSET>,
            SetDecoderAccuracy: SetDecoderAccuracy::<Identity, OFFSET>,
            Stereo: Stereo::<Identity, OFFSET>,
            SetStereo: SetStereo::<Identity, OFFSET>,
            DecoderWordSize: DecoderWordSize::<Identity, OFFSET>,
            SetDecoderWordSize: SetDecoderWordSize::<Identity, OFFSET>,
            IntegerDecode: IntegerDecode::<Identity, OFFSET>,
            SetIntegerDecode: SetIntegerDecode::<Identity, OFFSET>,
            DualMode: DualMode::<Identity, OFFSET>,
            SetDualMode: SetDualMode::<Identity, OFFSET>,
            AudioFormat: AudioFormat::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMpegAudioDecoder as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl windows_core::RuntimeName for IMpegAudioDecoder {}
windows_core::imp::define_interface!(IMultiMediaStream, IMultiMediaStream_Vtbl, 0xb502d1bc_9a57_11d0_8fde_00c04fd9189d);
windows_core::imp::interface_hierarchy!(IMultiMediaStream, windows_core::IUnknown);
impl IMultiMediaStream {
    pub unsafe fn GetInformation(&self, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetInformation)(windows_core::Interface::as_raw(self), pdwflags as _, pstreamtype as _).ok() }
    }
    pub unsafe fn GetMediaStream(&self, idpurpose: *const windows_core::GUID) -> windows_core::Result<IMediaStream> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMediaStream)(windows_core::Interface::as_raw(self), idpurpose, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn EnumMediaStreams(&self, index: i32) -> windows_core::Result<IMediaStream> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumMediaStreams)(windows_core::Interface::as_raw(self), index, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn GetState(&self) -> windows_core::Result<STREAM_STATE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetState)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetState(&self, newstate: STREAM_STATE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetState)(windows_core::Interface::as_raw(self), newstate).ok() }
    }
    pub unsafe fn GetTime(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetTime)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetDuration(&self) -> windows_core::Result<i64> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDuration)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Seek(&self, seektime: i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Seek)(windows_core::Interface::as_raw(self), seektime).ok() }
    }
    pub unsafe fn GetEndOfStreamEventHandle(&self) -> windows_core::Result<super::super::Foundation::HANDLE> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetEndOfStreamEventHandle)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMultiMediaStream_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetInformation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut MMSSF_GET_INFORMATION_FLAGS, *mut STREAM_TYPE) -> windows_core::HRESULT,
    pub GetMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub EnumMediaStreams: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut STREAM_STATE) -> windows_core::HRESULT,
    pub SetState: unsafe extern "system" fn(*mut core::ffi::c_void, STREAM_STATE) -> windows_core::HRESULT,
    pub GetTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub GetDuration: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64) -> windows_core::HRESULT,
    pub Seek: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub GetEndOfStreamEventHandle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT,
}
pub trait IMultiMediaStream_Impl: windows_core::IUnknownImpl {
    fn GetInformation(&self, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> windows_core::Result<()>;
    fn GetMediaStream(&self, idpurpose: *const windows_core::GUID) -> windows_core::Result<IMediaStream>;
    fn EnumMediaStreams(&self, index: i32) -> windows_core::Result<IMediaStream>;
    fn GetState(&self) -> windows_core::Result<STREAM_STATE>;
    fn SetState(&self, newstate: STREAM_STATE) -> windows_core::Result<()>;
    fn GetTime(&self) -> windows_core::Result<i64>;
    fn GetDuration(&self) -> windows_core::Result<i64>;
    fn Seek(&self, seektime: i64) -> windows_core::Result<()>;
    fn GetEndOfStreamEventHandle(&self) -> windows_core::Result<super::super::Foundation::HANDLE>;
}
impl IMultiMediaStream_Vtbl {
    pub const fn new<Identity: IMultiMediaStream_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetInformation<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMultiMediaStream_Impl::GetInformation(this, core::mem::transmute_copy(&pdwflags), core::mem::transmute_copy(&pstreamtype)).into()
            }
        }
        unsafe extern "system" fn GetMediaStream<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idpurpose: *const windows_core::GUID, ppmediastream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::GetMediaStream(this, core::mem::transmute_copy(&idpurpose)) {
                    Ok(ok__) => {
                        ppmediastream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn EnumMediaStreams<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: i32, ppmediastream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::EnumMediaStreams(this, core::mem::transmute_copy(&index)) {
                    Ok(ok__) => {
                        ppmediastream.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetState<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrentstate: *mut STREAM_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::GetState(this) {
                    Ok(ok__) => {
                        pcurrentstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetState<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, newstate: STREAM_STATE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMultiMediaStream_Impl::SetState(this, core::mem::transmute_copy(&newstate)).into()
            }
        }
        unsafe extern "system" fn GetTime<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcurrenttime: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::GetTime(this) {
                    Ok(ok__) => {
                        pcurrenttime.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetDuration<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pduration: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::GetDuration(this) {
                    Ok(ok__) => {
                        pduration.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Seek<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, seektime: i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMultiMediaStream_Impl::Seek(this, core::mem::transmute_copy(&seektime)).into()
            }
        }
        unsafe extern "system" fn GetEndOfStreamEventHandle<Identity: IMultiMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pheos: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMultiMediaStream_Impl::GetEndOfStreamEventHandle(this) {
                    Ok(ok__) => {
                        pheos.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetInformation: GetInformation::<Identity, OFFSET>,
            GetMediaStream: GetMediaStream::<Identity, OFFSET>,
            EnumMediaStreams: EnumMediaStreams::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            SetState: SetState::<Identity, OFFSET>,
            GetTime: GetTime::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            Seek: Seek::<Identity, OFFSET>,
            GetEndOfStreamEventHandle: GetEndOfStreamEventHandle::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMultiMediaStream as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IMultiMediaStream {}
pub const INTERLEAVE_CAPTURE: InterleavingMode = InterleavingMode(1i32);
pub const INTERLEAVE_FULL: InterleavingMode = InterleavingMode(2i32);
pub const INTERLEAVE_NONE: InterleavingMode = InterleavingMode(0i32);
pub const INTERLEAVE_NONE_BUFFERED: InterleavingMode = InterleavingMode(3i32);
windows_core::imp::define_interface!(IOverlay, IOverlay_Vtbl, 0x56a868a1_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IOverlay, windows_core::IUnknown);
impl IOverlay {
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetPalette(&self, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetPalette)(windows_core::Interface::as_raw(self), pdwcolors as _, pppalette as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn SetPalette(&self, ppalette: &[super::super::Graphics::Gdi::PALETTEENTRY]) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetPalette)(windows_core::Interface::as_raw(self), ppalette.len().try_into().unwrap(), core::mem::transmute(ppalette.as_ptr())).ok() }
    }
    pub unsafe fn GetDefaultColorKey(&self) -> windows_core::Result<COLORKEY> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDefaultColorKey)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn GetColorKey(&self) -> windows_core::Result<COLORKEY> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetColorKey)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetColorKey(&self, pcolorkey: *mut COLORKEY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetColorKey)(windows_core::Interface::as_raw(self), pcolorkey as _).ok() }
    }
    pub unsafe fn GetWindowHandle(&self) -> windows_core::Result<super::super::Foundation::HWND> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetWindowHandle)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetClipList(&self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetClipList)(windows_core::Interface::as_raw(self), psourcerect as _, pdestinationrect as _, pprgndata as _).ok() }
    }
    pub unsafe fn GetVideoPosition(&self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoPosition)(windows_core::Interface::as_raw(self), psourcerect as _, pdestinationrect as _).ok() }
    }
    pub unsafe fn Advise<P0>(&self, poverlaynotify: P0, dwinterests: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IOverlayNotify>,
    {
        unsafe { (windows_core::Interface::vtable(self).Advise)(windows_core::Interface::as_raw(self), poverlaynotify.param().abi(), dwinterests).ok() }
    }
    pub unsafe fn Unadvise(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Unadvise)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IOverlay_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetPalette: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetPalette: usize,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub SetPalette: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    SetPalette: usize,
    pub GetDefaultColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut COLORKEY) -> windows_core::HRESULT,
    pub GetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut COLORKEY) -> windows_core::HRESULT,
    pub SetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut COLORKEY) -> windows_core::HRESULT,
    pub GetWindowHandle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::HWND) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetClipList: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::RECT, *mut super::super::Foundation::RECT, *mut *mut super::super::Graphics::Gdi::RGNDATA) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetClipList: usize,
    pub GetVideoPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::RECT, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub Advise: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub Unadvise: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IOverlay_Impl: windows_core::IUnknownImpl {
    fn GetPalette(&self, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::Result<()>;
    fn SetPalette(&self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::Result<()>;
    fn GetDefaultColorKey(&self) -> windows_core::Result<COLORKEY>;
    fn GetColorKey(&self) -> windows_core::Result<COLORKEY>;
    fn SetColorKey(&self, pcolorkey: *mut COLORKEY) -> windows_core::Result<()>;
    fn GetWindowHandle(&self) -> windows_core::Result<super::super::Foundation::HWND>;
    fn GetClipList(&self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> windows_core::Result<()>;
    fn GetVideoPosition(&self, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn Advise(&self, poverlaynotify: windows_core::Ref<IOverlayNotify>, dwinterests: u32) -> windows_core::Result<()>;
    fn Unadvise(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IOverlay_Vtbl {
    pub const fn new<Identity: IOverlay_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPalette<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcolors: *mut u32, pppalette: *mut *mut super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::GetPalette(this, core::mem::transmute_copy(&pdwcolors), core::mem::transmute_copy(&pppalette)).into()
            }
        }
        unsafe extern "system" fn SetPalette<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::SetPalette(this, core::mem::transmute_copy(&dwcolors), core::mem::transmute_copy(&ppalette)).into()
            }
        }
        unsafe extern "system" fn GetDefaultColorKey<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *mut COLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IOverlay_Impl::GetDefaultColorKey(this) {
                    Ok(ok__) => {
                        pcolorkey.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetColorKey<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *mut COLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IOverlay_Impl::GetColorKey(this) {
                    Ok(ok__) => {
                        pcolorkey.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetColorKey<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *mut COLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::SetColorKey(this, core::mem::transmute_copy(&pcolorkey)).into()
            }
        }
        unsafe extern "system" fn GetWindowHandle<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phwnd: *mut super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IOverlay_Impl::GetWindowHandle(this) {
                    Ok(ok__) => {
                        phwnd.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetClipList<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT, pprgndata: *mut *mut super::super::Graphics::Gdi::RGNDATA) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::GetClipList(this, core::mem::transmute_copy(&psourcerect), core::mem::transmute_copy(&pdestinationrect), core::mem::transmute_copy(&pprgndata)).into()
            }
        }
        unsafe extern "system" fn GetVideoPosition<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcerect: *mut super::super::Foundation::RECT, pdestinationrect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::GetVideoPosition(this, core::mem::transmute_copy(&psourcerect), core::mem::transmute_copy(&pdestinationrect)).into()
            }
        }
        unsafe extern "system" fn Advise<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poverlaynotify: *mut core::ffi::c_void, dwinterests: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::Advise(this, core::mem::transmute_copy(&poverlaynotify), core::mem::transmute_copy(&dwinterests)).into()
            }
        }
        unsafe extern "system" fn Unadvise<Identity: IOverlay_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlay_Impl::Unadvise(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPalette: GetPalette::<Identity, OFFSET>,
            SetPalette: SetPalette::<Identity, OFFSET>,
            GetDefaultColorKey: GetDefaultColorKey::<Identity, OFFSET>,
            GetColorKey: GetColorKey::<Identity, OFFSET>,
            SetColorKey: SetColorKey::<Identity, OFFSET>,
            GetWindowHandle: GetWindowHandle::<Identity, OFFSET>,
            GetClipList: GetClipList::<Identity, OFFSET>,
            GetVideoPosition: GetVideoPosition::<Identity, OFFSET>,
            Advise: Advise::<Identity, OFFSET>,
            Unadvise: Unadvise::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IOverlay as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IOverlay {}
windows_core::imp::define_interface!(IOverlayNotify, IOverlayNotify_Vtbl, 0x56a868a0_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IOverlayNotify, windows_core::IUnknown);
impl IOverlayNotify {
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn OnPaletteChange(&self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnPaletteChange)(windows_core::Interface::as_raw(self), dwcolors, ppalette).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn OnClipChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnClipChange)(windows_core::Interface::as_raw(self), psourcerect, pdestinationrect, prgndata).ok() }
    }
    pub unsafe fn OnColorKeyChange(&self, pcolorkey: *const COLORKEY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnColorKeyChange)(windows_core::Interface::as_raw(self), pcolorkey).ok() }
    }
    pub unsafe fn OnPositionChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnPositionChange)(windows_core::Interface::as_raw(self), psourcerect, pdestinationrect).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IOverlayNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub OnPaletteChange: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    OnPaletteChange: usize,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub OnClipChange: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT, *const super::super::Graphics::Gdi::RGNDATA) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    OnClipChange: usize,
    pub OnColorKeyChange: unsafe extern "system" fn(*mut core::ffi::c_void, *const COLORKEY) -> windows_core::HRESULT,
    pub OnPositionChange: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IOverlayNotify_Impl: windows_core::IUnknownImpl {
    fn OnPaletteChange(&self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::Result<()>;
    fn OnClipChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> windows_core::Result<()>;
    fn OnColorKeyChange(&self, pcolorkey: *const COLORKEY) -> windows_core::Result<()>;
    fn OnPositionChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IOverlayNotify_Vtbl {
    pub const fn new<Identity: IOverlayNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnPaletteChange<Identity: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlayNotify_Impl::OnPaletteChange(this, core::mem::transmute_copy(&dwcolors), core::mem::transmute_copy(&ppalette)).into()
            }
        }
        unsafe extern "system" fn OnClipChange<Identity: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlayNotify_Impl::OnClipChange(this, core::mem::transmute_copy(&psourcerect), core::mem::transmute_copy(&pdestinationrect), core::mem::transmute_copy(&prgndata)).into()
            }
        }
        unsafe extern "system" fn OnColorKeyChange<Identity: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcolorkey: *const COLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlayNotify_Impl::OnColorKeyChange(this, core::mem::transmute_copy(&pcolorkey)).into()
            }
        }
        unsafe extern "system" fn OnPositionChange<Identity: IOverlayNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlayNotify_Impl::OnPositionChange(this, core::mem::transmute_copy(&psourcerect), core::mem::transmute_copy(&pdestinationrect)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnPaletteChange: OnPaletteChange::<Identity, OFFSET>,
            OnClipChange: OnClipChange::<Identity, OFFSET>,
            OnColorKeyChange: OnColorKeyChange::<Identity, OFFSET>,
            OnPositionChange: OnPositionChange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IOverlayNotify as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IOverlayNotify {}
windows_core::imp::define_interface!(IOverlayNotify2, IOverlayNotify2_Vtbl, 0x680efa10_d535_11d1_87c8_00a0c9223196);
impl core::ops::Deref for IOverlayNotify2 {
    type Target = IOverlayNotify;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IOverlayNotify2, windows_core::IUnknown, IOverlayNotify);
impl IOverlayNotify2 {
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn OnDisplayChange(&self, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).OnDisplayChange)(windows_core::Interface::as_raw(self), hmonitor).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IOverlayNotify2_Vtbl {
    pub base__: IOverlayNotify_Vtbl,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub OnDisplayChange: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    OnDisplayChange: usize,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IOverlayNotify2_Impl: IOverlayNotify_Impl {
    fn OnDisplayChange(&self, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IOverlayNotify2_Vtbl {
    pub const fn new<Identity: IOverlayNotify2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnDisplayChange<Identity: IOverlayNotify2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IOverlayNotify2_Impl::OnDisplayChange(this, core::mem::transmute_copy(&hmonitor)).into()
            }
        }
        Self { base__: IOverlayNotify_Vtbl::new::<Identity, OFFSET>(), OnDisplayChange: OnDisplayChange::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IOverlayNotify2 as windows_core::Interface>::IID || iid == &<IOverlayNotify as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IOverlayNotify2 {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IPersistMediaPropertyBag, IPersistMediaPropertyBag_Vtbl, 0x5738e040_b67f_11d0_bd4d_00a0c911ce86);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IPersistMediaPropertyBag {
    type Target = super::super::System::Com::IPersist;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IPersistMediaPropertyBag, windows_core::IUnknown, super::super::System::Com::IPersist);
#[cfg(feature = "Win32_System_Com")]
impl IPersistMediaPropertyBag {
    pub unsafe fn InitNew(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InitNew)(windows_core::Interface::as_raw(self)).ok() }
    }
    #[cfg(feature = "Win32_System_Com_StructuredStorage")]
    pub unsafe fn Load<P0, P1>(&self, ppropbag: P0, perrorlog: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaPropertyBag>,
        P1: windows_core::Param<super::super::System::Com::IErrorLog>,
    {
        unsafe { (windows_core::Interface::vtable(self).Load)(windows_core::Interface::as_raw(self), ppropbag.param().abi(), perrorlog.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_System_Com_StructuredStorage")]
    pub unsafe fn Save<P0>(&self, ppropbag: P0, fcleardirty: bool, fsaveallproperties: bool) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IMediaPropertyBag>,
    {
        unsafe { (windows_core::Interface::vtable(self).Save)(windows_core::Interface::as_raw(self), ppropbag.param().abi(), fcleardirty.into(), fsaveallproperties.into()).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IPersistMediaPropertyBag_Vtbl {
    pub base__: super::super::System::Com::IPersist_Vtbl,
    pub InitNew: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_System_Com_StructuredStorage")]
    pub Load: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com_StructuredStorage"))]
    Load: usize,
    #[cfg(feature = "Win32_System_Com_StructuredStorage")]
    pub Save: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, windows_core::BOOL, windows_core::BOOL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com_StructuredStorage"))]
    Save: usize,
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
pub trait IPersistMediaPropertyBag_Impl: super::super::System::Com::IPersist_Impl {
    fn InitNew(&self) -> windows_core::Result<()>;
    fn Load(&self, ppropbag: windows_core::Ref<IMediaPropertyBag>, perrorlog: windows_core::Ref<super::super::System::Com::IErrorLog>) -> windows_core::Result<()>;
    fn Save(&self, ppropbag: windows_core::Ref<IMediaPropertyBag>, fcleardirty: windows_core::BOOL, fsaveallproperties: windows_core::BOOL) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IPersistMediaPropertyBag_Vtbl {
    pub const fn new<Identity: IPersistMediaPropertyBag_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InitNew<Identity: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPersistMediaPropertyBag_Impl::InitNew(this).into()
            }
        }
        unsafe extern "system" fn Load<Identity: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppropbag: *mut core::ffi::c_void, perrorlog: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPersistMediaPropertyBag_Impl::Load(this, core::mem::transmute_copy(&ppropbag), core::mem::transmute_copy(&perrorlog)).into()
            }
        }
        unsafe extern "system" fn Save<Identity: IPersistMediaPropertyBag_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppropbag: *mut core::ffi::c_void, fcleardirty: windows_core::BOOL, fsaveallproperties: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPersistMediaPropertyBag_Impl::Save(this, core::mem::transmute_copy(&ppropbag), core::mem::transmute_copy(&fcleardirty), core::mem::transmute_copy(&fsaveallproperties)).into()
            }
        }
        Self {
            base__: super::super::System::Com::IPersist_Vtbl::new::<Identity, OFFSET>(),
            InitNew: InitNew::<Identity, OFFSET>,
            Load: Load::<Identity, OFFSET>,
            Save: Save::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPersistMediaPropertyBag as windows_core::Interface>::IID || iid == &<super::super::System::Com::IPersist as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl windows_core::RuntimeName for IPersistMediaPropertyBag {}
windows_core::imp::define_interface!(IPin, IPin_Vtbl, 0x56a86891_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IPin, windows_core::IUnknown);
impl IPin {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn Connect<P0>(&self, preceivepin: P0, pmt: Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Connect)(windows_core::Interface::as_raw(self), preceivepin.param().abi(), pmt.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn ReceiveConnection<P0>(&self, pconnector: P0, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReceiveConnection)(windows_core::Interface::as_raw(self), pconnector.param().abi(), core::mem::transmute(pmt)).ok() }
    }
    pub unsafe fn Disconnect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Disconnect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn ConnectedTo(&self) -> windows_core::Result<IPin> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ConnectedTo)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn ConnectionMediaType(&self, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ConnectionMediaType)(windows_core::Interface::as_raw(self), core::mem::transmute(pmt)).ok() }
    }
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn QueryPinInfo(&self, pinfo: *mut PIN_INFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryPinInfo)(windows_core::Interface::as_raw(self), core::mem::transmute(pinfo)).ok() }
    }
    pub unsafe fn QueryDirection(&self) -> windows_core::Result<PIN_DIRECTION> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryDirection)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn QueryId(&self) -> windows_core::Result<windows_core::PWSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).QueryId)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn QueryAccept(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).QueryAccept)(windows_core::Interface::as_raw(self), core::mem::transmute(pmt)) }
    }
    pub unsafe fn EnumMediaTypes(&self) -> windows_core::Result<IEnumMediaTypes> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).EnumMediaTypes)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn QueryInternalConnections(&self, appin: Option<*mut Option<IPin>>, npin: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).QueryInternalConnections)(windows_core::Interface::as_raw(self), appin.unwrap_or(core::mem::zeroed()) as _, npin as _).ok() }
    }
    pub unsafe fn EndOfStream(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EndOfStream)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn BeginFlush(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).BeginFlush)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn EndFlush(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).EndFlush)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn NewSegment(&self, tstart: i64, tstop: i64, drate: f64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NewSegment)(windows_core::Interface::as_raw(self), tstart, tstop, drate).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPin_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub Connect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    Connect: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub ReceiveConnection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    ReceiveConnection: usize,
    pub Disconnect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ConnectedTo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub ConnectionMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    ConnectionMediaType: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub QueryPinInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut PIN_INFO) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    QueryPinInfo: usize,
    pub QueryDirection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut PIN_DIRECTION) -> windows_core::HRESULT,
    pub QueryId: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::PWSTR) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub QueryAccept: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    QueryAccept: usize,
    pub EnumMediaTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub QueryInternalConnections: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub EndOfStream: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub BeginFlush: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub EndFlush: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NewSegment: unsafe extern "system" fn(*mut core::ffi::c_void, i64, i64, f64) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
pub trait IPin_Impl: windows_core::IUnknownImpl {
    fn Connect(&self, preceivepin: windows_core::Ref<IPin>, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn ReceiveConnection(&self, pconnector: windows_core::Ref<IPin>, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn Disconnect(&self) -> windows_core::Result<()>;
    fn ConnectedTo(&self) -> windows_core::Result<IPin>;
    fn ConnectionMediaType(&self, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn QueryPinInfo(&self, pinfo: *mut PIN_INFO) -> windows_core::Result<()>;
    fn QueryDirection(&self) -> windows_core::Result<PIN_DIRECTION>;
    fn QueryId(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn QueryAccept(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT;
    fn EnumMediaTypes(&self) -> windows_core::Result<IEnumMediaTypes>;
    fn QueryInternalConnections(&self, appin: windows_core::OutRef<IPin>, npin: *mut u32) -> windows_core::Result<()>;
    fn EndOfStream(&self) -> windows_core::Result<()>;
    fn BeginFlush(&self) -> windows_core::Result<()>;
    fn EndFlush(&self) -> windows_core::Result<()>;
    fn NewSegment(&self, tstart: i64, tstop: i64, drate: f64) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl IPin_Vtbl {
    pub const fn new<Identity: IPin_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Connect<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, preceivepin: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::Connect(this, core::mem::transmute_copy(&preceivepin), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn ReceiveConnection<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pconnector: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::ReceiveConnection(this, core::mem::transmute_copy(&pconnector), core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn Disconnect<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::Disconnect(this).into()
            }
        }
        unsafe extern "system" fn ConnectedTo<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPin_Impl::ConnectedTo(this) {
                    Ok(ok__) => {
                        ppin.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::ConnectionMediaType(this, core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn QueryPinInfo<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinfo: *mut PIN_INFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::QueryPinInfo(this, core::mem::transmute_copy(&pinfo)).into()
            }
        }
        unsafe extern "system" fn QueryDirection<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppindir: *mut PIN_DIRECTION) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPin_Impl::QueryDirection(this) {
                    Ok(ok__) => {
                        ppindir.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn QueryId<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, id: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPin_Impl::QueryId(this) {
                    Ok(ok__) => {
                        id.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn QueryAccept<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::QueryAccept(this, core::mem::transmute_copy(&pmt))
            }
        }
        unsafe extern "system" fn EnumMediaTypes<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppenum: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPin_Impl::EnumMediaTypes(this) {
                    Ok(ok__) => {
                        ppenum.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn QueryInternalConnections<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, appin: *mut *mut core::ffi::c_void, npin: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::QueryInternalConnections(this, core::mem::transmute_copy(&appin), core::mem::transmute_copy(&npin)).into()
            }
        }
        unsafe extern "system" fn EndOfStream<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::EndOfStream(this).into()
            }
        }
        unsafe extern "system" fn BeginFlush<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::BeginFlush(this).into()
            }
        }
        unsafe extern "system" fn EndFlush<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::EndFlush(this).into()
            }
        }
        unsafe extern "system" fn NewSegment<Identity: IPin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tstart: i64, tstop: i64, drate: f64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPin_Impl::NewSegment(this, core::mem::transmute_copy(&tstart), core::mem::transmute_copy(&tstop), core::mem::transmute_copy(&drate)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Connect: Connect::<Identity, OFFSET>,
            ReceiveConnection: ReceiveConnection::<Identity, OFFSET>,
            Disconnect: Disconnect::<Identity, OFFSET>,
            ConnectedTo: ConnectedTo::<Identity, OFFSET>,
            ConnectionMediaType: ConnectionMediaType::<Identity, OFFSET>,
            QueryPinInfo: QueryPinInfo::<Identity, OFFSET>,
            QueryDirection: QueryDirection::<Identity, OFFSET>,
            QueryId: QueryId::<Identity, OFFSET>,
            QueryAccept: QueryAccept::<Identity, OFFSET>,
            EnumMediaTypes: EnumMediaTypes::<Identity, OFFSET>,
            QueryInternalConnections: QueryInternalConnections::<Identity, OFFSET>,
            EndOfStream: EndOfStream::<Identity, OFFSET>,
            BeginFlush: BeginFlush::<Identity, OFFSET>,
            EndFlush: EndFlush::<Identity, OFFSET>,
            NewSegment: NewSegment::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPin as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_System_Com"))]
impl windows_core::RuntimeName for IPin {}
windows_core::imp::define_interface!(IPinConnection, IPinConnection_Vtbl, 0x4a9a62d3_27d4_403d_91e9_89f540e55534);
windows_core::imp::interface_hierarchy!(IPinConnection, windows_core::IUnknown);
impl IPinConnection {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn DynamicQueryAccept(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DynamicQueryAccept)(windows_core::Interface::as_raw(self), core::mem::transmute(pmt)).ok() }
    }
    pub unsafe fn NotifyEndOfStream(&self, hnotifyevent: super::super::Foundation::HANDLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyEndOfStream)(windows_core::Interface::as_raw(self), hnotifyevent).ok() }
    }
    pub unsafe fn IsEndPin(&self) -> windows_core::HRESULT {
        unsafe { (windows_core::Interface::vtable(self).IsEndPin)(windows_core::Interface::as_raw(self)) }
    }
    pub unsafe fn DynamicDisconnect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DynamicDisconnect)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPinConnection_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub DynamicQueryAccept: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    DynamicQueryAccept: usize,
    pub NotifyEndOfStream: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HANDLE) -> windows_core::HRESULT,
    pub IsEndPin: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub DynamicDisconnect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub trait IPinConnection_Impl: windows_core::IUnknownImpl {
    fn DynamicQueryAccept(&self, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn NotifyEndOfStream(&self, hnotifyevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn IsEndPin(&self) -> windows_core::HRESULT;
    fn DynamicDisconnect(&self) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl IPinConnection_Vtbl {
    pub const fn new<Identity: IPinConnection_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DynamicQueryAccept<Identity: IPinConnection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinConnection_Impl::DynamicQueryAccept(this, core::mem::transmute_copy(&pmt)).into()
            }
        }
        unsafe extern "system" fn NotifyEndOfStream<Identity: IPinConnection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnotifyevent: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinConnection_Impl::NotifyEndOfStream(this, core::mem::transmute_copy(&hnotifyevent)).into()
            }
        }
        unsafe extern "system" fn IsEndPin<Identity: IPinConnection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinConnection_Impl::IsEndPin(this)
            }
        }
        unsafe extern "system" fn DynamicDisconnect<Identity: IPinConnection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinConnection_Impl::DynamicDisconnect(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            DynamicQueryAccept: DynamicQueryAccept::<Identity, OFFSET>,
            NotifyEndOfStream: NotifyEndOfStream::<Identity, OFFSET>,
            IsEndPin: IsEndPin::<Identity, OFFSET>,
            DynamicDisconnect: DynamicDisconnect::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPinConnection as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_MediaFoundation")]
impl windows_core::RuntimeName for IPinConnection {}
windows_core::imp::define_interface!(IPinFlowControl, IPinFlowControl_Vtbl, 0xc56e9858_dbf3_4f6b_8119_384af2060deb);
windows_core::imp::interface_hierarchy!(IPinFlowControl, windows_core::IUnknown);
impl IPinFlowControl {
    pub unsafe fn Block(&self, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Block)(windows_core::Interface::as_raw(self), dwblockflags, hevent).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPinFlowControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Block: unsafe extern "system" fn(*mut core::ffi::c_void, u32, super::super::Foundation::HANDLE) -> windows_core::HRESULT,
}
pub trait IPinFlowControl_Impl: windows_core::IUnknownImpl {
    fn Block(&self, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
}
impl IPinFlowControl_Vtbl {
    pub const fn new<Identity: IPinFlowControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Block<Identity: IPinFlowControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwblockflags: u32, hevent: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinFlowControl_Impl::Block(this, core::mem::transmute_copy(&dwblockflags), core::mem::transmute_copy(&hevent)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Block: Block::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPinFlowControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IPinFlowControl {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IPinInfo, IPinInfo_Vtbl, 0x56a868bd_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IPinInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IPinInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IPinInfo {
    pub unsafe fn Pin(&self) -> windows_core::Result<windows_core::IUnknown> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Pin)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn ConnectedTo(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ConnectedTo)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn ConnectionMediaType(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).ConnectionMediaType)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn FilterInfo(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FilterInfo)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Name(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Name)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn Direction(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Direction)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn PinID(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).PinID)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn MediaTypes(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).MediaTypes)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn Connect<P0>(&self, ppin: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).Connect)(windows_core::Interface::as_raw(self), ppin.param().abi()).ok() }
    }
    pub unsafe fn ConnectDirect<P0>(&self, ppin: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).ConnectDirect)(windows_core::Interface::as_raw(self), ppin.param().abi()).ok() }
    }
    pub unsafe fn ConnectWithType<P0, P1>(&self, ppin: P0, pmediatype: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
        P1: windows_core::Param<super::super::System::Com::IDispatch>,
    {
        unsafe { (windows_core::Interface::vtable(self).ConnectWithType)(windows_core::Interface::as_raw(self), ppin.param().abi(), pmediatype.param().abi()).ok() }
    }
    pub unsafe fn Disconnect(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Disconnect)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn Render(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Render)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IPinInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Pin: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ConnectedTo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ConnectionMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub FilterInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Name: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Direction: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub PinID: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub MediaTypes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Connect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ConnectDirect: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ConnectWithType: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Disconnect: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Render: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IPinInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn Pin(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn ConnectedTo(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn ConnectionMediaType(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn FilterInfo(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn Name(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Direction(&self) -> windows_core::Result<i32>;
    fn PinID(&self) -> windows_core::Result<windows_core::BSTR>;
    fn MediaTypes(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
    fn Connect(&self, ppin: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn ConnectDirect(&self, ppin: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn ConnectWithType(&self, ppin: windows_core::Ref<windows_core::IUnknown>, pmediatype: windows_core::Ref<super::super::System::Com::IDispatch>) -> windows_core::Result<()>;
    fn Disconnect(&self) -> windows_core::Result<()>;
    fn Render(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IPinInfo_Vtbl {
    pub const fn new<Identity: IPinInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Pin<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::Pin(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConnectedTo<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::ConnectedTo(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ConnectionMediaType<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::ConnectionMediaType(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FilterInfo<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::FilterInfo(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Name<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::Name(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Direction<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppdirection: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::Direction(this) {
                    Ok(ok__) => {
                        ppdirection.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn PinID<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strpinid: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::PinID(this) {
                    Ok(ok__) => {
                        strpinid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn MediaTypes<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPinInfo_Impl::MediaTypes(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Connect<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinInfo_Impl::Connect(this, core::mem::transmute_copy(&ppin)).into()
            }
        }
        unsafe extern "system" fn ConnectDirect<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinInfo_Impl::ConnectDirect(this, core::mem::transmute_copy(&ppin)).into()
            }
        }
        unsafe extern "system" fn ConnectWithType<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppin: *mut core::ffi::c_void, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinInfo_Impl::ConnectWithType(this, core::mem::transmute_copy(&ppin), core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn Disconnect<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinInfo_Impl::Disconnect(this).into()
            }
        }
        unsafe extern "system" fn Render<Identity: IPinInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPinInfo_Impl::Render(this).into()
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            Pin: Pin::<Identity, OFFSET>,
            ConnectedTo: ConnectedTo::<Identity, OFFSET>,
            ConnectionMediaType: ConnectionMediaType::<Identity, OFFSET>,
            FilterInfo: FilterInfo::<Identity, OFFSET>,
            Name: Name::<Identity, OFFSET>,
            Direction: Direction::<Identity, OFFSET>,
            PinID: PinID::<Identity, OFFSET>,
            MediaTypes: MediaTypes::<Identity, OFFSET>,
            Connect: Connect::<Identity, OFFSET>,
            ConnectDirect: ConnectDirect::<Identity, OFFSET>,
            ConnectWithType: ConnectWithType::<Identity, OFFSET>,
            Disconnect: Disconnect::<Identity, OFFSET>,
            Render: Render::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPinInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IPinInfo {}
windows_core::imp::define_interface!(IQualProp, IQualProp_Vtbl, 0x1bd0ecb0_f8e2_11ce_aac6_0020af0b99a3);
windows_core::imp::interface_hierarchy!(IQualProp, windows_core::IUnknown);
impl IQualProp {
    pub unsafe fn FramesDroppedInRenderer(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FramesDroppedInRenderer)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn FramesDrawn(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FramesDrawn)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn AvgFrameRate(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvgFrameRate)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn Jitter(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Jitter)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn AvgSyncOffset(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AvgSyncOffset)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn DevSyncOffset(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).DevSyncOffset)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IQualProp_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub FramesDroppedInRenderer: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub FramesDrawn: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub AvgFrameRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub Jitter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub AvgSyncOffset: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub DevSyncOffset: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
pub trait IQualProp_Impl: windows_core::IUnknownImpl {
    fn FramesDroppedInRenderer(&self) -> windows_core::Result<i32>;
    fn FramesDrawn(&self) -> windows_core::Result<i32>;
    fn AvgFrameRate(&self) -> windows_core::Result<i32>;
    fn Jitter(&self) -> windows_core::Result<i32>;
    fn AvgSyncOffset(&self) -> windows_core::Result<i32>;
    fn DevSyncOffset(&self) -> windows_core::Result<i32>;
}
impl IQualProp_Vtbl {
    pub const fn new<Identity: IQualProp_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FramesDroppedInRenderer<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcframes: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::FramesDroppedInRenderer(this) {
                    Ok(ok__) => {
                        pcframes.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FramesDrawn<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcframesdrawn: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::FramesDrawn(this) {
                    Ok(ok__) => {
                        pcframesdrawn.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AvgFrameRate<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piavgframerate: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::AvgFrameRate(this) {
                    Ok(ok__) => {
                        piavgframerate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Jitter<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ijitter: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::Jitter(this) {
                    Ok(ok__) => {
                        ijitter.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AvgSyncOffset<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piavg: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::AvgSyncOffset(this) {
                    Ok(ok__) => {
                        piavg.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn DevSyncOffset<Identity: IQualProp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pidev: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQualProp_Impl::DevSyncOffset(this) {
                    Ok(ok__) => {
                        pidev.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            FramesDroppedInRenderer: FramesDroppedInRenderer::<Identity, OFFSET>,
            FramesDrawn: FramesDrawn::<Identity, OFFSET>,
            AvgFrameRate: AvgFrameRate::<Identity, OFFSET>,
            Jitter: Jitter::<Identity, OFFSET>,
            AvgSyncOffset: AvgSyncOffset::<Identity, OFFSET>,
            DevSyncOffset: DevSyncOffset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IQualProp as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IQualProp {}
windows_core::imp::define_interface!(IQualityControl, IQualityControl_Vtbl, 0x56a868a5_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IQualityControl, windows_core::IUnknown);
impl IQualityControl {
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Notify<P0>(&self, pself: P0, q: Quality) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IBaseFilter>,
    {
        unsafe { (windows_core::Interface::vtable(self).Notify)(windows_core::Interface::as_raw(self), pself.param().abi(), core::mem::transmute(q)).ok() }
    }
    pub unsafe fn SetSink<P0>(&self, piqc: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IQualityControl>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetSink)(windows_core::Interface::as_raw(self), piqc.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IQualityControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Com")]
    pub Notify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, Quality) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    Notify: usize,
    pub SetSink: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_System_Com")]
pub trait IQualityControl_Impl: windows_core::IUnknownImpl {
    fn Notify(&self, pself: windows_core::Ref<IBaseFilter>, q: &Quality) -> windows_core::Result<()>;
    fn SetSink(&self, piqc: windows_core::Ref<IQualityControl>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IQualityControl_Vtbl {
    pub const fn new<Identity: IQualityControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Notify<Identity: IQualityControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pself: *mut core::ffi::c_void, q: Quality) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQualityControl_Impl::Notify(this, core::mem::transmute_copy(&pself), core::mem::transmute(&q)).into()
            }
        }
        unsafe extern "system" fn SetSink<Identity: IQualityControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piqc: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQualityControl_Impl::SetSink(this, core::mem::transmute_copy(&piqc)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Notify: Notify::<Identity, OFFSET>, SetSink: SetSink::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IQualityControl as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IQualityControl {}
windows_core::imp::define_interface!(IQueueCommand, IQueueCommand_Vtbl, 0x56a868b7_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IQueueCommand, windows_core::IUnknown);
impl IQueueCommand {
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn InvokeAtStreamTime(&self, pcmd: *mut Option<IDeferredCommand>, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InvokeAtStreamTime)(windows_core::Interface::as_raw(self), core::mem::transmute(pcmd), time, iid, dispidmethod, wflags, cargs, core::mem::transmute(pdispparams), core::mem::transmute(pvarresult), puargerr as _).ok() }
    }
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub unsafe fn InvokeAtPresentationTime(&self, pcmd: *mut Option<IDeferredCommand>, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InvokeAtPresentationTime)(windows_core::Interface::as_raw(self), core::mem::transmute(pcmd), time, iid, dispidmethod, wflags, cargs, core::mem::transmute(pdispparams), core::mem::transmute(pvarresult), puargerr as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IQueueCommand_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub InvokeAtStreamTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, f64, *const windows_core::GUID, i32, i16, i32, *const super::super::System::Variant::VARIANT, *mut super::super::System::Variant::VARIANT, *mut i16) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    InvokeAtStreamTime: usize,
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
    pub InvokeAtPresentationTime: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, f64, *const windows_core::GUID, i32, i16, i32, *const super::super::System::Variant::VARIANT, *mut super::super::System::Variant::VARIANT, *mut i16) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant")))]
    InvokeAtPresentationTime: usize,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IQueueCommand_Impl: windows_core::IUnknownImpl {
    fn InvokeAtStreamTime(&self, pcmd: windows_core::OutRef<IDeferredCommand>, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::Result<()>;
    fn InvokeAtPresentationTime(&self, pcmd: windows_core::OutRef<IDeferredCommand>, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IQueueCommand_Vtbl {
    pub const fn new<Identity: IQueueCommand_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InvokeAtStreamTime<Identity: IQueueCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcmd: *mut *mut core::ffi::c_void, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQueueCommand_Impl::InvokeAtStreamTime(this, core::mem::transmute_copy(&pcmd), core::mem::transmute_copy(&time), core::mem::transmute_copy(&iid), core::mem::transmute_copy(&dispidmethod), core::mem::transmute_copy(&wflags), core::mem::transmute_copy(&cargs), core::mem::transmute_copy(&pdispparams), core::mem::transmute_copy(&pvarresult), core::mem::transmute_copy(&puargerr)).into()
            }
        }
        unsafe extern "system" fn InvokeAtPresentationTime<Identity: IQueueCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcmd: *mut *mut core::ffi::c_void, time: f64, iid: *const windows_core::GUID, dispidmethod: i32, wflags: i16, cargs: i32, pdispparams: *const super::super::System::Variant::VARIANT, pvarresult: *mut super::super::System::Variant::VARIANT, puargerr: *mut i16) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQueueCommand_Impl::InvokeAtPresentationTime(this, core::mem::transmute_copy(&pcmd), core::mem::transmute_copy(&time), core::mem::transmute_copy(&iid), core::mem::transmute_copy(&dispidmethod), core::mem::transmute_copy(&wflags), core::mem::transmute_copy(&cargs), core::mem::transmute_copy(&pdispparams), core::mem::transmute_copy(&pvarresult), core::mem::transmute_copy(&puargerr)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InvokeAtStreamTime: InvokeAtStreamTime::<Identity, OFFSET>,
            InvokeAtPresentationTime: InvokeAtPresentationTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IQueueCommand as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IQueueCommand {}
pub const IRPM_STREAMM: MPEG2StreamType = MPEG2StreamType(26i32);
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IRegFilterInfo, IRegFilterInfo_Vtbl, 0x56a868bb_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IRegFilterInfo {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IRegFilterInfo, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IRegFilterInfo {
    pub unsafe fn Name(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Name)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn Filter(&self) -> windows_core::Result<super::super::System::Com::IDispatch> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Filter)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IRegFilterInfo_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub Name: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Filter: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IRegFilterInfo_Impl: super::super::System::Com::IDispatch_Impl {
    fn Name(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Filter(&self) -> windows_core::Result<super::super::System::Com::IDispatch>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IRegFilterInfo_Vtbl {
    pub const fn new<Identity: IRegFilterInfo_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Name<Identity: IRegFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strname: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRegFilterInfo_Impl::Name(this) {
                    Ok(ok__) => {
                        strname.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Filter<Identity: IRegFilterInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunk: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRegFilterInfo_Impl::Filter(this) {
                    Ok(ok__) => {
                        ppunk.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(), Name: Name::<Identity, OFFSET>, Filter: Filter::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRegFilterInfo as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IRegFilterInfo {}
windows_core::imp::define_interface!(IRegisterServiceProvider, IRegisterServiceProvider_Vtbl, 0x7b3a2f01_0751_48dd_b556_004785171c54);
windows_core::imp::interface_hierarchy!(IRegisterServiceProvider, windows_core::IUnknown);
impl IRegisterServiceProvider {
    pub unsafe fn RegisterService<P1>(&self, guidservice: *const windows_core::GUID, punkobject: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).RegisterService)(windows_core::Interface::as_raw(self), guidservice, punkobject.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRegisterServiceProvider_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub RegisterService: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IRegisterServiceProvider_Impl: windows_core::IUnknownImpl {
    fn RegisterService(&self, guidservice: *const windows_core::GUID, punkobject: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl IRegisterServiceProvider_Vtbl {
    pub const fn new<Identity: IRegisterServiceProvider_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RegisterService<Identity: IRegisterServiceProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidservice: *const windows_core::GUID, punkobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRegisterServiceProvider_Impl::RegisterService(this, core::mem::transmute_copy(&guidservice), core::mem::transmute_copy(&punkobject)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), RegisterService: RegisterService::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRegisterServiceProvider as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IRegisterServiceProvider {}
windows_core::imp::define_interface!(IResourceConsumer, IResourceConsumer_Vtbl, 0x56a868ad_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IResourceConsumer, windows_core::IUnknown);
impl IResourceConsumer {
    pub unsafe fn AcquireResource(&self, idresource: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AcquireResource)(windows_core::Interface::as_raw(self), idresource).ok() }
    }
    pub unsafe fn ReleaseResource(&self, idresource: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).ReleaseResource)(windows_core::Interface::as_raw(self), idresource).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IResourceConsumer_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AcquireResource: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub ReleaseResource: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
}
pub trait IResourceConsumer_Impl: windows_core::IUnknownImpl {
    fn AcquireResource(&self, idresource: i32) -> windows_core::Result<()>;
    fn ReleaseResource(&self, idresource: i32) -> windows_core::Result<()>;
}
impl IResourceConsumer_Vtbl {
    pub const fn new<Identity: IResourceConsumer_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AcquireResource<Identity: IResourceConsumer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceConsumer_Impl::AcquireResource(this, core::mem::transmute_copy(&idresource)).into()
            }
        }
        unsafe extern "system" fn ReleaseResource<Identity: IResourceConsumer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceConsumer_Impl::ReleaseResource(this, core::mem::transmute_copy(&idresource)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AcquireResource: AcquireResource::<Identity, OFFSET>,
            ReleaseResource: ReleaseResource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IResourceConsumer as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IResourceConsumer {}
windows_core::imp::define_interface!(IResourceManager, IResourceManager_Vtbl, 0x56a868ac_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IResourceManager, windows_core::IUnknown);
impl IResourceManager {
    pub unsafe fn Register<P0>(&self, pname: P0, cresource: i32) -> windows_core::Result<i32>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Register)(windows_core::Interface::as_raw(self), pname.param().abi(), cresource, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RegisterGroup<P0>(&self, pname: P0, paltokens: &[i32]) -> windows_core::Result<i32>
    where
        P0: windows_core::Param<windows_core::PCWSTR>,
    {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).RegisterGroup)(windows_core::Interface::as_raw(self), pname.param().abi(), paltokens.len().try_into().unwrap(), core::mem::transmute(paltokens.as_ptr()), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn RequestResource<P1, P2>(&self, idresource: i32, pfocusobject: P1, pconsumer: P2) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
        P2: windows_core::Param<IResourceConsumer>,
    {
        unsafe { (windows_core::Interface::vtable(self).RequestResource)(windows_core::Interface::as_raw(self), idresource, pfocusobject.param().abi(), pconsumer.param().abi()).ok() }
    }
    pub unsafe fn NotifyAcquire<P1>(&self, idresource: i32, pconsumer: P1, hr: windows_core::HRESULT) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IResourceConsumer>,
    {
        unsafe { (windows_core::Interface::vtable(self).NotifyAcquire)(windows_core::Interface::as_raw(self), idresource, pconsumer.param().abi(), hr).ok() }
    }
    pub unsafe fn NotifyRelease<P1>(&self, idresource: i32, pconsumer: P1, bstillwant: bool) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IResourceConsumer>,
    {
        unsafe { (windows_core::Interface::vtable(self).NotifyRelease)(windows_core::Interface::as_raw(self), idresource, pconsumer.param().abi(), bstillwant.into()).ok() }
    }
    pub unsafe fn CancelRequest<P1>(&self, idresource: i32, pconsumer: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IResourceConsumer>,
    {
        unsafe { (windows_core::Interface::vtable(self).CancelRequest)(windows_core::Interface::as_raw(self), idresource, pconsumer.param().abi()).ok() }
    }
    pub unsafe fn SetFocus<P0>(&self, pfocusobject: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetFocus)(windows_core::Interface::as_raw(self), pfocusobject.param().abi()).ok() }
    }
    pub unsafe fn ReleaseFocus<P0>(&self, pfocusobject: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).ReleaseFocus)(windows_core::Interface::as_raw(self), pfocusobject.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IResourceManager_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Register: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, i32, *mut i32) -> windows_core::HRESULT,
    pub RegisterGroup: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::PCWSTR, i32, *const i32, *mut i32) -> windows_core::HRESULT,
    pub RequestResource: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NotifyAcquire: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void, windows_core::HRESULT) -> windows_core::HRESULT,
    pub NotifyRelease: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub CancelRequest: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetFocus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub ReleaseFocus: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IResourceManager_Impl: windows_core::IUnknownImpl {
    fn Register(&self, pname: &windows_core::PCWSTR, cresource: i32) -> windows_core::Result<i32>;
    fn RegisterGroup(&self, pname: &windows_core::PCWSTR, cresource: i32, paltokens: *const i32) -> windows_core::Result<i32>;
    fn RequestResource(&self, idresource: i32, pfocusobject: windows_core::Ref<windows_core::IUnknown>, pconsumer: windows_core::Ref<IResourceConsumer>) -> windows_core::Result<()>;
    fn NotifyAcquire(&self, idresource: i32, pconsumer: windows_core::Ref<IResourceConsumer>, hr: windows_core::HRESULT) -> windows_core::Result<()>;
    fn NotifyRelease(&self, idresource: i32, pconsumer: windows_core::Ref<IResourceConsumer>, bstillwant: windows_core::BOOL) -> windows_core::Result<()>;
    fn CancelRequest(&self, idresource: i32, pconsumer: windows_core::Ref<IResourceConsumer>) -> windows_core::Result<()>;
    fn SetFocus(&self, pfocusobject: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn ReleaseFocus(&self, pfocusobject: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl IResourceManager_Vtbl {
    pub const fn new<Identity: IResourceManager_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Register<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pname: windows_core::PCWSTR, cresource: i32, pltoken: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IResourceManager_Impl::Register(this, core::mem::transmute(&pname), core::mem::transmute_copy(&cresource)) {
                    Ok(ok__) => {
                        pltoken.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RegisterGroup<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pname: windows_core::PCWSTR, cresource: i32, paltokens: *const i32, pltoken: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IResourceManager_Impl::RegisterGroup(this, core::mem::transmute(&pname), core::mem::transmute_copy(&cresource), core::mem::transmute_copy(&paltokens)) {
                    Ok(ok__) => {
                        pltoken.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RequestResource<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32, pfocusobject: *mut core::ffi::c_void, pconsumer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::RequestResource(this, core::mem::transmute_copy(&idresource), core::mem::transmute_copy(&pfocusobject), core::mem::transmute_copy(&pconsumer)).into()
            }
        }
        unsafe extern "system" fn NotifyAcquire<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32, pconsumer: *mut core::ffi::c_void, hr: windows_core::HRESULT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::NotifyAcquire(this, core::mem::transmute_copy(&idresource), core::mem::transmute_copy(&pconsumer), core::mem::transmute_copy(&hr)).into()
            }
        }
        unsafe extern "system" fn NotifyRelease<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32, pconsumer: *mut core::ffi::c_void, bstillwant: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::NotifyRelease(this, core::mem::transmute_copy(&idresource), core::mem::transmute_copy(&pconsumer), core::mem::transmute_copy(&bstillwant)).into()
            }
        }
        unsafe extern "system" fn CancelRequest<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, idresource: i32, pconsumer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::CancelRequest(this, core::mem::transmute_copy(&idresource), core::mem::transmute_copy(&pconsumer)).into()
            }
        }
        unsafe extern "system" fn SetFocus<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfocusobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::SetFocus(this, core::mem::transmute_copy(&pfocusobject)).into()
            }
        }
        unsafe extern "system" fn ReleaseFocus<Identity: IResourceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfocusobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IResourceManager_Impl::ReleaseFocus(this, core::mem::transmute_copy(&pfocusobject)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Register: Register::<Identity, OFFSET>,
            RegisterGroup: RegisterGroup::<Identity, OFFSET>,
            RequestResource: RequestResource::<Identity, OFFSET>,
            NotifyAcquire: NotifyAcquire::<Identity, OFFSET>,
            NotifyRelease: NotifyRelease::<Identity, OFFSET>,
            CancelRequest: CancelRequest::<Identity, OFFSET>,
            SetFocus: SetFocus::<Identity, OFFSET>,
            ReleaseFocus: ReleaseFocus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IResourceManager as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IResourceManager {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ISDBCAS_REQUEST_ID(pub i32);
pub const ISDBCAS_REQUEST_ID_EMD: ISDBCAS_REQUEST_ID = ISDBCAS_REQUEST_ID(58i32);
pub const ISDBCAS_REQUEST_ID_EMG: ISDBCAS_REQUEST_ID = ISDBCAS_REQUEST_ID(56i32);
pub const ISDB_Satellite: DVBSystemType = DVBSystemType(4i32);
pub const ISDB_Terrestrial: DVBSystemType = DVBSystemType(3i32);
pub const ISO_IEC_11172_2_VIDEO: MPEG2StreamType = MPEG2StreamType(1i32);
pub const ISO_IEC_11172_3_AUDIO: MPEG2StreamType = MPEG2StreamType(3i32);
pub const ISO_IEC_13522_MHEG: MPEG2StreamType = MPEG2StreamType(7i32);
pub const ISO_IEC_13818_1_AUXILIARY: MPEG2StreamType = MPEG2StreamType(14i32);
pub const ISO_IEC_13818_1_PES: MPEG2StreamType = MPEG2StreamType(6i32);
pub const ISO_IEC_13818_1_PRIVATE_SECTION: MPEG2StreamType = MPEG2StreamType(5i32);
pub const ISO_IEC_13818_1_RESERVED: MPEG2StreamType = MPEG2StreamType(28i32);
pub const ISO_IEC_13818_2_VIDEO: MPEG2StreamType = MPEG2StreamType(2i32);
pub const ISO_IEC_13818_3_AUDIO: MPEG2StreamType = MPEG2StreamType(4i32);
pub const ISO_IEC_13818_6_DOWNLOAD: MPEG2StreamType = MPEG2StreamType(20i32);
pub const ISO_IEC_13818_6_TYPE_A: MPEG2StreamType = MPEG2StreamType(10i32);
pub const ISO_IEC_13818_6_TYPE_B: MPEG2StreamType = MPEG2StreamType(11i32);
pub const ISO_IEC_13818_6_TYPE_C: MPEG2StreamType = MPEG2StreamType(12i32);
pub const ISO_IEC_13818_6_TYPE_D: MPEG2StreamType = MPEG2StreamType(13i32);
pub const ISO_IEC_13818_7_AUDIO: MPEG2StreamType = MPEG2StreamType(15i32);
pub const ISO_IEC_14496_1_IN_PES: MPEG2StreamType = MPEG2StreamType(18i32);
pub const ISO_IEC_14496_1_IN_SECTION: MPEG2StreamType = MPEG2StreamType(19i32);
pub const ISO_IEC_14496_2_VISUAL: MPEG2StreamType = MPEG2StreamType(16i32);
pub const ISO_IEC_14496_3_AUDIO: MPEG2StreamType = MPEG2StreamType(17i32);
pub const ISO_IEC_USER_PRIVATE: MPEG2StreamType = MPEG2StreamType(128i32);
windows_core::imp::define_interface!(ISeekingPassThru, ISeekingPassThru_Vtbl, 0x36b73883_c2c8_11cf_8b46_00805f6cef60);
windows_core::imp::interface_hierarchy!(ISeekingPassThru, windows_core::IUnknown);
impl ISeekingPassThru {
    pub unsafe fn Init<P1>(&self, bsupportrendering: bool, ppin: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IPin>,
    {
        unsafe { (windows_core::Interface::vtable(self).Init)(windows_core::Interface::as_raw(self), bsupportrendering.into(), ppin.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISeekingPassThru_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Init: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait ISeekingPassThru_Impl: windows_core::IUnknownImpl {
    fn Init(&self, bsupportrendering: windows_core::BOOL, ppin: windows_core::Ref<IPin>) -> windows_core::Result<()>;
}
impl ISeekingPassThru_Vtbl {
    pub const fn new<Identity: ISeekingPassThru_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Init<Identity: ISeekingPassThru_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bsupportrendering: windows_core::BOOL, ppin: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISeekingPassThru_Impl::Init(this, core::mem::transmute_copy(&bsupportrendering), core::mem::transmute_copy(&ppin)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Init: Init::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISeekingPassThru as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for ISeekingPassThru {}
windows_core::imp::define_interface!(ISelector, ISelector_Vtbl, 0x1abdaeca_68b6_4f83_9371_b413907c7b9f);
windows_core::imp::interface_hierarchy!(ISelector, windows_core::IUnknown);
impl ISelector {
    pub unsafe fn NumSources(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).NumSources)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SourceNodeId(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).SourceNodeId)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetSourceNodeId(&self, dwpinid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSourceNodeId)(windows_core::Interface::as_raw(self), dwpinid).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISelector_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub NumSources: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SourceNodeId: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetSourceNodeId: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait ISelector_Impl: windows_core::IUnknownImpl {
    fn NumSources(&self) -> windows_core::Result<u32>;
    fn SourceNodeId(&self) -> windows_core::Result<u32>;
    fn SetSourceNodeId(&self, dwpinid: u32) -> windows_core::Result<()>;
}
impl ISelector_Vtbl {
    pub const fn new<Identity: ISelector_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn NumSources<Identity: ISelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumsources: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISelector_Impl::NumSources(this) {
                    Ok(ok__) => {
                        pdwnumsources.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SourceNodeId<Identity: ISelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwpinid: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISelector_Impl::SourceNodeId(this) {
                    Ok(ok__) => {
                        pdwpinid.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSourceNodeId<Identity: ISelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwpinid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISelector_Impl::SetSourceNodeId(this, core::mem::transmute_copy(&dwpinid)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            NumSources: NumSources::<Identity, OFFSET>,
            SourceNodeId: SourceNodeId::<Identity, OFFSET>,
            SetSourceNodeId: SetSourceNodeId::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISelector as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for ISelector {}
windows_core::imp::define_interface!(ISpecifyParticularPages, ISpecifyParticularPages_Vtbl, 0x4c437b91_6e9e_11d1_a704_006097c4e476);
windows_core::imp::interface_hierarchy!(ISpecifyParticularPages, windows_core::IUnknown);
impl ISpecifyParticularPages {
    #[cfg(feature = "Win32_System_Ole")]
    pub unsafe fn GetPages(&self, guidwhatpages: *const windows_core::GUID) -> windows_core::Result<super::super::System::Ole::CAUUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetPages)(windows_core::Interface::as_raw(self), guidwhatpages, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISpecifyParticularPages_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_System_Ole")]
    pub GetPages: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *mut super::super::System::Ole::CAUUID) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_System_Ole"))]
    GetPages: usize,
}
#[cfg(feature = "Win32_System_Ole")]
pub trait ISpecifyParticularPages_Impl: windows_core::IUnknownImpl {
    fn GetPages(&self, guidwhatpages: *const windows_core::GUID) -> windows_core::Result<super::super::System::Ole::CAUUID>;
}
#[cfg(feature = "Win32_System_Ole")]
impl ISpecifyParticularPages_Vtbl {
    pub const fn new<Identity: ISpecifyParticularPages_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetPages<Identity: ISpecifyParticularPages_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidwhatpages: *const windows_core::GUID, ppages: *mut super::super::System::Ole::CAUUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISpecifyParticularPages_Impl::GetPages(this, core::mem::transmute_copy(&guidwhatpages)) {
                    Ok(ok__) => {
                        ppages.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetPages: GetPages::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISpecifyParticularPages as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Ole")]
impl windows_core::RuntimeName for ISpecifyParticularPages {}
windows_core::imp::define_interface!(IStreamBuilder, IStreamBuilder_Vtbl, 0x56a868bf_0ad4_11ce_b03a_0020af0ba770);
windows_core::imp::interface_hierarchy!(IStreamBuilder, windows_core::IUnknown);
impl IStreamBuilder {
    pub unsafe fn Render<P0, P1>(&self, ppinout: P0, pgraph: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IGraphBuilder>,
    {
        unsafe { (windows_core::Interface::vtable(self).Render)(windows_core::Interface::as_raw(self), ppinout.param().abi(), pgraph.param().abi()).ok() }
    }
    pub unsafe fn Backout<P0, P1>(&self, ppinout: P0, pgraph: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IPin>,
        P1: windows_core::Param<IGraphBuilder>,
    {
        unsafe { (windows_core::Interface::vtable(self).Backout)(windows_core::Interface::as_raw(self), ppinout.param().abi(), pgraph.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IStreamBuilder_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Render: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Backout: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IStreamBuilder_Impl: windows_core::IUnknownImpl {
    fn Render(&self, ppinout: windows_core::Ref<IPin>, pgraph: windows_core::Ref<IGraphBuilder>) -> windows_core::Result<()>;
    fn Backout(&self, ppinout: windows_core::Ref<IPin>, pgraph: windows_core::Ref<IGraphBuilder>) -> windows_core::Result<()>;
}
impl IStreamBuilder_Vtbl {
    pub const fn new<Identity: IStreamBuilder_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Render<Identity: IStreamBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void, pgraph: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamBuilder_Impl::Render(this, core::mem::transmute_copy(&ppinout), core::mem::transmute_copy(&pgraph)).into()
            }
        }
        unsafe extern "system" fn Backout<Identity: IStreamBuilder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppinout: *mut core::ffi::c_void, pgraph: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamBuilder_Impl::Backout(this, core::mem::transmute_copy(&ppinout), core::mem::transmute_copy(&pgraph)).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Render: Render::<Identity, OFFSET>, Backout: Backout::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IStreamBuilder as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IStreamBuilder {}
windows_core::imp::define_interface!(IStreamSample, IStreamSample_Vtbl, 0xb502d1be_9a57_11d0_8fde_00c04fd9189d);
windows_core::imp::interface_hierarchy!(IStreamSample, windows_core::IUnknown);
impl IStreamSample {
    pub unsafe fn GetMediaStream(&self, ppmediastream: *const Option<IMediaStream>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMediaStream)(windows_core::Interface::as_raw(self), core::mem::transmute(ppmediastream)).ok() }
    }
    pub unsafe fn GetSampleTimes(&self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSampleTimes)(windows_core::Interface::as_raw(self), pstarttime as _, pendtime as _, pcurrenttime as _).ok() }
    }
    pub unsafe fn SetSampleTimes(&self, pstarttime: *const i64, pendtime: *const i64) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSampleTimes)(windows_core::Interface::as_raw(self), pstarttime, pendtime).ok() }
    }
    pub unsafe fn Update(&self, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).Update)(windows_core::Interface::as_raw(self), dwflags, hevent, pfnapc, dwapcdata).ok() }
    }
    pub unsafe fn CompletionStatus(&self, dwflags: u32, dwmilliseconds: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CompletionStatus)(windows_core::Interface::as_raw(self), dwflags, dwmilliseconds).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IStreamSample_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetMediaStream: unsafe extern "system" fn(*mut core::ffi::c_void, *const *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetSampleTimes: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i64, *mut i64, *mut i64) -> windows_core::HRESULT,
    pub SetSampleTimes: unsafe extern "system" fn(*mut core::ffi::c_void, *const i64, *const i64) -> windows_core::HRESULT,
    pub Update: unsafe extern "system" fn(*mut core::ffi::c_void, u32, super::super::Foundation::HANDLE, super::super::Foundation::PAPCFUNC, usize) -> windows_core::HRESULT,
    pub CompletionStatus: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
}
pub trait IStreamSample_Impl: windows_core::IUnknownImpl {
    fn GetMediaStream(&self, ppmediastream: *const Option<IMediaStream>) -> windows_core::Result<()>;
    fn GetSampleTimes(&self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> windows_core::Result<()>;
    fn SetSampleTimes(&self, pstarttime: *const i64, pendtime: *const i64) -> windows_core::Result<()>;
    fn Update(&self, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> windows_core::Result<()>;
    fn CompletionStatus(&self, dwflags: u32, dwmilliseconds: u32) -> windows_core::Result<()>;
}
impl IStreamSample_Vtbl {
    pub const fn new<Identity: IStreamSample_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetMediaStream<Identity: IStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediastream: *const *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamSample_Impl::GetMediaStream(this, core::mem::transmute_copy(&ppmediastream)).into()
            }
        }
        unsafe extern "system" fn GetSampleTimes<Identity: IStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamSample_Impl::GetSampleTimes(this, core::mem::transmute_copy(&pstarttime), core::mem::transmute_copy(&pendtime), core::mem::transmute_copy(&pcurrenttime)).into()
            }
        }
        unsafe extern "system" fn SetSampleTimes<Identity: IStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstarttime: *const i64, pendtime: *const i64) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamSample_Impl::SetSampleTimes(this, core::mem::transmute_copy(&pstarttime), core::mem::transmute_copy(&pendtime)).into()
            }
        }
        unsafe extern "system" fn Update<Identity: IStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, hevent: super::super::Foundation::HANDLE, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamSample_Impl::Update(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&hevent), core::mem::transmute_copy(&pfnapc), core::mem::transmute_copy(&dwapcdata)).into()
            }
        }
        unsafe extern "system" fn CompletionStatus<Identity: IStreamSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, dwmilliseconds: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IStreamSample_Impl::CompletionStatus(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&dwmilliseconds)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMediaStream: GetMediaStream::<Identity, OFFSET>,
            GetSampleTimes: GetSampleTimes::<Identity, OFFSET>,
            SetSampleTimes: SetSampleTimes::<Identity, OFFSET>,
            Update: Update::<Identity, OFFSET>,
            CompletionStatus: CompletionStatus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IStreamSample as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IStreamSample {}
pub const ITU_T_H264: MPEG2StreamType = MPEG2StreamType(27i32);
pub const ITU_T_REC_H_222_1: MPEG2StreamType = MPEG2StreamType(9i32);
windows_core::imp::define_interface!(IVMRAspectRatioControl, IVMRAspectRatioControl_Vtbl, 0xede80b5c_bad6_4623_b537_65586c9f8dfd);
windows_core::imp::interface_hierarchy!(IVMRAspectRatioControl, windows_core::IUnknown);
impl IVMRAspectRatioControl {
    pub unsafe fn GetAspectRatioMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAspectRatioMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAspectRatioMode(&self, dwarmode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAspectRatioMode)(windows_core::Interface::as_raw(self), dwarmode).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRAspectRatioControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IVMRAspectRatioControl_Impl: windows_core::IUnknownImpl {
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn SetAspectRatioMode(&self, dwarmode: u32) -> windows_core::Result<()>;
}
impl IVMRAspectRatioControl_Vtbl {
    pub const fn new<Identity: IVMRAspectRatioControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetAspectRatioMode<Identity: IVMRAspectRatioControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwarmode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRAspectRatioControl_Impl::GetAspectRatioMode(this) {
                    Ok(ok__) => {
                        lpdwarmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IVMRAspectRatioControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwarmode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRAspectRatioControl_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&dwarmode)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRAspectRatioControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRAspectRatioControl {}
windows_core::imp::define_interface!(IVMRAspectRatioControl9, IVMRAspectRatioControl9_Vtbl, 0x00d96c29_bbde_4efc_9901_bb5036392146);
windows_core::imp::interface_hierarchy!(IVMRAspectRatioControl9, windows_core::IUnknown);
impl IVMRAspectRatioControl9 {
    pub unsafe fn GetAspectRatioMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAspectRatioMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAspectRatioMode(&self, dwarmode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAspectRatioMode)(windows_core::Interface::as_raw(self), dwarmode).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRAspectRatioControl9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
}
pub trait IVMRAspectRatioControl9_Impl: windows_core::IUnknownImpl {
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn SetAspectRatioMode(&self, dwarmode: u32) -> windows_core::Result<()>;
}
impl IVMRAspectRatioControl9_Vtbl {
    pub const fn new<Identity: IVMRAspectRatioControl9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetAspectRatioMode<Identity: IVMRAspectRatioControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwarmode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRAspectRatioControl9_Impl::GetAspectRatioMode(this) {
                    Ok(ok__) => {
                        lpdwarmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IVMRAspectRatioControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwarmode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRAspectRatioControl9_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&dwarmode)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRAspectRatioControl9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRAspectRatioControl9 {}
windows_core::imp::define_interface!(IVMRDeinterlaceControl, IVMRDeinterlaceControl_Vtbl, 0xbb057577_0db8_4e6a_87a7_1a8c9a505a0f);
windows_core::imp::interface_hierarchy!(IVMRDeinterlaceControl, windows_core::IUnknown);
impl IVMRDeinterlaceControl {
    pub unsafe fn GetNumberOfDeinterlaceModes(&self, lpvideodescription: *const VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNumberOfDeinterlaceModes)(windows_core::Interface::as_raw(self), lpvideodescription, lpdwnumdeinterlacemodes as _, lpdeinterlacemodes as _).ok() }
    }
    pub unsafe fn GetDeinterlaceModeCaps(&self, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDeinterlaceModeCaps)(windows_core::Interface::as_raw(self), lpdeinterlacemode, lpvideodescription, lpdeinterlacecaps as _).ok() }
    }
    pub unsafe fn GetDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDeinterlaceMode(&self, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, lpdeinterlacemode).ok() }
    }
    pub unsafe fn GetDeinterlacePrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDeinterlacePrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDeinterlacePrefs(&self, dwdeinterlaceprefs: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDeinterlacePrefs)(windows_core::Interface::as_raw(self), dwdeinterlaceprefs).ok() }
    }
    pub unsafe fn GetActualDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetActualDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRDeinterlaceControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNumberOfDeinterlaceModes: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMRVideoDesc, *mut u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetDeinterlaceModeCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const VMRVideoDesc, *mut VMRDeinterlaceCaps) -> windows_core::HRESULT,
    pub GetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetDeinterlacePrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDeinterlacePrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetActualDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IVMRDeinterlaceControl_Impl: windows_core::IUnknownImpl {
    fn GetNumberOfDeinterlaceModes(&self, lpvideodescription: *const VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetDeinterlaceModeCaps(&self, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> windows_core::Result<()>;
    fn GetDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID>;
    fn SetDeinterlaceMode(&self, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDeinterlacePrefs(&self) -> windows_core::Result<u32>;
    fn SetDeinterlacePrefs(&self, dwdeinterlaceprefs: u32) -> windows_core::Result<()>;
    fn GetActualDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID>;
}
impl IVMRDeinterlaceControl_Vtbl {
    pub const fn new<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpvideodescription: *const VMRVideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl_Impl::GetNumberOfDeinterlaceModes(this, core::mem::transmute_copy(&lpvideodescription), core::mem::transmute_copy(&lpdwnumdeinterlacemodes), core::mem::transmute_copy(&lpdeinterlacemodes)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMRVideoDesc, lpdeinterlacecaps: *mut VMRDeinterlaceCaps) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl_Impl::GetDeinterlaceModeCaps(this, core::mem::transmute_copy(&lpdeinterlacemode), core::mem::transmute_copy(&lpvideodescription), core::mem::transmute_copy(&lpdeinterlacecaps)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl_Impl::GetDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        lpdeinterlacemode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDeinterlaceMode<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl_Impl::SetDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&lpdeinterlacemode)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl_Impl::GetDeinterlacePrefs(this) {
                    Ok(ok__) => {
                        lpdwdeinterlaceprefs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwdeinterlaceprefs: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl_Impl::SetDeinterlacePrefs(this, core::mem::transmute_copy(&dwdeinterlaceprefs)).into()
            }
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Identity: IVMRDeinterlaceControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl_Impl::GetActualDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        lpdeinterlacemode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNumberOfDeinterlaceModes: GetNumberOfDeinterlaceModes::<Identity, OFFSET>,
            GetDeinterlaceModeCaps: GetDeinterlaceModeCaps::<Identity, OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Identity, OFFSET>,
            SetDeinterlaceMode: SetDeinterlaceMode::<Identity, OFFSET>,
            GetDeinterlacePrefs: GetDeinterlacePrefs::<Identity, OFFSET>,
            SetDeinterlacePrefs: SetDeinterlacePrefs::<Identity, OFFSET>,
            GetActualDeinterlaceMode: GetActualDeinterlaceMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRDeinterlaceControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRDeinterlaceControl {}
windows_core::imp::define_interface!(IVMRDeinterlaceControl9, IVMRDeinterlaceControl9_Vtbl, 0xa215fb8d_13c2_4f7f_993c_003d6271a459);
windows_core::imp::interface_hierarchy!(IVMRDeinterlaceControl9, windows_core::IUnknown);
impl IVMRDeinterlaceControl9 {
    pub unsafe fn GetNumberOfDeinterlaceModes(&self, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNumberOfDeinterlaceModes)(windows_core::Interface::as_raw(self), lpvideodescription, lpdwnumdeinterlacemodes as _, lpdeinterlacemodes as _).ok() }
    }
    pub unsafe fn GetDeinterlaceModeCaps(&self, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMR9VideoDesc, lpdeinterlacecaps: *mut VMR9DeinterlaceCaps) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDeinterlaceModeCaps)(windows_core::Interface::as_raw(self), lpdeinterlacemode, lpvideodescription, lpdeinterlacecaps as _).ok() }
    }
    pub unsafe fn GetDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDeinterlaceMode(&self, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, lpdeinterlacemode).ok() }
    }
    pub unsafe fn GetDeinterlacePrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDeinterlacePrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDeinterlacePrefs(&self, dwdeinterlaceprefs: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDeinterlacePrefs)(windows_core::Interface::as_raw(self), dwdeinterlaceprefs).ok() }
    }
    pub unsafe fn GetActualDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetActualDeinterlaceMode)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRDeinterlaceControl9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNumberOfDeinterlaceModes: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMR9VideoDesc, *mut u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub GetDeinterlaceModeCaps: unsafe extern "system" fn(*mut core::ffi::c_void, *const windows_core::GUID, *const VMR9VideoDesc, *mut VMR9DeinterlaceCaps) -> windows_core::HRESULT,
    pub GetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
    pub SetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const windows_core::GUID) -> windows_core::HRESULT,
    pub GetDeinterlacePrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDeinterlacePrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetActualDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut windows_core::GUID) -> windows_core::HRESULT,
}
pub trait IVMRDeinterlaceControl9_Impl: windows_core::IUnknownImpl {
    fn GetNumberOfDeinterlaceModes(&self, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetDeinterlaceModeCaps(&self, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMR9VideoDesc, lpdeinterlacecaps: *mut VMR9DeinterlaceCaps) -> windows_core::Result<()>;
    fn GetDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID>;
    fn SetDeinterlaceMode(&self, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDeinterlacePrefs(&self) -> windows_core::Result<u32>;
    fn SetDeinterlacePrefs(&self, dwdeinterlaceprefs: u32) -> windows_core::Result<()>;
    fn GetActualDeinterlaceMode(&self, dwstreamid: u32) -> windows_core::Result<windows_core::GUID>;
}
impl IVMRDeinterlaceControl9_Vtbl {
    pub const fn new<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNumberOfDeinterlaceModes<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpvideodescription: *const VMR9VideoDesc, lpdwnumdeinterlacemodes: *mut u32, lpdeinterlacemodes: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl9_Impl::GetNumberOfDeinterlaceModes(this, core::mem::transmute_copy(&lpvideodescription), core::mem::transmute_copy(&lpdwnumdeinterlacemodes), core::mem::transmute_copy(&lpdeinterlacemodes)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlaceModeCaps<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdeinterlacemode: *const windows_core::GUID, lpvideodescription: *const VMR9VideoDesc, lpdeinterlacecaps: *mut VMR9DeinterlaceCaps) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl9_Impl::GetDeinterlaceModeCaps(this, core::mem::transmute_copy(&lpdeinterlacemode), core::mem::transmute_copy(&lpvideodescription), core::mem::transmute_copy(&lpdeinterlacecaps)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl9_Impl::GetDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        lpdeinterlacemode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDeinterlaceMode<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *const windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl9_Impl::SetDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&lpdeinterlacemode)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlacePrefs<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwdeinterlaceprefs: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl9_Impl::GetDeinterlacePrefs(this) {
                    Ok(ok__) => {
                        lpdwdeinterlaceprefs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDeinterlacePrefs<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwdeinterlaceprefs: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRDeinterlaceControl9_Impl::SetDeinterlacePrefs(this, core::mem::transmute_copy(&dwdeinterlaceprefs)).into()
            }
        }
        unsafe extern "system" fn GetActualDeinterlaceMode<Identity: IVMRDeinterlaceControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpdeinterlacemode: *mut windows_core::GUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRDeinterlaceControl9_Impl::GetActualDeinterlaceMode(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        lpdeinterlacemode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNumberOfDeinterlaceModes: GetNumberOfDeinterlaceModes::<Identity, OFFSET>,
            GetDeinterlaceModeCaps: GetDeinterlaceModeCaps::<Identity, OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Identity, OFFSET>,
            SetDeinterlaceMode: SetDeinterlaceMode::<Identity, OFFSET>,
            GetDeinterlacePrefs: GetDeinterlacePrefs::<Identity, OFFSET>,
            SetDeinterlacePrefs: SetDeinterlacePrefs::<Identity, OFFSET>,
            GetActualDeinterlaceMode: GetActualDeinterlaceMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRDeinterlaceControl9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRDeinterlaceControl9 {}
windows_core::imp::define_interface!(IVMRFilterConfig, IVMRFilterConfig_Vtbl, 0x9e5530c5_7034_48b4_bb46_0b8a6efc8e36);
windows_core::imp::interface_hierarchy!(IVMRFilterConfig, windows_core::IUnknown);
impl IVMRFilterConfig {
    pub unsafe fn SetImageCompositor<P0>(&self, lpvmrimgcompositor: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IVMRImageCompositor>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetImageCompositor)(windows_core::Interface::as_raw(self), lpvmrimgcompositor.param().abi()).ok() }
    }
    pub unsafe fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetNumberOfStreams)(windows_core::Interface::as_raw(self), dwmaxstreams).ok() }
    }
    pub unsafe fn GetNumberOfStreams(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumberOfStreams)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingPrefs)(windows_core::Interface::as_raw(self), dwrenderflags).ok() }
    }
    pub unsafe fn GetRenderingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetRenderingMode(&self, mode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn GetRenderingMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRFilterConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetImageCompositor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetNumberOfStreams: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetNumberOfStreams: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetRenderingMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVMRFilterConfig_Impl: windows_core::IUnknownImpl {
    fn SetImageCompositor(&self, lpvmrimgcompositor: windows_core::Ref<IVMRImageCompositor>) -> windows_core::Result<()>;
    fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> windows_core::Result<()>;
    fn GetNumberOfStreams(&self) -> windows_core::Result<u32>;
    fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()>;
    fn GetRenderingPrefs(&self) -> windows_core::Result<u32>;
    fn SetRenderingMode(&self, mode: u32) -> windows_core::Result<()>;
    fn GetRenderingMode(&self) -> windows_core::Result<u32>;
}
impl IVMRFilterConfig_Vtbl {
    pub const fn new<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetImageCompositor<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpvmrimgcompositor: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig_Impl::SetImageCompositor(this, core::mem::transmute_copy(&lpvmrimgcompositor)).into()
            }
        }
        unsafe extern "system" fn SetNumberOfStreams<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmaxstreams: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig_Impl::SetNumberOfStreams(this, core::mem::transmute_copy(&dwmaxstreams)).into()
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmaxstreams: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig_Impl::GetNumberOfStreams(this) {
                    Ok(ok__) => {
                        pdwmaxstreams.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig_Impl::SetRenderingPrefs(this, core::mem::transmute_copy(&dwrenderflags)).into()
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrenderflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig_Impl::GetRenderingPrefs(this) {
                    Ok(ok__) => {
                        pdwrenderflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRenderingMode<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig_Impl::SetRenderingMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn GetRenderingMode<Identity: IVMRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig_Impl::GetRenderingMode(this) {
                    Ok(ok__) => {
                        pmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetImageCompositor: SetImageCompositor::<Identity, OFFSET>,
            SetNumberOfStreams: SetNumberOfStreams::<Identity, OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Identity, OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Identity, OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Identity, OFFSET>,
            SetRenderingMode: SetRenderingMode::<Identity, OFFSET>,
            GetRenderingMode: GetRenderingMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRFilterConfig as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRFilterConfig {}
windows_core::imp::define_interface!(IVMRFilterConfig9, IVMRFilterConfig9_Vtbl, 0x5a804648_4f66_4867_9c43_4f5c822cf1b8);
windows_core::imp::interface_hierarchy!(IVMRFilterConfig9, windows_core::IUnknown);
impl IVMRFilterConfig9 {
    pub unsafe fn SetImageCompositor<P0>(&self, lpvmrimgcompositor: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IVMRImageCompositor9>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetImageCompositor)(windows_core::Interface::as_raw(self), lpvmrimgcompositor.param().abi()).ok() }
    }
    pub unsafe fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetNumberOfStreams)(windows_core::Interface::as_raw(self), dwmaxstreams).ok() }
    }
    pub unsafe fn GetNumberOfStreams(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetNumberOfStreams)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingPrefs)(windows_core::Interface::as_raw(self), dwrenderflags).ok() }
    }
    pub unsafe fn GetRenderingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetRenderingMode(&self, mode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn GetRenderingMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRFilterConfig9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetImageCompositor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetNumberOfStreams: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetNumberOfStreams: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetRenderingMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVMRFilterConfig9_Impl: windows_core::IUnknownImpl {
    fn SetImageCompositor(&self, lpvmrimgcompositor: windows_core::Ref<IVMRImageCompositor9>) -> windows_core::Result<()>;
    fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> windows_core::Result<()>;
    fn GetNumberOfStreams(&self) -> windows_core::Result<u32>;
    fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()>;
    fn GetRenderingPrefs(&self) -> windows_core::Result<u32>;
    fn SetRenderingMode(&self, mode: u32) -> windows_core::Result<()>;
    fn GetRenderingMode(&self) -> windows_core::Result<u32>;
}
impl IVMRFilterConfig9_Vtbl {
    pub const fn new<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetImageCompositor<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpvmrimgcompositor: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig9_Impl::SetImageCompositor(this, core::mem::transmute_copy(&lpvmrimgcompositor)).into()
            }
        }
        unsafe extern "system" fn SetNumberOfStreams<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmaxstreams: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig9_Impl::SetNumberOfStreams(this, core::mem::transmute_copy(&dwmaxstreams)).into()
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmaxstreams: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig9_Impl::GetNumberOfStreams(this) {
                    Ok(ok__) => {
                        pdwmaxstreams.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig9_Impl::SetRenderingPrefs(this, core::mem::transmute_copy(&dwrenderflags)).into()
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrenderflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig9_Impl::GetRenderingPrefs(this) {
                    Ok(ok__) => {
                        pdwrenderflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRenderingMode<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRFilterConfig9_Impl::SetRenderingMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn GetRenderingMode<Identity: IVMRFilterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRFilterConfig9_Impl::GetRenderingMode(this) {
                    Ok(ok__) => {
                        pmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetImageCompositor: SetImageCompositor::<Identity, OFFSET>,
            SetNumberOfStreams: SetNumberOfStreams::<Identity, OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Identity, OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Identity, OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Identity, OFFSET>,
            SetRenderingMode: SetRenderingMode::<Identity, OFFSET>,
            GetRenderingMode: GetRenderingMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRFilterConfig9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRFilterConfig9 {}
windows_core::imp::define_interface!(IVMRImageCompositor, IVMRImageCompositor_Vtbl, 0x7a4fb5af_479f_4074_bb40_ce6722e43c82);
windows_core::imp::interface_hierarchy!(IVMRImageCompositor, windows_core::IUnknown);
impl IVMRImageCompositor {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn InitCompositionTarget<P0, P1>(&self, pd3ddevice: P0, pddsrendertarget: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface7>,
    {
        unsafe { (windows_core::Interface::vtable(self).InitCompositionTarget)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi(), pddsrendertarget.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn TermCompositionTarget<P0, P1>(&self, pd3ddevice: P0, pddsrendertarget: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface7>,
    {
        unsafe { (windows_core::Interface::vtable(self).TermCompositionTarget)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi(), pddsrendertarget.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetStreamMediaType(&self, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamMediaType)(windows_core::Interface::as_raw(self), dwstrmid, core::mem::transmute(pmt), ftexture.into()).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn CompositeImage<P0, P1>(&self, pd3ddevice: P0, pddsrendertarget: P1, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMRVIDEOSTREAMINFO, cstreams: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface7>,
    {
        unsafe { (windows_core::Interface::vtable(self).CompositeImage)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi(), pddsrendertarget.param().abi(), core::mem::transmute(pmtrendertarget), rtstart, rtend, dwclrbkgnd, core::mem::transmute(pvideostreaminfo), cstreams).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImageCompositor_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub InitCompositionTarget: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    InitCompositionTarget: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub TermCompositionTarget: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    TermCompositionTarget: usize,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetStreamMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const super::MediaFoundation::AM_MEDIA_TYPE, windows_core::BOOL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetStreamMediaType: usize,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation"))]
    pub CompositeImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE, i64, i64, u32, *const VMRVIDEOSTREAMINFO, u32) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation")))]
    CompositeImage: usize,
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation"))]
pub trait IVMRImageCompositor_Impl: windows_core::IUnknownImpl {
    fn InitCompositionTarget(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>, pddsrendertarget: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()>;
    fn TermCompositionTarget(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>, pddsrendertarget: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()>;
    fn SetStreamMediaType(&self, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: windows_core::BOOL) -> windows_core::Result<()>;
    fn CompositeImage(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>, pddsrendertarget: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface7>, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMRVIDEOSTREAMINFO, cstreams: u32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation"))]
impl IVMRImageCompositor_Vtbl {
    pub const fn new<Identity: IVMRImageCompositor_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InitCompositionTarget<Identity: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void, pddsrendertarget: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor_Impl::InitCompositionTarget(this, core::mem::transmute_copy(&pd3ddevice), core::mem::transmute_copy(&pddsrendertarget)).into()
            }
        }
        unsafe extern "system" fn TermCompositionTarget<Identity: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void, pddsrendertarget: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor_Impl::TermCompositionTarget(this, core::mem::transmute_copy(&pd3ddevice), core::mem::transmute_copy(&pddsrendertarget)).into()
            }
        }
        unsafe extern "system" fn SetStreamMediaType<Identity: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor_Impl::SetStreamMediaType(this, core::mem::transmute_copy(&dwstrmid), core::mem::transmute_copy(&pmt), core::mem::transmute_copy(&ftexture)).into()
            }
        }
        unsafe extern "system" fn CompositeImage<Identity: IVMRImageCompositor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void, pddsrendertarget: *mut core::ffi::c_void, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMRVIDEOSTREAMINFO, cstreams: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor_Impl::CompositeImage(this, core::mem::transmute_copy(&pd3ddevice), core::mem::transmute_copy(&pddsrendertarget), core::mem::transmute_copy(&pmtrendertarget), core::mem::transmute_copy(&rtstart), core::mem::transmute_copy(&rtend), core::mem::transmute_copy(&dwclrbkgnd), core::mem::transmute_copy(&pvideostreaminfo), core::mem::transmute_copy(&cstreams)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitCompositionTarget: InitCompositionTarget::<Identity, OFFSET>,
            TermCompositionTarget: TermCompositionTarget::<Identity, OFFSET>,
            SetStreamMediaType: SetStreamMediaType::<Identity, OFFSET>,
            CompositeImage: CompositeImage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImageCompositor as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Media_MediaFoundation"))]
impl windows_core::RuntimeName for IVMRImageCompositor {}
windows_core::imp::define_interface!(IVMRImageCompositor9, IVMRImageCompositor9_Vtbl, 0x4a5c89eb_df51_4654_ac2a_e48e02bbabf6);
windows_core::imp::interface_hierarchy!(IVMRImageCompositor9, windows_core::IUnknown);
impl IVMRImageCompositor9 {
    pub unsafe fn InitCompositionDevice<P0>(&self, pd3ddevice: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).InitCompositionDevice)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi()).ok() }
    }
    pub unsafe fn TermCompositionDevice<P0>(&self, pd3ddevice: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).TermCompositionDevice)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn SetStreamMediaType(&self, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamMediaType)(windows_core::Interface::as_raw(self), dwstrmid, core::mem::transmute(pmt), ftexture.into()).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn CompositeImage<P0, P1>(&self, pd3ddevice: P0, pddsrendertarget: P1, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows_core::IUnknown>,
        P1: windows_core::Param<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        unsafe { (windows_core::Interface::vtable(self).CompositeImage)(windows_core::Interface::as_raw(self), pd3ddevice.param().abi(), pddsrendertarget.param().abi(), core::mem::transmute(pmtrendertarget), rtstart, rtend, dwclrbkgnd, core::mem::transmute(pvideostreaminfo), cstreams).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImageCompositor9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub InitCompositionDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub TermCompositionDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub SetStreamMediaType: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const super::MediaFoundation::AM_MEDIA_TYPE, windows_core::BOOL) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    SetStreamMediaType: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
    pub CompositeImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE, i64, i64, u32, *const VMR9VideoStreamInfo, u32) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation")))]
    CompositeImage: usize,
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub trait IVMRImageCompositor9_Impl: windows_core::IUnknownImpl {
    fn InitCompositionDevice(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn TermCompositionDevice(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn SetStreamMediaType(&self, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: windows_core::BOOL) -> windows_core::Result<()>;
    fn CompositeImage(&self, pd3ddevice: windows_core::Ref<windows_core::IUnknown>, pddsrendertarget: windows_core::Ref<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
impl IVMRImageCompositor9_Vtbl {
    pub const fn new<Identity: IVMRImageCompositor9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InitCompositionDevice<Identity: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor9_Impl::InitCompositionDevice(this, core::mem::transmute_copy(&pd3ddevice)).into()
            }
        }
        unsafe extern "system" fn TermCompositionDevice<Identity: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor9_Impl::TermCompositionDevice(this, core::mem::transmute_copy(&pd3ddevice)).into()
            }
        }
        unsafe extern "system" fn SetStreamMediaType<Identity: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstrmid: u32, pmt: *const super::MediaFoundation::AM_MEDIA_TYPE, ftexture: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor9_Impl::SetStreamMediaType(this, core::mem::transmute_copy(&dwstrmid), core::mem::transmute_copy(&pmt), core::mem::transmute_copy(&ftexture)).into()
            }
        }
        unsafe extern "system" fn CompositeImage<Identity: IVMRImageCompositor9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pd3ddevice: *mut core::ffi::c_void, pddsrendertarget: *mut core::ffi::c_void, pmtrendertarget: *const super::MediaFoundation::AM_MEDIA_TYPE, rtstart: i64, rtend: i64, dwclrbkgnd: u32, pvideostreaminfo: *const VMR9VideoStreamInfo, cstreams: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImageCompositor9_Impl::CompositeImage(this, core::mem::transmute_copy(&pd3ddevice), core::mem::transmute_copy(&pddsrendertarget), core::mem::transmute_copy(&pmtrendertarget), core::mem::transmute_copy(&rtstart), core::mem::transmute_copy(&rtend), core::mem::transmute_copy(&dwclrbkgnd), core::mem::transmute_copy(&pvideostreaminfo), core::mem::transmute_copy(&cstreams)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitCompositionDevice: InitCompositionDevice::<Identity, OFFSET>,
            TermCompositionDevice: TermCompositionDevice::<Identity, OFFSET>,
            SetStreamMediaType: SetStreamMediaType::<Identity, OFFSET>,
            CompositeImage: CompositeImage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImageCompositor9 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
impl windows_core::RuntimeName for IVMRImageCompositor9 {}
windows_core::imp::define_interface!(IVMRImagePresenter, IVMRImagePresenter_Vtbl, 0xce704fe7_e71e_41fb_baa2_c4403e1182f5);
windows_core::imp::interface_hierarchy!(IVMRImagePresenter, windows_core::IUnknown);
impl IVMRImagePresenter {
    pub unsafe fn StartPresenting(&self, dwuserid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StartPresenting)(windows_core::Interface::as_raw(self), dwuserid).ok() }
    }
    pub unsafe fn StopPresenting(&self, dwuserid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StopPresenting)(windows_core::Interface::as_raw(self), dwuserid).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn PresentImage(&self, dwuserid: usize, lppresinfo: *const VMRPRESENTATIONINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PresentImage)(windows_core::Interface::as_raw(self), dwuserid, core::mem::transmute(lppresinfo)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImagePresenter_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub StartPresenting: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    pub StopPresenting: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub PresentImage: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *const VMRPRESENTATIONINFO) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    PresentImage: usize,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRImagePresenter_Impl: windows_core::IUnknownImpl {
    fn StartPresenting(&self, dwuserid: usize) -> windows_core::Result<()>;
    fn StopPresenting(&self, dwuserid: usize) -> windows_core::Result<()>;
    fn PresentImage(&self, dwuserid: usize, lppresinfo: *const VMRPRESENTATIONINFO) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRImagePresenter_Vtbl {
    pub const fn new<Identity: IVMRImagePresenter_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPresenting<Identity: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter_Impl::StartPresenting(this, core::mem::transmute_copy(&dwuserid)).into()
            }
        }
        unsafe extern "system" fn StopPresenting<Identity: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter_Impl::StopPresenting(this, core::mem::transmute_copy(&dwuserid)).into()
            }
        }
        unsafe extern "system" fn PresentImage<Identity: IVMRImagePresenter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lppresinfo: *const VMRPRESENTATIONINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter_Impl::PresentImage(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lppresinfo)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartPresenting: StartPresenting::<Identity, OFFSET>,
            StopPresenting: StopPresenting::<Identity, OFFSET>,
            PresentImage: PresentImage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImagePresenter as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVMRImagePresenter {}
windows_core::imp::define_interface!(IVMRImagePresenter9, IVMRImagePresenter9_Vtbl, 0x69188c61_12a3_40f0_8ffc_342e7b433fd7);
windows_core::imp::interface_hierarchy!(IVMRImagePresenter9, windows_core::IUnknown);
impl IVMRImagePresenter9 {
    pub unsafe fn StartPresenting(&self, dwuserid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StartPresenting)(windows_core::Interface::as_raw(self), dwuserid).ok() }
    }
    pub unsafe fn StopPresenting(&self, dwuserid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).StopPresenting)(windows_core::Interface::as_raw(self), dwuserid).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn PresentImage(&self, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).PresentImage)(windows_core::Interface::as_raw(self), dwuserid, core::mem::transmute(lppresinfo)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImagePresenter9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub StartPresenting: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    pub StopPresenting: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub PresentImage: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *const VMR9PresentationInfo) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    PresentImage: usize,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IVMRImagePresenter9_Impl: windows_core::IUnknownImpl {
    fn StartPresenting(&self, dwuserid: usize) -> windows_core::Result<()>;
    fn StopPresenting(&self, dwuserid: usize) -> windows_core::Result<()>;
    fn PresentImage(&self, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IVMRImagePresenter9_Vtbl {
    pub const fn new<Identity: IVMRImagePresenter9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPresenting<Identity: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter9_Impl::StartPresenting(this, core::mem::transmute_copy(&dwuserid)).into()
            }
        }
        unsafe extern "system" fn StopPresenting<Identity: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter9_Impl::StopPresenting(this, core::mem::transmute_copy(&dwuserid)).into()
            }
        }
        unsafe extern "system" fn PresentImage<Identity: IVMRImagePresenter9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lppresinfo: *const VMR9PresentationInfo) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenter9_Impl::PresentImage(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lppresinfo)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartPresenting: StartPresenting::<Identity, OFFSET>,
            StopPresenting: StopPresenting::<Identity, OFFSET>,
            PresentImage: PresentImage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImagePresenter9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IVMRImagePresenter9 {}
windows_core::imp::define_interface!(IVMRImagePresenterConfig, IVMRImagePresenterConfig_Vtbl, 0x9f3a1c85_8555_49ba_935f_be5b5b29d178);
windows_core::imp::interface_hierarchy!(IVMRImagePresenterConfig, windows_core::IUnknown);
impl IVMRImagePresenterConfig {
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingPrefs)(windows_core::Interface::as_raw(self), dwrenderflags).ok() }
    }
    pub unsafe fn GetRenderingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImagePresenterConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVMRImagePresenterConfig_Impl: windows_core::IUnknownImpl {
    fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()>;
    fn GetRenderingPrefs(&self) -> windows_core::Result<u32>;
}
impl IVMRImagePresenterConfig_Vtbl {
    pub const fn new<Identity: IVMRImagePresenterConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetRenderingPrefs<Identity: IVMRImagePresenterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenterConfig_Impl::SetRenderingPrefs(this, core::mem::transmute_copy(&dwrenderflags)).into()
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Identity: IVMRImagePresenterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRImagePresenterConfig_Impl::GetRenderingPrefs(this) {
                    Ok(ok__) => {
                        dwrenderflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetRenderingPrefs: SetRenderingPrefs::<Identity, OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImagePresenterConfig as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRImagePresenterConfig {}
windows_core::imp::define_interface!(IVMRImagePresenterConfig9, IVMRImagePresenterConfig9_Vtbl, 0x45c15cab_6e22_420a_8043_ae1f0ac02c7d);
windows_core::imp::interface_hierarchy!(IVMRImagePresenterConfig9, windows_core::IUnknown);
impl IVMRImagePresenterConfig9 {
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetRenderingPrefs)(windows_core::Interface::as_raw(self), dwrenderflags).ok() }
    }
    pub unsafe fn GetRenderingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetRenderingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImagePresenterConfig9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetRenderingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVMRImagePresenterConfig9_Impl: windows_core::IUnknownImpl {
    fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()>;
    fn GetRenderingPrefs(&self) -> windows_core::Result<u32>;
}
impl IVMRImagePresenterConfig9_Vtbl {
    pub const fn new<Identity: IVMRImagePresenterConfig9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetRenderingPrefs<Identity: IVMRImagePresenterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenterConfig9_Impl::SetRenderingPrefs(this, core::mem::transmute_copy(&dwrenderflags)).into()
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Identity: IVMRImagePresenterConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRImagePresenterConfig9_Impl::GetRenderingPrefs(this) {
                    Ok(ok__) => {
                        dwrenderflags.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetRenderingPrefs: SetRenderingPrefs::<Identity, OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImagePresenterConfig9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRImagePresenterConfig9 {}
windows_core::imp::define_interface!(IVMRImagePresenterExclModeConfig, IVMRImagePresenterExclModeConfig_Vtbl, 0xe6f7ce40_4673_44f1_8f77_5499d68cb4ea);
impl core::ops::Deref for IVMRImagePresenterExclModeConfig {
    type Target = IVMRImagePresenterConfig;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVMRImagePresenterExclModeConfig, windows_core::IUnknown, IVMRImagePresenterConfig);
impl IVMRImagePresenterExclModeConfig {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetXlcModeDDObjAndPrimarySurface<P0, P1>(&self, lpddobj: P0, lpprimarysurf: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw7>,
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface7>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetXlcModeDDObjAndPrimarySurface)(windows_core::Interface::as_raw(self), lpddobj.param().abi(), lpprimarysurf.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetXlcModeDDObjAndPrimarySurface(&self, lpddobj: *mut Option<super::super::Graphics::DirectDraw::IDirectDraw7>, lpprimarysurf: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetXlcModeDDObjAndPrimarySurface)(windows_core::Interface::as_raw(self), core::mem::transmute(lpddobj), core::mem::transmute(lpprimarysurf)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRImagePresenterExclModeConfig_Vtbl {
    pub base__: IVMRImagePresenterConfig_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetXlcModeDDObjAndPrimarySurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetXlcModeDDObjAndPrimarySurface: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetXlcModeDDObjAndPrimarySurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetXlcModeDDObjAndPrimarySurface: usize,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRImagePresenterExclModeConfig_Impl: IVMRImagePresenterConfig_Impl {
    fn SetXlcModeDDObjAndPrimarySurface(&self, lpddobj: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw7>, lpprimarysurf: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()>;
    fn GetXlcModeDDObjAndPrimarySurface(&self, lpddobj: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDraw7>, lpprimarysurf: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRImagePresenterExclModeConfig_Vtbl {
    pub const fn new<Identity: IVMRImagePresenterExclModeConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetXlcModeDDObjAndPrimarySurface<Identity: IVMRImagePresenterExclModeConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpddobj: *mut core::ffi::c_void, lpprimarysurf: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenterExclModeConfig_Impl::SetXlcModeDDObjAndPrimarySurface(this, core::mem::transmute_copy(&lpddobj), core::mem::transmute_copy(&lpprimarysurf)).into()
            }
        }
        unsafe extern "system" fn GetXlcModeDDObjAndPrimarySurface<Identity: IVMRImagePresenterExclModeConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpddobj: *mut *mut core::ffi::c_void, lpprimarysurf: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRImagePresenterExclModeConfig_Impl::GetXlcModeDDObjAndPrimarySurface(this, core::mem::transmute_copy(&lpddobj), core::mem::transmute_copy(&lpprimarysurf)).into()
            }
        }
        Self {
            base__: IVMRImagePresenterConfig_Vtbl::new::<Identity, OFFSET>(),
            SetXlcModeDDObjAndPrimarySurface: SetXlcModeDDObjAndPrimarySurface::<Identity, OFFSET>,
            GetXlcModeDDObjAndPrimarySurface: GetXlcModeDDObjAndPrimarySurface::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRImagePresenterExclModeConfig as windows_core::Interface>::IID || iid == &<IVMRImagePresenterConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVMRImagePresenterExclModeConfig {}
windows_core::imp::define_interface!(IVMRMixerBitmap, IVMRMixerBitmap_Vtbl, 0x1e673275_0257_40aa_af20_7c608d4a0428);
windows_core::imp::interface_hierarchy!(IVMRMixerBitmap, windows_core::IUnknown);
impl IVMRMixerBitmap {
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn SetAlphaBitmap(&self, pbmpparms: *const VMRALPHABITMAP) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAlphaBitmap)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const VMRALPHABITMAP) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UpdateAlphaBitmapParameters)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn GetAlphaBitmapParameters(&self, pbmpparms: *mut VMRALPHABITMAP) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAlphaBitmapParameters)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMixerBitmap_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub SetAlphaBitmap: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMRALPHABITMAP) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    SetAlphaBitmap: usize,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub UpdateAlphaBitmapParameters: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMRALPHABITMAP) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    UpdateAlphaBitmapParameters: usize,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub GetAlphaBitmapParameters: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMRALPHABITMAP) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    GetAlphaBitmapParameters: usize,
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMixerBitmap_Impl: windows_core::IUnknownImpl {
    fn SetAlphaBitmap(&self, pbmpparms: *const VMRALPHABITMAP) -> windows_core::Result<()>;
    fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const VMRALPHABITMAP) -> windows_core::Result<()>;
    fn GetAlphaBitmapParameters(&self, pbmpparms: *mut VMRALPHABITMAP) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRMixerBitmap_Vtbl {
    pub const fn new<Identity: IVMRMixerBitmap_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAlphaBitmap<Identity: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const VMRALPHABITMAP) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap_Impl::SetAlphaBitmap(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Identity: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const VMRALPHABITMAP) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap_Impl::UpdateAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Identity: IVMRMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *mut VMRALPHABITMAP) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap_Impl::GetAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Identity, OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Identity, OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMixerBitmap as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IVMRMixerBitmap {}
windows_core::imp::define_interface!(IVMRMixerBitmap9, IVMRMixerBitmap9_Vtbl, 0xced175e5_1935_4820_81bd_ff6ad00c9108);
windows_core::imp::interface_hierarchy!(IVMRMixerBitmap9, windows_core::IUnknown);
impl IVMRMixerBitmap9 {
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn SetAlphaBitmap(&self, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAlphaBitmap)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UpdateAlphaBitmapParameters)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn GetAlphaBitmapParameters(&self, pbmpparms: *mut VMR9AlphaBitmap) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAlphaBitmapParameters)(windows_core::Interface::as_raw(self), core::mem::transmute(pbmpparms)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMixerBitmap9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub SetAlphaBitmap: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMR9AlphaBitmap) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    SetAlphaBitmap: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub UpdateAlphaBitmapParameters: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMR9AlphaBitmap) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    UpdateAlphaBitmapParameters: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub GetAlphaBitmapParameters: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMR9AlphaBitmap) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    GetAlphaBitmapParameters: usize,
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRMixerBitmap9_Impl: windows_core::IUnknownImpl {
    fn SetAlphaBitmap(&self, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::Result<()>;
    fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::Result<()>;
    fn GetAlphaBitmapParameters(&self, pbmpparms: *mut VMR9AlphaBitmap) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IVMRMixerBitmap9_Vtbl {
    pub const fn new<Identity: IVMRMixerBitmap9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAlphaBitmap<Identity: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap9_Impl::SetAlphaBitmap(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Identity: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const VMR9AlphaBitmap) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap9_Impl::UpdateAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Identity: IVMRMixerBitmap9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *mut VMR9AlphaBitmap) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerBitmap9_Impl::GetAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Identity, OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Identity, OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMixerBitmap9 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IVMRMixerBitmap9 {}
windows_core::imp::define_interface!(IVMRMixerControl, IVMRMixerControl_Vtbl, 0x1c1a17b0_bed0_415d_974b_dc6696131599);
windows_core::imp::interface_hierarchy!(IVMRMixerControl, windows_core::IUnknown);
impl IVMRMixerControl {
    pub unsafe fn SetAlpha(&self, dwstreamid: u32, alpha: f32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAlpha)(windows_core::Interface::as_raw(self), dwstreamid, alpha).ok() }
    }
    pub unsafe fn GetAlpha(&self, dwstreamid: u32) -> windows_core::Result<f32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAlpha)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetZOrder(&self, dwstreamid: u32, dwz: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetZOrder)(windows_core::Interface::as_raw(self), dwstreamid, dwz).ok() }
    }
    pub unsafe fn GetZOrder(&self, dwstreamid: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetZOrder)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOutputRect(&self, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputRect)(windows_core::Interface::as_raw(self), dwstreamid, prect).ok() }
    }
    pub unsafe fn GetOutputRect(&self, dwstreamid: u32) -> windows_core::Result<NORMALIZEDRECT> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetOutputRect)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBackgroundClr(&self, clrbkg: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBackgroundClr)(windows_core::Interface::as_raw(self), clrbkg).ok() }
    }
    pub unsafe fn GetBackgroundClr(&self, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBackgroundClr)(windows_core::Interface::as_raw(self), lpclrbkg).ok() }
    }
    pub unsafe fn SetMixingPrefs(&self, dwmixerprefs: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMixingPrefs)(windows_core::Interface::as_raw(self), dwmixerprefs).ok() }
    }
    pub unsafe fn GetMixingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMixingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMixerControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetAlpha: unsafe extern "system" fn(*mut core::ffi::c_void, u32, f32) -> windows_core::HRESULT,
    pub GetAlpha: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut f32) -> windows_core::HRESULT,
    pub SetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub GetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub SetOutputRect: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const NORMALIZEDRECT) -> windows_core::HRESULT,
    pub GetOutputRect: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut NORMALIZEDRECT) -> windows_core::HRESULT,
    pub SetBackgroundClr: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub GetBackgroundClr: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub SetMixingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMixingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVMRMixerControl_Impl: windows_core::IUnknownImpl {
    fn SetAlpha(&self, dwstreamid: u32, alpha: f32) -> windows_core::Result<()>;
    fn GetAlpha(&self, dwstreamid: u32) -> windows_core::Result<f32>;
    fn SetZOrder(&self, dwstreamid: u32, dwz: u32) -> windows_core::Result<()>;
    fn GetZOrder(&self, dwstreamid: u32) -> windows_core::Result<u32>;
    fn SetOutputRect(&self, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> windows_core::Result<()>;
    fn GetOutputRect(&self, dwstreamid: u32) -> windows_core::Result<NORMALIZEDRECT>;
    fn SetBackgroundClr(&self, clrbkg: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBackgroundClr(&self, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn SetMixingPrefs(&self, dwmixerprefs: u32) -> windows_core::Result<()>;
    fn GetMixingPrefs(&self) -> windows_core::Result<u32>;
}
impl IVMRMixerControl_Vtbl {
    pub const fn new<Identity: IVMRMixerControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAlpha<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, alpha: f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::SetAlpha(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&alpha)).into()
            }
        }
        unsafe extern "system" fn GetAlpha<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl_Impl::GetAlpha(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        palpha.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetZOrder<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, dwz: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::SetZOrder(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&dwz)).into()
            }
        }
        unsafe extern "system" fn GetZOrder<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl_Impl::GetZOrder(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        pz.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputRect<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, prect: *const NORMALIZEDRECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::SetOutputRect(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&prect)).into()
            }
        }
        unsafe extern "system" fn GetOutputRect<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, prect: *mut NORMALIZEDRECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl_Impl::GetOutputRect(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        prect.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBackgroundClr<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clrbkg: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::SetBackgroundClr(this, core::mem::transmute_copy(&clrbkg)).into()
            }
        }
        unsafe extern "system" fn GetBackgroundClr<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::GetBackgroundClr(this, core::mem::transmute_copy(&lpclrbkg)).into()
            }
        }
        unsafe extern "system" fn SetMixingPrefs<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmixerprefs: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl_Impl::SetMixingPrefs(this, core::mem::transmute_copy(&dwmixerprefs)).into()
            }
        }
        unsafe extern "system" fn GetMixingPrefs<Identity: IVMRMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmixerprefs: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl_Impl::GetMixingPrefs(this) {
                    Ok(ok__) => {
                        pdwmixerprefs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAlpha: SetAlpha::<Identity, OFFSET>,
            GetAlpha: GetAlpha::<Identity, OFFSET>,
            SetZOrder: SetZOrder::<Identity, OFFSET>,
            GetZOrder: GetZOrder::<Identity, OFFSET>,
            SetOutputRect: SetOutputRect::<Identity, OFFSET>,
            GetOutputRect: GetOutputRect::<Identity, OFFSET>,
            SetBackgroundClr: SetBackgroundClr::<Identity, OFFSET>,
            GetBackgroundClr: GetBackgroundClr::<Identity, OFFSET>,
            SetMixingPrefs: SetMixingPrefs::<Identity, OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMixerControl as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRMixerControl {}
windows_core::imp::define_interface!(IVMRMixerControl9, IVMRMixerControl9_Vtbl, 0x1a777eaa_47c8_4930_b2c9_8fee1c1b0f3b);
windows_core::imp::interface_hierarchy!(IVMRMixerControl9, windows_core::IUnknown);
impl IVMRMixerControl9 {
    pub unsafe fn SetAlpha(&self, dwstreamid: u32, alpha: f32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAlpha)(windows_core::Interface::as_raw(self), dwstreamid, alpha).ok() }
    }
    pub unsafe fn GetAlpha(&self, dwstreamid: u32) -> windows_core::Result<f32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAlpha)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetZOrder(&self, dwstreamid: u32, dwz: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetZOrder)(windows_core::Interface::as_raw(self), dwstreamid, dwz).ok() }
    }
    pub unsafe fn GetZOrder(&self, dwstreamid: u32) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetZOrder)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOutputRect(&self, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOutputRect)(windows_core::Interface::as_raw(self), dwstreamid, prect).ok() }
    }
    pub unsafe fn GetOutputRect(&self, dwstreamid: u32) -> windows_core::Result<VMR9NormalizedRect> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetOutputRect)(windows_core::Interface::as_raw(self), dwstreamid, &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBackgroundClr(&self, clrbkg: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBackgroundClr)(windows_core::Interface::as_raw(self), clrbkg).ok() }
    }
    pub unsafe fn GetBackgroundClr(&self, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetBackgroundClr)(windows_core::Interface::as_raw(self), lpclrbkg).ok() }
    }
    pub unsafe fn SetMixingPrefs(&self, dwmixerprefs: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMixingPrefs)(windows_core::Interface::as_raw(self), dwmixerprefs).ok() }
    }
    pub unsafe fn GetMixingPrefs(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMixingPrefs)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetProcAmpControl(&self, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetProcAmpControl)(windows_core::Interface::as_raw(self), dwstreamid, lpclrcontrol).ok() }
    }
    pub unsafe fn GetProcAmpControl(&self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetProcAmpControl)(windows_core::Interface::as_raw(self), dwstreamid, lpclrcontrol as _).ok() }
    }
    pub unsafe fn GetProcAmpControlRange(&self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetProcAmpControlRange)(windows_core::Interface::as_raw(self), dwstreamid, lpclrcontrol as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMixerControl9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetAlpha: unsafe extern "system" fn(*mut core::ffi::c_void, u32, f32) -> windows_core::HRESULT,
    pub GetAlpha: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut f32) -> windows_core::HRESULT,
    pub SetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32) -> windows_core::HRESULT,
    pub GetZOrder: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut u32) -> windows_core::HRESULT,
    pub SetOutputRect: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const VMR9NormalizedRect) -> windows_core::HRESULT,
    pub GetOutputRect: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut VMR9NormalizedRect) -> windows_core::HRESULT,
    pub SetBackgroundClr: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub GetBackgroundClr: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub SetMixingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMixingPrefs: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetProcAmpControl: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *const VMR9ProcAmpControl) -> windows_core::HRESULT,
    pub GetProcAmpControl: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut VMR9ProcAmpControl) -> windows_core::HRESULT,
    pub GetProcAmpControlRange: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut VMR9ProcAmpControlRange) -> windows_core::HRESULT,
}
pub trait IVMRMixerControl9_Impl: windows_core::IUnknownImpl {
    fn SetAlpha(&self, dwstreamid: u32, alpha: f32) -> windows_core::Result<()>;
    fn GetAlpha(&self, dwstreamid: u32) -> windows_core::Result<f32>;
    fn SetZOrder(&self, dwstreamid: u32, dwz: u32) -> windows_core::Result<()>;
    fn GetZOrder(&self, dwstreamid: u32) -> windows_core::Result<u32>;
    fn SetOutputRect(&self, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> windows_core::Result<()>;
    fn GetOutputRect(&self, dwstreamid: u32) -> windows_core::Result<VMR9NormalizedRect>;
    fn SetBackgroundClr(&self, clrbkg: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBackgroundClr(&self, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn SetMixingPrefs(&self, dwmixerprefs: u32) -> windows_core::Result<()>;
    fn GetMixingPrefs(&self) -> windows_core::Result<u32>;
    fn SetProcAmpControl(&self, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> windows_core::Result<()>;
    fn GetProcAmpControl(&self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> windows_core::Result<()>;
    fn GetProcAmpControlRange(&self, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> windows_core::Result<()>;
}
impl IVMRMixerControl9_Vtbl {
    pub const fn new<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAlpha<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, alpha: f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetAlpha(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&alpha)).into()
            }
        }
        unsafe extern "system" fn GetAlpha<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, palpha: *mut f32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl9_Impl::GetAlpha(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        palpha.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetZOrder<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, dwz: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetZOrder(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&dwz)).into()
            }
        }
        unsafe extern "system" fn GetZOrder<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pz: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl9_Impl::GetZOrder(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        pz.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOutputRect<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, prect: *const VMR9NormalizedRect) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetOutputRect(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&prect)).into()
            }
        }
        unsafe extern "system" fn GetOutputRect<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, prect: *mut VMR9NormalizedRect) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl9_Impl::GetOutputRect(this, core::mem::transmute_copy(&dwstreamid)) {
                    Ok(ok__) => {
                        prect.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBackgroundClr<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clrbkg: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetBackgroundClr(this, core::mem::transmute_copy(&clrbkg)).into()
            }
        }
        unsafe extern "system" fn GetBackgroundClr<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclrbkg: *const super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::GetBackgroundClr(this, core::mem::transmute_copy(&lpclrbkg)).into()
            }
        }
        unsafe extern "system" fn SetMixingPrefs<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmixerprefs: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetMixingPrefs(this, core::mem::transmute_copy(&dwmixerprefs)).into()
            }
        }
        unsafe extern "system" fn GetMixingPrefs<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmixerprefs: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMixerControl9_Impl::GetMixingPrefs(this) {
                    Ok(ok__) => {
                        pdwmixerprefs.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetProcAmpControl<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *const VMR9ProcAmpControl) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::SetProcAmpControl(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&lpclrcontrol)).into()
            }
        }
        unsafe extern "system" fn GetProcAmpControl<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControl) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::GetProcAmpControl(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&lpclrcontrol)).into()
            }
        }
        unsafe extern "system" fn GetProcAmpControlRange<Identity: IVMRMixerControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, lpclrcontrol: *mut VMR9ProcAmpControlRange) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMixerControl9_Impl::GetProcAmpControlRange(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&lpclrcontrol)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAlpha: SetAlpha::<Identity, OFFSET>,
            GetAlpha: GetAlpha::<Identity, OFFSET>,
            SetZOrder: SetZOrder::<Identity, OFFSET>,
            GetZOrder: GetZOrder::<Identity, OFFSET>,
            SetOutputRect: SetOutputRect::<Identity, OFFSET>,
            GetOutputRect: GetOutputRect::<Identity, OFFSET>,
            SetBackgroundClr: SetBackgroundClr::<Identity, OFFSET>,
            GetBackgroundClr: GetBackgroundClr::<Identity, OFFSET>,
            SetMixingPrefs: SetMixingPrefs::<Identity, OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Identity, OFFSET>,
            SetProcAmpControl: SetProcAmpControl::<Identity, OFFSET>,
            GetProcAmpControl: GetProcAmpControl::<Identity, OFFSET>,
            GetProcAmpControlRange: GetProcAmpControlRange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMixerControl9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRMixerControl9 {}
windows_core::imp::define_interface!(IVMRMonitorConfig, IVMRMonitorConfig_Vtbl, 0x9cf0b1b6_fbaa_4b7f_88cf_cf1f130a0dce);
windows_core::imp::interface_hierarchy!(IVMRMonitorConfig, windows_core::IUnknown);
impl IVMRMonitorConfig {
    pub unsafe fn SetMonitor(&self, pguid: *const VMRGUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMonitor)(windows_core::Interface::as_raw(self), pguid).ok() }
    }
    pub unsafe fn GetMonitor(&self, pguid: *mut VMRGUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMonitor)(windows_core::Interface::as_raw(self), pguid as _).ok() }
    }
    pub unsafe fn SetDefaultMonitor(&self, pguid: *const VMRGUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefaultMonitor)(windows_core::Interface::as_raw(self), pguid).ok() }
    }
    pub unsafe fn GetDefaultMonitor(&self, pguid: *mut VMRGUID) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDefaultMonitor)(windows_core::Interface::as_raw(self), pguid as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetAvailableMonitors(&self, pinfo: &mut [VMRMONITORINFO], pdwnumdevices: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAvailableMonitors)(windows_core::Interface::as_raw(self), core::mem::transmute(pinfo.as_ptr()), pinfo.len().try_into().unwrap(), pdwnumdevices as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMonitorConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMRGUID) -> windows_core::HRESULT,
    pub GetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMRGUID) -> windows_core::HRESULT,
    pub SetDefaultMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMRGUID) -> windows_core::HRESULT,
    pub GetDefaultMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMRGUID) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetAvailableMonitors: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMRMONITORINFO, u32, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetAvailableMonitors: usize,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IVMRMonitorConfig_Impl: windows_core::IUnknownImpl {
    fn SetMonitor(&self, pguid: *const VMRGUID) -> windows_core::Result<()>;
    fn GetMonitor(&self, pguid: *mut VMRGUID) -> windows_core::Result<()>;
    fn SetDefaultMonitor(&self, pguid: *const VMRGUID) -> windows_core::Result<()>;
    fn GetDefaultMonitor(&self, pguid: *mut VMRGUID) -> windows_core::Result<()>;
    fn GetAvailableMonitors(&self, pinfo: *mut VMRMONITORINFO, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IVMRMonitorConfig_Vtbl {
    pub const fn new<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetMonitor<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const VMRGUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig_Impl::SetMonitor(this, core::mem::transmute_copy(&pguid)).into()
            }
        }
        unsafe extern "system" fn GetMonitor<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *mut VMRGUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig_Impl::GetMonitor(this, core::mem::transmute_copy(&pguid)).into()
            }
        }
        unsafe extern "system" fn SetDefaultMonitor<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *const VMRGUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig_Impl::SetDefaultMonitor(this, core::mem::transmute_copy(&pguid)).into()
            }
        }
        unsafe extern "system" fn GetDefaultMonitor<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguid: *mut VMRGUID) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig_Impl::GetDefaultMonitor(this, core::mem::transmute_copy(&pguid)).into()
            }
        }
        unsafe extern "system" fn GetAvailableMonitors<Identity: IVMRMonitorConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinfo: *mut VMRMONITORINFO, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig_Impl::GetAvailableMonitors(this, core::mem::transmute_copy(&pinfo), core::mem::transmute_copy(&dwmaxinfoarraysize), core::mem::transmute_copy(&pdwnumdevices)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMonitor: SetMonitor::<Identity, OFFSET>,
            GetMonitor: GetMonitor::<Identity, OFFSET>,
            SetDefaultMonitor: SetDefaultMonitor::<Identity, OFFSET>,
            GetDefaultMonitor: GetDefaultMonitor::<Identity, OFFSET>,
            GetAvailableMonitors: GetAvailableMonitors::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMonitorConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IVMRMonitorConfig {}
windows_core::imp::define_interface!(IVMRMonitorConfig9, IVMRMonitorConfig9_Vtbl, 0x46c2e457_8ba0_4eef_b80b_0680f0978749);
windows_core::imp::interface_hierarchy!(IVMRMonitorConfig9, windows_core::IUnknown);
impl IVMRMonitorConfig9 {
    pub unsafe fn SetMonitor(&self, udev: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMonitor)(windows_core::Interface::as_raw(self), udev).ok() }
    }
    pub unsafe fn GetMonitor(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetMonitor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetDefaultMonitor(&self, udev: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDefaultMonitor)(windows_core::Interface::as_raw(self), udev).ok() }
    }
    pub unsafe fn GetDefaultMonitor(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetDefaultMonitor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetAvailableMonitors(&self, pinfo: &mut [VMR9MonitorInfo], pdwnumdevices: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetAvailableMonitors)(windows_core::Interface::as_raw(self), core::mem::transmute(pinfo.as_ptr()), pinfo.len().try_into().unwrap(), pdwnumdevices as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRMonitorConfig9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetDefaultMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetDefaultMonitor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetAvailableMonitors: unsafe extern "system" fn(*mut core::ffi::c_void, *mut VMR9MonitorInfo, u32, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetAvailableMonitors: usize,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IVMRMonitorConfig9_Impl: windows_core::IUnknownImpl {
    fn SetMonitor(&self, udev: u32) -> windows_core::Result<()>;
    fn GetMonitor(&self) -> windows_core::Result<u32>;
    fn SetDefaultMonitor(&self, udev: u32) -> windows_core::Result<()>;
    fn GetDefaultMonitor(&self) -> windows_core::Result<u32>;
    fn GetAvailableMonitors(&self, pinfo: *mut VMR9MonitorInfo, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IVMRMonitorConfig9_Vtbl {
    pub const fn new<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetMonitor<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, udev: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig9_Impl::SetMonitor(this, core::mem::transmute_copy(&udev)).into()
            }
        }
        unsafe extern "system" fn GetMonitor<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pudev: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMonitorConfig9_Impl::GetMonitor(this) {
                    Ok(ok__) => {
                        pudev.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDefaultMonitor<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, udev: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig9_Impl::SetDefaultMonitor(this, core::mem::transmute_copy(&udev)).into()
            }
        }
        unsafe extern "system" fn GetDefaultMonitor<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pudev: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRMonitorConfig9_Impl::GetDefaultMonitor(this) {
                    Ok(ok__) => {
                        pudev.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetAvailableMonitors<Identity: IVMRMonitorConfig9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinfo: *mut VMR9MonitorInfo, dwmaxinfoarraysize: u32, pdwnumdevices: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRMonitorConfig9_Impl::GetAvailableMonitors(this, core::mem::transmute_copy(&pinfo), core::mem::transmute_copy(&dwmaxinfoarraysize), core::mem::transmute_copy(&pdwnumdevices)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMonitor: SetMonitor::<Identity, OFFSET>,
            GetMonitor: GetMonitor::<Identity, OFFSET>,
            SetDefaultMonitor: SetDefaultMonitor::<Identity, OFFSET>,
            GetDefaultMonitor: GetDefaultMonitor::<Identity, OFFSET>,
            GetAvailableMonitors: GetAvailableMonitors::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRMonitorConfig9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IVMRMonitorConfig9 {}
windows_core::imp::define_interface!(IVMRSurface, IVMRSurface_Vtbl, 0xa9849bbe_9ec8_4263_b764_62730f0d15d0);
windows_core::imp::interface_hierarchy!(IVMRSurface, windows_core::IUnknown);
impl IVMRSurface {
    pub unsafe fn IsSurfaceLocked(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsSurfaceLocked)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn LockSurface(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).LockSurface)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn UnlockSurface(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnlockSurface)(windows_core::Interface::as_raw(self)).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetSurface(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface7> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSurface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurface_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub IsSurfaceLocked: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LockSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub UnlockSurface: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetSurface: usize,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRSurface_Impl: windows_core::IUnknownImpl {
    fn IsSurfaceLocked(&self) -> windows_core::Result<()>;
    fn LockSurface(&self) -> windows_core::Result<*mut u8>;
    fn UnlockSurface(&self) -> windows_core::Result<()>;
    fn GetSurface(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface7>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRSurface_Vtbl {
    pub const fn new<Identity: IVMRSurface_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn IsSurfaceLocked<Identity: IVMRSurface_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurface_Impl::IsSurfaceLocked(this).into()
            }
        }
        unsafe extern "system" fn LockSurface<Identity: IVMRSurface_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsurface: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRSurface_Impl::LockSurface(this) {
                    Ok(ok__) => {
                        lpsurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn UnlockSurface<Identity: IVMRSurface_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurface_Impl::UnlockSurface(this).into()
            }
        }
        unsafe extern "system" fn GetSurface<Identity: IVMRSurface_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplpsurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRSurface_Impl::GetSurface(this) {
                    Ok(ok__) => {
                        lplpsurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsSurfaceLocked: IsSurfaceLocked::<Identity, OFFSET>,
            LockSurface: LockSurface::<Identity, OFFSET>,
            UnlockSurface: UnlockSurface::<Identity, OFFSET>,
            GetSurface: GetSurface::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurface as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVMRSurface {}
windows_core::imp::define_interface!(IVMRSurface9, IVMRSurface9_Vtbl, 0xdfc581a1_6e1f_4c3a_8d0a_5e9792ea2afc);
windows_core::imp::interface_hierarchy!(IVMRSurface9, windows_core::IUnknown);
impl IVMRSurface9 {
    pub unsafe fn IsSurfaceLocked(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsSurfaceLocked)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn LockSurface(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).LockSurface)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn UnlockSurface(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).UnlockSurface)(windows_core::Interface::as_raw(self)).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetSurface(&self) -> windows_core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSurface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurface9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub IsSurfaceLocked: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub LockSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub UnlockSurface: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetSurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetSurface: usize,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IVMRSurface9_Impl: windows_core::IUnknownImpl {
    fn IsSurfaceLocked(&self) -> windows_core::Result<()>;
    fn LockSurface(&self) -> windows_core::Result<*mut u8>;
    fn UnlockSurface(&self) -> windows_core::Result<()>;
    fn GetSurface(&self) -> windows_core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IVMRSurface9_Vtbl {
    pub const fn new<Identity: IVMRSurface9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn IsSurfaceLocked<Identity: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurface9_Impl::IsSurfaceLocked(this).into()
            }
        }
        unsafe extern "system" fn LockSurface<Identity: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsurface: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRSurface9_Impl::LockSurface(this) {
                    Ok(ok__) => {
                        lpsurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn UnlockSurface<Identity: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurface9_Impl::UnlockSurface(this).into()
            }
        }
        unsafe extern "system" fn GetSurface<Identity: IVMRSurface9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lplpsurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRSurface9_Impl::GetSurface(this) {
                    Ok(ok__) => {
                        lplpsurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsSurfaceLocked: IsSurfaceLocked::<Identity, OFFSET>,
            LockSurface: LockSurface::<Identity, OFFSET>,
            UnlockSurface: UnlockSurface::<Identity, OFFSET>,
            GetSurface: GetSurface::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurface9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IVMRSurface9 {}
windows_core::imp::define_interface!(IVMRSurfaceAllocator, IVMRSurfaceAllocator_Vtbl, 0x31ce832e_4484_458b_8cca_f4d7e3db0b52);
windows_core::imp::interface_hierarchy!(IVMRSurfaceAllocator, windows_core::IUnknown);
impl IVMRSurfaceAllocator {
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn AllocateSurface(&self, dwuserid: usize, lpallocinfo: *const VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: *mut Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AllocateSurface)(windows_core::Interface::as_raw(self), dwuserid, lpallocinfo, lpdwactualbuffers as _, core::mem::transmute(lplpsurface)).ok() }
    }
    pub unsafe fn FreeSurface(&self, dwid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).FreeSurface)(windows_core::Interface::as_raw(self), dwid).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn PrepareSurface<P1>(&self, dwuserid: usize, lpsurface: P1, dwsurfaceflags: u32) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDrawSurface7>,
    {
        unsafe { (windows_core::Interface::vtable(self).PrepareSurface)(windows_core::Interface::as_raw(self), dwuserid, lpsurface.param().abi(), dwsurfaceflags).ok() }
    }
    pub unsafe fn AdviseNotify<P0>(&self, lpivmrsurfallocnotify: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IVMRSurfaceAllocatorNotify>,
    {
        unsafe { (windows_core::Interface::vtable(self).AdviseNotify)(windows_core::Interface::as_raw(self), lpivmrsurfallocnotify.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurfaceAllocator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub AllocateSurface: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *const VMRALLOCATIONINFO, *mut u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    AllocateSurface: usize,
    pub FreeSurface: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub PrepareSurface: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    PrepareSurface: usize,
    pub AdviseNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocator_Impl: windows_core::IUnknownImpl {
    fn AllocateSurface(&self, dwuserid: usize, lpallocinfo: *const VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: windows_core::OutRef<super::super::Graphics::DirectDraw::IDirectDrawSurface7>) -> windows_core::Result<()>;
    fn FreeSurface(&self, dwid: usize) -> windows_core::Result<()>;
    fn PrepareSurface(&self, dwuserid: usize, lpsurface: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDrawSurface7>, dwsurfaceflags: u32) -> windows_core::Result<()>;
    fn AdviseNotify(&self, lpivmrsurfallocnotify: windows_core::Ref<IVMRSurfaceAllocatorNotify>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocator_Vtbl {
    pub const fn new<Identity: IVMRSurfaceAllocator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AllocateSurface<Identity: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lpallocinfo: *const VMRALLOCATIONINFO, lpdwactualbuffers: *mut u32, lplpsurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator_Impl::AllocateSurface(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lpallocinfo), core::mem::transmute_copy(&lpdwactualbuffers), core::mem::transmute_copy(&lplpsurface)).into()
            }
        }
        unsafe extern "system" fn FreeSurface<Identity: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator_Impl::FreeSurface(this, core::mem::transmute_copy(&dwid)).into()
            }
        }
        unsafe extern "system" fn PrepareSurface<Identity: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lpsurface: *mut core::ffi::c_void, dwsurfaceflags: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator_Impl::PrepareSurface(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lpsurface), core::mem::transmute_copy(&dwsurfaceflags)).into()
            }
        }
        unsafe extern "system" fn AdviseNotify<Identity: IVMRSurfaceAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpivmrsurfallocnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator_Impl::AdviseNotify(this, core::mem::transmute_copy(&lpivmrsurfallocnotify)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AllocateSurface: AllocateSurface::<Identity, OFFSET>,
            FreeSurface: FreeSurface::<Identity, OFFSET>,
            PrepareSurface: PrepareSurface::<Identity, OFFSET>,
            AdviseNotify: AdviseNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IVMRSurfaceAllocator {}
windows_core::imp::define_interface!(IVMRSurfaceAllocator9, IVMRSurfaceAllocator9_Vtbl, 0x8d5148ea_3f5d_46cf_9df1_d1b896eedb1f);
windows_core::imp::interface_hierarchy!(IVMRSurfaceAllocator9, windows_core::IUnknown);
impl IVMRSurfaceAllocator9 {
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn InitializeDevice(&self, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InitializeDevice)(windows_core::Interface::as_raw(self), dwuserid, lpallocinfo, lpnumbuffers as _).ok() }
    }
    pub unsafe fn TerminateDevice(&self, dwid: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).TerminateDevice)(windows_core::Interface::as_raw(self), dwid).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetSurface(&self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32) -> windows_core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetSurface)(windows_core::Interface::as_raw(self), dwuserid, surfaceindex, surfaceflags, &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn AdviseNotify<P0>(&self, lpivmrsurfallocnotify: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IVMRSurfaceAllocatorNotify9>,
    {
        unsafe { (windows_core::Interface::vtable(self).AdviseNotify)(windows_core::Interface::as_raw(self), lpivmrsurfallocnotify.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurfaceAllocator9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub InitializeDevice: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *const VMR9AllocationInfo, *mut u32) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    InitializeDevice: usize,
    pub TerminateDevice: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetSurface: unsafe extern "system" fn(*mut core::ffi::c_void, usize, u32, u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetSurface: usize,
    pub AdviseNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IVMRSurfaceAllocator9_Impl: windows_core::IUnknownImpl {
    fn InitializeDevice(&self, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> windows_core::Result<()>;
    fn TerminateDevice(&self, dwid: usize) -> windows_core::Result<()>;
    fn GetSurface(&self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32) -> windows_core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9>;
    fn AdviseNotify(&self, lpivmrsurfallocnotify: windows_core::Ref<IVMRSurfaceAllocatorNotify9>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IVMRSurfaceAllocator9_Vtbl {
    pub const fn new<Identity: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InitializeDevice<Identity: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator9_Impl::InitializeDevice(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lpallocinfo), core::mem::transmute_copy(&lpnumbuffers)).into()
            }
        }
        unsafe extern "system" fn TerminateDevice<Identity: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwid: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator9_Impl::TerminateDevice(this, core::mem::transmute_copy(&dwid)).into()
            }
        }
        unsafe extern "system" fn GetSurface<Identity: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRSurfaceAllocator9_Impl::GetSurface(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&surfaceindex), core::mem::transmute_copy(&surfaceflags)) {
                    Ok(ok__) => {
                        lplpsurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AdviseNotify<Identity: IVMRSurfaceAllocator9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpivmrsurfallocnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocator9_Impl::AdviseNotify(this, core::mem::transmute_copy(&lpivmrsurfallocnotify)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitializeDevice: InitializeDevice::<Identity, OFFSET>,
            TerminateDevice: TerminateDevice::<Identity, OFFSET>,
            GetSurface: GetSurface::<Identity, OFFSET>,
            AdviseNotify: AdviseNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocator9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IVMRSurfaceAllocator9 {}
windows_core::imp::define_interface!(IVMRSurfaceAllocatorEx9, IVMRSurfaceAllocatorEx9_Vtbl, 0x6de9a68a_a928_4522_bf57_655ae3866456);
impl core::ops::Deref for IVMRSurfaceAllocatorEx9 {
    type Target = IVMRSurfaceAllocator9;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVMRSurfaceAllocatorEx9, windows_core::IUnknown, IVMRSurfaceAllocator9);
impl IVMRSurfaceAllocatorEx9 {
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetSurfaceEx(&self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, lprcdst: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetSurfaceEx)(windows_core::Interface::as_raw(self), dwuserid, surfaceindex, surfaceflags, core::mem::transmute(lplpsurface), lprcdst as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurfaceAllocatorEx9_Vtbl {
    pub base__: IVMRSurfaceAllocator9_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetSurfaceEx: unsafe extern "system" fn(*mut core::ffi::c_void, usize, u32, u32, *mut *mut core::ffi::c_void, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetSurfaceEx: usize,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IVMRSurfaceAllocatorEx9_Impl: IVMRSurfaceAllocator9_Impl {
    fn GetSurfaceEx(&self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: windows_core::OutRef<super::super::Graphics::Direct3D9::IDirect3DSurface9>, lprcdst: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IVMRSurfaceAllocatorEx9_Vtbl {
    pub const fn new<Identity: IVMRSurfaceAllocatorEx9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetSurfaceEx<Identity: IVMRSurfaceAllocatorEx9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, surfaceindex: u32, surfaceflags: u32, lplpsurface: *mut *mut core::ffi::c_void, lprcdst: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorEx9_Impl::GetSurfaceEx(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&surfaceindex), core::mem::transmute_copy(&surfaceflags), core::mem::transmute_copy(&lplpsurface), core::mem::transmute_copy(&lprcdst)).into()
            }
        }
        Self { base__: IVMRSurfaceAllocator9_Vtbl::new::<Identity, OFFSET>(), GetSurfaceEx: GetSurfaceEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorEx9 as windows_core::Interface>::IID || iid == &<IVMRSurfaceAllocator9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IVMRSurfaceAllocatorEx9 {}
windows_core::imp::define_interface!(IVMRSurfaceAllocatorNotify, IVMRSurfaceAllocatorNotify_Vtbl, 0xaada05a8_5a4e_4729_af0b_cea27aed51e2);
windows_core::imp::interface_hierarchy!(IVMRSurfaceAllocatorNotify, windows_core::IUnknown);
impl IVMRSurfaceAllocatorNotify {
    pub unsafe fn AdviseSurfaceAllocator<P1>(&self, dwuserid: usize, lpivrmsurfaceallocator: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IVMRSurfaceAllocator>,
    {
        unsafe { (windows_core::Interface::vtable(self).AdviseSurfaceAllocator)(windows_core::Interface::as_raw(self), dwuserid, lpivrmsurfaceallocator.param().abi()).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn SetDDrawDevice<P0>(&self, lpddrawdevice: P0, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw7>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetDDrawDevice)(windows_core::Interface::as_raw(self), lpddrawdevice.param().abi(), hmonitor).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn ChangeDDrawDevice<P0>(&self, lpddrawdevice: P0, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::DirectDraw::IDirectDraw7>,
    {
        unsafe { (windows_core::Interface::vtable(self).ChangeDDrawDevice)(windows_core::Interface::as_raw(self), lpddrawdevice.param().abi(), hmonitor).ok() }
    }
    pub unsafe fn RestoreDDrawSurfaces(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RestoreDDrawSurfaces)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn NotifyEvent(&self, eventcode: i32, param1: isize, param2: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyEvent)(windows_core::Interface::as_raw(self), eventcode, param1, param2).ok() }
    }
    pub unsafe fn SetBorderColor(&self, clrborder: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBorderColor)(windows_core::Interface::as_raw(self), clrborder).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurfaceAllocatorNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AdviseSurfaceAllocator: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub SetDDrawDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    SetDDrawDevice: usize,
    #[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub ChangeDDrawDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi")))]
    ChangeDDrawDevice: usize,
    pub RestoreDDrawSurfaces: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub NotifyEvent: unsafe extern "system" fn(*mut core::ffi::c_void, i32, isize, isize) -> windows_core::HRESULT,
    pub SetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocatorNotify_Impl: windows_core::IUnknownImpl {
    fn AdviseSurfaceAllocator(&self, dwuserid: usize, lpivrmsurfaceallocator: windows_core::Ref<IVMRSurfaceAllocator>) -> windows_core::Result<()>;
    fn SetDDrawDevice(&self, lpddrawdevice: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw7>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>;
    fn ChangeDDrawDevice(&self, lpddrawdevice: windows_core::Ref<super::super::Graphics::DirectDraw::IDirectDraw7>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>;
    fn RestoreDDrawSurfaces(&self) -> windows_core::Result<()>;
    fn NotifyEvent(&self, eventcode: i32, param1: isize, param2: isize) -> windows_core::Result<()>;
    fn SetBorderColor(&self, clrborder: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocatorNotify_Vtbl {
    pub const fn new<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AdviseSurfaceAllocator<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::AdviseSurfaceAllocator(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lpivrmsurfaceallocator)).into()
            }
        }
        unsafe extern "system" fn SetDDrawDevice<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpddrawdevice: *mut core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::SetDDrawDevice(this, core::mem::transmute_copy(&lpddrawdevice), core::mem::transmute_copy(&hmonitor)).into()
            }
        }
        unsafe extern "system" fn ChangeDDrawDevice<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpddrawdevice: *mut core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::ChangeDDrawDevice(this, core::mem::transmute_copy(&lpddrawdevice), core::mem::transmute_copy(&hmonitor)).into()
            }
        }
        unsafe extern "system" fn RestoreDDrawSurfaces<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::RestoreDDrawSurfaces(this).into()
            }
        }
        unsafe extern "system" fn NotifyEvent<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::NotifyEvent(this, core::mem::transmute_copy(&eventcode), core::mem::transmute_copy(&param1), core::mem::transmute_copy(&param2)).into()
            }
        }
        unsafe extern "system" fn SetBorderColor<Identity: IVMRSurfaceAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clrborder: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify_Impl::SetBorderColor(this, core::mem::transmute_copy(&clrborder)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AdviseSurfaceAllocator: AdviseSurfaceAllocator::<Identity, OFFSET>,
            SetDDrawDevice: SetDDrawDevice::<Identity, OFFSET>,
            ChangeDDrawDevice: ChangeDDrawDevice::<Identity, OFFSET>,
            RestoreDDrawSurfaces: RestoreDDrawSurfaces::<Identity, OFFSET>,
            NotifyEvent: NotifyEvent::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorNotify as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IVMRSurfaceAllocatorNotify {}
windows_core::imp::define_interface!(IVMRSurfaceAllocatorNotify9, IVMRSurfaceAllocatorNotify9_Vtbl, 0xdca3f5df_bb3a_4d03_bd81_84614bfbfa0c);
windows_core::imp::interface_hierarchy!(IVMRSurfaceAllocatorNotify9, windows_core::IUnknown);
impl IVMRSurfaceAllocatorNotify9 {
    pub unsafe fn AdviseSurfaceAllocator<P1>(&self, dwuserid: usize, lpivrmsurfaceallocator: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<IVMRSurfaceAllocator9>,
    {
        unsafe { (windows_core::Interface::vtable(self).AdviseSurfaceAllocator)(windows_core::Interface::as_raw(self), dwuserid, lpivrmsurfaceallocator.param().abi()).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn SetD3DDevice<P0>(&self, lpd3ddevice: P0, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::Direct3D9::IDirect3DDevice9>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetD3DDevice)(windows_core::Interface::as_raw(self), lpd3ddevice.param().abi(), hmonitor).ok() }
    }
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn ChangeD3DDevice<P0>(&self, lpd3ddevice: P0, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Graphics::Direct3D9::IDirect3DDevice9>,
    {
        unsafe { (windows_core::Interface::vtable(self).ChangeD3DDevice)(windows_core::Interface::as_raw(self), lpd3ddevice.param().abi(), hmonitor).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn AllocateSurfaceHelper(&self, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).AllocateSurfaceHelper)(windows_core::Interface::as_raw(self), lpallocinfo, lpnumbuffers as _, core::mem::transmute(lplpsurface)).ok() }
    }
    pub unsafe fn NotifyEvent(&self, eventcode: i32, param1: isize, param2: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyEvent)(windows_core::Interface::as_raw(self), eventcode, param1, param2).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRSurfaceAllocatorNotify9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub AdviseSurfaceAllocator: unsafe extern "system" fn(*mut core::ffi::c_void, usize, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub SetD3DDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    SetD3DDevice: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub ChangeD3DDevice: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    ChangeD3DDevice: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub AllocateSurfaceHelper: unsafe extern "system" fn(*mut core::ffi::c_void, *const VMR9AllocationInfo, *mut u32, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    AllocateSurfaceHelper: usize,
    pub NotifyEvent: unsafe extern "system" fn(*mut core::ffi::c_void, i32, isize, isize) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IVMRSurfaceAllocatorNotify9_Impl: windows_core::IUnknownImpl {
    fn AdviseSurfaceAllocator(&self, dwuserid: usize, lpivrmsurfaceallocator: windows_core::Ref<IVMRSurfaceAllocator9>) -> windows_core::Result<()>;
    fn SetD3DDevice(&self, lpd3ddevice: windows_core::Ref<super::super::Graphics::Direct3D9::IDirect3DDevice9>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>;
    fn ChangeD3DDevice(&self, lpd3ddevice: windows_core::Ref<super::super::Graphics::Direct3D9::IDirect3DDevice9>, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::Result<()>;
    fn AllocateSurfaceHelper(&self, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: windows_core::OutRef<super::super::Graphics::Direct3D9::IDirect3DSurface9>) -> windows_core::Result<()>;
    fn NotifyEvent(&self, eventcode: i32, param1: isize, param2: isize) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IVMRSurfaceAllocatorNotify9_Vtbl {
    pub const fn new<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AdviseSurfaceAllocator<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserid: usize, lpivrmsurfaceallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify9_Impl::AdviseSurfaceAllocator(this, core::mem::transmute_copy(&dwuserid), core::mem::transmute_copy(&lpivrmsurfaceallocator)).into()
            }
        }
        unsafe extern "system" fn SetD3DDevice<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpd3ddevice: *mut core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify9_Impl::SetD3DDevice(this, core::mem::transmute_copy(&lpd3ddevice), core::mem::transmute_copy(&hmonitor)).into()
            }
        }
        unsafe extern "system" fn ChangeD3DDevice<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpd3ddevice: *mut core::ffi::c_void, hmonitor: super::super::Graphics::Gdi::HMONITOR) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify9_Impl::ChangeD3DDevice(this, core::mem::transmute_copy(&lpd3ddevice), core::mem::transmute_copy(&hmonitor)).into()
            }
        }
        unsafe extern "system" fn AllocateSurfaceHelper<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32, lplpsurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify9_Impl::AllocateSurfaceHelper(this, core::mem::transmute_copy(&lpallocinfo), core::mem::transmute_copy(&lpnumbuffers), core::mem::transmute_copy(&lplpsurface)).into()
            }
        }
        unsafe extern "system" fn NotifyEvent<Identity: IVMRSurfaceAllocatorNotify9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eventcode: i32, param1: isize, param2: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRSurfaceAllocatorNotify9_Impl::NotifyEvent(this, core::mem::transmute_copy(&eventcode), core::mem::transmute_copy(&param1), core::mem::transmute_copy(&param2)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AdviseSurfaceAllocator: AdviseSurfaceAllocator::<Identity, OFFSET>,
            SetD3DDevice: SetD3DDevice::<Identity, OFFSET>,
            ChangeD3DDevice: ChangeD3DDevice::<Identity, OFFSET>,
            AllocateSurfaceHelper: AllocateSurfaceHelper::<Identity, OFFSET>,
            NotifyEvent: NotifyEvent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRSurfaceAllocatorNotify9 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IVMRSurfaceAllocatorNotify9 {}
windows_core::imp::define_interface!(IVMRVideoStreamControl, IVMRVideoStreamControl_Vtbl, 0x058d1f11_2a54_4bef_bd54_df706626b727);
windows_core::imp::interface_hierarchy!(IVMRVideoStreamControl, windows_core::IUnknown);
impl IVMRVideoStreamControl {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn SetColorKey(&self, lpclrkey: *const super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetColorKey)(windows_core::Interface::as_raw(self), lpclrkey).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetColorKey(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::DDCOLORKEY> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetColorKey)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetStreamActiveState(&self, factive: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamActiveState)(windows_core::Interface::as_raw(self), factive.into()).ok() }
    }
    pub unsafe fn GetStreamActiveState(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStreamActiveState)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRVideoStreamControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub SetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    SetColorKey: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetColorKey: usize,
    pub SetStreamActiveState: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetStreamActiveState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVMRVideoStreamControl_Impl: windows_core::IUnknownImpl {
    fn SetColorKey(&self, lpclrkey: *const super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::Result<()>;
    fn GetColorKey(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::DDCOLORKEY>;
    fn SetStreamActiveState(&self, factive: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetStreamActiveState(&self) -> windows_core::Result<windows_core::BOOL>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVMRVideoStreamControl_Vtbl {
    pub const fn new<Identity: IVMRVideoStreamControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetColorKey<Identity: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclrkey: *const super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRVideoStreamControl_Impl::SetColorKey(this, core::mem::transmute_copy(&lpclrkey)).into()
            }
        }
        unsafe extern "system" fn GetColorKey<Identity: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclrkey: *mut super::super::Graphics::DirectDraw::DDCOLORKEY) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRVideoStreamControl_Impl::GetColorKey(this) {
                    Ok(ok__) => {
                        lpclrkey.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStreamActiveState<Identity: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, factive: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRVideoStreamControl_Impl::SetStreamActiveState(this, core::mem::transmute_copy(&factive)).into()
            }
        }
        unsafe extern "system" fn GetStreamActiveState<Identity: IVMRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpfactive: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRVideoStreamControl_Impl::GetStreamActiveState(this) {
                    Ok(ok__) => {
                        lpfactive.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetColorKey: SetColorKey::<Identity, OFFSET>,
            GetColorKey: GetColorKey::<Identity, OFFSET>,
            SetStreamActiveState: SetStreamActiveState::<Identity, OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRVideoStreamControl as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVMRVideoStreamControl {}
windows_core::imp::define_interface!(IVMRVideoStreamControl9, IVMRVideoStreamControl9_Vtbl, 0xd0cfe38b_93e7_4772_8957_0400c49a4485);
windows_core::imp::interface_hierarchy!(IVMRVideoStreamControl9, windows_core::IUnknown);
impl IVMRVideoStreamControl9 {
    pub unsafe fn SetStreamActiveState(&self, factive: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetStreamActiveState)(windows_core::Interface::as_raw(self), factive.into()).ok() }
    }
    pub unsafe fn GetStreamActiveState(&self) -> windows_core::Result<windows_core::BOOL> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetStreamActiveState)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRVideoStreamControl9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetStreamActiveState: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetStreamActiveState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IVMRVideoStreamControl9_Impl: windows_core::IUnknownImpl {
    fn SetStreamActiveState(&self, factive: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetStreamActiveState(&self) -> windows_core::Result<windows_core::BOOL>;
}
impl IVMRVideoStreamControl9_Vtbl {
    pub const fn new<Identity: IVMRVideoStreamControl9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetStreamActiveState<Identity: IVMRVideoStreamControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, factive: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRVideoStreamControl9_Impl::SetStreamActiveState(this, core::mem::transmute_copy(&factive)).into()
            }
        }
        unsafe extern "system" fn GetStreamActiveState<Identity: IVMRVideoStreamControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpfactive: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRVideoStreamControl9_Impl::GetStreamActiveState(this) {
                    Ok(ok__) => {
                        lpfactive.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetStreamActiveState: SetStreamActiveState::<Identity, OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRVideoStreamControl9 as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVMRVideoStreamControl9 {}
windows_core::imp::define_interface!(IVMRWindowlessControl, IVMRWindowlessControl_Vtbl, 0x0eb1088c_4dcd_46f0_878f_39dae86a51b7);
windows_core::imp::interface_hierarchy!(IVMRWindowlessControl, windows_core::IUnknown);
impl IVMRWindowlessControl {
    pub unsafe fn GetNativeVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNativeVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _, lparwidth as _, lparheight as _).ok() }
    }
    pub unsafe fn GetMinIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMinIdealVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _).ok() }
    }
    pub unsafe fn GetMaxIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMaxIdealVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _).ok() }
    }
    pub unsafe fn SetVideoPosition(&self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoPosition)(windows_core::Interface::as_raw(self), lpsrcrect, lpdstrect).ok() }
    }
    pub unsafe fn GetVideoPosition(&self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoPosition)(windows_core::Interface::as_raw(self), lpsrcrect as _, lpdstrect as _).ok() }
    }
    pub unsafe fn GetAspectRatioMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAspectRatioMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAspectRatioMode(&self, aspectratiomode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAspectRatioMode)(windows_core::Interface::as_raw(self), aspectratiomode).ok() }
    }
    pub unsafe fn SetVideoClippingWindow(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoClippingWindow)(windows_core::Interface::as_raw(self), hwnd).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn RepaintVideo(&self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RepaintVideo)(windows_core::Interface::as_raw(self), hwnd, hdc).ok() }
    }
    pub unsafe fn DisplayModeChanged(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DisplayModeChanged)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetCurrentImage(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentImage)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBorderColor)(windows_core::Interface::as_raw(self), clr).ok() }
    }
    pub unsafe fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetBorderColor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetColorKey(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetColorKey)(windows_core::Interface::as_raw(self), clr).ok() }
    }
    pub unsafe fn GetColorKey(&self) -> windows_core::Result<super::super::Foundation::COLORREF> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetColorKey)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRWindowlessControl_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNativeVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMinIdealVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMaxIdealVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetVideoPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub GetVideoPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::RECT, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub GetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetVideoClippingWindow: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub RepaintVideo: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND, super::super::Graphics::Gdi::HDC) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    RepaintVideo: usize,
    pub DisplayModeChanged: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetCurrentImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub SetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub GetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub SetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub GetColorKey: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IVMRWindowlessControl_Impl: windows_core::IUnknownImpl {
    fn GetNativeVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::Result<()>;
    fn GetMinIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()>;
    fn GetMaxIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()>;
    fn SetVideoPosition(&self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetVideoPosition(&self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn SetAspectRatioMode(&self, aspectratiomode: u32) -> windows_core::Result<()>;
    fn SetVideoClippingWindow(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn RepaintVideo(&self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::Result<()>;
    fn DisplayModeChanged(&self) -> windows_core::Result<()>;
    fn GetCurrentImage(&self) -> windows_core::Result<*mut u8>;
    fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
    fn SetColorKey(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetColorKey(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IVMRWindowlessControl_Vtbl {
    pub const fn new<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNativeVideoSize<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::GetNativeVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight), core::mem::transmute_copy(&lparwidth), core::mem::transmute_copy(&lparheight)).into()
            }
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::GetMinIdealVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight)).into()
            }
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::GetMaxIdealVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight)).into()
            }
        }
        unsafe extern "system" fn SetVideoPosition<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::SetVideoPosition(this, core::mem::transmute_copy(&lpsrcrect), core::mem::transmute_copy(&lpdstrect)).into()
            }
        }
        unsafe extern "system" fn GetVideoPosition<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::GetVideoPosition(this, core::mem::transmute_copy(&lpsrcrect), core::mem::transmute_copy(&lpdstrect)).into()
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpaspectratiomode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl_Impl::GetAspectRatioMode(this) {
                    Ok(ok__) => {
                        lpaspectratiomode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, aspectratiomode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&aspectratiomode)).into()
            }
        }
        unsafe extern "system" fn SetVideoClippingWindow<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::SetVideoClippingWindow(this, core::mem::transmute_copy(&hwnd)).into()
            }
        }
        unsafe extern "system" fn RepaintVideo<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::RepaintVideo(this, core::mem::transmute_copy(&hwnd), core::mem::transmute_copy(&hdc)).into()
            }
        }
        unsafe extern "system" fn DisplayModeChanged<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::DisplayModeChanged(this).into()
            }
        }
        unsafe extern "system" fn GetCurrentImage<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdib: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl_Impl::GetCurrentImage(this) {
                    Ok(ok__) => {
                        lpdib.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBorderColor<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::SetBorderColor(this, core::mem::transmute_copy(&clr)).into()
            }
        }
        unsafe extern "system" fn GetBorderColor<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclr: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl_Impl::GetBorderColor(this) {
                    Ok(ok__) => {
                        lpclr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetColorKey<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl_Impl::SetColorKey(this, core::mem::transmute_copy(&clr)).into()
            }
        }
        unsafe extern "system" fn GetColorKey<Identity: IVMRWindowlessControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclr: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl_Impl::GetColorKey(this) {
                    Ok(ok__) => {
                        lpclr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Identity, OFFSET>,
            GetMinIdealVideoSize: GetMinIdealVideoSize::<Identity, OFFSET>,
            GetMaxIdealVideoSize: GetMaxIdealVideoSize::<Identity, OFFSET>,
            SetVideoPosition: SetVideoPosition::<Identity, OFFSET>,
            GetVideoPosition: GetVideoPosition::<Identity, OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
            SetVideoClippingWindow: SetVideoClippingWindow::<Identity, OFFSET>,
            RepaintVideo: RepaintVideo::<Identity, OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Identity, OFFSET>,
            GetCurrentImage: GetCurrentImage::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            GetBorderColor: GetBorderColor::<Identity, OFFSET>,
            SetColorKey: SetColorKey::<Identity, OFFSET>,
            GetColorKey: GetColorKey::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRWindowlessControl as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IVMRWindowlessControl {}
windows_core::imp::define_interface!(IVMRWindowlessControl9, IVMRWindowlessControl9_Vtbl, 0x8f537d09_f85e_4414_b23b_502e54c79927);
windows_core::imp::interface_hierarchy!(IVMRWindowlessControl9, windows_core::IUnknown);
impl IVMRWindowlessControl9 {
    pub unsafe fn GetNativeVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetNativeVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _, lparwidth as _, lparheight as _).ok() }
    }
    pub unsafe fn GetMinIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMinIdealVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _).ok() }
    }
    pub unsafe fn GetMaxIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMaxIdealVideoSize)(windows_core::Interface::as_raw(self), lpwidth as _, lpheight as _).ok() }
    }
    pub unsafe fn SetVideoPosition(&self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoPosition)(windows_core::Interface::as_raw(self), lpsrcrect, lpdstrect).ok() }
    }
    pub unsafe fn GetVideoPosition(&self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoPosition)(windows_core::Interface::as_raw(self), lpsrcrect as _, lpdstrect as _).ok() }
    }
    pub unsafe fn GetAspectRatioMode(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetAspectRatioMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAspectRatioMode(&self, aspectratiomode: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAspectRatioMode)(windows_core::Interface::as_raw(self), aspectratiomode).ok() }
    }
    pub unsafe fn SetVideoClippingWindow(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoClippingWindow)(windows_core::Interface::as_raw(self), hwnd).ok() }
    }
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn RepaintVideo(&self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RepaintVideo)(windows_core::Interface::as_raw(self), hwnd, hdc).ok() }
    }
    pub unsafe fn DisplayModeChanged(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).DisplayModeChanged)(windows_core::Interface::as_raw(self)).ok() }
    }
    pub unsafe fn GetCurrentImage(&self) -> windows_core::Result<*mut u8> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetCurrentImage)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBorderColor)(windows_core::Interface::as_raw(self), clr).ok() }
    }
    pub unsafe fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetBorderColor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVMRWindowlessControl9_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub GetNativeVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMinIdealVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMaxIdealVideoSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub SetVideoPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::super::Foundation::RECT, *const super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub GetVideoPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::RECT, *mut super::super::Foundation::RECT) -> windows_core::HRESULT,
    pub GetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetVideoClippingWindow: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub RepaintVideo: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::HWND, super::super::Graphics::Gdi::HDC) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    RepaintVideo: usize,
    pub DisplayModeChanged: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub GetCurrentImage: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut u8) -> windows_core::HRESULT,
    pub SetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, super::super::Foundation::COLORREF) -> windows_core::HRESULT,
    pub GetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IVMRWindowlessControl9_Impl: windows_core::IUnknownImpl {
    fn GetNativeVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::Result<()>;
    fn GetMinIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()>;
    fn GetMaxIdealVideoSize(&self, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::Result<()>;
    fn SetVideoPosition(&self, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetVideoPosition(&self, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn SetAspectRatioMode(&self, aspectratiomode: u32) -> windows_core::Result<()>;
    fn SetVideoClippingWindow(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn RepaintVideo(&self, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::Result<()>;
    fn DisplayModeChanged(&self) -> windows_core::Result<()>;
    fn GetCurrentImage(&self) -> windows_core::Result<*mut u8>;
    fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IVMRWindowlessControl9_Vtbl {
    pub const fn new<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetNativeVideoSize<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32, lparwidth: *mut i32, lparheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::GetNativeVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight), core::mem::transmute_copy(&lparwidth), core::mem::transmute_copy(&lparheight)).into()
            }
        }
        unsafe extern "system" fn GetMinIdealVideoSize<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::GetMinIdealVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight)).into()
            }
        }
        unsafe extern "system" fn GetMaxIdealVideoSize<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpwidth: *mut i32, lpheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::GetMaxIdealVideoSize(this, core::mem::transmute_copy(&lpwidth), core::mem::transmute_copy(&lpheight)).into()
            }
        }
        unsafe extern "system" fn SetVideoPosition<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsrcrect: *const super::super::Foundation::RECT, lpdstrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::SetVideoPosition(this, core::mem::transmute_copy(&lpsrcrect), core::mem::transmute_copy(&lpdstrect)).into()
            }
        }
        unsafe extern "system" fn GetVideoPosition<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpsrcrect: *mut super::super::Foundation::RECT, lpdstrect: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::GetVideoPosition(this, core::mem::transmute_copy(&lpsrcrect), core::mem::transmute_copy(&lpdstrect)).into()
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpaspectratiomode: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl9_Impl::GetAspectRatioMode(this) {
                    Ok(ok__) => {
                        lpaspectratiomode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, aspectratiomode: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&aspectratiomode)).into()
            }
        }
        unsafe extern "system" fn SetVideoClippingWindow<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::SetVideoClippingWindow(this, core::mem::transmute_copy(&hwnd)).into()
            }
        }
        unsafe extern "system" fn RepaintVideo<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND, hdc: super::super::Graphics::Gdi::HDC) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::RepaintVideo(this, core::mem::transmute_copy(&hwnd), core::mem::transmute_copy(&hdc)).into()
            }
        }
        unsafe extern "system" fn DisplayModeChanged<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::DisplayModeChanged(this).into()
            }
        }
        unsafe extern "system" fn GetCurrentImage<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdib: *mut *mut u8) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl9_Impl::GetCurrentImage(this) {
                    Ok(ok__) => {
                        lpdib.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBorderColor<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVMRWindowlessControl9_Impl::SetBorderColor(this, core::mem::transmute_copy(&clr)).into()
            }
        }
        unsafe extern "system" fn GetBorderColor<Identity: IVMRWindowlessControl9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclr: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVMRWindowlessControl9_Impl::GetBorderColor(this) {
                    Ok(ok__) => {
                        lpclr.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Identity, OFFSET>,
            GetMinIdealVideoSize: GetMinIdealVideoSize::<Identity, OFFSET>,
            GetMaxIdealVideoSize: GetMaxIdealVideoSize::<Identity, OFFSET>,
            SetVideoPosition: SetVideoPosition::<Identity, OFFSET>,
            GetVideoPosition: GetVideoPosition::<Identity, OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
            SetVideoClippingWindow: SetVideoClippingWindow::<Identity, OFFSET>,
            RepaintVideo: RepaintVideo::<Identity, OFFSET>,
            DisplayModeChanged: DisplayModeChanged::<Identity, OFFSET>,
            GetCurrentImage: GetCurrentImage::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            GetBorderColor: GetBorderColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVMRWindowlessControl9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IVMRWindowlessControl9 {}
windows_core::imp::define_interface!(IVPBaseConfig, IVPBaseConfig_Vtbl, 0);
windows_core::imp::interface_hierarchy!(IVPBaseConfig, windows_core::IUnknown);
impl IVPBaseConfig {
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetConnectInfo(&self, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: Option<*mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetConnectInfo)(windows_core::Interface::as_raw(self), pdwnumconnectinfo as _, pddvpconnectinfo.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn SetConnectInfo(&self, dwchosenentry: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetConnectInfo)(windows_core::Interface::as_raw(self), dwchosenentry).ok() }
    }
    pub unsafe fn GetVPDataInfo(&self, pamvpdatainfo: *mut AMVPDATAINFO) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVPDataInfo)(windows_core::Interface::as_raw(self), pamvpdatainfo as _).ok() }
    }
    pub unsafe fn GetMaxPixelRate(&self, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMaxPixelRate)(windows_core::Interface::as_raw(self), pamvpsize as _, pdwmaxpixelspersecond as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn InformVPInputFormats(&self, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).InformVPInputFormats)(windows_core::Interface::as_raw(self), dwnumformats, pddpixelformats as _).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetVideoFormats(&self, pdwnumformats: *mut u32, pddpixelformats: Option<*mut super::super::Graphics::DirectDraw::DDPIXELFORMAT>) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVideoFormats)(windows_core::Interface::as_raw(self), pdwnumformats as _, pddpixelformats.unwrap_or(core::mem::zeroed()) as _).ok() }
    }
    pub unsafe fn SetVideoFormat(&self, dwchosenentry: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoFormat)(windows_core::Interface::as_raw(self), dwchosenentry).ok() }
    }
    pub unsafe fn SetInvertPolarity(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetInvertPolarity)(windows_core::Interface::as_raw(self)).ok() }
    }
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetOverlaySurface(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetOverlaySurface)(windows_core::Interface::as_raw(self), &mut result__).and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub unsafe fn SetDirectDrawKernelHandle(&self, dwddkernelhandle: usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDirectDrawKernelHandle)(windows_core::Interface::as_raw(self), dwddkernelhandle).ok() }
    }
    pub unsafe fn SetVideoPortID(&self, dwvideoportid: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoPortID)(windows_core::Interface::as_raw(self), dwvideoportid).ok() }
    }
    pub unsafe fn SetDDSurfaceKernelHandles(&self, chandles: u32, rgddkernelhandles: *mut usize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDDSurfaceKernelHandles)(windows_core::Interface::as_raw(self), chandles, rgddkernelhandles as _).ok() }
    }
    pub unsafe fn SetSurfaceParameters(&self, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetSurfaceParameters)(windows_core::Interface::as_raw(self), dwpitch, dwxorigin, dwyorigin).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPBaseConfig_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetConnectInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetConnectInfo: usize,
    pub SetConnectInfo: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetVPDataInfo: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AMVPDATAINFO) -> windows_core::HRESULT,
    pub GetMaxPixelRate: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AMVPSIZE, *mut u32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub InformVPInputFormats: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    InformVPInputFormats: usize,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetVideoFormats: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32, *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetVideoFormats: usize,
    pub SetVideoFormat: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetInvertPolarity: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub GetOverlaySurface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_DirectDraw"))]
    GetOverlaySurface: usize,
    pub SetDirectDrawKernelHandle: unsafe extern "system" fn(*mut core::ffi::c_void, usize) -> windows_core::HRESULT,
    pub SetVideoPortID: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub SetDDSurfaceKernelHandles: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut usize) -> windows_core::HRESULT,
    pub SetSurfaceParameters: unsafe extern "system" fn(*mut core::ffi::c_void, u32, u32, u32) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVPBaseConfig_Impl: windows_core::IUnknownImpl {
    fn GetConnectInfo(&self, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> windows_core::Result<()>;
    fn SetConnectInfo(&self, dwchosenentry: u32) -> windows_core::Result<()>;
    fn GetVPDataInfo(&self, pamvpdatainfo: *mut AMVPDATAINFO) -> windows_core::Result<()>;
    fn GetMaxPixelRate(&self, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> windows_core::Result<()>;
    fn InformVPInputFormats(&self, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::Result<()>;
    fn GetVideoFormats(&self, pdwnumformats: *mut u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::Result<()>;
    fn SetVideoFormat(&self, dwchosenentry: u32) -> windows_core::Result<()>;
    fn SetInvertPolarity(&self) -> windows_core::Result<()>;
    fn GetOverlaySurface(&self) -> windows_core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface>;
    fn SetDirectDrawKernelHandle(&self, dwddkernelhandle: usize) -> windows_core::Result<()>;
    fn SetVideoPortID(&self, dwvideoportid: u32) -> windows_core::Result<()>;
    fn SetDDSurfaceKernelHandles(&self, chandles: u32, rgddkernelhandles: *mut usize) -> windows_core::Result<()>;
    fn SetSurfaceParameters(&self, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVPBaseConfig_Vtbl {
    pub const fn new<Identity: IVPBaseConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetConnectInfo<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: *mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::GetConnectInfo(this, core::mem::transmute_copy(&pdwnumconnectinfo), core::mem::transmute_copy(&pddvpconnectinfo)).into()
            }
        }
        unsafe extern "system" fn SetConnectInfo<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwchosenentry: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetConnectInfo(this, core::mem::transmute_copy(&dwchosenentry)).into()
            }
        }
        unsafe extern "system" fn GetVPDataInfo<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pamvpdatainfo: *mut AMVPDATAINFO) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::GetVPDataInfo(this, core::mem::transmute_copy(&pamvpdatainfo)).into()
            }
        }
        unsafe extern "system" fn GetMaxPixelRate<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::GetMaxPixelRate(this, core::mem::transmute_copy(&pamvpsize), core::mem::transmute_copy(&pdwmaxpixelspersecond)).into()
            }
        }
        unsafe extern "system" fn InformVPInputFormats<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::InformVPInputFormats(this, core::mem::transmute_copy(&dwnumformats), core::mem::transmute_copy(&pddpixelformats)).into()
            }
        }
        unsafe extern "system" fn GetVideoFormats<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumformats: *mut u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::GetVideoFormats(this, core::mem::transmute_copy(&pdwnumformats), core::mem::transmute_copy(&pddpixelformats)).into()
            }
        }
        unsafe extern "system" fn SetVideoFormat<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwchosenentry: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetVideoFormat(this, core::mem::transmute_copy(&dwchosenentry)).into()
            }
        }
        unsafe extern "system" fn SetInvertPolarity<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetInvertPolarity(this).into()
            }
        }
        unsafe extern "system" fn GetOverlaySurface<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppddoverlaysurface: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVPBaseConfig_Impl::GetOverlaySurface(this) {
                    Ok(ok__) => {
                        ppddoverlaysurface.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetDirectDrawKernelHandle<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwddkernelhandle: usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetDirectDrawKernelHandle(this, core::mem::transmute_copy(&dwddkernelhandle)).into()
            }
        }
        unsafe extern "system" fn SetVideoPortID<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwvideoportid: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetVideoPortID(this, core::mem::transmute_copy(&dwvideoportid)).into()
            }
        }
        unsafe extern "system" fn SetDDSurfaceKernelHandles<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, chandles: u32, rgddkernelhandles: *mut usize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetDDSurfaceKernelHandles(this, core::mem::transmute_copy(&chandles), core::mem::transmute_copy(&rgddkernelhandles)).into()
            }
        }
        unsafe extern "system" fn SetSurfaceParameters<Identity: IVPBaseConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseConfig_Impl::SetSurfaceParameters(this, core::mem::transmute_copy(&dwpitch), core::mem::transmute_copy(&dwxorigin), core::mem::transmute_copy(&dwyorigin)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetConnectInfo: GetConnectInfo::<Identity, OFFSET>,
            SetConnectInfo: SetConnectInfo::<Identity, OFFSET>,
            GetVPDataInfo: GetVPDataInfo::<Identity, OFFSET>,
            GetMaxPixelRate: GetMaxPixelRate::<Identity, OFFSET>,
            InformVPInputFormats: InformVPInputFormats::<Identity, OFFSET>,
            GetVideoFormats: GetVideoFormats::<Identity, OFFSET>,
            SetVideoFormat: SetVideoFormat::<Identity, OFFSET>,
            SetInvertPolarity: SetInvertPolarity::<Identity, OFFSET>,
            GetOverlaySurface: GetOverlaySurface::<Identity, OFFSET>,
            SetDirectDrawKernelHandle: SetDirectDrawKernelHandle::<Identity, OFFSET>,
            SetVideoPortID: SetVideoPortID::<Identity, OFFSET>,
            SetDDSurfaceKernelHandles: SetDDSurfaceKernelHandles::<Identity, OFFSET>,
            SetSurfaceParameters: SetSurfaceParameters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPBaseConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVPBaseConfig {}
windows_core::imp::define_interface!(IVPBaseNotify, IVPBaseNotify_Vtbl, 0);
windows_core::imp::interface_hierarchy!(IVPBaseNotify, windows_core::IUnknown);
impl IVPBaseNotify {
    pub unsafe fn RenegotiateVPParameters(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).RenegotiateVPParameters)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPBaseNotify_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub RenegotiateVPParameters: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IVPBaseNotify_Impl: windows_core::IUnknownImpl {
    fn RenegotiateVPParameters(&self) -> windows_core::Result<()>;
}
impl IVPBaseNotify_Vtbl {
    pub const fn new<Identity: IVPBaseNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RenegotiateVPParameters<Identity: IVPBaseNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPBaseNotify_Impl::RenegotiateVPParameters(this).into()
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), RenegotiateVPParameters: RenegotiateVPParameters::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPBaseNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVPBaseNotify {}
windows_core::imp::define_interface!(IVPConfig, IVPConfig_Vtbl, 0xbc29a660_30e3_11d0_9e69_00c04fd7c15b);
impl core::ops::Deref for IVPConfig {
    type Target = IVPBaseConfig;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVPConfig, windows_core::IUnknown, IVPBaseConfig);
impl IVPConfig {
    pub unsafe fn IsVPDecimationAllowed(&self, pbisdecimationallowed: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).IsVPDecimationAllowed)(windows_core::Interface::as_raw(self), pbisdecimationallowed as _).ok() }
    }
    pub unsafe fn SetScalingFactors(&self, pamvpsize: *mut AMVPSIZE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetScalingFactors)(windows_core::Interface::as_raw(self), pamvpsize as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPConfig_Vtbl {
    pub base__: IVPBaseConfig_Vtbl,
    pub IsVPDecimationAllowed: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
    pub SetScalingFactors: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AMVPSIZE) -> windows_core::HRESULT,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVPConfig_Impl: IVPBaseConfig_Impl {
    fn IsVPDecimationAllowed(&self, pbisdecimationallowed: *mut windows_core::BOOL) -> windows_core::Result<()>;
    fn SetScalingFactors(&self, pamvpsize: *mut AMVPSIZE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVPConfig_Vtbl {
    pub const fn new<Identity: IVPConfig_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn IsVPDecimationAllowed<Identity: IVPConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbisdecimationallowed: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPConfig_Impl::IsVPDecimationAllowed(this, core::mem::transmute_copy(&pbisdecimationallowed)).into()
            }
        }
        unsafe extern "system" fn SetScalingFactors<Identity: IVPConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pamvpsize: *mut AMVPSIZE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPConfig_Impl::SetScalingFactors(this, core::mem::transmute_copy(&pamvpsize)).into()
            }
        }
        Self {
            base__: IVPBaseConfig_Vtbl::new::<Identity, OFFSET>(),
            IsVPDecimationAllowed: IsVPDecimationAllowed::<Identity, OFFSET>,
            SetScalingFactors: SetScalingFactors::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPConfig as windows_core::Interface>::IID || iid == &<IVPBaseConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVPConfig {}
windows_core::imp::define_interface!(IVPManager, IVPManager_Vtbl, 0xaac18c18_e186_46d2_825d_a1f8dc8e395a);
windows_core::imp::interface_hierarchy!(IVPManager, windows_core::IUnknown);
impl IVPManager {
    pub unsafe fn SetVideoPortIndex(&self, dwvideoportindex: u32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVideoPortIndex)(windows_core::Interface::as_raw(self), dwvideoportindex).ok() }
    }
    pub unsafe fn GetVideoPortIndex(&self) -> windows_core::Result<u32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).GetVideoPortIndex)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPManager_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetVideoPortIndex: unsafe extern "system" fn(*mut core::ffi::c_void, u32) -> windows_core::HRESULT,
    pub GetVideoPortIndex: unsafe extern "system" fn(*mut core::ffi::c_void, *mut u32) -> windows_core::HRESULT,
}
pub trait IVPManager_Impl: windows_core::IUnknownImpl {
    fn SetVideoPortIndex(&self, dwvideoportindex: u32) -> windows_core::Result<()>;
    fn GetVideoPortIndex(&self) -> windows_core::Result<u32>;
}
impl IVPManager_Vtbl {
    pub const fn new<Identity: IVPManager_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetVideoPortIndex<Identity: IVPManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwvideoportindex: u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPManager_Impl::SetVideoPortIndex(this, core::mem::transmute_copy(&dwvideoportindex)).into()
            }
        }
        unsafe extern "system" fn GetVideoPortIndex<Identity: IVPManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwvideoportindex: *mut u32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVPManager_Impl::GetVideoPortIndex(this) {
                    Ok(ok__) => {
                        pdwvideoportindex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetVideoPortIndex: SetVideoPortIndex::<Identity, OFFSET>,
            GetVideoPortIndex: GetVideoPortIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPManager as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVPManager {}
windows_core::imp::define_interface!(IVPNotify, IVPNotify_Vtbl, 0xc76794a1_d6c5_11d0_9e69_00c04fd7c15b);
impl core::ops::Deref for IVPNotify {
    type Target = IVPBaseNotify;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVPNotify, windows_core::IUnknown, IVPBaseNotify);
impl IVPNotify {
    pub unsafe fn SetDeinterlaceMode(&self, mode: AMVP_MODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetDeinterlaceMode)(windows_core::Interface::as_raw(self), mode).ok() }
    }
    pub unsafe fn GetDeinterlaceMode(&self, pmode: *mut AMVP_MODE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetDeinterlaceMode)(windows_core::Interface::as_raw(self), pmode as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPNotify_Vtbl {
    pub base__: IVPBaseNotify_Vtbl,
    pub SetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, AMVP_MODE) -> windows_core::HRESULT,
    pub GetDeinterlaceMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut AMVP_MODE) -> windows_core::HRESULT,
}
pub trait IVPNotify_Impl: IVPBaseNotify_Impl {
    fn SetDeinterlaceMode(&self, mode: AMVP_MODE) -> windows_core::Result<()>;
    fn GetDeinterlaceMode(&self, pmode: *mut AMVP_MODE) -> windows_core::Result<()>;
}
impl IVPNotify_Vtbl {
    pub const fn new<Identity: IVPNotify_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetDeinterlaceMode<Identity: IVPNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: AMVP_MODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPNotify_Impl::SetDeinterlaceMode(this, core::mem::transmute_copy(&mode)).into()
            }
        }
        unsafe extern "system" fn GetDeinterlaceMode<Identity: IVPNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut AMVP_MODE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPNotify_Impl::GetDeinterlaceMode(this, core::mem::transmute_copy(&pmode)).into()
            }
        }
        Self {
            base__: IVPBaseNotify_Vtbl::new::<Identity, OFFSET>(),
            SetDeinterlaceMode: SetDeinterlaceMode::<Identity, OFFSET>,
            GetDeinterlaceMode: GetDeinterlaceMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPNotify as windows_core::Interface>::IID || iid == &<IVPBaseNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVPNotify {}
windows_core::imp::define_interface!(IVPNotify2, IVPNotify2_Vtbl, 0xebf47183_8764_11d1_9e69_00c04fd7c15b);
impl core::ops::Deref for IVPNotify2 {
    type Target = IVPNotify;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVPNotify2, windows_core::IUnknown, IVPBaseNotify, IVPNotify);
impl IVPNotify2 {
    pub unsafe fn SetVPSyncMaster(&self, bvpsyncmaster: bool) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVPSyncMaster)(windows_core::Interface::as_raw(self), bvpsyncmaster.into()).ok() }
    }
    pub unsafe fn GetVPSyncMaster(&self, pbvpsyncmaster: *mut windows_core::BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetVPSyncMaster)(windows_core::Interface::as_raw(self), pbvpsyncmaster as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVPNotify2_Vtbl {
    pub base__: IVPNotify_Vtbl,
    pub SetVPSyncMaster: unsafe extern "system" fn(*mut core::ffi::c_void, windows_core::BOOL) -> windows_core::HRESULT,
    pub GetVPSyncMaster: unsafe extern "system" fn(*mut core::ffi::c_void, *mut windows_core::BOOL) -> windows_core::HRESULT,
}
pub trait IVPNotify2_Impl: IVPNotify_Impl {
    fn SetVPSyncMaster(&self, bvpsyncmaster: windows_core::BOOL) -> windows_core::Result<()>;
    fn GetVPSyncMaster(&self, pbvpsyncmaster: *mut windows_core::BOOL) -> windows_core::Result<()>;
}
impl IVPNotify2_Vtbl {
    pub const fn new<Identity: IVPNotify2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetVPSyncMaster<Identity: IVPNotify2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bvpsyncmaster: windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPNotify2_Impl::SetVPSyncMaster(this, core::mem::transmute_copy(&bvpsyncmaster)).into()
            }
        }
        unsafe extern "system" fn GetVPSyncMaster<Identity: IVPNotify2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbvpsyncmaster: *mut windows_core::BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVPNotify2_Impl::GetVPSyncMaster(this, core::mem::transmute_copy(&pbvpsyncmaster)).into()
            }
        }
        Self {
            base__: IVPNotify_Vtbl::new::<Identity, OFFSET>(),
            SetVPSyncMaster: SetVPSyncMaster::<Identity, OFFSET>,
            GetVPSyncMaster: GetVPSyncMaster::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPNotify2 as windows_core::Interface>::IID || iid == &<IVPBaseNotify as windows_core::Interface>::IID || iid == &<IVPNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVPNotify2 {}
windows_core::imp::define_interface!(IVPVBIConfig, IVPVBIConfig_Vtbl, 0xec529b00_1a1f_11d1_bad9_00609744111a);
impl core::ops::Deref for IVPVBIConfig {
    type Target = IVPBaseConfig;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVPVBIConfig, windows_core::IUnknown, IVPBaseConfig);
#[repr(C)]
#[doc(hidden)]
pub struct IVPVBIConfig_Vtbl {
    pub base__: IVPBaseConfig_Vtbl,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub trait IVPVBIConfig_Impl: IVPBaseConfig_Impl {}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl IVPVBIConfig_Vtbl {
    pub const fn new<Identity: IVPVBIConfig_Impl, const OFFSET: isize>() -> Self {
        Self { base__: IVPBaseConfig_Vtbl::new::<Identity, OFFSET>() }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPVBIConfig as windows_core::Interface>::IID || iid == &<IVPBaseConfig as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl windows_core::RuntimeName for IVPVBIConfig {}
windows_core::imp::define_interface!(IVPVBINotify, IVPVBINotify_Vtbl, 0xec529b01_1a1f_11d1_bad9_00609744111a);
impl core::ops::Deref for IVPVBINotify {
    type Target = IVPBaseNotify;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVPVBINotify, windows_core::IUnknown, IVPBaseNotify);
#[repr(C)]
#[doc(hidden)]
pub struct IVPVBINotify_Vtbl {
    pub base__: IVPBaseNotify_Vtbl,
}
pub trait IVPVBINotify_Impl: IVPBaseNotify_Impl {}
impl IVPVBINotify_Vtbl {
    pub const fn new<Identity: IVPVBINotify_Impl, const OFFSET: isize>() -> Self {
        Self { base__: IVPBaseNotify_Vtbl::new::<Identity, OFFSET>() }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVPVBINotify as windows_core::Interface>::IID || iid == &<IVPBaseNotify as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVPVBINotify {}
windows_core::imp::define_interface!(IVideoEncoder, IVideoEncoder_Vtbl, 0x02997c3b_8e1b_460e_9270_545e0de9563e);
impl core::ops::Deref for IVideoEncoder {
    type Target = IEncoderAPI;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
windows_core::imp::interface_hierarchy!(IVideoEncoder, windows_core::IUnknown, IEncoderAPI);
#[repr(C)]
#[doc(hidden)]
pub struct IVideoEncoder_Vtbl {
    pub base__: IEncoderAPI_Vtbl,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait IVideoEncoder_Impl: IEncoderAPI_Impl {}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl IVideoEncoder_Vtbl {
    pub const fn new<Identity: IVideoEncoder_Impl, const OFFSET: isize>() -> Self {
        Self { base__: IEncoderAPI_Vtbl::new::<Identity, OFFSET>() }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVideoEncoder as windows_core::Interface>::IID || iid == &<IEncoderAPI as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IVideoEncoder {}
windows_core::imp::define_interface!(IVideoFrameStep, IVideoFrameStep_Vtbl, 0xe46a9787_2b71_444d_a4b5_1fab7b708d6a);
windows_core::imp::interface_hierarchy!(IVideoFrameStep, windows_core::IUnknown);
impl IVideoFrameStep {
    pub unsafe fn Step<P1>(&self, dwframes: u32, pstepobject: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).Step)(windows_core::Interface::as_raw(self), dwframes, pstepobject.param().abi()).ok() }
    }
    pub unsafe fn CanStep<P1>(&self, bmultiple: i32, pstepobject: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<windows_core::IUnknown>,
    {
        unsafe { (windows_core::Interface::vtable(self).CanStep)(windows_core::Interface::as_raw(self), bmultiple, pstepobject.param().abi()).ok() }
    }
    pub unsafe fn CancelStep(&self) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).CancelStep)(windows_core::Interface::as_raw(self)).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVideoFrameStep_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub Step: unsafe extern "system" fn(*mut core::ffi::c_void, u32, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CanStep: unsafe extern "system" fn(*mut core::ffi::c_void, i32, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub CancelStep: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
pub trait IVideoFrameStep_Impl: windows_core::IUnknownImpl {
    fn Step(&self, dwframes: u32, pstepobject: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CanStep(&self, bmultiple: i32, pstepobject: windows_core::Ref<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CancelStep(&self) -> windows_core::Result<()>;
}
impl IVideoFrameStep_Vtbl {
    pub const fn new<Identity: IVideoFrameStep_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Step<Identity: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwframes: u32, pstepobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoFrameStep_Impl::Step(this, core::mem::transmute_copy(&dwframes), core::mem::transmute_copy(&pstepobject)).into()
            }
        }
        unsafe extern "system" fn CanStep<Identity: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bmultiple: i32, pstepobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoFrameStep_Impl::CanStep(this, core::mem::transmute_copy(&bmultiple), core::mem::transmute_copy(&pstepobject)).into()
            }
        }
        unsafe extern "system" fn CancelStep<Identity: IVideoFrameStep_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoFrameStep_Impl::CancelStep(this).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Step: Step::<Identity, OFFSET>,
            CanStep: CanStep::<Identity, OFFSET>,
            CancelStep: CancelStep::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVideoFrameStep as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVideoFrameStep {}
windows_core::imp::define_interface!(IVideoProcAmp, IVideoProcAmp_Vtbl, 0x4050560e_42a7_413a_85c2_09269a2d0f44);
windows_core::imp::interface_hierarchy!(IVideoProcAmp, windows_core::IUnknown);
impl IVideoProcAmp {
    pub unsafe fn get_BacklightCompensation(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_BacklightCompensation)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_BacklightCompensation(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_BacklightCompensation)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_BacklightCompensation(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_BacklightCompensation)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Brightness(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Brightness)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Brightness(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Brightness)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Brightness(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Brightness)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_ColorEnable(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_ColorEnable)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_ColorEnable(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_ColorEnable)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_ColorEnable(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_ColorEnable)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Contrast(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Contrast)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Contrast(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Contrast)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Contrast(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Contrast)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Gamma(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Gamma)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Gamma(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Gamma)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Gamma(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Gamma)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Saturation(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Saturation)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Saturation(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Saturation)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Saturation(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Saturation)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Sharpness(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Sharpness)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Sharpness(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Sharpness)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Sharpness(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Sharpness)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_WhiteBalance(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_WhiteBalance)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_WhiteBalance(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_WhiteBalance)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_WhiteBalance(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_WhiteBalance)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Gain(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Gain)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Gain(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Gain)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Gain(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Gain)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_Hue(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_Hue)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_Hue(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_Hue)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_Hue(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_Hue)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_DigitalMultiplier(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_DigitalMultiplier)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_DigitalMultiplier(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_DigitalMultiplier)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_DigitalMultiplier(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_DigitalMultiplier)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_PowerlineFrequency(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_PowerlineFrequency)(windows_core::Interface::as_raw(self), pvalue as _, pflags as _).ok() }
    }
    pub unsafe fn put_PowerlineFrequency(&self, value: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_PowerlineFrequency)(windows_core::Interface::as_raw(self), value, flags).ok() }
    }
    pub unsafe fn getRange_PowerlineFrequency(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_PowerlineFrequency)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
    pub unsafe fn get_WhiteBalanceComponent(&self, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).get_WhiteBalanceComponent)(windows_core::Interface::as_raw(self), pvalue1 as _, pvalue2 as _, pflags as _).ok() }
    }
    pub unsafe fn put_WhiteBalanceComponent(&self, value1: i32, value2: i32, flags: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).put_WhiteBalanceComponent)(windows_core::Interface::as_raw(self), value1, value2, flags).ok() }
    }
    pub unsafe fn getRange_WhiteBalanceComponent(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).getRange_WhiteBalanceComponent)(windows_core::Interface::as_raw(self), pmin as _, pmax as _, psteppingdelta as _, pdefault as _, pcapsflag as _).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVideoProcAmp_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub get_BacklightCompensation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_BacklightCompensation: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_BacklightCompensation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Brightness: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Brightness: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Brightness: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_ColorEnable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_ColorEnable: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_ColorEnable: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Contrast: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Contrast: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Contrast: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Gamma: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Gamma: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Gamma: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Saturation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Saturation: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Saturation: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Sharpness: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Sharpness: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Sharpness: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_WhiteBalance: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_WhiteBalance: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_WhiteBalance: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Gain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Gain: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Gain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_Hue: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_Hue: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_Hue: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_DigitalMultiplier: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_DigitalMultiplier: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_DigitalMultiplier: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_PowerlineFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_PowerlineFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32) -> windows_core::HRESULT,
    pub getRange_PowerlineFrequency: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub get_WhiteBalanceComponent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub put_WhiteBalanceComponent: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32) -> windows_core::HRESULT,
    pub getRange_WhiteBalanceComponent: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
}
pub trait IVideoProcAmp_Impl: windows_core::IUnknownImpl {
    fn get_BacklightCompensation(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_BacklightCompensation(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_BacklightCompensation(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Brightness(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Brightness(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Brightness(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_ColorEnable(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_ColorEnable(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_ColorEnable(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Contrast(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Contrast(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Contrast(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Gamma(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Gamma(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Gamma(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Saturation(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Saturation(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Saturation(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Sharpness(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Sharpness(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Sharpness(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_WhiteBalance(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_WhiteBalance(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_WhiteBalance(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Gain(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Gain(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Gain(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_Hue(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_Hue(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_Hue(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_DigitalMultiplier(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_DigitalMultiplier(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_DigitalMultiplier(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_PowerlineFrequency(&self, pvalue: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_PowerlineFrequency(&self, value: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_PowerlineFrequency(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
    fn get_WhiteBalanceComponent(&self, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> windows_core::Result<()>;
    fn put_WhiteBalanceComponent(&self, value1: i32, value2: i32, flags: i32) -> windows_core::Result<()>;
    fn getRange_WhiteBalanceComponent(&self, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::Result<()>;
}
impl IVideoProcAmp_Vtbl {
    pub const fn new<Identity: IVideoProcAmp_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn get_BacklightCompensation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_BacklightCompensation(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_BacklightCompensation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_BacklightCompensation(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_BacklightCompensation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_BacklightCompensation(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Brightness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Brightness(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Brightness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Brightness(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Brightness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Brightness(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_ColorEnable<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_ColorEnable(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_ColorEnable<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_ColorEnable(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_ColorEnable<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_ColorEnable(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Contrast<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Contrast(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Contrast<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Contrast(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Contrast<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Contrast(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Gamma<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Gamma(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Gamma<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Gamma(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Gamma<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Gamma(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Saturation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Saturation(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Saturation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Saturation(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Saturation<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Saturation(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Sharpness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Sharpness(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Sharpness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Sharpness(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Sharpness<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Sharpness(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_WhiteBalance<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_WhiteBalance(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_WhiteBalance<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_WhiteBalance(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_WhiteBalance<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_WhiteBalance(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Gain<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Gain(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Gain<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Gain(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Gain<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Gain(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_Hue<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_Hue(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_Hue<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_Hue(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_Hue<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_Hue(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_DigitalMultiplier<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_DigitalMultiplier(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_DigitalMultiplier<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_DigitalMultiplier(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_DigitalMultiplier<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_DigitalMultiplier(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_PowerlineFrequency<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_PowerlineFrequency(this, core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_PowerlineFrequency<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_PowerlineFrequency(this, core::mem::transmute_copy(&value), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_PowerlineFrequency<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_PowerlineFrequency(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        unsafe extern "system" fn get_WhiteBalanceComponent<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvalue1: *mut i32, pvalue2: *mut i32, pflags: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::get_WhiteBalanceComponent(this, core::mem::transmute_copy(&pvalue1), core::mem::transmute_copy(&pvalue2), core::mem::transmute_copy(&pflags)).into()
            }
        }
        unsafe extern "system" fn put_WhiteBalanceComponent<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value1: i32, value2: i32, flags: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::put_WhiteBalanceComponent(this, core::mem::transmute_copy(&value1), core::mem::transmute_copy(&value2), core::mem::transmute_copy(&flags)).into()
            }
        }
        unsafe extern "system" fn getRange_WhiteBalanceComponent<Identity: IVideoProcAmp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmin: *mut i32, pmax: *mut i32, psteppingdelta: *mut i32, pdefault: *mut i32, pcapsflag: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoProcAmp_Impl::getRange_WhiteBalanceComponent(this, core::mem::transmute_copy(&pmin), core::mem::transmute_copy(&pmax), core::mem::transmute_copy(&psteppingdelta), core::mem::transmute_copy(&pdefault), core::mem::transmute_copy(&pcapsflag)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_BacklightCompensation: get_BacklightCompensation::<Identity, OFFSET>,
            put_BacklightCompensation: put_BacklightCompensation::<Identity, OFFSET>,
            getRange_BacklightCompensation: getRange_BacklightCompensation::<Identity, OFFSET>,
            get_Brightness: get_Brightness::<Identity, OFFSET>,
            put_Brightness: put_Brightness::<Identity, OFFSET>,
            getRange_Brightness: getRange_Brightness::<Identity, OFFSET>,
            get_ColorEnable: get_ColorEnable::<Identity, OFFSET>,
            put_ColorEnable: put_ColorEnable::<Identity, OFFSET>,
            getRange_ColorEnable: getRange_ColorEnable::<Identity, OFFSET>,
            get_Contrast: get_Contrast::<Identity, OFFSET>,
            put_Contrast: put_Contrast::<Identity, OFFSET>,
            getRange_Contrast: getRange_Contrast::<Identity, OFFSET>,
            get_Gamma: get_Gamma::<Identity, OFFSET>,
            put_Gamma: put_Gamma::<Identity, OFFSET>,
            getRange_Gamma: getRange_Gamma::<Identity, OFFSET>,
            get_Saturation: get_Saturation::<Identity, OFFSET>,
            put_Saturation: put_Saturation::<Identity, OFFSET>,
            getRange_Saturation: getRange_Saturation::<Identity, OFFSET>,
            get_Sharpness: get_Sharpness::<Identity, OFFSET>,
            put_Sharpness: put_Sharpness::<Identity, OFFSET>,
            getRange_Sharpness: getRange_Sharpness::<Identity, OFFSET>,
            get_WhiteBalance: get_WhiteBalance::<Identity, OFFSET>,
            put_WhiteBalance: put_WhiteBalance::<Identity, OFFSET>,
            getRange_WhiteBalance: getRange_WhiteBalance::<Identity, OFFSET>,
            get_Gain: get_Gain::<Identity, OFFSET>,
            put_Gain: put_Gain::<Identity, OFFSET>,
            getRange_Gain: getRange_Gain::<Identity, OFFSET>,
            get_Hue: get_Hue::<Identity, OFFSET>,
            put_Hue: put_Hue::<Identity, OFFSET>,
            getRange_Hue: getRange_Hue::<Identity, OFFSET>,
            get_DigitalMultiplier: get_DigitalMultiplier::<Identity, OFFSET>,
            put_DigitalMultiplier: put_DigitalMultiplier::<Identity, OFFSET>,
            getRange_DigitalMultiplier: getRange_DigitalMultiplier::<Identity, OFFSET>,
            get_PowerlineFrequency: get_PowerlineFrequency::<Identity, OFFSET>,
            put_PowerlineFrequency: put_PowerlineFrequency::<Identity, OFFSET>,
            getRange_PowerlineFrequency: getRange_PowerlineFrequency::<Identity, OFFSET>,
            get_WhiteBalanceComponent: get_WhiteBalanceComponent::<Identity, OFFSET>,
            put_WhiteBalanceComponent: put_WhiteBalanceComponent::<Identity, OFFSET>,
            getRange_WhiteBalanceComponent: getRange_WhiteBalanceComponent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVideoProcAmp as windows_core::Interface>::IID
    }
}
impl windows_core::RuntimeName for IVideoProcAmp {}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::define_interface!(IVideoWindow, IVideoWindow_Vtbl, 0x56a868b4_0ad4_11ce_b03a_0020af0ba770);
#[cfg(feature = "Win32_System_Com")]
impl core::ops::Deref for IVideoWindow {
    type Target = super::super::System::Com::IDispatch;
    fn deref(&self) -> &Self::Target {
        unsafe { core::mem::transmute(self) }
    }
}
#[cfg(feature = "Win32_System_Com")]
windows_core::imp::interface_hierarchy!(IVideoWindow, windows_core::IUnknown, super::super::System::Com::IDispatch);
#[cfg(feature = "Win32_System_Com")]
impl IVideoWindow {
    pub unsafe fn SetCaption(&self, strcaption: &windows_core::BSTR) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetCaption)(windows_core::Interface::as_raw(self), core::mem::transmute_copy(strcaption)).ok() }
    }
    pub unsafe fn Caption(&self) -> windows_core::Result<windows_core::BSTR> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Caption)(windows_core::Interface::as_raw(self), &mut result__).map(|| core::mem::transmute(result__))
        }
    }
    pub unsafe fn SetWindowStyle(&self, windowstyle: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowStyle)(windows_core::Interface::as_raw(self), windowstyle).ok() }
    }
    pub unsafe fn WindowStyle(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WindowStyle)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetWindowStyleEx(&self, windowstyleex: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowStyleEx)(windows_core::Interface::as_raw(self), windowstyleex).ok() }
    }
    pub unsafe fn WindowStyleEx(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WindowStyleEx)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetAutoShow(&self, autoshow: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetAutoShow)(windows_core::Interface::as_raw(self), autoshow).ok() }
    }
    pub unsafe fn AutoShow(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).AutoShow)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetWindowState(&self, windowstate: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowState)(windows_core::Interface::as_raw(self), windowstate).ok() }
    }
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub unsafe fn WindowState(&self) -> windows_core::Result<super::super::UI::WindowsAndMessaging::SHOW_WINDOW_CMD> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).WindowState)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBackgroundPalette(&self, backgroundpalette: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBackgroundPalette)(windows_core::Interface::as_raw(self), backgroundpalette).ok() }
    }
    pub unsafe fn BackgroundPalette(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).BackgroundPalette)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetVisible(&self, visible: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetVisible)(windows_core::Interface::as_raw(self), visible).ok() }
    }
    pub unsafe fn Visible(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Visible)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetLeft(&self, left: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetLeft)(windows_core::Interface::as_raw(self), left).ok() }
    }
    pub unsafe fn Left(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Left)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetWidth(&self, width: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWidth)(windows_core::Interface::as_raw(self), width).ok() }
    }
    pub unsafe fn Width(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Width)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetTop(&self, top: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetTop)(windows_core::Interface::as_raw(self), top).ok() }
    }
    pub unsafe fn Top(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Top)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetHeight(&self, height: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetHeight)(windows_core::Interface::as_raw(self), height).ok() }
    }
    pub unsafe fn Height(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Height)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetOwner(&self, owner: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetOwner)(windows_core::Interface::as_raw(self), owner).ok() }
    }
    pub unsafe fn Owner(&self) -> windows_core::Result<isize> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).Owner)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetMessageDrain(&self, drain: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetMessageDrain)(windows_core::Interface::as_raw(self), drain).ok() }
    }
    pub unsafe fn MessageDrain(&self) -> windows_core::Result<isize> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).MessageDrain)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn BorderColor(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).BorderColor)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetBorderColor(&self, color: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetBorderColor)(windows_core::Interface::as_raw(self), color).ok() }
    }
    pub unsafe fn FullScreenMode(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).FullScreenMode)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
    pub unsafe fn SetFullScreenMode(&self, fullscreenmode: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetFullScreenMode)(windows_core::Interface::as_raw(self), fullscreenmode).ok() }
    }
    pub unsafe fn SetWindowForeground(&self, focus: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowForeground)(windows_core::Interface::as_raw(self), focus).ok() }
    }
    pub unsafe fn NotifyOwnerMessage(&self, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NotifyOwnerMessage)(windows_core::Interface::as_raw(self), hwnd, umsg, wparam, lparam).ok() }
    }
    pub unsafe fn SetWindowPosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).SetWindowPosition)(windows_core::Interface::as_raw(self), left, top, width, height).ok() }
    }
    pub unsafe fn GetWindowPosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetWindowPosition)(windows_core::Interface::as_raw(self), pleft as _, ptop as _, pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn GetMinIdealImageSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMinIdealImageSize)(windows_core::Interface::as_raw(self), pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn GetMaxIdealImageSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetMaxIdealImageSize)(windows_core::Interface::as_raw(self), pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn GetRestorePosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).GetRestorePosition)(windows_core::Interface::as_raw(self), pleft as _, ptop as _, pwidth as _, pheight as _).ok() }
    }
    pub unsafe fn HideCursor(&self, hidecursor: OA_BOOL) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).HideCursor)(windows_core::Interface::as_raw(self), hidecursor).ok() }
    }
    pub unsafe fn IsCursorHidden(&self) -> windows_core::Result<i32> {
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(self).IsCursorHidden)(windows_core::Interface::as_raw(self), &mut result__).map(|| result__)
        }
    }
}
#[cfg(feature = "Win32_System_Com")]
#[repr(C)]
#[doc(hidden)]
pub struct IVideoWindow_Vtbl {
    pub base__: super::super::System::Com::IDispatch_Vtbl,
    pub SetCaption: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Caption: unsafe extern "system" fn(*mut core::ffi::c_void, *mut *mut core::ffi::c_void) -> windows_core::HRESULT,
    pub SetWindowStyle: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub WindowStyle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetWindowStyleEx: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub WindowStyleEx: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetAutoShow: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub AutoShow: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetWindowState: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_UI_WindowsAndMessaging")]
    pub WindowState: unsafe extern "system" fn(*mut core::ffi::c_void, *mut super::super::UI::WindowsAndMessaging::SHOW_WINDOW_CMD) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_UI_WindowsAndMessaging"))]
    WindowState: usize,
    pub SetBackgroundPalette: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub BackgroundPalette: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetVisible: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Visible: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetLeft: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Left: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetWidth: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Width: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetTop: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Top: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetHeight: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub Height: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetOwner: unsafe extern "system" fn(*mut core::ffi::c_void, isize) -> windows_core::HRESULT,
    pub Owner: unsafe extern "system" fn(*mut core::ffi::c_void, *mut isize) -> windows_core::HRESULT,
    pub SetMessageDrain: unsafe extern "system" fn(*mut core::ffi::c_void, isize) -> windows_core::HRESULT,
    pub MessageDrain: unsafe extern "system" fn(*mut core::ffi::c_void, *mut isize) -> windows_core::HRESULT,
    pub BorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetBorderColor: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub FullScreenMode: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
    pub SetFullScreenMode: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub SetWindowForeground: unsafe extern "system" fn(*mut core::ffi::c_void, i32) -> windows_core::HRESULT,
    pub NotifyOwnerMessage: unsafe extern "system" fn(*mut core::ffi::c_void, isize, i32, isize, isize) -> windows_core::HRESULT,
    pub SetWindowPosition: unsafe extern "system" fn(*mut core::ffi::c_void, i32, i32, i32, i32) -> windows_core::HRESULT,
    pub GetWindowPosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMinIdealImageSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetMaxIdealImageSize: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub GetRestorePosition: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32, *mut i32, *mut i32, *mut i32) -> windows_core::HRESULT,
    pub HideCursor: unsafe extern "system" fn(*mut core::ffi::c_void, OA_BOOL) -> windows_core::HRESULT,
    pub IsCursorHidden: unsafe extern "system" fn(*mut core::ffi::c_void, *mut i32) -> windows_core::HRESULT,
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant", feature = "Win32_UI_WindowsAndMessaging"))]
pub trait IVideoWindow_Impl: super::super::System::Com::IDispatch_Impl {
    fn SetCaption(&self, strcaption: &windows_core::BSTR) -> windows_core::Result<()>;
    fn Caption(&self) -> windows_core::Result<windows_core::BSTR>;
    fn SetWindowStyle(&self, windowstyle: i32) -> windows_core::Result<()>;
    fn WindowStyle(&self) -> windows_core::Result<i32>;
    fn SetWindowStyleEx(&self, windowstyleex: i32) -> windows_core::Result<()>;
    fn WindowStyleEx(&self) -> windows_core::Result<i32>;
    fn SetAutoShow(&self, autoshow: i32) -> windows_core::Result<()>;
    fn AutoShow(&self) -> windows_core::Result<i32>;
    fn SetWindowState(&self, windowstate: i32) -> windows_core::Result<()>;
    fn WindowState(&self) -> windows_core::Result<super::super::UI::WindowsAndMessaging::SHOW_WINDOW_CMD>;
    fn SetBackgroundPalette(&self, backgroundpalette: i32) -> windows_core::Result<()>;
    fn BackgroundPalette(&self) -> windows_core::Result<i32>;
    fn SetVisible(&self, visible: i32) -> windows_core::Result<()>;
    fn Visible(&self) -> windows_core::Result<i32>;
    fn SetLeft(&self, left: i32) -> windows_core::Result<()>;
    fn Left(&self) -> windows_core::Result<i32>;
    fn SetWidth(&self, width: i32) -> windows_core::Result<()>;
    fn Width(&self) -> windows_core::Result<i32>;
    fn SetTop(&self, top: i32) -> windows_core::Result<()>;
    fn Top(&self) -> windows_core::Result<i32>;
    fn SetHeight(&self, height: i32) -> windows_core::Result<()>;
    fn Height(&self) -> windows_core::Result<i32>;
    fn SetOwner(&self, owner: isize) -> windows_core::Result<()>;
    fn Owner(&self) -> windows_core::Result<isize>;
    fn SetMessageDrain(&self, drain: isize) -> windows_core::Result<()>;
    fn MessageDrain(&self) -> windows_core::Result<isize>;
    fn BorderColor(&self) -> windows_core::Result<i32>;
    fn SetBorderColor(&self, color: i32) -> windows_core::Result<()>;
    fn FullScreenMode(&self) -> windows_core::Result<i32>;
    fn SetFullScreenMode(&self, fullscreenmode: i32) -> windows_core::Result<()>;
    fn SetWindowForeground(&self, focus: i32) -> windows_core::Result<()>;
    fn NotifyOwnerMessage(&self, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> windows_core::Result<()>;
    fn SetWindowPosition(&self, left: i32, top: i32, width: i32, height: i32) -> windows_core::Result<()>;
    fn GetWindowPosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn GetMinIdealImageSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn GetMaxIdealImageSize(&self, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn GetRestorePosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::Result<()>;
    fn HideCursor(&self, hidecursor: OA_BOOL) -> windows_core::Result<()>;
    fn IsCursorHidden(&self) -> windows_core::Result<i32>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant", feature = "Win32_UI_WindowsAndMessaging"))]
impl IVideoWindow_Vtbl {
    pub const fn new<Identity: IVideoWindow_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetCaption<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strcaption: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetCaption(this, core::mem::transmute(&strcaption)).into()
            }
        }
        unsafe extern "system" fn Caption<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, strcaption: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Caption(this) {
                    Ok(ok__) => {
                        strcaption.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetWindowStyle<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstyle: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWindowStyle(this, core::mem::transmute_copy(&windowstyle)).into()
            }
        }
        unsafe extern "system" fn WindowStyle<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstyle: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::WindowStyle(this) {
                    Ok(ok__) => {
                        windowstyle.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetWindowStyleEx<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstyleex: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWindowStyleEx(this, core::mem::transmute_copy(&windowstyleex)).into()
            }
        }
        unsafe extern "system" fn WindowStyleEx<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstyleex: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::WindowStyleEx(this) {
                    Ok(ok__) => {
                        windowstyleex.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAutoShow<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, autoshow: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetAutoShow(this, core::mem::transmute_copy(&autoshow)).into()
            }
        }
        unsafe extern "system" fn AutoShow<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, autoshow: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::AutoShow(this) {
                    Ok(ok__) => {
                        autoshow.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetWindowState<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstate: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWindowState(this, core::mem::transmute_copy(&windowstate)).into()
            }
        }
        unsafe extern "system" fn WindowState<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windowstate: *mut super::super::UI::WindowsAndMessaging::SHOW_WINDOW_CMD) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::WindowState(this) {
                    Ok(ok__) => {
                        windowstate.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBackgroundPalette<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, backgroundpalette: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetBackgroundPalette(this, core::mem::transmute_copy(&backgroundpalette)).into()
            }
        }
        unsafe extern "system" fn BackgroundPalette<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbackgroundpalette: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::BackgroundPalette(this) {
                    Ok(ok__) => {
                        pbackgroundpalette.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetVisible<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, visible: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetVisible(this, core::mem::transmute_copy(&visible)).into()
            }
        }
        unsafe extern "system" fn Visible<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvisible: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Visible(this) {
                    Ok(ok__) => {
                        pvisible.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLeft<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, left: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetLeft(this, core::mem::transmute_copy(&left)).into()
            }
        }
        unsafe extern "system" fn Left<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pleft: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Left(this) {
                    Ok(ok__) => {
                        pleft.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetWidth<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, width: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWidth(this, core::mem::transmute_copy(&width)).into()
            }
        }
        unsafe extern "system" fn Width<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwidth: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Width(this) {
                    Ok(ok__) => {
                        pwidth.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTop<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, top: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetTop(this, core::mem::transmute_copy(&top)).into()
            }
        }
        unsafe extern "system" fn Top<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptop: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Top(this) {
                    Ok(ok__) => {
                        ptop.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetHeight<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, height: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetHeight(this, core::mem::transmute_copy(&height)).into()
            }
        }
        unsafe extern "system" fn Height<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Height(this) {
                    Ok(ok__) => {
                        pheight.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOwner<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, owner: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetOwner(this, core::mem::transmute_copy(&owner)).into()
            }
        }
        unsafe extern "system" fn Owner<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, owner: *mut isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::Owner(this) {
                    Ok(ok__) => {
                        owner.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMessageDrain<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, drain: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetMessageDrain(this, core::mem::transmute_copy(&drain)).into()
            }
        }
        unsafe extern "system" fn MessageDrain<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, drain: *mut isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::MessageDrain(this) {
                    Ok(ok__) => {
                        drain.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn BorderColor<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, color: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::BorderColor(this) {
                    Ok(ok__) => {
                        color.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetBorderColor<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, color: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetBorderColor(this, core::mem::transmute_copy(&color)).into()
            }
        }
        unsafe extern "system" fn FullScreenMode<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fullscreenmode: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::FullScreenMode(this) {
                    Ok(ok__) => {
                        fullscreenmode.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFullScreenMode<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fullscreenmode: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetFullScreenMode(this, core::mem::transmute_copy(&fullscreenmode)).into()
            }
        }
        unsafe extern "system" fn SetWindowForeground<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, focus: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWindowForeground(this, core::mem::transmute_copy(&focus)).into()
            }
        }
        unsafe extern "system" fn NotifyOwnerMessage<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: isize, umsg: i32, wparam: isize, lparam: isize) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::NotifyOwnerMessage(this, core::mem::transmute_copy(&hwnd), core::mem::transmute_copy(&umsg), core::mem::transmute_copy(&wparam), core::mem::transmute_copy(&lparam)).into()
            }
        }
        unsafe extern "system" fn SetWindowPosition<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, left: i32, top: i32, width: i32, height: i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::SetWindowPosition(this, core::mem::transmute_copy(&left), core::mem::transmute_copy(&top), core::mem::transmute_copy(&width), core::mem::transmute_copy(&height)).into()
            }
        }
        unsafe extern "system" fn GetWindowPosition<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::GetWindowPosition(this, core::mem::transmute_copy(&pleft), core::mem::transmute_copy(&ptop), core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn GetMinIdealImageSize<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::GetMinIdealImageSize(this, core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn GetMaxIdealImageSize<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::GetMaxIdealImageSize(this, core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn GetRestorePosition<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::GetRestorePosition(this, core::mem::transmute_copy(&pleft), core::mem::transmute_copy(&ptop), core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight)).into()
            }
        }
        unsafe extern "system" fn HideCursor<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hidecursor: OA_BOOL) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVideoWindow_Impl::HideCursor(this, core::mem::transmute_copy(&hidecursor)).into()
            }
        }
        unsafe extern "system" fn IsCursorHidden<Identity: IVideoWindow_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cursorhidden: *mut i32) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVideoWindow_Impl::IsCursorHidden(this) {
                    Ok(ok__) => {
                        cursorhidden.write(core::mem::transmute(ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: super::super::System::Com::IDispatch_Vtbl::new::<Identity, OFFSET>(),
            SetCaption: SetCaption::<Identity, OFFSET>,
            Caption: Caption::<Identity, OFFSET>,
            SetWindowStyle: SetWindowStyle::<Identity, OFFSET>,
            WindowStyle: WindowStyle::<Identity, OFFSET>,
            SetWindowStyleEx: SetWindowStyleEx::<Identity, OFFSET>,
            WindowStyleEx: WindowStyleEx::<Identity, OFFSET>,
            SetAutoShow: SetAutoShow::<Identity, OFFSET>,
            AutoShow: AutoShow::<Identity, OFFSET>,
            SetWindowState: SetWindowState::<Identity, OFFSET>,
            WindowState: WindowState::<Identity, OFFSET>,
            SetBackgroundPalette: SetBackgroundPalette::<Identity, OFFSET>,
            BackgroundPalette: BackgroundPalette::<Identity, OFFSET>,
            SetVisible: SetVisible::<Identity, OFFSET>,
            Visible: Visible::<Identity, OFFSET>,
            SetLeft: SetLeft::<Identity, OFFSET>,
            Left: Left::<Identity, OFFSET>,
            SetWidth: SetWidth::<Identity, OFFSET>,
            Width: Width::<Identity, OFFSET>,
            SetTop: SetTop::<Identity, OFFSET>,
            Top: Top::<Identity, OFFSET>,
            SetHeight: SetHeight::<Identity, OFFSET>,
            Height: Height::<Identity, OFFSET>,
            SetOwner: SetOwner::<Identity, OFFSET>,
            Owner: Owner::<Identity, OFFSET>,
            SetMessageDrain: SetMessageDrain::<Identity, OFFSET>,
            MessageDrain: MessageDrain::<Identity, OFFSET>,
            BorderColor: BorderColor::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            FullScreenMode: FullScreenMode::<Identity, OFFSET>,
            SetFullScreenMode: SetFullScreenMode::<Identity, OFFSET>,
            SetWindowForeground: SetWindowForeground::<Identity, OFFSET>,
            NotifyOwnerMessage: NotifyOwnerMessage::<Identity, OFFSET>,
            SetWindowPosition: SetWindowPosition::<Identity, OFFSET>,
            GetWindowPosition: GetWindowPosition::<Identity, OFFSET>,
            GetMinIdealImageSize: GetMinIdealImageSize::<Identity, OFFSET>,
            GetMaxIdealImageSize: GetMaxIdealImageSize::<Identity, OFFSET>,
            GetRestorePosition: GetRestorePosition::<Identity, OFFSET>,
            HideCursor: HideCursor::<Identity, OFFSET>,
            IsCursorHidden: IsCursorHidden::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVideoWindow as windows_core::Interface>::IID || iid == &<super::super::System::Com::IDispatch as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant", feature = "Win32_UI_WindowsAndMessaging"))]
impl windows_core::RuntimeName for IVideoWindow {}
windows_core::imp::define_interface!(IWMCodecAMVideoAccelerator, IWMCodecAMVideoAccelerator_Vtbl, 0xd98ee251_34e0_4a2d_9312_9b4c788d9fa1);
windows_core::imp::interface_hierarchy!(IWMCodecAMVideoAccelerator, windows_core::IUnknown);
impl IWMCodecAMVideoAccelerator {
    pub unsafe fn SetAcceleratorInterface<P0>(&self, piamva: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMVideoAccelerator>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetAcceleratorInterface)(windows_core::Interface::as_raw(self), piamva.param().abi()).ok() }
    }
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn NegotiateConnection(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()> {
        unsafe { (windows_core::Interface::vtable(self).NegotiateConnection)(windows_core::Interface::as_raw(self), core::mem::transmute(pmediatype)).ok() }
    }
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn SetPlayerNotify<P0>(&self, phook: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::WindowsMediaFormat::IWMPlayerTimestampHook>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetPlayerNotify)(windows_core::Interface::as_raw(self), phook.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecAMVideoAccelerator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    pub SetAcceleratorInterface: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub NegotiateConnection: unsafe extern "system" fn(*mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    NegotiateConnection: usize,
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub SetPlayerNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_WindowsMediaFormat"))]
    SetPlayerNotify: usize,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
pub trait IWMCodecAMVideoAccelerator_Impl: windows_core::IUnknownImpl {
    fn SetAcceleratorInterface(&self, piamva: windows_core::Ref<IAMVideoAccelerator>) -> windows_core::Result<()>;
    fn NegotiateConnection(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn SetPlayerNotify(&self, phook: windows_core::Ref<super::WindowsMediaFormat::IWMPlayerTimestampHook>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl IWMCodecAMVideoAccelerator_Vtbl {
    pub const fn new<Identity: IWMCodecAMVideoAccelerator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SetAcceleratorInterface<Identity: IWMCodecAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piamva: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IWMCodecAMVideoAccelerator_Impl::SetAcceleratorInterface(this, core::mem::transmute_copy(&piamva)).into()
            }
        }
        unsafe extern "system" fn NegotiateConnection<Identity: IWMCodecAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IWMCodecAMVideoAccelerator_Impl::NegotiateConnection(this, core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn SetPlayerNotify<Identity: IWMCodecAMVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phook: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IWMCodecAMVideoAccelerator_Impl::SetPlayerNotify(this, core::mem::transmute_copy(&phook)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAcceleratorInterface: SetAcceleratorInterface::<Identity, OFFSET>,
            NegotiateConnection: NegotiateConnection::<Identity, OFFSET>,
            SetPlayerNotify: SetPlayerNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecAMVideoAccelerator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl windows_core::RuntimeName for IWMCodecAMVideoAccelerator {}
windows_core::imp::define_interface!(IWMCodecVideoAccelerator, IWMCodecVideoAccelerator_Vtbl, 0x990641b0_739f_4e94_a808_9888da8f75af);
windows_core::imp::interface_hierarchy!(IWMCodecVideoAccelerator, windows_core::IUnknown);
impl IWMCodecVideoAccelerator {
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub unsafe fn NegotiateConnection<P0>(&self, piamva: P0, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>
    where
        P0: windows_core::Param<IAMVideoAccelerator>,
    {
        unsafe { (windows_core::Interface::vtable(self).NegotiateConnection)(windows_core::Interface::as_raw(self), piamva.param().abi(), core::mem::transmute(pmediatype)).ok() }
    }
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn SetPlayerNotify<P0>(&self, phook: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::WindowsMediaFormat::IWMPlayerTimestampHook>,
    {
        unsafe { (windows_core::Interface::vtable(self).SetPlayerNotify)(windows_core::Interface::as_raw(self), phook.param().abi()).ok() }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecVideoAccelerator_Vtbl {
    pub base__: windows_core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Media_MediaFoundation")]
    pub NegotiateConnection: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void, *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_MediaFoundation"))]
    NegotiateConnection: usize,
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub SetPlayerNotify: unsafe extern "system" fn(*mut core::ffi::c_void, *mut core::ffi::c_void) -> windows_core::HRESULT,
    #[cfg(not(feature = "Win32_Media_WindowsMediaFormat"))]
    SetPlayerNotify: usize,
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
pub trait IWMCodecVideoAccelerator_Impl: windows_core::IUnknownImpl {
    fn NegotiateConnection(&self, piamva: windows_core::Ref<IAMVideoAccelerator>, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::Result<()>;
    fn SetPlayerNotify(&self, phook: windows_core::Ref<super::WindowsMediaFormat::IWMPlayerTimestampHook>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl IWMCodecVideoAccelerator_Vtbl {
    pub const fn new<Identity: IWMCodecVideoAccelerator_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn NegotiateConnection<Identity: IWMCodecVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piamva: *mut core::ffi::c_void, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IWMCodecVideoAccelerator_Impl::NegotiateConnection(this, core::mem::transmute_copy(&piamva), core::mem::transmute_copy(&pmediatype)).into()
            }
        }
        unsafe extern "system" fn SetPlayerNotify<Identity: IWMCodecVideoAccelerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phook: *mut core::ffi::c_void) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IWMCodecVideoAccelerator_Impl::SetPlayerNotify(this, core::mem::transmute_copy(&phook)).into()
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            NegotiateConnection: NegotiateConnection::<Identity, OFFSET>,
            SetPlayerNotify: SetPlayerNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecVideoAccelerator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_MediaFoundation", feature = "Win32_Media_WindowsMediaFormat"))]
impl windows_core::RuntimeName for IWMCodecVideoAccelerator {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct InterleavingMode(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct KSPROPERTY_IPSINK(pub i32);
impl KSPROPERTY_IPSINK {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for KSPROPERTY_IPSINK {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for KSPROPERTY_IPSINK {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for KSPROPERTY_IPSINK {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for KSPROPERTY_IPSINK {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for KSPROPERTY_IPSINK {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const KSPROPERTY_IPSINK_ADAPTER_ADDRESS: KSPROPERTY_IPSINK = KSPROPERTY_IPSINK(2i32);
pub const KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION: KSPROPERTY_IPSINK = KSPROPERTY_IPSINK(1i32);
pub const KSPROPERTY_IPSINK_MULTICASTLIST: KSPROPERTY_IPSINK = KSPROPERTY_IPSINK(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct KS_BDA_FRAME_INFO {
    pub ExtendedHeaderSize: u32,
    pub dwFrameFlags: u32,
    pub ulEvent: u32,
    pub ulChannelNumber: u32,
    pub ulSubchannelNumber: u32,
    pub ulReason: u32,
}
pub const LIBID_QuartzNetTypeLib: windows_core::GUID = windows_core::GUID::from_u128(0x56a868b1_0ad4_11ce_b03a_0020af0ba770);
pub const LIBID_QuartzTypeLib: windows_core::GUID = windows_core::GUID::from_u128(0x56a868b0_0ad4_11ce_b03a_0020af0ba770);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct LNB_Source(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct LocationCodeSchemeType(pub i32);
pub const MAX_DEINTERLACE_DEVICE_GUIDS: u32 = 32u32;
pub const MAX_DEINTERLACE_SURFACES: u32 = 32u32;
pub const MAX_ERROR_TEXT_LEN: u32 = 160u32;
pub const MAX_FILTER_NAME: u32 = 128u32;
pub const MAX_NUMBER_OF_STREAMS: STREAMIF_CONSTANTS = STREAMIF_CONSTANTS(16i32);
pub const MAX_PIN_NAME: u32 = 128u32;
pub const MAX_SIZE_MPEG1_SEQUENCE_INFO: u32 = 140u32;
pub const MEDIASUBTYPE_ATSC_SI: windows_core::GUID = windows_core::GUID::from_u128(0xb3c7397c_d303_414d_b33c_4ed2c9d29733);
pub const MEDIASUBTYPE_DOLBY_AC3: windows_core::GUID = windows_core::GUID::from_u128(0xe06d802c_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DTS: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8033_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DVB_SI: windows_core::GUID = windows_core::GUID::from_u128(0xe9dd31a3_221d_4adb_8532_9af309c1a408);
pub const MEDIASUBTYPE_DVD_LPCM_AUDIO: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8032_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DVD_NAVIGATION_DSI: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8030_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DVD_NAVIGATION_PCI: windows_core::GUID = windows_core::GUID::from_u128(0xe06d802f_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8031_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_DVD_SUBPICTURE: windows_core::GUID = windows_core::GUID::from_u128(0xe06d802d_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_ISDB_SI: windows_core::GUID = windows_core::GUID::from_u128(0xe89ad298_3601_4b06_aaec_9ddeedcc5bd0);
pub const MEDIASUBTYPE_MPEG2DATA: windows_core::GUID = windows_core::GUID::from_u128(0xc892e55b_252d_42b5_a316_d997e7a5d995);
pub const MEDIASUBTYPE_MPEG2_AUDIO: windows_core::GUID = windows_core::GUID::from_u128(0xe06d802b_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_PROCESSED: windows_core::GUID = windows_core::GUID::from_u128(0xaf748dd4_0d80_11db_9705_005056c00008);
pub const MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_RAW: windows_core::GUID = windows_core::GUID::from_u128(0x0d7aed42_cb9a_11db_9705_005056c00008);
pub const MEDIASUBTYPE_MPEG2_PROGRAM: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8022_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_MPEG2_TRANSPORT: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8023_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE: windows_core::GUID = windows_core::GUID::from_u128(0x138aa9a4_1ee2_4c5b_988e_19abfdbc8a11);
pub const MEDIASUBTYPE_MPEG2_UDCR_TRANSPORT: windows_core::GUID = windows_core::GUID::from_u128(0x18bec4ea_4676_450e_b478_0cd84c54b327);
pub const MEDIASUBTYPE_MPEG2_VERSIONED_TABLES: windows_core::GUID = windows_core::GUID::from_u128(0x1ed988b0_3ffc_4523_8725_347beec1a8a0);
pub const MEDIASUBTYPE_MPEG2_VIDEO: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8026_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_MPEG2_WMDRM_TRANSPORT: windows_core::GUID = windows_core::GUID::from_u128(0x18bec4ea_4676_450e_b478_0cd84c54b327);
pub const MEDIASUBTYPE_SDDS: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8034_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIASUBTYPE_TIF_SI: windows_core::GUID = windows_core::GUID::from_u128(0xec232eb2_cb96_4191_b226_0ea129f38250);
pub const MEDIATYPE_CONTROL: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8021_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIATYPE_DVD_ENCRYPTED_PACK: windows_core::GUID = windows_core::GUID::from_u128(0xed0b916a_044d_11d1_aa78_00c04fc31d60);
pub const MEDIATYPE_DVD_NAVIGATION: windows_core::GUID = windows_core::GUID::from_u128(0xe06d802e_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIATYPE_MPEG2_PACK: windows_core::GUID = windows_core::GUID::from_u128(0x36523b13_8ee5_11d1_8ca3_0060b057664a);
pub const MEDIATYPE_MPEG2_PES: windows_core::GUID = windows_core::GUID::from_u128(0xe06d8020_db46_11cf_b4d1_00805f6cbbea);
pub const MEDIATYPE_MPEG2_SECTIONS: windows_core::GUID = windows_core::GUID::from_u128(0x455f176c_4b06_47ce_9aef_8caef73df7b5);
pub const MEDIA_ELEMENTARY_STREAM: MEDIA_SAMPLE_CONTENT = MEDIA_SAMPLE_CONTENT(1i32);
pub const MEDIA_MPEG2_PSI: MEDIA_SAMPLE_CONTENT = MEDIA_SAMPLE_CONTENT(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MEDIA_SAMPLE_CONTENT(pub i32);
pub const MEDIA_TRANSPORT_PACKET: MEDIA_SAMPLE_CONTENT = MEDIA_SAMPLE_CONTENT(0i32);
pub const MEDIA_TRANSPORT_PAYLOAD: MEDIA_SAMPLE_CONTENT = MEDIA_SAMPLE_CONTENT(3i32);
pub const MERIT_DO_NOT_USE: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(2097152i32);
pub const MERIT_HW_COMPRESSOR: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(1048656i32);
pub const MERIT_NORMAL: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(6291456i32);
pub const MERIT_PREFERRED: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(8388608i32);
pub const MERIT_SW_COMPRESSOR: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(1048576i32);
pub const MERIT_UNLIKELY: IFILTERMAPPER_MERIT = IFILTERMAPPER_MERIT(4194304i32);
pub const METADATA_IN_DATA_CAROUSEL: MPEG2StreamType = MPEG2StreamType(23i32);
pub const METADATA_IN_DOWNLOAD_PROTOCOL: MPEG2StreamType = MPEG2StreamType(25i32);
pub const METADATA_IN_OBJECT_CAROUSEL: MPEG2StreamType = MPEG2StreamType(24i32);
pub const METADATA_IN_PES: MPEG2StreamType = MPEG2StreamType(21i32);
pub const METADATA_IN_SECTION: MPEG2StreamType = MPEG2StreamType(22i32);
pub const MIN_DIMENSION: u32 = 1u32;
pub const MMSSF_ASYNCHRONOUS: MMSSF_GET_INFORMATION_FLAGS = MMSSF_GET_INFORMATION_FLAGS(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MMSSF_GET_INFORMATION_FLAGS(pub i32);
impl MMSSF_GET_INFORMATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for MMSSF_GET_INFORMATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for MMSSF_GET_INFORMATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const MMSSF_HASCLOCK: MMSSF_GET_INFORMATION_FLAGS = MMSSF_GET_INFORMATION_FLAGS(1i32);
pub const MMSSF_SUPPORTSEEK: MMSSF_GET_INFORMATION_FLAGS = MMSSF_GET_INFORMATION_FLAGS(2i32);
pub const MPBOOL_FALSE: u32 = 0u32;
pub const MPBOOL_TRUE: u32 = 1u32;
#[repr(C, packed(1))]
#[cfg(feature = "Win32_Media_Audio")]
#[derive(Clone, Copy, Default)]
pub struct MPEG1WAVEFORMAT {
    pub wfx: super::Audio::WAVEFORMATEX,
    pub fwHeadLayer: u16,
    pub dwHeadBitrate: u32,
    pub fwHeadMode: u16,
    pub fwHeadModeExt: u16,
    pub wHeadEmphasis: u16,
    pub fwHeadFlags: u16,
    pub dwPTSLow: u32,
    pub dwPTSHigh: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MPEG2StreamType(pub i32);
pub const MPEG2_BASE: u32 = 512u32;
pub const MPEG2_E_ALREADY_INITIALIZED: windows_core::HRESULT = windows_core::HRESULT(0x80040201_u32 as _);
pub const MPEG2_E_BUFFER_TOO_SMALL: windows_core::HRESULT = windows_core::HRESULT(0x80040219_u32 as _);
pub const MPEG2_E_DATA_SOURCE_FAILED: windows_core::HRESULT = windows_core::HRESULT(0x80040216_u32 as _);
pub const MPEG2_E_DII_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040217_u32 as _);
pub const MPEG2_E_DSHOW_PIN_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040218_u32 as _);
pub const MPEG2_E_DSI_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x8004020A_u32 as _);
pub const MPEG2_E_FILE_OFFSET_TOO_BIG: windows_core::HRESULT = windows_core::HRESULT(0x80040212_u32 as _);
pub const MPEG2_E_INCORRECT_DESCRIPTOR_TAG: windows_core::HRESULT = windows_core::HRESULT(0x8004021D_u32 as _);
pub const MPEG2_E_INVALID_CAROUSEL_ID: windows_core::HRESULT = windows_core::HRESULT(0x8004020C_u32 as _);
pub const MPEG2_E_INVALID_SG_OBJECT_KIND: windows_core::HRESULT = windows_core::HRESULT(0x8004020E_u32 as _);
pub const MPEG2_E_INVALID_UDP_PORT: windows_core::HRESULT = windows_core::HRESULT(0x80040215_u32 as _);
pub const MPEG2_E_MALFORMED_DSMCC_MESSAGE: windows_core::HRESULT = windows_core::HRESULT(0x8004020D_u32 as _);
pub const MPEG2_E_MALFORMED_TABLE: windows_core::HRESULT = windows_core::HRESULT(0x80040203_u32 as _);
pub const MPEG2_E_MISSING_SECTIONS: windows_core::HRESULT = windows_core::HRESULT(0x8004021A_u32 as _);
pub const MPEG2_E_NEXT_TABLE_OPS_NOT_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x8004021C_u32 as _);
pub const MPEG2_E_NOT_PRESENT: windows_core::HRESULT = windows_core::HRESULT(0x80040205_u32 as _);
pub const MPEG2_E_OBJECT_KIND_NOT_A_DIRECTORY: windows_core::HRESULT = windows_core::HRESULT(0x80040210_u32 as _);
pub const MPEG2_E_OBJECT_KIND_NOT_A_FILE: windows_core::HRESULT = windows_core::HRESULT(0x80040211_u32 as _);
pub const MPEG2_E_OBJECT_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x8004020F_u32 as _);
pub const MPEG2_E_OUT_OF_BOUNDS: windows_core::HRESULT = windows_core::HRESULT(0x80040202_u32 as _);
pub const MPEG2_E_REGISTRY_ACCESS_FAILED: windows_core::HRESULT = windows_core::HRESULT(0x80040214_u32 as _);
pub const MPEG2_E_SECTION_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040206_u32 as _);
pub const MPEG2_E_SERVER_UNAVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x8004020B_u32 as _);
pub const MPEG2_E_SERVICE_ID_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040208_u32 as _);
pub const MPEG2_E_SERVICE_PMT_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040209_u32 as _);
pub const MPEG2_E_STREAM_STOPPED: windows_core::HRESULT = windows_core::HRESULT(0x80040213_u32 as _);
pub const MPEG2_E_TOO_MANY_SECTIONS: windows_core::HRESULT = windows_core::HRESULT(0x8004021B_u32 as _);
pub const MPEG2_E_TX_STREAM_UNAVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x80040207_u32 as _);
pub const MPEG2_E_UNDEFINED: windows_core::HRESULT = windows_core::HRESULT(0x80040204_u32 as _);
pub const MPEG2_E_UNINITIALIZED: windows_core::HRESULT = windows_core::HRESULT(0x80040200_u32 as _);
pub const MPEG2_PROGRAM_DIRECTORY_PES_PACKET: u32 = 2u32;
pub const MPEG2_PROGRAM_ELEMENTARY_STREAM: u32 = 1u32;
pub const MPEG2_PROGRAM_PACK_HEADER: u32 = 3u32;
pub const MPEG2_PROGRAM_PES_STREAM: u32 = 4u32;
pub const MPEG2_PROGRAM_STREAM_MAP: u32 = 0u32;
pub const MPEG2_PROGRAM_SYSTEM_HEADER: u32 = 5u32;
pub const MPEG2_S_MORE_DATA_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x40200_u32 as _);
pub const MPEG2_S_MPE_INFO_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x40204_u32 as _);
pub const MPEG2_S_MPE_INFO_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x40205_u32 as _);
pub const MPEG2_S_NEW_MODULE_VERSION: windows_core::HRESULT = windows_core::HRESULT(0x40206_u32 as _);
pub const MPEG2_S_NO_MORE_DATA_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x40201_u32 as _);
pub const MPEG2_S_SG_INFO_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x40202_u32 as _);
pub const MPEG2_S_SG_INFO_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x40203_u32 as _);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct MPEG2_TRANSPORT_STRIDE {
    pub dwOffset: u32,
    pub dwPacketLength: u32,
    pub dwStride: u32,
}
#[repr(C, packed(1))]
#[cfg(feature = "Win32_Media_Audio")]
#[derive(Clone, Copy, Default)]
pub struct MPEGLAYER3WAVEFORMAT {
    pub wfx: super::Audio::WAVEFORMATEX,
    pub wID: u16,
    pub fdwFlags: MPEGLAYER3WAVEFORMAT_FLAGS,
    pub nBlockSize: u16,
    pub nFramesPerBlock: u16,
    pub nCodecDelay: u16,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MPEGLAYER3WAVEFORMAT_FLAGS(pub u32);
pub const MPEGLAYER3_FLAG_PADDING_ISO: MPEGLAYER3WAVEFORMAT_FLAGS = MPEGLAYER3WAVEFORMAT_FLAGS(0u32);
pub const MPEGLAYER3_FLAG_PADDING_OFF: MPEGLAYER3WAVEFORMAT_FLAGS = MPEGLAYER3WAVEFORMAT_FLAGS(2u32);
pub const MPEGLAYER3_FLAG_PADDING_ON: MPEGLAYER3WAVEFORMAT_FLAGS = MPEGLAYER3WAVEFORMAT_FLAGS(1u32);
pub const MPF_ENVLP_BEGIN_CURRENTVAL: u32 = 1u32;
pub const MPF_ENVLP_BEGIN_NEUTRALVAL: u32 = 2u32;
pub const MPF_ENVLP_STANDARD: u32 = 0u32;
pub const MPF_PUNCHIN_NOW: u32 = 1u32;
pub const MPF_PUNCHIN_REFTIME: u32 = 0u32;
pub const MPF_PUNCHIN_STOPPED: u32 = 2u32;
pub const MPT_BOOL: MP_TYPE = MP_TYPE(2i32);
pub const MPT_ENUM: MP_TYPE = MP_TYPE(3i32);
pub const MPT_FLOAT: MP_TYPE = MP_TYPE(1i32);
pub const MPT_INT: MP_TYPE = MP_TYPE(0i32);
pub const MPT_MAX: MP_TYPE = MP_TYPE(4i32);
pub const MP_CURVE_INVSQUARE: MP_CURVE_TYPE = MP_CURVE_TYPE(8i32);
pub const MP_CURVE_JUMP: MP_CURVE_TYPE = MP_CURVE_TYPE(1i32);
pub const MP_CURVE_LINEAR: MP_CURVE_TYPE = MP_CURVE_TYPE(2i32);
pub const MP_CURVE_SINE: MP_CURVE_TYPE = MP_CURVE_TYPE(16i32);
pub const MP_CURVE_SQUARE: MP_CURVE_TYPE = MP_CURVE_TYPE(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MP_CURVE_TYPE(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct MP_ENVELOPE_SEGMENT {
    pub rtStart: i64,
    pub rtEnd: i64,
    pub valStart: f32,
    pub valEnd: f32,
    pub iCurve: MP_CURVE_TYPE,
    pub flags: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MP_PARAMINFO {
    pub mpType: MP_TYPE,
    pub mopCaps: u32,
    pub mpdMinValue: f32,
    pub mpdMaxValue: f32,
    pub mpdNeutralValue: f32,
    pub szUnitText: [u16; 32],
    pub szLabel: [u16; 32],
}
impl Default for MP_PARAMINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MP_TYPE(pub i32);
pub const MSDRI_S_MMI_PENDING: windows_core::HRESULT = windows_core::HRESULT(0x2_u32 as _);
pub const MSDRI_S_PENDING: windows_core::HRESULT = windows_core::HRESULT(0x1_u32 as _);
pub const MSPID_PrimaryAudio: windows_core::GUID = windows_core::GUID::from_u128(0xa35ff56b_9fda_11d0_8fdf_00c04fd9189d);
pub const MSPID_PrimaryVideo: windows_core::GUID = windows_core::GUID::from_u128(0xa35ff56a_9fda_11d0_8fdf_00c04fd9189d);
pub const MSTapeDeviceGUID: windows_core::GUID = windows_core::GUID::from_u128(0x8c0f6af2_0edb_44c1_8aeb_59040bd830ed);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct MUX_PID_TYPE(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MainAVIHeader {
    pub dwMicroSecPerFrame: u32,
    pub dwMaxBytesPerSec: u32,
    pub dwPaddingGranularity: u32,
    pub dwFlags: u32,
    pub dwTotalFrames: u32,
    pub dwInitialFrames: u32,
    pub dwStreams: u32,
    pub dwSuggestedBufferSize: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwReserved: [u32; 4],
}
impl Default for MainAVIHeader {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const MixerPref9_ARAdjustXorY: VMR9MixerPrefs = VMR9MixerPrefs(4i32);
pub const MixerPref9_AnisotropicFiltering: VMR9MixerPrefs = VMR9MixerPrefs(64i32);
pub const MixerPref9_BiLinearFiltering: VMR9MixerPrefs = VMR9MixerPrefs(16i32);
pub const MixerPref9_DecimateMask: VMR9MixerPrefs = VMR9MixerPrefs(15i32);
pub const MixerPref9_DecimateOutput: VMR9MixerPrefs = VMR9MixerPrefs(2i32);
pub const MixerPref9_DynamicDecimateBy2: VMR9MixerPrefs = VMR9MixerPrefs(2097152i32);
pub const MixerPref9_DynamicMask: VMR9MixerPrefs = VMR9MixerPrefs(15728640i32);
pub const MixerPref9_DynamicReserved: VMR9MixerPrefs = VMR9MixerPrefs(12582912i32);
pub const MixerPref9_DynamicSwitchToBOB: VMR9MixerPrefs = VMR9MixerPrefs(1048576i32);
pub const MixerPref9_FilteringMask: VMR9MixerPrefs = VMR9MixerPrefs(4080i32);
pub const MixerPref9_FilteringReserved: VMR9MixerPrefs = VMR9MixerPrefs(3584i32);
pub const MixerPref9_GaussianQuadFiltering: VMR9MixerPrefs = VMR9MixerPrefs(256i32);
pub const MixerPref9_NoDecimation: VMR9MixerPrefs = VMR9MixerPrefs(1i32);
pub const MixerPref9_NonSquareMixing: VMR9MixerPrefs = VMR9MixerPrefs(8i32);
pub const MixerPref9_PointFiltering: VMR9MixerPrefs = VMR9MixerPrefs(32i32);
pub const MixerPref9_PyramidalQuadFiltering: VMR9MixerPrefs = VMR9MixerPrefs(128i32);
pub const MixerPref9_RenderTargetMask: VMR9MixerPrefs = VMR9MixerPrefs(1044480i32);
pub const MixerPref9_RenderTargetRGB: VMR9MixerPrefs = VMR9MixerPrefs(4096i32);
pub const MixerPref9_RenderTargetReserved: VMR9MixerPrefs = VMR9MixerPrefs(1032192i32);
pub const MixerPref9_RenderTargetYUV: VMR9MixerPrefs = VMR9MixerPrefs(8192i32);
pub const MixerPref_ARAdjustXorY: VMRMixerPrefs = VMRMixerPrefs(4i32);
pub const MixerPref_BiLinearFiltering: VMRMixerPrefs = VMRMixerPrefs(16i32);
pub const MixerPref_DecimateMask: VMRMixerPrefs = VMRMixerPrefs(15i32);
pub const MixerPref_DecimateOutput: VMRMixerPrefs = VMRMixerPrefs(2i32);
pub const MixerPref_DecimationReserved: VMRMixerPrefs = VMRMixerPrefs(8i32);
pub const MixerPref_DynamicDecimateBy2: VMRMixerPrefs = VMRMixerPrefs(131072i32);
pub const MixerPref_DynamicMask: VMRMixerPrefs = VMRMixerPrefs(983040i32);
pub const MixerPref_DynamicReserved: VMRMixerPrefs = VMRMixerPrefs(786432i32);
pub const MixerPref_DynamicSwitchToBOB: VMRMixerPrefs = VMRMixerPrefs(65536i32);
pub const MixerPref_FilteringMask: VMRMixerPrefs = VMRMixerPrefs(240i32);
pub const MixerPref_NoDecimation: VMRMixerPrefs = VMRMixerPrefs(1i32);
pub const MixerPref_PointFiltering: VMRMixerPrefs = VMRMixerPrefs(32i32);
pub const MixerPref_RenderTargetMask: VMRMixerPrefs = VMRMixerPrefs(65280i32);
pub const MixerPref_RenderTargetRGB: VMRMixerPrefs = VMRMixerPrefs(256i32);
pub const MixerPref_RenderTargetReserved: VMRMixerPrefs = VMRMixerPrefs(57344i32);
pub const MixerPref_RenderTargetYUV: VMRMixerPrefs = VMRMixerPrefs(4096i32);
pub const MixerPref_RenderTargetYUV420: VMRMixerPrefs = VMRMixerPrefs(512i32);
pub const MixerPref_RenderTargetYUV422: VMRMixerPrefs = VMRMixerPrefs(1024i32);
pub const MixerPref_RenderTargetYUV444: VMRMixerPrefs = VMRMixerPrefs(2048i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ModulationType(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct NORMALIZEDRECT {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
pub const NotAssociated: SmartCardAssociationType = SmartCardAssociationType(0i32);
pub const NotEntitled: EntitlementType = EntitlementType(1i32);
pub const NotReady: UICloseReasonType = UICloseReasonType(0i32);
pub const OAFALSE: OA_BOOL = OA_BOOL(0i32);
pub const OATRUE: OA_BOOL = OA_BOOL(-1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct OA_BOOL(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct OUTPUT_STATE(pub i32);
impl OUTPUT_STATE {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for OUTPUT_STATE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for OUTPUT_STATE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for OUTPUT_STATE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for OUTPUT_STATE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for OUTPUT_STATE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const PBDA_AUX_CONNECTOR_TYPE_Composite: windows_core::GUID = windows_core::GUID::from_u128(0xf6298b4c_c725_4d42_849b_410bbb14ea62);
pub const PBDA_AUX_CONNECTOR_TYPE_SVideo: windows_core::GUID = windows_core::GUID::from_u128(0xa0e905f4_24c9_4a54_b761_213355efc13a);
pub const PBDA_Encoder_Audio_AlgorithmType_AC3: u32 = 1u32;
pub const PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII: u32 = 0u32;
pub const PBDA_Encoder_BitrateMode_Average: u32 = 3u32;
pub const PBDA_Encoder_BitrateMode_Constant: u32 = 1u32;
pub const PBDA_Encoder_BitrateMode_Variable: u32 = 2u32;
pub const PBDA_Encoder_Video_AVC: u32 = 1u32;
pub const PBDA_Encoder_Video_H264: u32 = 1u32;
pub const PBDA_Encoder_Video_MPEG2PartII: u32 = 0u32;
pub const PBDA_Encoder_Video_MPEG4Part10: u32 = 1u32;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_CREATEVIDEOPROCESSDEVICE = Option<unsafe extern "system" fn(pd3dd9: windows_core::Ref<super::super::Graphics::Direct3D9::IDirect3DDevice9>, pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxsubstreams: u32, phdevice: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT>;
pub type PDXVA2SW_DESTROYVIDEOPROCESSDEVICE = Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETFILTERPROPERTYRANGE = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32, prange: *mut super::MediaFoundation::DXVA2_ValueRange) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETPROCAMPRANGE = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32, prange: *mut super::MediaFoundation::DXVA2_ValueRange) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETVIDEOPROCESSORCAPS = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut super::MediaFoundation::DXVA2_VideoProcessorCaps) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, pcount: *mut u32) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32) -> windows_core::HRESULT>;
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
pub type PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS = Option<unsafe extern "system" fn(pvideodesc: *const super::MediaFoundation::DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT>;
pub type PDXVA2SW_VIDEOPROCESSBEGINFRAME = Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT>;
#[cfg(feature = "Win32_Media_MediaFoundation")]
pub type PDXVA2SW_VIDEOPROCESSBLT = Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pblt: *const DXVA2_VIDEOPROCESSBLT) -> windows_core::HRESULT>;
pub type PDXVA2SW_VIDEOPROCESSENDFRAME = Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, phandlecomplete: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT>;
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub type PDXVA2SW_VIDEOPROCESSSETRENDERTARGET = Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, prendertarget: windows_core::Ref<super::super::Graphics::Direct3D9::IDirect3DSurface9>) -> windows_core::HRESULT>;
pub const PID_ELEMENTARY_STREAM: MUX_PID_TYPE = MUX_PID_TYPE(0i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct PID_MAP {
    pub ulPID: u32,
    pub MediaSampleContent: MEDIA_SAMPLE_CONTENT,
}
pub const PID_MPEG2_SECTION_PSI_SI: MUX_PID_TYPE = MUX_PID_TYPE(1i32);
pub const PID_OTHER: MUX_PID_TYPE = MUX_PID_TYPE(-1i32);
pub const PINDIR_INPUT: PIN_DIRECTION = PIN_DIRECTION(0i32);
pub const PINDIR_OUTPUT: PIN_DIRECTION = PIN_DIRECTION(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct PIN_DIRECTION(pub i32);
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
#[derive(Clone, Debug, PartialEq)]
pub struct PIN_INFO {
    pub pFilter: core::mem::ManuallyDrop<Option<IBaseFilter>>,
    pub dir: PIN_DIRECTION,
    pub achName: [u16; 128],
}
#[cfg(feature = "Win32_System_Com")]
impl Default for PIN_INFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const PhysConn_Audio_1394: PhysicalConnectorType = PhysicalConnectorType(4103i32);
pub const PhysConn_Audio_AESDigital: PhysicalConnectorType = PhysicalConnectorType(4099i32);
pub const PhysConn_Audio_AUX: PhysicalConnectorType = PhysicalConnectorType(4102i32);
pub const PhysConn_Audio_AudioDecoder: PhysicalConnectorType = PhysicalConnectorType(4105i32);
pub const PhysConn_Audio_Line: PhysicalConnectorType = PhysicalConnectorType(4097i32);
pub const PhysConn_Audio_Mic: PhysicalConnectorType = PhysicalConnectorType(4098i32);
pub const PhysConn_Audio_SCSI: PhysicalConnectorType = PhysicalConnectorType(4101i32);
pub const PhysConn_Audio_SPDIFDigital: PhysicalConnectorType = PhysicalConnectorType(4100i32);
pub const PhysConn_Audio_Tuner: PhysicalConnectorType = PhysicalConnectorType(4096i32);
pub const PhysConn_Audio_USB: PhysicalConnectorType = PhysicalConnectorType(4104i32);
pub const PhysConn_Video_1394: PhysicalConnectorType = PhysicalConnectorType(10i32);
pub const PhysConn_Video_AUX: PhysicalConnectorType = PhysicalConnectorType(9i32);
pub const PhysConn_Video_Black: PhysicalConnectorType = PhysicalConnectorType(15i32);
pub const PhysConn_Video_Composite: PhysicalConnectorType = PhysicalConnectorType(2i32);
pub const PhysConn_Video_ParallelDigital: PhysicalConnectorType = PhysicalConnectorType(7i32);
pub const PhysConn_Video_RGB: PhysicalConnectorType = PhysicalConnectorType(4i32);
pub const PhysConn_Video_SCART: PhysicalConnectorType = PhysicalConnectorType(14i32);
pub const PhysConn_Video_SCSI: PhysicalConnectorType = PhysicalConnectorType(8i32);
pub const PhysConn_Video_SVideo: PhysicalConnectorType = PhysicalConnectorType(3i32);
pub const PhysConn_Video_SerialDigital: PhysicalConnectorType = PhysicalConnectorType(6i32);
pub const PhysConn_Video_Tuner: PhysicalConnectorType = PhysicalConnectorType(1i32);
pub const PhysConn_Video_USB: PhysicalConnectorType = PhysicalConnectorType(11i32);
pub const PhysConn_Video_VideoDecoder: PhysicalConnectorType = PhysicalConnectorType(12i32);
pub const PhysConn_Video_VideoEncoder: PhysicalConnectorType = PhysicalConnectorType(13i32);
pub const PhysConn_Video_YRYBY: PhysicalConnectorType = PhysicalConnectorType(5i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct PhysicalConnectorType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct Pilot(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct Polarisation(pub i32);
pub const ProcAmpControl9_Brightness: VMR9ProcAmpControlFlags = VMR9ProcAmpControlFlags(1i32);
pub const ProcAmpControl9_Contrast: VMR9ProcAmpControlFlags = VMR9ProcAmpControlFlags(2i32);
pub const ProcAmpControl9_Hue: VMR9ProcAmpControlFlags = VMR9ProcAmpControlFlags(4i32);
pub const ProcAmpControl9_Mask: VMR9ProcAmpControlFlags = VMR9ProcAmpControlFlags(15i32);
pub const ProcAmpControl9_Saturation: VMR9ProcAmpControlFlags = VMR9ProcAmpControlFlags(8i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Quality {
    pub Type: QualityMessageType,
    pub Proportion: i32,
    pub Late: i64,
    pub TimeStamp: i64,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct QualityMessageType(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct REGFILTER {
    pub Clsid: windows_core::GUID,
    pub Name: windows_core::PWSTR,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct REGFILTER2 {
    pub dwVersion: u32,
    pub dwMerit: u32,
    pub Anonymous: REGFILTER2_0,
}
impl Default for REGFILTER2 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union REGFILTER2_0 {
    pub Anonymous1: REGFILTER2_0_0,
    pub Anonymous2: REGFILTER2_0_1,
}
impl Default for REGFILTER2_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct REGFILTER2_0_0 {
    pub cPins: u32,
    pub rgPins: *const REGFILTERPINS,
}
impl Default for REGFILTER2_0_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct REGFILTER2_0_1 {
    pub cPins2: u32,
    pub rgPins2: *const REGFILTERPINS2,
}
impl Default for REGFILTER2_0_1 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct REGFILTERPINS {
    pub strName: windows_core::PWSTR,
    pub bRendered: windows_core::BOOL,
    pub bOutput: windows_core::BOOL,
    pub bZero: windows_core::BOOL,
    pub bMany: windows_core::BOOL,
    pub clsConnectsToFilter: *const windows_core::GUID,
    pub strConnectsToPin: windows_core::PCWSTR,
    pub nMediaTypes: u32,
    pub lpMediaType: *const REGPINTYPES,
}
impl Default for REGFILTERPINS {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct REGFILTERPINS2 {
    pub dwFlags: u32,
    pub cInstances: u32,
    pub nMediaTypes: u32,
    pub lpMediaType: *const REGPINTYPES,
    pub nMediums: u32,
    pub lpMedium: *const REGPINMEDIUM,
    pub clsPinCategory: *const windows_core::GUID,
}
impl Default for REGFILTERPINS2 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct REGPINMEDIUM {
    pub clsMedium: windows_core::GUID,
    pub dw1: u32,
    pub dw2: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct REGPINTYPES {
    pub clsMajorType: *const windows_core::GUID,
    pub clsMinorType: *const windows_core::GUID,
}
impl Default for REGPINTYPES {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct REG_PINFLAG(pub i32);
impl REG_PINFLAG {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for REG_PINFLAG {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for REG_PINFLAG {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for REG_PINFLAG {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for REG_PINFLAG {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for REG_PINFLAG {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const REG_PINFLAG_B_MANY: REG_PINFLAG = REG_PINFLAG(4i32);
pub const REG_PINFLAG_B_OUTPUT: REG_PINFLAG = REG_PINFLAG(8i32);
pub const REG_PINFLAG_B_RENDERER: REG_PINFLAG = REG_PINFLAG(2i32);
pub const REG_PINFLAG_B_ZERO: REG_PINFLAG = REG_PINFLAG(1i32);
pub const REMFILTERF_LEAVECONNECTED: _REM_FILTER_FLAGS = _REM_FILTER_FLAGS(1i32);
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct RIFFCHUNK {
    pub fcc: u32,
    pub cb: u32,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct RIFFLIST {
    pub fcc: u32,
    pub cb: u32,
    pub fccListType: u32,
}
pub const ReadData: OUTPUT_STATE = OUTPUT_STATE(1i32);
pub const RenderData: OUTPUT_STATE = OUTPUT_STATE(2i32);
pub const RenderPrefs9_DoNotRenderBorder: VMR9RenderPrefs = VMR9RenderPrefs(1i32);
pub const RenderPrefs9_Mask: VMR9RenderPrefs = VMR9RenderPrefs(1i32);
pub const RenderPrefs_AllowOffscreen: VMRRenderPrefs = VMRRenderPrefs(0i32);
pub const RenderPrefs_AllowOverlays: VMRRenderPrefs = VMRRenderPrefs(0i32);
pub const RenderPrefs_DoNotRenderColorKeyAndBorder: VMRRenderPrefs = VMRRenderPrefs(8i32);
pub const RenderPrefs_ForceOffscreen: VMRRenderPrefs = VMRRenderPrefs(1i32);
pub const RenderPrefs_ForceOverlays: VMRRenderPrefs = VMRRenderPrefs(2i32);
pub const RenderPrefs_Mask: VMRRenderPrefs = VMRRenderPrefs(63i32);
pub const RenderPrefs_PreferAGPMemWhenMixing: VMRRenderPrefs = VMRRenderPrefs(32i32);
pub const RenderPrefs_Reserved: VMRRenderPrefs = VMRRenderPrefs(16i32);
pub const RenderPrefs_RestrictToInitialMonitor: VMRRenderPrefs = VMRRenderPrefs(0i32);
pub const Reserved1: MPEG2StreamType = MPEG2StreamType(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct RollOff(pub i32);
pub const SCTE28_ConditionalAccess: ApplicationTypeType = ApplicationTypeType(0i32);
pub const SCTE28_CopyProtection: ApplicationTypeType = ApplicationTypeType(5i32);
pub const SCTE28_Diagnostic: ApplicationTypeType = ApplicationTypeType(6i32);
pub const SCTE28_IPService: ApplicationTypeType = ApplicationTypeType(2i32);
pub const SCTE28_NetworkInterface_SCTE55_1: ApplicationTypeType = ApplicationTypeType(4i32);
pub const SCTE28_NetworkInterface_SCTE55_2: ApplicationTypeType = ApplicationTypeType(3i32);
pub const SCTE28_POD_Host_Binding_Information: ApplicationTypeType = ApplicationTypeType(1i32);
pub const SCTE28_Reserved: ApplicationTypeType = ApplicationTypeType(8i32);
pub const SCTE28_Undesignated: ApplicationTypeType = ApplicationTypeType(7i32);
pub const SCTE_18: LocationCodeSchemeType = LocationCodeSchemeType(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SNDDEV_ERR(pub i32);
pub const SNDDEV_ERROR_AddBuffer: SNDDEV_ERR = SNDDEV_ERR(13i32);
pub const SNDDEV_ERROR_Close: SNDDEV_ERR = SNDDEV_ERR(2i32);
pub const SNDDEV_ERROR_GetCaps: SNDDEV_ERR = SNDDEV_ERR(3i32);
pub const SNDDEV_ERROR_GetPosition: SNDDEV_ERR = SNDDEV_ERR(8i32);
pub const SNDDEV_ERROR_Open: SNDDEV_ERR = SNDDEV_ERR(1i32);
pub const SNDDEV_ERROR_Pause: SNDDEV_ERR = SNDDEV_ERR(10i32);
pub const SNDDEV_ERROR_PrepareHeader: SNDDEV_ERR = SNDDEV_ERR(4i32);
pub const SNDDEV_ERROR_Query: SNDDEV_ERR = SNDDEV_ERR(14i32);
pub const SNDDEV_ERROR_Reset: SNDDEV_ERR = SNDDEV_ERR(6i32);
pub const SNDDEV_ERROR_Restart: SNDDEV_ERR = SNDDEV_ERR(7i32);
pub const SNDDEV_ERROR_Start: SNDDEV_ERR = SNDDEV_ERR(12i32);
pub const SNDDEV_ERROR_Stop: SNDDEV_ERR = SNDDEV_ERR(11i32);
pub const SNDDEV_ERROR_UnprepareHeader: SNDDEV_ERR = SNDDEV_ERR(5i32);
pub const SNDDEV_ERROR_Write: SNDDEV_ERR = SNDDEV_ERR(9i32);
pub const SPECIFYPAGES_STATISTICS: windows_core::GUID = windows_core::GUID::from_u128(0x4c437b92_6e9e_11d1_a704_006097c4e476);
pub const SSUPDATE_ASYNC: SSUPDATE_TYPE = SSUPDATE_TYPE(1i32);
pub const SSUPDATE_CONTINUOUS: SSUPDATE_TYPE = SSUPDATE_TYPE(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SSUPDATE_TYPE(pub i32);
pub const STDINDEXSIZE: u32 = 16384u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct STREAMIF_CONSTANTS(pub i32);
pub const STREAMSTATE_RUN: STREAM_STATE = STREAM_STATE(1i32);
pub const STREAMSTATE_STOP: STREAM_STATE = STREAM_STATE(0i32);
pub const STREAMTYPE_READ: STREAM_TYPE = STREAM_TYPE(0i32);
pub const STREAMTYPE_TRANSFORM: STREAM_TYPE = STREAM_TYPE(2i32);
pub const STREAMTYPE_WRITE: STREAM_TYPE = STREAM_TYPE(1i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct STREAM_ID_MAP {
    pub stream_id: u32,
    pub dwMediaSampleContent: u32,
    pub ulSubstreamFilterValue: u32,
    pub iDataOffset: i32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct STREAM_STATE(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct STREAM_TYPE(pub i32);
pub const SUBSTREAM_FILTER_VAL_NONE: u32 = 268435456u32;
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ScanModulationTypes(pub i32);
pub const ScanModulationTypesMask_DVBC: ScanModulationTypes = ScanModulationTypes(75i32);
pub const ScanModulationTypesMask_MCE_All_TV: ScanModulationTypes = ScanModulationTypes(-1i32);
pub const ScanModulationTypesMask_MCE_AnalogTv: ScanModulationTypes = ScanModulationTypes(28i32);
pub const ScanModulationTypesMask_MCE_DigitalCable: ScanModulationTypes = ScanModulationTypes(11i32);
pub const ScanModulationTypesMask_MCE_TerrestrialATSC: ScanModulationTypes = ScanModulationTypes(23i32);
#[repr(C)]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct SmartCardApplication {
    pub ApplicationType: ApplicationTypeType,
    pub ApplicationVersion: u16,
    pub pbstrApplicationName: core::mem::ManuallyDrop<windows_core::BSTR>,
    pub pbstrApplicationURL: core::mem::ManuallyDrop<windows_core::BSTR>,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SmartCardAssociationType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SmartCardStatusType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SpectralInversion(pub i32);
pub const State_Paused: FILTER_STATE = FILTER_STATE(1i32);
pub const State_Running: FILTER_STATE = FILTER_STATE(2i32);
pub const State_Stopped: FILTER_STATE = FILTER_STATE(0i32);
pub const StatusActive: ComponentStatus = ComponentStatus(0i32);
pub const StatusInactive: ComponentStatus = ComponentStatus(1i32);
pub const StatusUnavailable: ComponentStatus = ComponentStatus(2i32);
pub const SystemClosed: UICloseReasonType = UICloseReasonType(2i32);
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct TIMECODEDATA {
    pub time: super::TIMECODE,
    pub dwSMPTEflags: u32,
    pub dwUser: u32,
}
impl Default for TIMECODEDATA {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const TIMECODE_RATE_30DROP: u32 = 0u32;
pub const TIMECODE_SMPTE_BINARY_GROUP: u32 = 7u32;
pub const TIMECODE_SMPTE_COLOR_FRAME: u32 = 8u32;
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct TRUECOLORINFO {
    pub dwBitMasks: [u32; 3],
    pub bmiColors: [super::super::Graphics::Gdi::RGBQUAD; 256],
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for TRUECOLORINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct TVAudioMode(pub i32);
pub const TechnicalFailure: EntitlementType = EntitlementType(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct TransmissionMode(pub i32);
pub const TunerInputAntenna: TunerInputType = TunerInputType(1i32);
pub const TunerInputCable: TunerInputType = TunerInputType(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct TunerInputType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct UICloseReasonType(pub i32);
pub const UOP_FLAG_Pause_On: VALID_UOP_FLAG = VALID_UOP_FLAG(524288i32);
pub const UOP_FLAG_PlayNext_Chapter: VALID_UOP_FLAG = VALID_UOP_FLAG(128i32);
pub const UOP_FLAG_PlayPrev_Or_Replay_Chapter: VALID_UOP_FLAG = VALID_UOP_FLAG(64i32);
pub const UOP_FLAG_Play_Backwards: VALID_UOP_FLAG = VALID_UOP_FLAG(512i32);
pub const UOP_FLAG_Play_Chapter: VALID_UOP_FLAG = VALID_UOP_FLAG(2i32);
pub const UOP_FLAG_Play_Chapter_Or_AtTime: VALID_UOP_FLAG = VALID_UOP_FLAG(32i32);
pub const UOP_FLAG_Play_Forwards: VALID_UOP_FLAG = VALID_UOP_FLAG(256i32);
pub const UOP_FLAG_Play_Title: VALID_UOP_FLAG = VALID_UOP_FLAG(4i32);
pub const UOP_FLAG_Play_Title_Or_AtTime: VALID_UOP_FLAG = VALID_UOP_FLAG(1i32);
pub const UOP_FLAG_Resume: VALID_UOP_FLAG = VALID_UOP_FLAG(65536i32);
pub const UOP_FLAG_ReturnFromSubMenu: VALID_UOP_FLAG = VALID_UOP_FLAG(16i32);
pub const UOP_FLAG_Select_Angle: VALID_UOP_FLAG = VALID_UOP_FLAG(4194304i32);
pub const UOP_FLAG_Select_Audio_Stream: VALID_UOP_FLAG = VALID_UOP_FLAG(1048576i32);
pub const UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode: VALID_UOP_FLAG = VALID_UOP_FLAG(8388608i32);
pub const UOP_FLAG_Select_Or_Activate_Button: VALID_UOP_FLAG = VALID_UOP_FLAG(131072i32);
pub const UOP_FLAG_Select_SubPic_Stream: VALID_UOP_FLAG = VALID_UOP_FLAG(2097152i32);
pub const UOP_FLAG_Select_Video_Mode_Preference: VALID_UOP_FLAG = VALID_UOP_FLAG(16777216i32);
pub const UOP_FLAG_ShowMenu_Angle: VALID_UOP_FLAG = VALID_UOP_FLAG(16384i32);
pub const UOP_FLAG_ShowMenu_Audio: VALID_UOP_FLAG = VALID_UOP_FLAG(8192i32);
pub const UOP_FLAG_ShowMenu_Chapter: VALID_UOP_FLAG = VALID_UOP_FLAG(32768i32);
pub const UOP_FLAG_ShowMenu_Root: VALID_UOP_FLAG = VALID_UOP_FLAG(2048i32);
pub const UOP_FLAG_ShowMenu_SubPic: VALID_UOP_FLAG = VALID_UOP_FLAG(4096i32);
pub const UOP_FLAG_ShowMenu_Title: VALID_UOP_FLAG = VALID_UOP_FLAG(1024i32);
pub const UOP_FLAG_Still_Off: VALID_UOP_FLAG = VALID_UOP_FLAG(262144i32);
pub const UOP_FLAG_Stop: VALID_UOP_FLAG = VALID_UOP_FLAG(8i32);
pub const USER_PRIVATE: MPEG2StreamType = MPEG2StreamType(16i32);
pub const UserClosed: UICloseReasonType = UICloseReasonType(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VALID_UOP_FLAG(pub i32);
pub const VFW_E_ADVISE_ALREADY_SET: windows_core::HRESULT = windows_core::HRESULT(0x80040236_u32 as _);
pub const VFW_E_ALREADY_CANCELLED: windows_core::HRESULT = windows_core::HRESULT(0x80040234_u32 as _);
pub const VFW_E_ALREADY_COMMITTED: windows_core::HRESULT = windows_core::HRESULT(0x8004020F_u32 as _);
pub const VFW_E_ALREADY_CONNECTED: windows_core::HRESULT = windows_core::HRESULT(0x80040204_u32 as _);
pub const VFW_E_BADALIGN: windows_core::HRESULT = windows_core::HRESULT(0x8004020E_u32 as _);
pub const VFW_E_BAD_KEY: windows_core::HRESULT = windows_core::HRESULT(0x800403F2_u32 as _);
pub const VFW_E_BAD_VIDEOCD: windows_core::HRESULT = windows_core::HRESULT(0x80040269_u32 as _);
pub const VFW_E_BUFFERS_OUTSTANDING: windows_core::HRESULT = windows_core::HRESULT(0x80040210_u32 as _);
pub const VFW_E_BUFFER_NOTSET: windows_core::HRESULT = windows_core::HRESULT(0x8004020C_u32 as _);
pub const VFW_E_BUFFER_OVERFLOW: windows_core::HRESULT = windows_core::HRESULT(0x8004020D_u32 as _);
pub const VFW_E_BUFFER_UNDERFLOW: windows_core::HRESULT = windows_core::HRESULT(0x80040264_u32 as _);
pub const VFW_E_CANNOT_CONNECT: windows_core::HRESULT = windows_core::HRESULT(0x80040217_u32 as _);
pub const VFW_E_CANNOT_LOAD_SOURCE_FILTER: windows_core::HRESULT = windows_core::HRESULT(0x80040241_u32 as _);
pub const VFW_E_CANNOT_RENDER: windows_core::HRESULT = windows_core::HRESULT(0x80040218_u32 as _);
pub const VFW_E_CERTIFICATION_FAILURE: windows_core::HRESULT = windows_core::HRESULT(0x80040295_u32 as _);
pub const VFW_E_CHANGING_FORMAT: windows_core::HRESULT = windows_core::HRESULT(0x80040219_u32 as _);
pub const VFW_E_CIRCULAR_GRAPH: windows_core::HRESULT = windows_core::HRESULT(0x80040231_u32 as _);
pub const VFW_E_CODECAPI_ENUMERATED: windows_core::HRESULT = windows_core::HRESULT(0x80040311_u32 as _);
pub const VFW_E_CODECAPI_LINEAR_RANGE: windows_core::HRESULT = windows_core::HRESULT(0x80040310_u32 as _);
pub const VFW_E_CODECAPI_NO_CURRENT_VALUE: windows_core::HRESULT = windows_core::HRESULT(0x80040314_u32 as _);
pub const VFW_E_CODECAPI_NO_DEFAULT: windows_core::HRESULT = windows_core::HRESULT(0x80040313_u32 as _);
pub const VFW_E_COLOR_KEY_SET: windows_core::HRESULT = windows_core::HRESULT(0x8004021E_u32 as _);
pub const VFW_E_COPYPROT_FAILED: windows_core::HRESULT = windows_core::HRESULT(0x8004027D_u32 as _);
pub const VFW_E_CORRUPT_GRAPH_FILE: windows_core::HRESULT = windows_core::HRESULT(0x80040235_u32 as _);
pub const VFW_E_DDRAW_CAPS_NOT_SUITABLE: windows_core::HRESULT = windows_core::HRESULT(0x80040273_u32 as _);
pub const VFW_E_DDRAW_VERSION_NOT_SUITABLE: windows_core::HRESULT = windows_core::HRESULT(0x8004027C_u32 as _);
pub const VFW_E_DUPLICATE_NAME: windows_core::HRESULT = windows_core::HRESULT(0x8004022D_u32 as _);
pub const VFW_E_DVD_CHAPTER_DOES_NOT_EXIST: windows_core::HRESULT = windows_core::HRESULT(0x80040315_u32 as _);
pub const VFW_E_DVD_CMD_CANCELLED: windows_core::HRESULT = windows_core::HRESULT(0x80040283_u32 as _);
pub const VFW_E_DVD_DECNOTENOUGH: windows_core::HRESULT = windows_core::HRESULT(0x8004027B_u32 as _);
pub const VFW_E_DVD_GRAPHNOTREADY: windows_core::HRESULT = windows_core::HRESULT(0x80040279_u32 as _);
pub const VFW_E_DVD_INCOMPATIBLE_REGION: windows_core::HRESULT = windows_core::HRESULT(0x80040287_u32 as _);
pub const VFW_E_DVD_INVALIDDOMAIN: windows_core::HRESULT = windows_core::HRESULT(0x80040277_u32 as _);
pub const VFW_E_DVD_INVALID_DISC: windows_core::HRESULT = windows_core::HRESULT(0x80040291_u32 as _);
pub const VFW_E_DVD_LOW_PARENTAL_LEVEL: windows_core::HRESULT = windows_core::HRESULT(0x8004028A_u32 as _);
pub const VFW_E_DVD_MENU_DOES_NOT_EXIST: windows_core::HRESULT = windows_core::HRESULT(0x80040282_u32 as _);
pub const VFW_E_DVD_NONBLOCKING: windows_core::HRESULT = windows_core::HRESULT(0x8004029C_u32 as _);
pub const VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH: windows_core::HRESULT = windows_core::HRESULT(0x8004029E_u32 as _);
pub const VFW_E_DVD_NOT_IN_KARAOKE_MODE: windows_core::HRESULT = windows_core::HRESULT(0x8004028B_u32 as _);
pub const VFW_E_DVD_NO_ATTRIBUTES: windows_core::HRESULT = windows_core::HRESULT(0x80040288_u32 as _);
pub const VFW_E_DVD_NO_BUTTON: windows_core::HRESULT = windows_core::HRESULT(0x80040278_u32 as _);
pub const VFW_E_DVD_NO_GOUP_PGC: windows_core::HRESULT = windows_core::HRESULT(0x80040289_u32 as _);
pub const VFW_E_DVD_NO_RESUME_INFORMATION: windows_core::HRESULT = windows_core::HRESULT(0x80040292_u32 as _);
pub const VFW_E_DVD_OPERATION_INHIBITED: windows_core::HRESULT = windows_core::HRESULT(0x80040276_u32 as _);
pub const VFW_E_DVD_RENDERFAIL: windows_core::HRESULT = windows_core::HRESULT(0x8004027A_u32 as _);
pub const VFW_E_DVD_RESOLUTION_ERROR: windows_core::HRESULT = windows_core::HRESULT(0x8004029F_u32 as _);
pub const VFW_E_DVD_STATE_CORRUPT: windows_core::HRESULT = windows_core::HRESULT(0x80040285_u32 as _);
pub const VFW_E_DVD_STATE_WRONG_DISC: windows_core::HRESULT = windows_core::HRESULT(0x80040286_u32 as _);
pub const VFW_E_DVD_STATE_WRONG_VERSION: windows_core::HRESULT = windows_core::HRESULT(0x80040284_u32 as _);
pub const VFW_E_DVD_STREAM_DISABLED: windows_core::HRESULT = windows_core::HRESULT(0x8004028F_u32 as _);
pub const VFW_E_DVD_TITLE_UNKNOWN: windows_core::HRESULT = windows_core::HRESULT(0x80040290_u32 as _);
pub const VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH: windows_core::HRESULT = windows_core::HRESULT(0x8004029D_u32 as _);
pub const VFW_E_DVD_VMR9_INCOMPATIBLEDEC: windows_core::HRESULT = windows_core::HRESULT(0x8004029A_u32 as _);
pub const VFW_E_DVD_WRONG_SPEED: windows_core::HRESULT = windows_core::HRESULT(0x80040281_u32 as _);
pub const VFW_E_ENUM_OUT_OF_RANGE: windows_core::HRESULT = windows_core::HRESULT(0x80040230_u32 as _);
pub const VFW_E_ENUM_OUT_OF_SYNC: windows_core::HRESULT = windows_core::HRESULT(0x80040203_u32 as _);
pub const VFW_E_FILE_TOO_SHORT: windows_core::HRESULT = windows_core::HRESULT(0x80040243_u32 as _);
pub const VFW_E_FILTER_ACTIVE: windows_core::HRESULT = windows_core::HRESULT(0x80040205_u32 as _);
pub const VFW_E_FRAME_STEP_UNSUPPORTED: windows_core::HRESULT = windows_core::HRESULT(0x8004028E_u32 as _);
pub const VFW_E_INVALIDMEDIATYPE: windows_core::HRESULT = windows_core::HRESULT(0x80040200_u32 as _);
pub const VFW_E_INVALIDSUBTYPE: windows_core::HRESULT = windows_core::HRESULT(0x80040201_u32 as _);
pub const VFW_E_INVALID_CLSID: windows_core::HRESULT = windows_core::HRESULT(0x80040247_u32 as _);
pub const VFW_E_INVALID_DIRECTION: windows_core::HRESULT = windows_core::HRESULT(0x80040208_u32 as _);
pub const VFW_E_INVALID_FILE_FORMAT: windows_core::HRESULT = windows_core::HRESULT(0x8004022F_u32 as _);
pub const VFW_E_INVALID_FILE_VERSION: windows_core::HRESULT = windows_core::HRESULT(0x80040244_u32 as _);
pub const VFW_E_INVALID_MEDIA_TYPE: windows_core::HRESULT = windows_core::HRESULT(0x80040248_u32 as _);
pub const VFW_E_INVALID_RECT: windows_core::HRESULT = windows_core::HRESULT(0x80040229_u32 as _);
pub const VFW_E_IN_FULLSCREEN_MODE: windows_core::HRESULT = windows_core::HRESULT(0x8004023B_u32 as _);
pub const VFW_E_MEDIA_TIME_NOT_SET: windows_core::HRESULT = windows_core::HRESULT(0x80040251_u32 as _);
pub const VFW_E_MONO_AUDIO_HW: windows_core::HRESULT = windows_core::HRESULT(0x80040253_u32 as _);
pub const VFW_E_MPEG_NOT_CONSTRAINED: windows_core::HRESULT = windows_core::HRESULT(0x8004025E_u32 as _);
pub const VFW_E_NEED_OWNER: windows_core::HRESULT = windows_core::HRESULT(0x80040202_u32 as _);
pub const VFW_E_NOT_ALLOWED_TO_SAVE: windows_core::HRESULT = windows_core::HRESULT(0x80040232_u32 as _);
pub const VFW_E_NOT_COMMITTED: windows_core::HRESULT = windows_core::HRESULT(0x80040211_u32 as _);
pub const VFW_E_NOT_CONNECTED: windows_core::HRESULT = windows_core::HRESULT(0x80040209_u32 as _);
pub const VFW_E_NOT_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x80040216_u32 as _);
pub const VFW_E_NOT_IN_GRAPH: windows_core::HRESULT = windows_core::HRESULT(0x8004025F_u32 as _);
pub const VFW_E_NOT_OVERLAY_CONNECTION: windows_core::HRESULT = windows_core::HRESULT(0x8004021B_u32 as _);
pub const VFW_E_NOT_PAUSED: windows_core::HRESULT = windows_core::HRESULT(0x80040225_u32 as _);
pub const VFW_E_NOT_RUNNING: windows_core::HRESULT = windows_core::HRESULT(0x80040226_u32 as _);
pub const VFW_E_NOT_SAMPLE_CONNECTION: windows_core::HRESULT = windows_core::HRESULT(0x8004021C_u32 as _);
pub const VFW_E_NOT_STOPPED: windows_core::HRESULT = windows_core::HRESULT(0x80040224_u32 as _);
pub const VFW_E_NO_ACCEPTABLE_TYPES: windows_core::HRESULT = windows_core::HRESULT(0x80040207_u32 as _);
pub const VFW_E_NO_ADVISE_SET: windows_core::HRESULT = windows_core::HRESULT(0x80040239_u32 as _);
pub const VFW_E_NO_ALLOCATOR: windows_core::HRESULT = windows_core::HRESULT(0x8004020A_u32 as _);
pub const VFW_E_NO_AUDIO_HARDWARE: windows_core::HRESULT = windows_core::HRESULT(0x80040256_u32 as _);
pub const VFW_E_NO_CAPTURE_HARDWARE: windows_core::HRESULT = windows_core::HRESULT(0x80040275_u32 as _);
pub const VFW_E_NO_CLOCK: windows_core::HRESULT = windows_core::HRESULT(0x80040213_u32 as _);
pub const VFW_E_NO_COLOR_KEY_FOUND: windows_core::HRESULT = windows_core::HRESULT(0x8004021F_u32 as _);
pub const VFW_E_NO_COLOR_KEY_SET: windows_core::HRESULT = windows_core::HRESULT(0x8004021A_u32 as _);
pub const VFW_E_NO_COPP_HW: windows_core::HRESULT = windows_core::HRESULT(0x8004029B_u32 as _);
pub const VFW_E_NO_DECOMPRESSOR: windows_core::HRESULT = windows_core::HRESULT(0x80040255_u32 as _);
pub const VFW_E_NO_DISPLAY_PALETTE: windows_core::HRESULT = windows_core::HRESULT(0x80040221_u32 as _);
pub const VFW_E_NO_FULLSCREEN: windows_core::HRESULT = windows_core::HRESULT(0x8004023A_u32 as _);
pub const VFW_E_NO_INTERFACE: windows_core::HRESULT = windows_core::HRESULT(0x80040215_u32 as _);
pub const VFW_E_NO_MODEX_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x80040238_u32 as _);
pub const VFW_E_NO_PALETTE_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x80040220_u32 as _);
pub const VFW_E_NO_SINK: windows_core::HRESULT = windows_core::HRESULT(0x80040214_u32 as _);
pub const VFW_E_NO_TIME_FORMAT: windows_core::HRESULT = windows_core::HRESULT(0x80040261_u32 as _);
pub const VFW_E_NO_TIME_FORMAT_SET: windows_core::HRESULT = windows_core::HRESULT(0x80040252_u32 as _);
pub const VFW_E_NO_TRANSPORT: windows_core::HRESULT = windows_core::HRESULT(0x80040266_u32 as _);
pub const VFW_E_NO_TYPES: windows_core::HRESULT = windows_core::HRESULT(0x80040206_u32 as _);
pub const VFW_E_NO_VP_HARDWARE: windows_core::HRESULT = windows_core::HRESULT(0x80040274_u32 as _);
pub const VFW_E_OUT_OF_VIDEO_MEMORY: windows_core::HRESULT = windows_core::HRESULT(0x80040271_u32 as _);
pub const VFW_E_PALETTE_SET: windows_core::HRESULT = windows_core::HRESULT(0x8004021D_u32 as _);
pub const VFW_E_PIN_ALREADY_BLOCKED: windows_core::HRESULT = windows_core::HRESULT(0x80040294_u32 as _);
pub const VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD: windows_core::HRESULT = windows_core::HRESULT(0x80040293_u32 as _);
pub const VFW_E_PROCESSOR_NOT_SUITABLE: windows_core::HRESULT = windows_core::HRESULT(0x8004025B_u32 as _);
pub const VFW_E_READ_ONLY: windows_core::HRESULT = windows_core::HRESULT(0x80040262_u32 as _);
pub const VFW_E_RPZA: windows_core::HRESULT = windows_core::HRESULT(0x80040259_u32 as _);
pub const VFW_E_RUNTIME_ERROR: windows_core::HRESULT = windows_core::HRESULT(0x8004020B_u32 as _);
pub const VFW_E_SAMPLE_REJECTED: windows_core::HRESULT = windows_core::HRESULT(0x8004022B_u32 as _);
pub const VFW_E_SAMPLE_REJECTED_EOS: windows_core::HRESULT = windows_core::HRESULT(0x8004022C_u32 as _);
pub const VFW_E_SAMPLE_TIME_NOT_SET: windows_core::HRESULT = windows_core::HRESULT(0x80040249_u32 as _);
pub const VFW_E_SIZENOTSET: windows_core::HRESULT = windows_core::HRESULT(0x80040212_u32 as _);
pub const VFW_E_START_TIME_AFTER_END: windows_core::HRESULT = windows_core::HRESULT(0x80040228_u32 as _);
pub const VFW_E_STATE_CHANGED: windows_core::HRESULT = windows_core::HRESULT(0x80040223_u32 as _);
pub const VFW_E_TIMEOUT: windows_core::HRESULT = windows_core::HRESULT(0x8004022E_u32 as _);
pub const VFW_E_TIME_ALREADY_PASSED: windows_core::HRESULT = windows_core::HRESULT(0x80040233_u32 as _);
pub const VFW_E_TIME_EXPIRED: windows_core::HRESULT = windows_core::HRESULT(0x8004027F_u32 as _);
pub const VFW_E_TOO_MANY_COLORS: windows_core::HRESULT = windows_core::HRESULT(0x80040222_u32 as _);
pub const VFW_E_TYPE_NOT_ACCEPTED: windows_core::HRESULT = windows_core::HRESULT(0x8004022A_u32 as _);
pub const VFW_E_UNKNOWN_FILE_TYPE: windows_core::HRESULT = windows_core::HRESULT(0x80040240_u32 as _);
pub const VFW_E_UNSUPPORTED_AUDIO: windows_core::HRESULT = windows_core::HRESULT(0x8004025C_u32 as _);
pub const VFW_E_UNSUPPORTED_STREAM: windows_core::HRESULT = windows_core::HRESULT(0x80040265_u32 as _);
pub const VFW_E_UNSUPPORTED_VIDEO: windows_core::HRESULT = windows_core::HRESULT(0x8004025D_u32 as _);
pub const VFW_E_VMR_NOT_IN_MIXER_MODE: windows_core::HRESULT = windows_core::HRESULT(0x80040296_u32 as _);
pub const VFW_E_VMR_NO_AP_SUPPLIED: windows_core::HRESULT = windows_core::HRESULT(0x80040297_u32 as _);
pub const VFW_E_VMR_NO_DEINTERLACE_HW: windows_core::HRESULT = windows_core::HRESULT(0x80040298_u32 as _);
pub const VFW_E_VMR_NO_PROCAMP_HW: windows_core::HRESULT = windows_core::HRESULT(0x80040299_u32 as _);
pub const VFW_E_VP_NEGOTIATION_FAILED: windows_core::HRESULT = windows_core::HRESULT(0x80040272_u32 as _);
pub const VFW_E_WRONG_STATE: windows_core::HRESULT = windows_core::HRESULT(0x80040227_u32 as _);
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct VFW_FILTERLIST {
    pub cFilters: u32,
    pub aClsId: [windows_core::GUID; 1],
}
impl Default for VFW_FILTERLIST {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const VFW_FIRST_CODE: u32 = 512u32;
pub const VFW_S_AUDIO_NOT_RENDERED: windows_core::HRESULT = windows_core::HRESULT(0x40258_u32 as _);
pub const VFW_S_CANT_CUE: windows_core::HRESULT = windows_core::HRESULT(0x40268_u32 as _);
pub const VFW_S_CONNECTIONS_DEFERRED: windows_core::HRESULT = windows_core::HRESULT(0x40246_u32 as _);
pub const VFW_S_DUPLICATE_NAME: windows_core::HRESULT = windows_core::HRESULT(0x4022D_u32 as _);
pub const VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE: windows_core::HRESULT = windows_core::HRESULT(0x4028C_u32 as _);
pub const VFW_S_DVD_NON_ONE_SEQUENTIAL: windows_core::HRESULT = windows_core::HRESULT(0x40280_u32 as _);
pub const VFW_S_DVD_NOT_ACCURATE: windows_core::HRESULT = windows_core::HRESULT(0x4028D_u32 as _);
pub const VFW_S_DVD_RENDER_STATUS: windows_core::HRESULT = windows_core::HRESULT(0x40320_u32 as _);
pub const VFW_S_ESTIMATED: windows_core::HRESULT = windows_core::HRESULT(0x40260_u32 as _);
pub const VFW_S_MEDIA_TYPE_IGNORED: windows_core::HRESULT = windows_core::HRESULT(0x40254_u32 as _);
pub const VFW_S_NOPREVIEWPIN: windows_core::HRESULT = windows_core::HRESULT(0x4027E_u32 as _);
pub const VFW_S_NO_MORE_ITEMS: windows_core::HRESULT = windows_core::HRESULT(0x40103_u32 as _);
pub const VFW_S_NO_STOP_TIME: windows_core::HRESULT = windows_core::HRESULT(0x40270_u32 as _);
pub const VFW_S_PARTIAL_RENDER: windows_core::HRESULT = windows_core::HRESULT(0x40242_u32 as _);
pub const VFW_S_RESERVED: windows_core::HRESULT = windows_core::HRESULT(0x40263_u32 as _);
pub const VFW_S_RESOURCE_NOT_NEEDED: windows_core::HRESULT = windows_core::HRESULT(0x40250_u32 as _);
pub const VFW_S_RPZA: windows_core::HRESULT = windows_core::HRESULT(0x4025A_u32 as _);
pub const VFW_S_SOME_DATA_IGNORED: windows_core::HRESULT = windows_core::HRESULT(0x40245_u32 as _);
pub const VFW_S_STATE_INTERMEDIATE: windows_core::HRESULT = windows_core::HRESULT(0x40237_u32 as _);
pub const VFW_S_STREAM_OFF: windows_core::HRESULT = windows_core::HRESULT(0x40267_u32 as _);
pub const VFW_S_VIDEO_NOT_RENDERED: windows_core::HRESULT = windows_core::HRESULT(0x40257_u32 as _);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VIDEOENCODER_BITRATE_MODE(pub i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy)]
pub struct VIDEOINFO {
    pub rcSource: super::super::Foundation::RECT,
    pub rcTarget: super::super::Foundation::RECT,
    pub dwBitRate: u32,
    pub dwBitErrorRate: u32,
    pub AvgTimePerFrame: i64,
    pub bmiHeader: super::super::Graphics::Gdi::BITMAPINFOHEADER,
    pub Anonymous: VIDEOINFO_0,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for VIDEOINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy)]
pub union VIDEOINFO_0 {
    pub bmiColors: [super::super::Graphics::Gdi::RGBQUAD; 256],
    pub dwBitMasks: [u32; 3],
    pub TrueColorInfo: TRUECOLORINFO,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for VIDEOINFO_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VIDEO_STREAM_CONFIG_CAPS {
    pub guid: windows_core::GUID,
    pub VideoStandard: u32,
    pub InputSize: super::super::Foundation::SIZE,
    pub MinCroppingSize: super::super::Foundation::SIZE,
    pub MaxCroppingSize: super::super::Foundation::SIZE,
    pub CropGranularityX: i32,
    pub CropGranularityY: i32,
    pub CropAlignX: i32,
    pub CropAlignY: i32,
    pub MinOutputSize: super::super::Foundation::SIZE,
    pub MaxOutputSize: super::super::Foundation::SIZE,
    pub OutputGranularityX: i32,
    pub OutputGranularityY: i32,
    pub StretchTapsX: i32,
    pub StretchTapsY: i32,
    pub ShrinkTapsX: i32,
    pub ShrinkTapsY: i32,
    pub MinFrameInterval: i64,
    pub MaxFrameInterval: i64,
    pub MinBitsPerSecond: i32,
    pub MaxBitsPerSecond: i32,
}
pub const VMR9ARMode_LetterBox: VMR9AspectRatioMode = VMR9AspectRatioMode(1i32);
pub const VMR9ARMode_None: VMR9AspectRatioMode = VMR9AspectRatioMode(0i32);
pub const VMR9AllocFlag_3DRenderTarget: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(1i32);
pub const VMR9AllocFlag_DXVATarget: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(2i32);
pub const VMR9AllocFlag_OffscreenSurface: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(8i32);
pub const VMR9AllocFlag_RGBDynamicSwitch: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(16i32);
pub const VMR9AllocFlag_TextureSurface: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(4i32);
pub const VMR9AllocFlag_UsageMask: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(255i32);
pub const VMR9AllocFlag_UsageReserved: VMR9SurfaceAllocationFlags = VMR9SurfaceAllocationFlags(224i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9AllocationInfo {
    pub dwFlags: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub Format: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub Pool: super::super::Graphics::Direct3D9::D3DPOOL,
    pub MinBuffers: u32,
    pub szAspectRatio: super::super::Foundation::SIZE,
    pub szNativeSize: super::super::Foundation::SIZE,
}
#[repr(C)]
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMR9AlphaBitmap {
    pub dwFlags: u32,
    pub hdc: super::super::Graphics::Gdi::HDC,
    pub pDDS: core::mem::ManuallyDrop<Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
    pub rSrc: super::super::Foundation::RECT,
    pub rDest: VMR9NormalizedRect,
    pub fAlpha: f32,
    pub clrSrcKey: super::super::Foundation::COLORREF,
    pub dwFilterMode: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9AlphaBitmapFlags(pub i32);
pub const VMR9AlphaBitmap_Disable: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(1i32);
pub const VMR9AlphaBitmap_EntireDDS: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(4i32);
pub const VMR9AlphaBitmap_FilterMode: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(32i32);
pub const VMR9AlphaBitmap_SrcColorKey: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(8i32);
pub const VMR9AlphaBitmap_SrcRect: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(16i32);
pub const VMR9AlphaBitmap_hDC: VMR9AlphaBitmapFlags = VMR9AlphaBitmapFlags(2i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9AspectRatioMode(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9DeinterlaceCaps {
    pub dwSize: u32,
    pub dwNumPreviousOutputFrames: u32,
    pub dwNumForwardRefSamples: u32,
    pub dwNumBackwardRefSamples: u32,
    pub DeinterlaceTechnology: VMR9DeinterlaceTech,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9DeinterlacePrefs(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9DeinterlaceTech(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9Frequency {
    pub dwNumerator: u32,
    pub dwDenominator: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9MixerPrefs(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9Mode(pub i32);
pub const VMR9Mode_Mask: VMR9Mode = VMR9Mode(7i32);
pub const VMR9Mode_Renderless: VMR9Mode = VMR9Mode(4i32);
pub const VMR9Mode_Windowed: VMR9Mode = VMR9Mode(1i32);
pub const VMR9Mode_Windowless: VMR9Mode = VMR9Mode(2i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct VMR9MonitorInfo {
    pub uDevID: u32,
    pub rcMonitor: super::super::Foundation::RECT,
    pub hMon: super::super::Graphics::Gdi::HMONITOR,
    pub dwFlags: u32,
    pub szDevice: [u16; 32],
    pub szDescription: [u16; 512],
    pub liDriverVersion: i64,
    pub dwVendorId: u32,
    pub dwDeviceId: u32,
    pub dwSubSysId: u32,
    pub dwRevision: u32,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for VMR9MonitorInfo {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9NormalizedRect {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9PresentationFlags(pub i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMR9PresentationInfo {
    pub dwFlags: u32,
    pub lpSurf: core::mem::ManuallyDrop<Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
    pub rtStart: i64,
    pub rtEnd: i64,
    pub szAspectRatio: super::super::Foundation::SIZE,
    pub rcSrc: super::super::Foundation::RECT,
    pub rcDst: super::super::Foundation::RECT,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9ProcAmpControl {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub Brightness: f32,
    pub Contrast: f32,
    pub Hue: f32,
    pub Saturation: f32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9ProcAmpControlFlags(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9ProcAmpControlRange {
    pub dwSize: u32,
    pub dwProperty: VMR9ProcAmpControlFlags,
    pub MinValue: f32,
    pub MaxValue: f32,
    pub DefaultValue: f32,
    pub StepSize: f32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9RenderPrefs(pub i32);
pub const VMR9Sample_Discontinuity: VMR9PresentationFlags = VMR9PresentationFlags(4i32);
pub const VMR9Sample_Preroll: VMR9PresentationFlags = VMR9PresentationFlags(2i32);
pub const VMR9Sample_SrcDstRectsValid: VMR9PresentationFlags = VMR9PresentationFlags(16i32);
pub const VMR9Sample_SyncPoint: VMR9PresentationFlags = VMR9PresentationFlags(1i32);
pub const VMR9Sample_TimeValid: VMR9PresentationFlags = VMR9PresentationFlags(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9SurfaceAllocationFlags(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMR9VideoDesc {
    pub dwSize: u32,
    pub dwSampleWidth: u32,
    pub dwSampleHeight: u32,
    pub SampleFormat: VMR9_SampleFormat,
    pub dwFourCC: u32,
    pub InputSampleFreq: VMR9Frequency,
    pub OutputFrameFreq: VMR9Frequency,
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMR9VideoStreamInfo {
    pub pddsVideoSurface: core::mem::ManuallyDrop<Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwStrmID: u32,
    pub fAlpha: f32,
    pub rNormal: VMR9NormalizedRect,
    pub rtStart: i64,
    pub rtEnd: i64,
    pub SampleFormat: VMR9_SampleFormat,
}
pub const VMR9_SampleFieldInterleavedEvenFirst: VMR9_SampleFormat = VMR9_SampleFormat(3i32);
pub const VMR9_SampleFieldInterleavedOddFirst: VMR9_SampleFormat = VMR9_SampleFormat(4i32);
pub const VMR9_SampleFieldSingleEven: VMR9_SampleFormat = VMR9_SampleFormat(5i32);
pub const VMR9_SampleFieldSingleOdd: VMR9_SampleFormat = VMR9_SampleFormat(6i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR9_SampleFormat(pub i32);
pub const VMR9_SampleProgressiveFrame: VMR9_SampleFormat = VMR9_SampleFormat(2i32);
pub const VMR9_SampleReserved: VMR9_SampleFormat = VMR9_SampleFormat(1i32);
#[repr(C)]
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct VMRALLOCATIONINFO {
    pub dwFlags: u32,
    pub lpHdr: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER,
    pub lpPixFmt: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT,
    pub szAspectRatio: super::super::Foundation::SIZE,
    pub dwMinBuffers: u32,
    pub dwMaxBuffers: u32,
    pub dwInterlaceFlags: u32,
    pub szNativeSize: super::super::Foundation::SIZE,
}
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl Default for VMRALLOCATIONINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(all(feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMRALPHABITMAP {
    pub dwFlags: u32,
    pub hdc: super::super::Graphics::Gdi::HDC,
    pub pDDS: core::mem::ManuallyDrop<Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>>,
    pub rSrc: super::super::Foundation::RECT,
    pub rDest: NORMALIZEDRECT,
    pub fAlpha: f32,
    pub clrSrcKey: super::super::Foundation::COLORREF,
}
pub const VMRBITMAP_DISABLE: u32 = 1u32;
pub const VMRBITMAP_ENTIREDDS: u32 = 4u32;
pub const VMRBITMAP_HDC: u32 = 2u32;
pub const VMRBITMAP_SRCCOLORKEY: u32 = 8u32;
pub const VMRBITMAP_SRCRECT: u32 = 16u32;
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMRDeinterlaceCaps {
    pub dwSize: u32,
    pub dwNumPreviousOutputFrames: u32,
    pub dwNumForwardRefSamples: u32,
    pub dwNumBackwardRefSamples: u32,
    pub DeinterlaceTechnology: VMRDeinterlaceTech,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRDeinterlacePrefs(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRDeinterlaceTech(pub i32);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMRFrequency {
    pub dwNumerator: u32,
    pub dwDenominator: u32,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct VMRGUID {
    pub pGUID: *mut windows_core::GUID,
    pub GUID: windows_core::GUID,
}
impl Default for VMRGUID {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct VMRMONITORINFO {
    pub guid: VMRGUID,
    pub rcMonitor: super::super::Foundation::RECT,
    pub hMon: super::super::Graphics::Gdi::HMONITOR,
    pub dwFlags: u32,
    pub szDevice: [u16; 32],
    pub szDescription: [u16; 256],
    pub liDriverVersion: i64,
    pub dwVendorId: u32,
    pub dwDeviceId: u32,
    pub dwSubSysId: u32,
    pub dwRevision: u32,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl Default for VMRMONITORINFO {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRMixerPrefs(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRMode(pub i32);
pub const VMRMode_Mask: VMRMode = VMRMode(7i32);
pub const VMRMode_Renderless: VMRMode = VMRMode(4i32);
pub const VMRMode_Windowed: VMRMode = VMRMode(1i32);
pub const VMRMode_Windowless: VMRMode = VMRMode(2i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMRPRESENTATIONINFO {
    pub dwFlags: u32,
    pub lpSurf: core::mem::ManuallyDrop<Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>>,
    pub rtStart: i64,
    pub rtEnd: i64,
    pub szAspectRatio: super::super::Foundation::SIZE,
    pub rcSrc: super::super::Foundation::RECT,
    pub rcDst: super::super::Foundation::RECT,
    pub dwTypeSpecificFlags: u32,
    pub dwInterlaceFlags: u32,
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRPresentationFlags(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRRenderPrefs(pub i32);
pub const VMRSample_Discontinuity: VMRPresentationFlags = VMRPresentationFlags(4i32);
pub const VMRSample_Preroll: VMRPresentationFlags = VMRPresentationFlags(2i32);
pub const VMRSample_SrcDstRectsValid: VMRPresentationFlags = VMRPresentationFlags(16i32);
pub const VMRSample_SyncPoint: VMRPresentationFlags = VMRPresentationFlags(1i32);
pub const VMRSample_TimeValid: VMRPresentationFlags = VMRPresentationFlags(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMRSurfaceAllocationFlags(pub i32);
#[repr(C)]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[derive(Clone, Debug, Default, PartialEq)]
pub struct VMRVIDEOSTREAMINFO {
    pub pddsVideoSurface: core::mem::ManuallyDrop<Option<super::super::Graphics::DirectDraw::IDirectDrawSurface7>>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwStrmID: u32,
    pub fAlpha: f32,
    pub ddClrKey: super::super::Graphics::DirectDraw::DDCOLORKEY,
    pub rNormal: NORMALIZEDRECT,
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct VMRVideoDesc {
    pub dwSize: u32,
    pub dwSampleWidth: u32,
    pub dwSampleHeight: u32,
    pub SingleFieldPerSample: windows_core::BOOL,
    pub dwFourCC: u32,
    pub InputSampleFreq: VMRFrequency,
    pub OutputFrameFreq: VMRFrequency,
}
pub const VMR_ARMODE_LETTER_BOX: VMR_ASPECT_RATIO_MODE = VMR_ASPECT_RATIO_MODE(1i32);
pub const VMR_ARMODE_NONE: VMR_ASPECT_RATIO_MODE = VMR_ASPECT_RATIO_MODE(0i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VMR_ASPECT_RATIO_MODE(pub i32);
pub const VMR_NOTSUPPORTED: u32 = 0u32;
pub const VMR_RENDER_DEVICE_OVERLAY: u32 = 1u32;
pub const VMR_RENDER_DEVICE_SYSMEM: u32 = 4u32;
pub const VMR_RENDER_DEVICE_VIDMEM: u32 = 2u32;
pub const VMR_SUPPORTED: u32 = 1u32;
pub const VariableBitRateAverage: VIDEOENCODER_BITRATE_MODE = VIDEOENCODER_BITRATE_MODE(1i32);
pub const VariableBitRatePeak: VIDEOENCODER_BITRATE_MODE = VIDEOENCODER_BITRATE_MODE(2i32);
pub const VfwCaptureDialog_Display: VfwCaptureDialogs = VfwCaptureDialogs(4i32);
pub const VfwCaptureDialog_Format: VfwCaptureDialogs = VfwCaptureDialogs(2i32);
pub const VfwCaptureDialog_Source: VfwCaptureDialogs = VfwCaptureDialogs(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VfwCaptureDialogs(pub i32);
pub const VfwCompressDialog_About: VfwCompressDialogs = VfwCompressDialogs(2i32);
pub const VfwCompressDialog_Config: VfwCompressDialogs = VfwCompressDialogs(1i32);
pub const VfwCompressDialog_QueryAbout: VfwCompressDialogs = VfwCompressDialogs(8i32);
pub const VfwCompressDialog_QueryConfig: VfwCompressDialogs = VfwCompressDialogs(4i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VfwCompressDialogs(pub i32);
pub const VideoControlFlag_ExternalTriggerEnable: VideoControlFlags = VideoControlFlags(4i32);
pub const VideoControlFlag_FlipHorizontal: VideoControlFlags = VideoControlFlags(1i32);
pub const VideoControlFlag_FlipVertical: VideoControlFlags = VideoControlFlags(2i32);
pub const VideoControlFlag_Trigger: VideoControlFlags = VideoControlFlags(8i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VideoControlFlags(pub i32);
pub const VideoCopyProtectionMacrovisionBasic: VideoCopyProtectionType = VideoCopyProtectionType(0i32);
pub const VideoCopyProtectionMacrovisionCBI: VideoCopyProtectionType = VideoCopyProtectionType(1i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VideoCopyProtectionType(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VideoProcAmpFlags(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct VideoProcAmpProperty(pub i32);
pub const VideoProcAmp_BacklightCompensation: VideoProcAmpProperty = VideoProcAmpProperty(8i32);
pub const VideoProcAmp_Brightness: VideoProcAmpProperty = VideoProcAmpProperty(0i32);
pub const VideoProcAmp_ColorEnable: VideoProcAmpProperty = VideoProcAmpProperty(6i32);
pub const VideoProcAmp_Contrast: VideoProcAmpProperty = VideoProcAmpProperty(1i32);
pub const VideoProcAmp_Flags_Auto: VideoProcAmpFlags = VideoProcAmpFlags(1i32);
pub const VideoProcAmp_Flags_Manual: VideoProcAmpFlags = VideoProcAmpFlags(2i32);
pub const VideoProcAmp_Gain: VideoProcAmpProperty = VideoProcAmpProperty(9i32);
pub const VideoProcAmp_Gamma: VideoProcAmpProperty = VideoProcAmpProperty(5i32);
pub const VideoProcAmp_Hue: VideoProcAmpProperty = VideoProcAmpProperty(2i32);
pub const VideoProcAmp_Saturation: VideoProcAmpProperty = VideoProcAmpProperty(3i32);
pub const VideoProcAmp_Sharpness: VideoProcAmpProperty = VideoProcAmpProperty(4i32);
pub const VideoProcAmp_WhiteBalance: VideoProcAmpProperty = VideoProcAmpProperty(7i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AMRESCTL_RESERVEFLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AMSTREAMSELECTENABLEFLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AMSTREAMSELECTINFOFLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_AUDIO_RENDERER_STAT_PARAM(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_FILTER_MISC_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_INTF_SEARCH_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_OVERLAY_NOTIFY_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_PUSHSOURCE_FLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _AM_RENSDEREXFLAGS(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _DVDECODERRESOLUTION(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _DVENCODERFORMAT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _DVENCODERRESOLUTION(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _DVENCODERVIDEOFORMAT(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _DVRESOLUTION(pub i32);
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct _REM_FILTER_FLAGS(pub i32);
pub const g_wszExcludeScriptStreamDeliverySynchronization: windows_core::PCWSTR = windows_core::w!("ExcludeScriptStreamDeliverySynchronization");
pub const iBLUE: u32 = 2u32;
pub const iEGA_COLORS: u32 = 16u32;
pub const iGREEN: u32 = 1u32;
pub const iMASK_COLORS: u32 = 3u32;
pub const iMAXBITS: u32 = 8u32;
pub const iPALETTE: u32 = 8u32;
pub const iPALETTE_COLORS: u32 = 256u32;
pub const iRED: u32 = 0u32;
pub const iTRUECOLOR: u32 = 16u32;
